(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory();
	else
		root["Quagga"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 90);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(68);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _getPrototypeOf(t) {
  return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(68);
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
var assertThisInitialized = __webpack_require__(150);
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return assertThisInitialized(t);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(38);
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && setPrototypeOf(t, e);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(146)();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports) {

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(46);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(151);
function _get() {
  return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(102),
    getValue = __webpack_require__(108);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(91),
    createAssigner = __webpack_require__(134);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(152);
var iterableToArray = __webpack_require__(153);
var unsupportedIterableToArray = __webpack_require__(66);
var nonIterableSpread = __webpack_require__(154);
function _toConsumableArray(r) {
  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    getRawTag = __webpack_require__(104),
    objectToString = __webpack_require__(105);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(60),
    baseAssignValue = __webpack_require__(29);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(61),
    baseKeysIn = __webpack_require__(132),
    isArrayLike = __webpack_require__(26);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(92),
    listCacheDelete = __webpack_require__(93),
    listCacheGet = __webpack_require__(94),
    listCacheHas = __webpack_require__(95),
    listCacheSet = __webpack_require__(96);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(23);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(117);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(28),
    isLength = __webpack_require__(56);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isObject = __webpack_require__(10);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(50);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(124);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(55);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(126),
    isObjectLike = __webpack_require__(11);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8),
    stubFalse = __webpack_require__(128);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(30)(module)))

/***/ }),
/* 36 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(46);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(30)(module)))

/***/ }),
/* 38 */
/***/ (function(module, exports) {

function _setPrototypeOf(t, e) {
  return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(61),
    baseKeys = __webpack_require__(159),
    isArrayLike = __webpack_require__(26);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(163),
    stubArray = __webpack_require__(75);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(166),
    Map = __webpack_require__(27),
    Promise = __webpack_require__(167),
    Set = __webpack_require__(168),
    WeakMap = __webpack_require__(169),
    baseGetTag = __webpack_require__(17),
    toSource = __webpack_require__(47);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(12),
    isKey = __webpack_require__(180),
    stringToPath = __webpack_require__(181),
    toString = __webpack_require__(184);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(21),
    stackClear = __webpack_require__(97),
    stackDelete = __webpack_require__(98),
    stackGet = __webpack_require__(99),
    stackHas = __webpack_require__(100),
    stackSet = __webpack_require__(101);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(103)))

/***/ }),
/* 47 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(109),
    mapCacheDelete = __webpack_require__(116),
    mapCacheGet = __webpack_require__(118),
    mapCacheHas = __webpack_require__(119),
    mapCacheSet = __webpack_require__(120);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(29),
    eq = __webpack_require__(23);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(30)(module)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(31);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 53 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(125),
    getPrototype = __webpack_require__(32),
    isPrototype = __webpack_require__(33);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 56 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    getPrototype = __webpack_require__(32),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(129),
    baseUnary = __webpack_require__(36),
    nodeUtil = __webpack_require__(37);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 59 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(29),
    eq = __webpack_require__(23);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(131),
    isArguments = __webpack_require__(34),
    isArray = __webpack_require__(12),
    isBuffer = __webpack_require__(35),
    isIndex = __webpack_require__(62),
    isTypedArray = __webpack_require__(58);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 62 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(136);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(137),
    shortOut = __webpack_require__(139);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(67);
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
  }
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
var toPrimitive = __webpack_require__(145);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 69 */
/***/ (function(module, exports) {

function _OverloadYield(e, d) {
  this.v = e, this.k = d;
}
module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var regeneratorDefine = __webpack_require__(71);
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return regeneratorDefine(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = !1,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function d(t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = !0, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), !0), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function () {
    return this;
  }), regeneratorDefine(u, "toString", function () {
    return "[object Generator]";
  }), (module.exports = _regenerator = function _regenerator() {
    return {
      w: i,
      m: f
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  module.exports = _regeneratorDefine = function regeneratorDefine(e, r, n, t) {
    function o(r, n) {
      _regeneratorDefine(e, r, function (e) {
        return this._invoke(r, n, e);
      });
    }
    r ? i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
}
module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var regenerator = __webpack_require__(70);
var regeneratorAsyncIterator = __webpack_require__(73);
function _regeneratorAsyncGen(r, e, t, o, n) {
  return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
}
module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var OverloadYield = __webpack_require__(69);
var regeneratorDefine = __webpack_require__(71);
function AsyncIterator(t, e) {
  function n(r, o, i, f) {
    try {
      var c = t[r](o),
        u = c.value;
      return u instanceof OverloadYield ? e.resolve(u.v).then(function (t) {
        n("next", t, i, f);
      }, function (t) {
        n("throw", t, i, f);
      }) : e.resolve(u).then(function (t) {
        c.value = t, i(c);
      }, function (t) {
        return n("throw", t, i, f);
      });
    } catch (t) {
      f(t);
    }
  }
  var r;
  this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function () {
    return this;
  })), regeneratorDefine(this, "_invoke", function (t, o, i) {
    function f() {
      return new e(function (e, r) {
        n(t, i, e, r);
      });
    }
    return r = r ? r.then(f, f) : f();
  }, !0);
}
module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 75 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(41),
    getPrototype = __webpack_require__(32),
    getSymbols = __webpack_require__(40),
    stubArray = __webpack_require__(75);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(41),
    isArray = __webpack_require__(12);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(77),
    getSymbolsIn = __webpack_require__(76),
    keysIn = __webpack_require__(20);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(44);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(142);
var iterableToArrayLimit = __webpack_require__(143);
var unsupportedIterableToArray = __webpack_require__(66);
var nonIterableRest = __webpack_require__(144);
function _slicedToArray(r, e) {
  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(155);
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(74),
    baseClone = __webpack_require__(156),
    baseUnset = __webpack_require__(179),
    castPath = __webpack_require__(43),
    copyObject = __webpack_require__(18),
    customOmitClone = __webpack_require__(190),
    flatRest = __webpack_require__(191),
    getAllKeysIn = __webpack_require__(78);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(1);
var setPrototypeOf = __webpack_require__(38);
var isNativeFunction = __webpack_require__(195);
var construct = __webpack_require__(196);
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return module.exports = _wrapNativeSuper = function _wrapNativeSuper(t) {
    if (null === t || !isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return construct(t, arguments, getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), setPrototypeOf(Wrapper, t);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(198);


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(45),
    assignMergeValue = __webpack_require__(49),
    baseFor = __webpack_require__(121),
    baseMergeDeep = __webpack_require__(123),
    isObject = __webpack_require__(10),
    keysIn = __webpack_require__(20),
    safeGet = __webpack_require__(59);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(21);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 99 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 100 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(21),
    Map = __webpack_require__(27),
    MapCache = __webpack_require__(48);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(28),
    isMasked = __webpack_require__(106),
    isObject = __webpack_require__(10),
    toSource = __webpack_require__(47);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 105 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(107);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(110),
    ListCache = __webpack_require__(21),
    Map = __webpack_require__(27);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(111),
    hashDelete = __webpack_require__(112),
    hashGet = __webpack_require__(113),
    hashHas = __webpack_require__(114),
    hashSet = __webpack_require__(115);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 112 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 117 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(122);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 122 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(49),
    cloneBuffer = __webpack_require__(51),
    cloneTypedArray = __webpack_require__(52),
    copyArray = __webpack_require__(53),
    initCloneObject = __webpack_require__(54),
    isArguments = __webpack_require__(34),
    isArray = __webpack_require__(12),
    isArrayLikeObject = __webpack_require__(127),
    isBuffer = __webpack_require__(35),
    isFunction = __webpack_require__(28),
    isObject = __webpack_require__(10),
    isPlainObject = __webpack_require__(57),
    isTypedArray = __webpack_require__(58),
    safeGet = __webpack_require__(59),
    toPlainObject = __webpack_require__(130);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(10);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(26),
    isObjectLike = __webpack_require__(11);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 128 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isLength = __webpack_require__(56),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    keysIn = __webpack_require__(20);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 131 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(10),
    isPrototype = __webpack_require__(33),
    nativeKeysIn = __webpack_require__(133);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 133 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(135),
    isIterateeCall = __webpack_require__(140);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(63),
    overRest = __webpack_require__(64),
    setToString = __webpack_require__(65);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 136 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(138),
    defineProperty = __webpack_require__(50),
    identity = __webpack_require__(63);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 138 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(23),
    isArrayLike = __webpack_require__(26),
    isIndex = __webpack_require__(62),
    isObject = __webpack_require__(10);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */

if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (/* function FrameRequestCallback */callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}
if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */
}
if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2

    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }
    var to = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];
      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}

/***/ }),
/* 142 */
/***/ (function(module, exports) {

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var OverloadYield = __webpack_require__(69);
var regenerator = __webpack_require__(70);
var regeneratorAsync = __webpack_require__(147);
var regeneratorAsyncGen = __webpack_require__(72);
var regeneratorAsyncIterator = __webpack_require__(73);
var regeneratorKeys = __webpack_require__(148);
var regeneratorValues = __webpack_require__(149);
function _regeneratorRuntime() {
  "use strict";

  var r = regenerator(),
    e = r.m(_regeneratorRuntime),
    t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
  function n(r) {
    var e = "function" == typeof r && r.constructor;
    return !!e && (e === t || "GeneratorFunction" === (e.displayName || e.name));
  }
  var o = {
    "throw": 1,
    "return": 2,
    "break": 3,
    "continue": 3
  };
  function a(r) {
    var e, t;
    return function (n) {
      e || (e = {
        stop: function stop() {
          return t(n.a, 2);
        },
        "catch": function _catch() {
          return n.v;
        },
        abrupt: function abrupt(r, e) {
          return t(n.a, o[r], e);
        },
        delegateYield: function delegateYield(r, o, a) {
          return e.resultName = o, t(n.d, regeneratorValues(r), a);
        },
        finish: function finish(r) {
          return t(n.f, r);
        }
      }, t = function t(r, _t, o) {
        n.p = e.prev, n.n = e.next;
        try {
          return r(_t, o);
        } finally {
          e.next = n.n;
        }
      }), e.resultName && (e[e.resultName] = n.v, e.resultName = void 0), e.sent = n.v, e.next = n.n;
      try {
        return r.call(this, e);
      } finally {
        n.p = e.prev, n.n = e.next;
      }
    };
  }
  return (module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return {
      wrap: function wrap(e, t, n, o) {
        return r.w(a(e), t, n, o && o.reverse());
      },
      isGeneratorFunction: n,
      mark: r.m,
      awrap: function awrap(r, e) {
        return new OverloadYield(r, e);
      },
      AsyncIterator: regeneratorAsyncIterator,
      async: function async(r, e, t, o, u) {
        return (n(e) ? regeneratorAsyncGen : regeneratorAsync)(a(r), e, t, o, u);
      },
      keys: regeneratorKeys,
      values: regeneratorValues
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var regeneratorAsyncGen = __webpack_require__(72);
function _regeneratorAsync(n, e, r, t, o) {
  var a = regeneratorAsyncGen(n, e, r, t, o);
  return a.next().then(function (n) {
    return n.done ? n.value : a.next();
  });
}
module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 148 */
/***/ (function(module, exports) {

function _regeneratorKeys(e) {
  var n = Object(e),
    r = [];
  for (var t in n) r.unshift(t);
  return function e() {
    for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e;
    return e.done = !0, e;
  };
}
module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
function _regeneratorValues(e) {
  if (null != e) {
    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
      r = 0;
    if (t) return t.call(e);
    if ("function" == typeof e.next) return e;
    if (!isNaN(e.length)) return {
      next: function next() {
        return e && r >= e.length && (e = void 0), {
          value: e && e[r++],
          done: !e
        };
      }
    };
  }
  throw new TypeError(_typeof(e) + " is not iterable");
}
module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(1);
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)););
  return t;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(67);
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return arrayLikeToArray(r);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 153 */
/***/ (function(module, exports) {

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 155 */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(45),
    arrayEach = __webpack_require__(157),
    assignValue = __webpack_require__(60),
    baseAssign = __webpack_require__(158),
    baseAssignIn = __webpack_require__(161),
    cloneBuffer = __webpack_require__(51),
    copyArray = __webpack_require__(53),
    copySymbols = __webpack_require__(162),
    copySymbolsIn = __webpack_require__(164),
    getAllKeys = __webpack_require__(165),
    getAllKeysIn = __webpack_require__(78),
    getTag = __webpack_require__(42),
    initCloneArray = __webpack_require__(170),
    initCloneByTag = __webpack_require__(171),
    initCloneObject = __webpack_require__(54),
    isArray = __webpack_require__(12),
    isBuffer = __webpack_require__(35),
    isMap = __webpack_require__(175),
    isObject = __webpack_require__(10),
    isSet = __webpack_require__(177),
    keys = __webpack_require__(39),
    keysIn = __webpack_require__(20);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 157 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    keys = __webpack_require__(39);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(33),
    nativeKeys = __webpack_require__(160);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(55);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    keysIn = __webpack_require__(20);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    getSymbols = __webpack_require__(40);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    getSymbolsIn = __webpack_require__(76);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(77),
    getSymbols = __webpack_require__(40),
    keys = __webpack_require__(39);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(31),
    cloneDataView = __webpack_require__(172),
    cloneRegExp = __webpack_require__(173),
    cloneSymbol = __webpack_require__(174),
    cloneTypedArray = __webpack_require__(52);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(31);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 173 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(176),
    baseUnary = __webpack_require__(36),
    nodeUtil = __webpack_require__(37);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(42),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(178),
    baseUnary = __webpack_require__(36),
    nodeUtil = __webpack_require__(37);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(42),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(43),
    last = __webpack_require__(186),
    parent = __webpack_require__(187),
    toKey = __webpack_require__(79);

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(12),
    isSymbol = __webpack_require__(44);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(182);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(183);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(48);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(185);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    arrayMap = __webpack_require__(74),
    isArray = __webpack_require__(12),
    isSymbol = __webpack_require__(44);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 186 */
/***/ (function(module, exports) {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(188),
    baseSlice = __webpack_require__(189);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(43),
    toKey = __webpack_require__(79);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 189 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var isPlainObject = __webpack_require__(57);

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(192),
    overRest = __webpack_require__(64),
    setToString = __webpack_require__(65);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(193);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(41),
    isFlattenable = __webpack_require__(194);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    isArguments = __webpack_require__(34),
    isArray = __webpack_require__(12);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 195 */
/***/ (function(module, exports) {

function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var isNativeReflectConstruct = __webpack_require__(197);
var setPrototypeOf = __webpack_require__(38);
function _construct(t, e, r) {
  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && setPrototypeOf(p, r.prototype), p;
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 197 */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "Readers", function() { return /* reexport */ reader_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/mat2.js
var mat2_namespaceObject = {};
__webpack_require__.r(mat2_namespaceObject);
__webpack_require__.d(mat2_namespaceObject, "create", function() { return mat2_create; });
__webpack_require__.d(mat2_namespaceObject, "clone", function() { return clone; });
__webpack_require__.d(mat2_namespaceObject, "copy", function() { return copy; });
__webpack_require__.d(mat2_namespaceObject, "identity", function() { return identity; });
__webpack_require__.d(mat2_namespaceObject, "fromValues", function() { return fromValues; });
__webpack_require__.d(mat2_namespaceObject, "set", function() { return set; });
__webpack_require__.d(mat2_namespaceObject, "transpose", function() { return transpose; });
__webpack_require__.d(mat2_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(mat2_namespaceObject, "adjoint", function() { return adjoint; });
__webpack_require__.d(mat2_namespaceObject, "determinant", function() { return determinant; });
__webpack_require__.d(mat2_namespaceObject, "multiply", function() { return multiply; });
__webpack_require__.d(mat2_namespaceObject, "rotate", function() { return rotate; });
__webpack_require__.d(mat2_namespaceObject, "scale", function() { return mat2_scale; });
__webpack_require__.d(mat2_namespaceObject, "fromRotation", function() { return fromRotation; });
__webpack_require__.d(mat2_namespaceObject, "fromScaling", function() { return fromScaling; });
__webpack_require__.d(mat2_namespaceObject, "str", function() { return str; });
__webpack_require__.d(mat2_namespaceObject, "frob", function() { return frob; });
__webpack_require__.d(mat2_namespaceObject, "LDU", function() { return LDU; });
__webpack_require__.d(mat2_namespaceObject, "add", function() { return add; });
__webpack_require__.d(mat2_namespaceObject, "subtract", function() { return subtract; });
__webpack_require__.d(mat2_namespaceObject, "exactEquals", function() { return exactEquals; });
__webpack_require__.d(mat2_namespaceObject, "equals", function() { return mat2_equals; });
__webpack_require__.d(mat2_namespaceObject, "multiplyScalar", function() { return multiplyScalar; });
__webpack_require__.d(mat2_namespaceObject, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
__webpack_require__.d(mat2_namespaceObject, "mul", function() { return mul; });
__webpack_require__.d(mat2_namespaceObject, "sub", function() { return sub; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec2.js
var vec2_namespaceObject = {};
__webpack_require__.r(vec2_namespaceObject);
__webpack_require__.d(vec2_namespaceObject, "create", function() { return vec2_create; });
__webpack_require__.d(vec2_namespaceObject, "clone", function() { return vec2_clone; });
__webpack_require__.d(vec2_namespaceObject, "fromValues", function() { return vec2_fromValues; });
__webpack_require__.d(vec2_namespaceObject, "copy", function() { return vec2_copy; });
__webpack_require__.d(vec2_namespaceObject, "set", function() { return vec2_set; });
__webpack_require__.d(vec2_namespaceObject, "add", function() { return vec2_add; });
__webpack_require__.d(vec2_namespaceObject, "subtract", function() { return vec2_subtract; });
__webpack_require__.d(vec2_namespaceObject, "multiply", function() { return vec2_multiply; });
__webpack_require__.d(vec2_namespaceObject, "divide", function() { return divide; });
__webpack_require__.d(vec2_namespaceObject, "ceil", function() { return ceil; });
__webpack_require__.d(vec2_namespaceObject, "floor", function() { return floor; });
__webpack_require__.d(vec2_namespaceObject, "min", function() { return min; });
__webpack_require__.d(vec2_namespaceObject, "max", function() { return vec2_max; });
__webpack_require__.d(vec2_namespaceObject, "round", function() { return vec2_round; });
__webpack_require__.d(vec2_namespaceObject, "scale", function() { return vec2_scale; });
__webpack_require__.d(vec2_namespaceObject, "scaleAndAdd", function() { return scaleAndAdd; });
__webpack_require__.d(vec2_namespaceObject, "distance", function() { return distance; });
__webpack_require__.d(vec2_namespaceObject, "squaredDistance", function() { return squaredDistance; });
__webpack_require__.d(vec2_namespaceObject, "length", function() { return vec2_length; });
__webpack_require__.d(vec2_namespaceObject, "squaredLength", function() { return squaredLength; });
__webpack_require__.d(vec2_namespaceObject, "negate", function() { return negate; });
__webpack_require__.d(vec2_namespaceObject, "inverse", function() { return inverse; });
__webpack_require__.d(vec2_namespaceObject, "normalize", function() { return normalize; });
__webpack_require__.d(vec2_namespaceObject, "dot", function() { return dot; });
__webpack_require__.d(vec2_namespaceObject, "cross", function() { return cross; });
__webpack_require__.d(vec2_namespaceObject, "lerp", function() { return lerp; });
__webpack_require__.d(vec2_namespaceObject, "random", function() { return random; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2", function() { return transformMat2; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2d", function() { return transformMat2d; });
__webpack_require__.d(vec2_namespaceObject, "transformMat3", function() { return transformMat3; });
__webpack_require__.d(vec2_namespaceObject, "transformMat4", function() { return transformMat4; });
__webpack_require__.d(vec2_namespaceObject, "rotate", function() { return vec2_rotate; });
__webpack_require__.d(vec2_namespaceObject, "angle", function() { return angle; });
__webpack_require__.d(vec2_namespaceObject, "signedAngle", function() { return signedAngle; });
__webpack_require__.d(vec2_namespaceObject, "zero", function() { return zero; });
__webpack_require__.d(vec2_namespaceObject, "str", function() { return vec2_str; });
__webpack_require__.d(vec2_namespaceObject, "exactEquals", function() { return vec2_exactEquals; });
__webpack_require__.d(vec2_namespaceObject, "equals", function() { return vec2_equals; });
__webpack_require__.d(vec2_namespaceObject, "len", function() { return len; });
__webpack_require__.d(vec2_namespaceObject, "sub", function() { return vec2_sub; });
__webpack_require__.d(vec2_namespaceObject, "mul", function() { return vec2_mul; });
__webpack_require__.d(vec2_namespaceObject, "div", function() { return div; });
__webpack_require__.d(vec2_namespaceObject, "dist", function() { return dist; });
__webpack_require__.d(vec2_namespaceObject, "sqrDist", function() { return sqrDist; });
__webpack_require__.d(vec2_namespaceObject, "sqrLen", function() { return sqrLen; });
__webpack_require__.d(vec2_namespaceObject, "forEach", function() { return forEach; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec3.js
var vec3_namespaceObject = {};
__webpack_require__.r(vec3_namespaceObject);
__webpack_require__.d(vec3_namespaceObject, "create", function() { return vec3_create; });
__webpack_require__.d(vec3_namespaceObject, "clone", function() { return vec3_clone; });
__webpack_require__.d(vec3_namespaceObject, "length", function() { return vec3_length; });
__webpack_require__.d(vec3_namespaceObject, "fromValues", function() { return vec3_fromValues; });
__webpack_require__.d(vec3_namespaceObject, "copy", function() { return vec3_copy; });
__webpack_require__.d(vec3_namespaceObject, "set", function() { return vec3_set; });
__webpack_require__.d(vec3_namespaceObject, "add", function() { return vec3_add; });
__webpack_require__.d(vec3_namespaceObject, "subtract", function() { return vec3_subtract; });
__webpack_require__.d(vec3_namespaceObject, "multiply", function() { return vec3_multiply; });
__webpack_require__.d(vec3_namespaceObject, "divide", function() { return vec3_divide; });
__webpack_require__.d(vec3_namespaceObject, "ceil", function() { return vec3_ceil; });
__webpack_require__.d(vec3_namespaceObject, "floor", function() { return vec3_floor; });
__webpack_require__.d(vec3_namespaceObject, "min", function() { return vec3_min; });
__webpack_require__.d(vec3_namespaceObject, "max", function() { return vec3_max; });
__webpack_require__.d(vec3_namespaceObject, "round", function() { return vec3_round; });
__webpack_require__.d(vec3_namespaceObject, "scale", function() { return vec3_scale; });
__webpack_require__.d(vec3_namespaceObject, "scaleAndAdd", function() { return vec3_scaleAndAdd; });
__webpack_require__.d(vec3_namespaceObject, "distance", function() { return vec3_distance; });
__webpack_require__.d(vec3_namespaceObject, "squaredDistance", function() { return vec3_squaredDistance; });
__webpack_require__.d(vec3_namespaceObject, "squaredLength", function() { return vec3_squaredLength; });
__webpack_require__.d(vec3_namespaceObject, "negate", function() { return vec3_negate; });
__webpack_require__.d(vec3_namespaceObject, "inverse", function() { return vec3_inverse; });
__webpack_require__.d(vec3_namespaceObject, "normalize", function() { return vec3_normalize; });
__webpack_require__.d(vec3_namespaceObject, "dot", function() { return vec3_dot; });
__webpack_require__.d(vec3_namespaceObject, "cross", function() { return vec3_cross; });
__webpack_require__.d(vec3_namespaceObject, "lerp", function() { return vec3_lerp; });
__webpack_require__.d(vec3_namespaceObject, "slerp", function() { return slerp; });
__webpack_require__.d(vec3_namespaceObject, "hermite", function() { return hermite; });
__webpack_require__.d(vec3_namespaceObject, "bezier", function() { return bezier; });
__webpack_require__.d(vec3_namespaceObject, "random", function() { return vec3_random; });
__webpack_require__.d(vec3_namespaceObject, "transformMat4", function() { return vec3_transformMat4; });
__webpack_require__.d(vec3_namespaceObject, "transformMat3", function() { return vec3_transformMat3; });
__webpack_require__.d(vec3_namespaceObject, "transformQuat", function() { return transformQuat; });
__webpack_require__.d(vec3_namespaceObject, "rotateX", function() { return rotateX; });
__webpack_require__.d(vec3_namespaceObject, "rotateY", function() { return rotateY; });
__webpack_require__.d(vec3_namespaceObject, "rotateZ", function() { return rotateZ; });
__webpack_require__.d(vec3_namespaceObject, "angle", function() { return vec3_angle; });
__webpack_require__.d(vec3_namespaceObject, "zero", function() { return vec3_zero; });
__webpack_require__.d(vec3_namespaceObject, "str", function() { return vec3_str; });
__webpack_require__.d(vec3_namespaceObject, "exactEquals", function() { return vec3_exactEquals; });
__webpack_require__.d(vec3_namespaceObject, "equals", function() { return vec3_equals; });
__webpack_require__.d(vec3_namespaceObject, "sub", function() { return vec3_sub; });
__webpack_require__.d(vec3_namespaceObject, "mul", function() { return vec3_mul; });
__webpack_require__.d(vec3_namespaceObject, "div", function() { return vec3_div; });
__webpack_require__.d(vec3_namespaceObject, "dist", function() { return vec3_dist; });
__webpack_require__.d(vec3_namespaceObject, "sqrDist", function() { return vec3_sqrDist; });
__webpack_require__.d(vec3_namespaceObject, "len", function() { return vec3_len; });
__webpack_require__.d(vec3_namespaceObject, "sqrLen", function() { return vec3_sqrLen; });
__webpack_require__.d(vec3_namespaceObject, "forEach", function() { return vec3_forEach; });

// NAMESPACE OBJECT: ./src/reader/index.ts
var reader_namespaceObject = {};
__webpack_require__.r(reader_namespaceObject);
__webpack_require__.d(reader_namespaceObject, "BarcodeReader", function() { return barcode_reader; });
__webpack_require__.d(reader_namespaceObject, "TwoOfFiveReader", function() { return _2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "NewCodabarReader", function() { return codabar_reader; });
__webpack_require__.d(reader_namespaceObject, "Code128Reader", function() { return code_128_reader; });
__webpack_require__.d(reader_namespaceObject, "Code32Reader", function() { return code_32_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39Reader", function() { return code_39_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39VINReader", function() { return code_39_vin_reader; });
__webpack_require__.d(reader_namespaceObject, "Code93Reader", function() { return code_93_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN2Reader", function() { return ean_2_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN5Reader", function() { return ean_5_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN8Reader", function() { return ean_8_reader; });
__webpack_require__.d(reader_namespaceObject, "EANReader", function() { return ean_reader; });
__webpack_require__.d(reader_namespaceObject, "I2of5Reader", function() { return i2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "PharmacodeReader", function() { return pharmacode_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCEReader", function() { return upc_e_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCReader", function() { return upc_reader; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(9);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(15);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(141);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(80);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(2);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(3);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var ANGLE_ORDER = "zyx";

/**
 * Symmetric round
 * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background
 *
 * @param {Number} a value to round
 */
function round(a) {
  if (a >= 0) return Math.round(a);
  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);
}

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Convert Radian To Degree
 *
 * @param {Number} a Angle in Radians
 */
function toDegree(a) {
  return a * radian;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a          The first number to test.
 * @param {Number} b          The second number to test.
 * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;
  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));
}
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat2.js


/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function mat2_create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }
  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2 | null} out, or null if source matrix is not invertible
 */
function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is necessary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function mat2_scale(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat2_equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
var sub = subtract;
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec2.js


/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function vec2_create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function vec2_clone(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function vec2_fromValues(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */
function vec2_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function vec2_set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * symmetric round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */
function vec2_round(out, a) {
  out[0] = round(a[0]);
  out[1] = round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function vec2_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec2_length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */
function vec2_rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}

/**
 * Get the smallest angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
}

/**
 * Get the signed angle in the interval [-pi,pi] between two 2D vectors (positive if `a` is to the right of `b`)
 * 
 * @param {ReadonlyVec2} a The first vector
 * @param {ReadonlyVec2} b The second vector
 * @returns {number} The signed angle in radians
 */
function signedAngle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}

/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */
function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec2_str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = vec2_length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var vec2_sub = vec2_subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var vec2_mul = vec2_multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = vec2_create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js


/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function vec3_create() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function vec3_clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec3_length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function vec3_fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */
function vec3_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function vec3_set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */
function vec3_ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */
function vec3_floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * symmetric round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */
function vec3_round(out, a) {
  out[0] = round(a[0]);
  out[1] = round(a[1]);
  out[2] = round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function vec3_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function vec3_scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */
function vec3_distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function vec3_squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function vec3_squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */
function vec3_negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */
function vec3_inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */
function vec3_normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec3_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function vec3_lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a spherical linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function slerp(out, a, b, t) {
  var angle = Math.acos(Math.min(Math.max(vec3_dot(a, b), -1), 1));
  var sinTotal = Math.sin(angle);
  var ratioA = Math.sin((1 - t) * angle) / sinTotal;
  var ratioB = Math.sin(t * angle) / sinTotal;
  out[0] = ratioA * a[0] + ratioB * b[0];
  out[1] = ratioA * a[1] + ratioB * b[1];
  out[2] = ratioA * a[2] + ratioB * b[2];
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec3} out
 */
function vec3_random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = RANDOM() * 2.0 * Math.PI;
  var z = RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */
function vec3_transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function vec3_transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q normalized quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // Fast Vector Rotation using Quaternions by Robert Eisele
  // https://raw.org/proof/vector-rotation-using-quaternions/

  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var vx = a[0],
    vy = a[1],
    vz = a[2];

  // t = q x v
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;

  // t = 2t
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;

  // v + w t + q x t
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateX(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateY(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateZ(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */
function vec3_angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)),
    cosine = mag && vec3_dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}

/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */
function vec3_zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec3_str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var vec3_sub = vec3_subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var vec3_mul = vec3_multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var vec3_div = vec3_divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var vec3_dist = vec3_distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var vec3_sqrDist = vec3_squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var vec3_len = vec3_length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var vec3_sqrLen = vec3_squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var vec3_forEach = function () {
  var vec = vec3_create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/index.js











// CONCATENATED MODULE: ./src/common/array_helper.ts
/* eslint-disable no-param-reassign */

/* harmony default export */ var array_helper = ({
  init: function init(arr, val) {
    arr.fill(val);
  },
  /**
   * IN-PLACE Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    // Durstenfeld shuffle algorithm
    // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
    for (var i = arr.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var _ref = [arr[j], arr[i]];
      arr[i] = _ref[0];
      arr[j] = _ref[1];
    }
    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },
  /**
   * returns the elements which's score is bigger than the threshold
   */
  // eslint-disable-next-line no-unused-vars
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }
      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }
    return max;
  },
  max: function max(arr) {
    var max = 0;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }
    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;
    while (length--) {
      sum += arr[length];
    }
    return sum;
  }
});
// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)



/**
 * Creates a cluster for grouping similar orientations of datapoints
 */
/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2_namespaceObject.clone([0, 0])
    };
    var pointMap = {};
    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }
    function updateCenter() {
      var i;
      var sum = 0;
      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }
      center.rad = sum / points.length;
      center.vec = vec2_namespaceObject.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }
    function init() {
      _add(point);
      updateCenter();
    }
    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);
          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2_namespaceObject.dot(otherPoint.point.vec, center.vec));
        if (similarity > threshold) {
          return true;
        }
        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */
/* eslint-disable no-bitwise */




/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */
function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return vec2_namespaceObject.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3_namespaceObject.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}

/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */
function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y;

  // sum up first column
  posB = width;
  sum = 0;
  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }
  posA = 0;
  posB = 1;
  sum = 0;
  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }
  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;
    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;

  // sum up first row
  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }
  for (var v = 1; v < height; v++) {
    sum = 0;
    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }
  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;
  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }
  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);
  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }
  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;
  for (i = 1; i < length - 1; i++) {
    right = line[i + 1];
    //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign
    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }
  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;
  function px(init, end) {
    var sum = 0;
    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }
    return sum;
  }
  function mx(init, end) {
    var sum = 0;
    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }
    return sum;
  }
  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);
    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;
      if (p12 === 0) {
        p12 = 1;
      }
      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }
    return array_helper.maxIndex(vet);
  }
  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
}

// local thresholding
function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }
  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1);

  // clear out top & bottom-border
  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  }

  // clear out left & right border
  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }
  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];
  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }
  function addToCluster(newPoint) {
    var found = false;
    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];
      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }
    return found;
  }

  // iterate over each cloud
  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);
    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }
  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;
    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;
      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }
        return false;
      }

      // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met

      var from = points[idx];
      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }
      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx];
      // eslint-disable-next-line no-cond-assign
      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }
      return found ? toIdx : null;
    }
    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length);

      // trace forward
      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]);
      // eslint-disable-next-line no-cond-assign
      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }
      if (centerPos > 0) {
        currentPos = centerPos;
        // eslint-disable-next-line no-cond-assign
        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }
      if (top.length > result.length) {
        result = top;
      }
    }
    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;
  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;
  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function cv_utils_subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }
  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;
  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }
  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;
  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;
  while (length--) {
    sum += data[length];
  }
  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;
  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }
  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);
    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;
      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }
  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;
  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }
    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;
  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      var alpha = imageData[i * 4 + 3];
      if (alpha === 0) {
        // eslint-disable-next-line no-param-reassign
        outArray[i] = 255; // Treat transparent pixels as white
      } else {
        // eslint-disable-next-line no-param-reassign
        outArray[i] = imageData[i * 4 + 0];
      }
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      var _alpha = imageData[_i * 4 + 3];
      if (_alpha === 0) {
        // eslint-disable-next-line no-param-reassign
        outArray[_i] = 255; // Treat transparent pixels as white
      } else {
        // eslint-disable-next-line no-param-reassign
        outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
      }
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;
  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width;
    // eslint-disable-next-line no-param-reassign
    canvas.height = this.height;
    console.warn('* loadImageArray getContext 2d');
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);
    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
      data = _ctx$getImageData.data;
    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };
  img.src = src;
}

/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */
function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;
  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }
    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;
  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  }
  // eslint-disable-next-line no-param-reassign
  rgb[0] = (r + m) * 255 | 0;
  // eslint-disable-next-line no-param-reassign
  rgb[1] = (g + m) * 255 | 0;
  // eslint-disable-next-line no-param-reassign
  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  // Handle edge cases
  // NaN: Not a number - no meaningful divisors
  // Infinity: Infinite values have no finite divisors
  // Non-positive: Divisors are typically defined for positive integers only
  // While negative numbers technically have divisors, returning them would complicate
  // the API (would need to return both positive and negative divisors, or make assumptions)
  if (!Number.isFinite(n) || n < 1) {
    return [];
  }
  var largeDivisors = [];
  var divisors = [];
  var sqrtN = Math.sqrt(n);
  for (var i = 1; i <= sqrtN; i++) {
    if (n % i === 0) {
      divisors.push(i);
      // Only add the complementary divisor if it's different (not a perfect square root)
      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }
  return divisors.concat(largeDivisors);
}
function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }
  return result;
}
function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);
  var divisorsY = _computeDivisors(imgSize.y);
  var wideSide = Math.max(imgSize.x, imgSize.y);
  var common = _computeIntersection(divisorsX, divisorsY);
  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;
  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];
    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }
    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }
    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }
    return null;
  }
  optimalPatchSize = findPatchSizeForDivisors(common);
  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));
    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }
  // Fallback: if no optimal patch size found, use image size (or 1x1 minimum)
  // This ensures the function always returns a valid {x, y} object
  if (!optimalPatchSize) {
    optimalPatchSize = {
      x: Math.max(1, imgSize.x),
      y: Math.max(1, imgSize.y)
    };
  }
  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    // Skip styling properties that aren't dimension converters
    if (!_dimensionsConverters[key]) {
      return result;
    }
    var value = area[key];
    var parsed = _parseCSSDimensionValues(value);
    var calculated = _dimensionsConverters[key](parsed, context);

    // eslint-disable-next-line no-param-reassign
    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}
// CONCATENATED MODULE: ./src/common/image_wrapper.ts







function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}
var image_wrapper_ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;
    classCallCheck_default()(this, ImageWrapper);
    defineProperty_default()(this, "data", void 0);
    defineProperty_default()(this, "size", void 0);
    defineProperty_default()(this, "indexMapping", void 0);
    if (!data) {
      this.data = new ArrayType(size.x * size.y);
      if (initialize) {
        array_helper.init(this.data, 0);
      }
    } else {
      this.data = data;
    }
    this.size = size;
  }

  // tests if a position is within the image, extended out by a border on each side
  return createClass_default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border);
      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    }

    // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.
  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
        sizeX = _imageWrapper$size.x,
        sizeY = _imageWrapper$size.y;
      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }
      return imageWrapper;
      // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    }

    // Retrieve a grayscale value at the given pixel position of the image
  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    }

    // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)
  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };
        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }
        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }
      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    }

    // Sets a given pixel position in the image to the given grayscale value
  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    }

    // Sets the border of the image (1 pixel) to zero
  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
        width = _this$size.x,
        height = _this$size.y;
      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }
      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }
      delete this.indexMapping;
      return this;
    }

    // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.
  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;
      if (labelCount <= 0) {
        return result;
      }
      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }
      for (y = 0; y < height; y++) {
        ysq = y * y;
        for (x = 0; x < width; x++) {
          val = data[y * width + x];
          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }
      for (i = 0; i < labelCount; i++) {
        label = labelSum[i];
        // eslint-disable-next-line no-restricted-globals
        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI;
          // eslint-disable-next-line no-mixed-operators
          label.theta = (tmp * 180 / PI + 90) % 180 - 90;
          if (label.theta < 0) {
            label.theta += 180;
          }
          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2_namespaceObject.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }
      return result;
    }

    // return a Uint8ClampedArray containing this grayscale image converted to RGBA form
  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);
      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }
      return ret;
    }

    // Display this ImageWrapper in a given Canvas element at the specified scale
  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      console.warn('* imagewrapper show getcontext 2d');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }
      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale);
      // eslint-disable-next-line no-param-reassign
      canvas.width = this.size.x;
      // eslint-disable-next-line no-param-reassign
      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    }

    // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.
  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      console.warn('* imagewrapper overlay getcontext 2d');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }
      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;
      while (length--) {
        hsv[0] = this.data[length] * adjustedScale;
        // eslint-disable-next-line no-nested-ternary
        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : hsv2rgb(hsv, rgb);
        var pos = length * 4;
        var _result = result;
        var _result2 = slicedToArray_default()(_result, 3);
        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }
      ctx.putImageData(frame, from.x, from.y);
    }
  }]);
}();
/* harmony default export */ var image_wrapper = (image_wrapper_ImageWrapper);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(7);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(6);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// CONCATENATED MODULE: ./src/common/image_debug.ts
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.

// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.

/* harmony default export */ var image_debug = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);
    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }
    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;
    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }
    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }
    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(4);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(1);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(5);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts



/* eslint-disable no-unused-vars */
/* eslint-disable class-methods-use-this */
// eslint-disable-next-line import/no-cycle



// for some reason this throws a shadow error on itself?!
// eslint-disable-next-line no-shadow
var BarcodeDirection = /*#__PURE__*/function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
  return BarcodeDirection;
}({});
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);
    defineProperty_default()(this, "_row", []);
    defineProperty_default()(this, "config", {});
    defineProperty_default()(this, "supplements", []);
    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);
    defineProperty_default()(this, "FORMAT", 'unknown');
    defineProperty_default()(this, "CONFIG_KEYS", {});
    this._row = [];
    this.config = config || {};
    if (supplements) {
      this.supplements = supplements;
    }
  }
  return createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }
      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      var maxSingleError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.SINGLE_CODE_ERROR || 1;
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }
      if (sum < modulo) {
        return Number.MAX_VALUE;
      }
      barWidth = sum / modulo;
      // eslint-disable-next-line no-param-reassign
      maxSingleError *= barWidth;
      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;
        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }
        error += singleError;
      }
      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }
      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;
      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);
        if (tmp > 1) {
          // eslint-disable-next-line no-param-reassign
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern;
      // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));
      var result = this.decode();
      // console.warn('* first result=', result);
      if (result === null) {
        this._row.reverse();
        result = this.decode();
        // console.warn('* reversed result=', result);
        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }
      if (result) {
        result.format = this.FORMAT;
      }
      // console.warn('* returning', result);
      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      // eslint-disable-next-line no-param-reassign
      start = start < 0 ? 0 : start;
      var i;
      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;
      for (var i = offset; i < end; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          // eslint-disable-next-line no-param-reassign
          isWhite = !isWhite;
        }
      }
      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper.init(counters, 0);
      for (var i = start; i < end; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          // eslint-disable-next-line no-param-reassign
          counters[counterPos]++;
        } else {
          counterPos++;
          if (counterPos === numCounters) {
            break;
          } else {
            // eslint-disable-next-line no-param-reassign
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }
      return counters;
    }

    // override/implement this in your custom readers.
  }, {
    key: "decodeImage",
    value: function decodeImage(imageWrapper) {
      // eslint-disable-next-line no-void
      void imageWrapper;
      return null;
    }
  }], [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }

    // Reader-specific adjacent-line validation threshold (0 => disabled)
  }]);
}();
defineProperty_default()(barcode_reader_BarcodeReader, "adjacentLineValidationMatches", 0);
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts






function _callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var N = 1;
var W = 3;
var START_PATTERN = [W, N, W, N, N, N];
var STOP_PATTERN = [W, N, N, N, W];
var CODE_PATTERN = [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]];
var START_PATTERN_LENGTH = START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);
var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  function TwoOfFiveReader() {
    var _this;
    classCallCheck_default()(this, TwoOfFiveReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, TwoOfFiveReader, [].concat(args));
    defineProperty_default()(_this, "barSpaceRatio", [1, 1]);
    defineProperty_default()(_this, "FORMAT", '2of5');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.78);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.30);
    return _this;
  }
  inherits_default()(TwoOfFiveReader, _BarcodeReader);
  return createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }
      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;
            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }
            error = this._matchPattern(counter, pattern);
            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }
            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;
      var offset = this._nextSet(this._row);
      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;
      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true);
        if (!startInfo) {
          return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();
      var offset = this._nextSet(this._row);
      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);
      this._row.reverse();
      if (endInfo === null) {
        return null;
      }

      // reverse numbers
      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      for (var code = 0; code < CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, CODE_PATTERN[code]);
        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }
      if (bestMatch.error < epsilon) {
        return bestMatch;
      }
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;
      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }
        code = this._decodeCode(counter);
        if (!code) {
          return null;
        }
        result.push("".concat(code.code));
        decodedCodes.push(code);
      }
      return code;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      var endInfo = this._findEnd();
      if (!endInfo) {
        return null;
      }
      var counters = this._fillCounters(startInfo.end, endInfo.start, false);
      if (!this._verifyCounterLength(counters)) {
        return null;
      }
      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];
      var code = this._decodePayload(counters, result, decodedCodes);
      if (!code) {
        return null;
      }
      if (result.length < 5) {
        return null;
      }
      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts






function codabar_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, codabar_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function codabar_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (codabar_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


// const ALPHABETH_STRING = '0123456789-$:/.+ABCD';
var ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;
var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  function NewCodabarReader() {
    var _this;
    classCallCheck_default()(this, NewCodabarReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = codabar_reader_callSuper(this, NewCodabarReader, [].concat(args));
    defineProperty_default()(_this, "_counters", []);
    defineProperty_default()(_this, "FORMAT", 'codabar');
    return _this;
  }
  inherits_default()(NewCodabarReader, _BarcodeReader);
  return createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;
      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];
        if (counter > max) {
          max = counter;
        }
        if (counter < min) {
          min = counter;
        }
      }
      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;
      if (end > this._counters.length) {
        return -1;
      }
      var barThreshold = this._computeAlternatingThreshold(offset, end);
      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);
      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;
      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;
        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }
        bitmask >>= 1;
      }
      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;
      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }
      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);
      var end = start;
      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);
        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }
      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;
      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }
      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);
      for (var i = 0; i < ALPHABET.length; i++) {
        if (ALPHABET[i] === charCode) {
          return CHARACTER_ENCODINGS[i];
        }
      }
      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;
      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);
        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }
        pos += 8;
      }
      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);
      var pos = startCounter;
      var pattern;
      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);
        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];
          if (size < cat.min || size > cat.max) {
            return false;
          }
          pattern >>= 1;
        }
        pos += 8;
      }
      return true;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();
      if (!start) {
        return null;
      }
      var nextStart = start.startCounter;
      var result = [];
      var pattern;
      do {
        pattern = this._toPattern(nextStart);
        if (pattern < 0) {
          return null;
        }
        var decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        nextStart += 8;
        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length);

      // verify end
      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      }

      // verify end white space
      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }
      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }
      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;
      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);
      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts






function code_128_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_128_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_128_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_128_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code128Reader() {
    var _this;
    classCallCheck_default()(this, Code128Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_128_reader_callSuper(this, Code128Reader, [].concat(args));
    defineProperty_default()(_this, "CODE_SHIFT", 98);
    defineProperty_default()(_this, "CODE_C", 99);
    defineProperty_default()(_this, "CODE_B", 100);
    defineProperty_default()(_this, "CODE_A", 101);
    defineProperty_default()(_this, "FNC1", 102);
    defineProperty_default()(_this, "START_CODE_A", 103);
    defineProperty_default()(_this, "START_CODE_B", 104);
    defineProperty_default()(_this, "START_CODE_C", 105);
    defineProperty_default()(_this, "STOP_CODE", 106);
    // ASCII 29 is the Group Separator character used to represent FNC1 in GS1-128 barcodes
    defineProperty_default()(_this, "FNC1_CHAR", String.fromCharCode(29));
    defineProperty_default()(_this, "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.64);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.30);
    defineProperty_default()(_this, "FORMAT", 'code_128');
    defineProperty_default()(_this, "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });
    return _this;
  }
  inherits_default()(Code128Reader, _BarcodeReader);
  return createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }
            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            bestMatch.end = i;
            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }
            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }
            return bestMatch;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);
      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    value:
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = this._nextSet(this._row);
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);
            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }
            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }
            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var _this2 = this;
      var startInfo = this._findStart();
      if (startInfo === null) {
        return null;
      }
      // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;

      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;
      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;
          case _this2.START_CODE_B:
            return _this2.CODE_B;
          case _this2.START_CODE_C:
            return _this2.CODE_C;
          default:
            return null;
        }
      }(code.code);
      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);
        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }
          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }
          decodedCodes.push(code);
          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;
                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;
                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;
                  case this.FNC1:
                    result.push(this.FNC1_CHAR);
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;
                  case this.FNC1:
                    result.push(this.FNC1_CHAR);
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;
                  case this.FNC1:
                    result.push(this.FNC1_CHAR);
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
          }
        } else {
          done = true;
        }
        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }
      if (code === null) {
        return null;
      }
      code.end = this._nextUnset(this._row, code.end);
      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }
      checksum -= multiplier * rawResult[rawResult.length - 1];
      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }
      if (!result.length) {
        return null;
      }

      // remove last code from result (checksum)
      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }
      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
        trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
        sumNormalized = 0,
        sumExpected = 0;
      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }
      return sumExpected / sumNormalized;
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(13);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(16);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts







function code_39_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_39_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_39_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_39_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/* eslint-disable class-methods-use-this */


var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var code_39_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_39_reader_CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;
var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code39Reader() {
    var _this;
    classCallCheck_default()(this, Code39Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_39_reader_callSuper(this, Code39Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_39');
    return _this;
  }
  inherits_default()(Code39Reader, _BarcodeReader);
  return createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);
      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;
      for (var i = offset; i < this._row.length; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }
            patternStart += counter[0] + counter[1];
            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }
            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;
      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;
        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            // eslint-disable-next-line no-bitwise
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }
        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;
              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }
          return pattern;
        }
      }
      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;
      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }
      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_39_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_39_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_39_reader_ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper.sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;
      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }
      return false;
    }
  }, {
    key: "decode",
    value: function decode() {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      var start = this._findStart();
      if (!start) {
        return null;
      }
      var nextStart = this._nextSet(this._row, start.end);
      var decodedChar;
      var lastStart;
      do {
        counters = this._toCounters(nextStart, counters);
        var pattern = this._toPattern(counters);
        if (pattern < 0) {
          return null;
        }
        decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper.sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');
      result.pop();
      if (!result.length) {
        return null;
      }
      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }
      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts







function code_32_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_32_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_32_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_32_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }

var patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';
var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  function Code32Reader() {
    var _this;
    classCallCheck_default()(this, Code32Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_32_reader_callSuper(this, Code32Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_32_reader');
    return _this;
  }
  inherits_default()(Code32Reader, _Code39Reader);
  return createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }
      var res = 0;
      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }
      var code32 = "".concat(res);
      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }
      return 'A' + code32;
    }

    // TODO (this was todo in original repo, no text was there. sorry.)
  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "decode",
    value: function decode() {
      var result = _superPropGet(Code32Reader, "decode", this, 3)([]);
      if (!result) {
        return null;
      }
      var code = result.code;
      if (!code) {
        return null;
      }
      code = code.replace(patterns.AEIO, '');
      if (!this._checkChecksum(code)) {
        return null;
      }
      var code32 = this._decodeCode32(code);
      if (!code32) {
        return null;
      }
      result.code = code32;
      return result;
    }
  }]);
}(code_39_reader);
/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts







function code_39_vin_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_39_vin_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_39_vin_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_39_vin_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function code_39_vin_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
/* eslint-disable class-methods-use-this */


var code_39_vin_reader_patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};
var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  function Code39VINReader() {
    var _this;
    classCallCheck_default()(this, Code39VINReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_39_vin_reader_callSuper(this, Code39VINReader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_39_vin');
    return _this;
  }
  inherits_default()(Code39VINReader, _Code39Reader);
  return createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    value:
    // TODO (this was todo in original repo, no text was there. sorry.)
    function _checkChecksum(code) {
      return !!code;
    }

    // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
  }, {
    key: "decode",
    value: function decode() {
      var result = code_39_vin_reader_superPropGet(Code39VINReader, "decode", this, 3)([]);
      if (!result) {
        return null;
      }
      var code = result.code;
      if (!code) {
        return null;
      }
      code = code.replace(code_39_vin_reader_patterns.IOQ, '');
      if (!code.match(code_39_vin_reader_patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }
        return null;
      }
      if (!this._checkChecksum(code)) {
        return null;
      }
      result.code = code;
      return result;
    }
  }]);
}(code_39_reader);
/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts







function code_93_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_93_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_93_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_93_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;
var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code93Reader() {
    var _this;
    classCallCheck_default()(this, Code93Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_93_reader_callSuper(this, Code93Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_93');
    return _this;
  }
  inherits_default()(Code93Reader, _BarcodeReader);
  return createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;
      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);
        if (normalized < 1 || normalized > 4) {
          return -1;
        }
        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }
      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);
      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }
            patternStart += counter[0] + counter[1];
            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }
            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }
      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];
      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];
        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }
          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;
          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }
              break;
            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }
              break;
            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }
              break;
            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }
              break;
            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }
          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }
      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      start = this._findStart();
      if (!start) {
        return null;
      }
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];
      var nextStart = this._nextSet(this._row, start.end);
      var lastStart;
      var decodedChar;
      do {
        counters = this._toCounters(nextStart, counters);
        var pattern = this._toPattern(counters);
        if (pattern < 0) {
          return null;
        }
        decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper.sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');
      result.pop();
      if (!result.length) {
        return null;
      }
      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }
      if (!this._verifyChecksums(result)) {
        return null;
      }
      result = result.slice(0, result.length - 2);
      // yes, this is an assign inside an if.
      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }
      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/ean_reader.ts






function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function ean_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }



// const CODE_L_START = 0;
var CODE_G_START = 10;

var ean_reader_START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var ean_reader_CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
// const SINGLE_CODE_ERROR = 0.70;
var AVG_CODE_ERROR = 0.48;
var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  // TODO: does this need to be in the class?

  function EANReader(config, supplements) {
    var _this;
    classCallCheck_default()(this, EANReader);
    _this = ean_reader_callSuper(this, EANReader, [merge_default()({
      supplements: []
    }, config), supplements]);
    defineProperty_default()(_this, "FORMAT", 'ean_13');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.70);
    defineProperty_default()(_this, "STOP_PATTERN", [1, 1, 1]);
    return _this;
  }
  inherits_default()(EANReader, _BarcodeReader);
  return createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR;
      // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);
      var counterPos = 0;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      var found = false;
      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern);
            // console.warn('* matchPattern', error, counter, pattern);
            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i;
              // console.warn('* return bestMatch', JSON.stringify(bestMatch));
              return bestMatch;
            }
            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      if (found) {
        // console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {
        // console.warn('* return null');
      }
      return found ? bestMatch : null;
    }

    // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?
  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;
      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = ean_reader_CODE_PATTERN.length;
        // console.warn('* decodeCode after length');
      }
      var found = false;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, ean_reader_CODE_PATTERN[code]);
              bestMatch.end = i;
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            }
            // console.warn('* return bestMatch', JSON.stringify(bestMatch));
            return bestMatch;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);
      var startInfo = null;
      while (!startInfo) {
        startInfo = this._findPattern(ean_reader_START_PATTERN, offset, false, true);
        // console.warn('* startInfo=', JSON.stringify(startInfo));
        if (!startInfo) {
          return null;
        }
        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      // console.warn('* returning null');
      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      }
      // console.warn('* return null');
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);
      var codeFrequency = 0x0;
      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);
        // console.warn('* decodeCode=', outCode);
        if (!outCode) {
          // console.warn('* return null');
          return null;
        }
        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }
        result.push(outCode.code);
        decodedCodes.push(outCode);
      }
      var firstDigit = this._calculateFirstDigit(codeFrequency);
      // console.warn('* firstDigit=', firstDigit);
      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }
      result.unshift(firstDigit);
      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false);
      // console.warn('* findPattern=', JSON.stringify(middlePattern));

      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }
      decodedCodes.push(middlePattern);
      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START);
        // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }
        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      }

      // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);
      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      }
      // console.warn('* return null');
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;
      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }
      sum *= 3;
      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      }

      // console.warn('* end checksum', sum % 10 === 0);
      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);
      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);
      if (startInfo === null) {
        return null;
      }

      // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');
      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i].decode(this._row, startInfo.end);
          // console.warn('* decode result=', result);
          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      }

      // console.warn('* end decodeExtensions');
      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);
      if (!code) {
        return null;
      }
      code = this._findEnd(code.end, false);
      if (!code) {
        return null;
      }
      decodedCodes.push(code);

      // Checksum
      if (!this._checksum(result)) {
        return null;
      }

      // console.warn('* this.supplements=', this.supplements);
      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end);
        // console.warn('* decodeExtensions returns', supplement);
        if (!supplement) {
          return null;
        }
        if (!supplement.decodedCodes) {
          return null;
        }
        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };
        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }
        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }
      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);
}(barcode_reader);
/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts






function ean_2_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_2_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_2_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_2_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  function EAN2Reader() {
    var _this;
    classCallCheck_default()(this, EAN2Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_2_reader_callSuper(this, EAN2Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_2');
    return _this;
  }
  inherits_default()(EAN2Reader, _EANReader);
  return createClass_default()(EAN2Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (row) {
        this._row = row;
      }
      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;
      if (offset === undefined) {
        return null;
      }
      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }
        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }
      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }
      var startInfo = this._findStart();
      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);
}(ean_reader);
;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts






function ean_5_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_5_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_5_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_5_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }
  return null;
}
function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;
  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }
  sum *= 3;
  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }
  sum *= 3;
  return sum % 10;
}
var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  function EAN5Reader() {
    var _this;
    classCallCheck_default()(this, EAN5Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_5_reader_callSuper(this, EAN5Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_5');
    return _this;
  }
  inherits_default()(EAN5Reader, _EANReader);
  return createClass_default()(EAN5Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (start === undefined) {
        return null;
      }
      if (row) {
        this._row = row;
      }
      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];
      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }
        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }
      if (result.length !== 5) {
        return null;
      }
      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }
      var startInfo = this._findStart();
      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);
}(ean_reader);
;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts






function ean_8_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_8_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_8_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_8_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  function EAN8Reader() {
    var _this;
    classCallCheck_default()(this, EAN8Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_8_reader_callSuper(this, EAN8Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_8');
    return _this;
  }
  inherits_default()(EAN8Reader, _EANReader);
  return createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;
      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);
        if (!code) {
          return null;
        }
        result.push(code.code);
        decodedCodes.push(code);
      }
      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);
      if (code === null) {
        return null;
      }
      decodedCodes.push(code);
      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
      }
      return code;
    }
  }]);
}(ean_reader);
/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts







function i2of5_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, i2of5_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function i2of5_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (i2of5_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function i2of5_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that



var i2of5_reader_N = 1;
var i2of5_reader_W = 3;
var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  function I2of5Reader(opts) {
    var _this;
    classCallCheck_default()(this, I2of5Reader);
    _this = i2of5_reader_callSuper(this, I2of5Reader, [merge_default()({
      normalizeBarSpaceWidth: false
    }, opts)]);
    defineProperty_default()(_this, "barSpaceRatio", [1, 1]);
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.78);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.38);
    defineProperty_default()(_this, "START_PATTERN", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N]);
    defineProperty_default()(_this, "STOP_PATTERN", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W]);
    defineProperty_default()(_this, "CODE_PATTERN", [[i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N]]);
    defineProperty_default()(_this, "MAX_CORRECTION_FACTOR", 5);
    defineProperty_default()(_this, "FORMAT", 'i2of5');
    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }
    _this.config = opts;
    return possibleConstructorReturn_default()(_this, _this);
  }
  inherits_default()(I2of5Reader, _BarcodeReader);
  return createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;
        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }
        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;
        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }
      return i2of5_reader_superPropGet(I2of5Reader, "_matchPattern", this, 3)([counter, code]);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);
            var error = this._matchPattern(counter, pattern);
            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }
            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;
      var offset = this._nextSet(this._row);
      var startInfo = null;
      var narrowBarWidth = 1;
      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);
        if (!startInfo) {
          return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();
      var endInfo = this._findPattern(this.STOP_PATTERN);
      this._row.reverse();
      if (endInfo === null) {
        return null;
      }

      // reverse numbers
      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];
      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);
        if (!code) {
          return null;
        }
        codes.push(code);
      }
      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }
      if (bestMatch.error < epsilon) {
        return bestMatch;
      }
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;
      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }
        codes = this._decodePair(counterPair);
        if (!codes) {
          return null;
        }
        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }
      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      decodedCodes.push(startInfo);
      var endInfo = this._findEnd();
      if (!endInfo) {
        return null;
      }
      var counters = this._fillCounters(startInfo.end, endInfo.start, false);
      if (!this._verifyCounterLength(counters)) {
        return null;
      }
      var code = this._decodePayload(counters, result, decodedCodes);
      if (!code) {
        return null;
      }
      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }
      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/pharmacode_reader.ts







function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function pharmacode_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, pharmacode_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function pharmacode_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (pharmacode_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


/**
 * Pharmacode (Pharmaceutical Binary Code) Reader
 *
 * Pharmacode is a binary barcode used in pharmaceutical packaging.
 * It encodes numbers from 3 to 131070 using narrow and wide bars.
 *
 * Encoding rules:
 * - Reading from right to left (least significant first)
 * - Narrow bar at position i adds 2^i to the value
 * - Wide bar at position i adds 2^(i+1) to the value
 * - Bars are separated by uniform-width spaces
 * - Minimum 2 bars, maximum 16 bars
 * - Valid range: 3 to 131070
 *
 * Example: Value 755
 * Binary representation of bars (from left to right in barcode):
 * wide, narrow, wide, narrow, narrow, wide, narrow, wide, narrow
 *
 * Reference: https://en.wikipedia.org/wiki/Pharmacode
 */

// Minimum number of bars in a valid Pharmacode
var MIN_BAR_COUNT = 2;
// Maximum number of bars in a valid Pharmacode
var MAX_BAR_COUNT = 16;
// Minimum valid Pharmacode value
var MIN_VALUE = 3;
// Maximum valid Pharmacode value
var MAX_VALUE = 131070;

// Threshold ratio to distinguish narrow from wide bars
// A bar wider than this ratio of the narrow bar width is considered wide
var WIDE_BAR_THRESHOLD = 1.6;

// Maximum allowed variation in space widths (coefficient of variation)
// Reduced from 0.4 to help with false positives, but allowing some tolerance
var MAX_SPACE_VARIANCE = 0.35;

// Minimum quiet zone requirement in barcode widths (pharmaceutical spec: 6mm min)
// We use 1x narrow bar width as a minimum quiet zone
var MIN_QUIET_ZONE_WIDTHS = 1;

// Allowed narrow/wide bar ratios (1:2, 1:2.5, 1:3)
// These are multipliers applied to narrow bar width
var ALLOWED_WIDE_BAR_RATIOS = [2.0, 2.5, 3.0];
var WIDE_BAR_RATIO_TOLERANCE = 0.05; // Allow 5% deviation from the detected ratio
var pharmacode_reader_PharmacodeReader = /*#__PURE__*/function (_BarcodeReader) {
  function PharmacodeReader() {
    var _this;
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck_default()(this, PharmacodeReader);
    _this = pharmacode_reader_callSuper(this, PharmacodeReader, [config]);
    defineProperty_default()(_this, "FORMAT", 'pharmacode');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.7);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.48);
    return _this;
  }

  /**
   * Find the start of the barcode (first black bar after leading whitespace)
   * Public so that barcode_decoder can use it for tilted barcode validation
   */
  inherits_default()(PharmacodeReader, _BarcodeReader);
  return createClass_default()(PharmacodeReader, [{
    key: "_findStart",
    value: function _findStart() {
      // Strategy: scan leftright; accept the first bar that:
      // 1. Has a sufficient leading quiet zone ( 2 bar width, min 20px)
      // 2. Is followed by another bar at a reasonable distance ( 10 bar width)
      //    This rejects isolated noise bars surrounded by large white spaces.

      var minQuietZone = 20;
      var searchPos = 0;
      while (searchPos < this._row.length) {
        var barStart = this._nextSet(this._row, searchPos);
        if (barStart >= this._row.length) {
          return null; // no more black pixels
        }

        // Find the end of this black run
        var barEnd = barStart;
        while (barEnd < this._row.length && this._row[barEnd]) {
          barEnd++;
        }
        var barWidth = barEnd - barStart;

        // Skip narrow noise bars
        if (barWidth < 5) {
          searchPos = barEnd + 1;
          continue;
        }

        // Check leading quiet zone
        var requiredQuietZone = Math.max(barWidth * 2, minQuietZone);
        var quietZoneStart = barStart - requiredQuietZone;
        if (quietZoneStart < 0) {
          searchPos = barEnd + 1;
          continue;
        }
        if (!this._matchRange(quietZoneStart, barStart, 0)) {
          searchPos = barEnd + 1;
          continue;
        }

        // Forward-look: Check that the next bar appears within a reasonable distance.
        // A real barcode has bars followed by narrow spaces (5-15px), not huge gaps.
        // Allow up to 10 bar width for the space (being generous for very narrow bars).
        var maxSpaceToNextBar = Math.max(barWidth * 10, 50);
        var nextBarStart = this._nextSet(this._row, barEnd);
        if (nextBarStart >= this._row.length) {
          // No next bar; this is an isolated bar, likely noise
          searchPos = barEnd + 1;
          continue;
        }
        var spaceToNextBar = nextBarStart - barEnd;
        if (spaceToNextBar > maxSpaceToNextBar) {
          // Space is too large; this is likely an isolated bar
          searchPos = barEnd + 1;
          continue;
        }
        return {
          start: barStart,
          end: barEnd
        };
      }
      return null;
    }

    /**
     * Smooth bar widths to reduce edge-detection jitter from colored barcodes.
     * Applies median filter to adjacent bars: if a bar is 13px different from neighbors,
     * snap it to the median of local bars to stabilize measurements.
     */
  }, {
    key: "_smoothBarWidths",
    value: function _smoothBarWidths(bars) {
      if (bars.length <= 2) {
        return bars; // Not enough bars to smooth
      }
      var smoothed = bars.slice();
      for (var i = 1; i < smoothed.length - 1; i++) {
        var prev = smoothed[i - 1];
        var curr = smoothed[i];
        var next = smoothed[i + 1];

        // If current bar is significantly different from neighbors, snap to median
        var median = [prev, curr, next].sort(function (a, b) {
          return a - b;
        })[1];
        var deviation = Math.abs(curr - median);

        // If deviation is small (13px), snap to median to reduce noise
        if (deviation > 0 && deviation <= 3) {
          smoothed[i] = median;
        }
      }
      return smoothed;
    }

    /**
     * Extract all bar and space widths from the pattern.
     * Uses real-time quiet zone detection to stop extraction before reaching image edge.
     */
  }, {
    key: "_extractBarsAndSpaces",
    value: function _extractBarsAndSpaces(startPos) {
      var bars = [];
      var spaces = [];
      var pos = startPos;
      var currentWidth = 0;
      var foundTrailingQuietZone = false;

      // Extract first bar
      while (pos < this._row.length && this._row[pos]) {
        currentWidth++;
        pos++;
      }
      if (currentWidth === 0) {
        return null;
      }
      bars.push(currentWidth);

      // Extract first space (needed to establish space width and estimate narrow bar)
      currentWidth = 0;
      while (pos < this._row.length && !this._row[pos]) {
        currentWidth++;
        pos++;
      }
      if (currentWidth === 0 || pos >= this._row.length) {
        return null; // No space after first bar, or hit edge
      }
      spaces.push(currentWidth);

      // Estimate narrow bar width for quiet zone detection
      // If first bar < first space, assume first bar is narrow
      // Otherwise, estimate narrow from space (space  1.25 * narrow)
      var estimatedNarrowWidth = bars[0] < spaces[0] ? bars[0] : spaces[0] * 0.8;

      // Pharmaceutical spec: quiet zone must be >= 6mm  6x narrow bar (strict)
      var strictQuietZone = estimatedNarrowWidth * 6;
      // Adaptive quiet zone: 2.5x the typical inter-bar space width
      // This should catch legitimate quiet zones while avoiding false positives
      var adaptiveQuietZone = spaces[0] * 2.5;

      // Continue extracting alternating bars and spaces
      // Stop BEFORE reaching MAX_BAR_COUNT+1 to avoid extracting too many bars
      while (pos < this._row.length && bars.length < MAX_BAR_COUNT) {
        // Extract bar
        currentWidth = 0;
        while (pos < this._row.length && this._row[pos]) {
          currentWidth++;
          pos++;
        }
        if (currentWidth === 0) {
          // Reached end of barcode (no more bars)
          break;
        }
        bars.push(currentWidth);

        // Extract space
        currentWidth = 0;
        var spaceStart = pos;
        while (pos < this._row.length && !this._row[pos]) {
          currentWidth++;
          pos++;
        }
        if (currentWidth === 0) {
          // No space after this bar - barcode ended
          break;
        }

        // Check if this space is a quiet zone (strict pharmaceutical spec)
        if (currentWidth >= strictQuietZone) {
          // Found strict trailing quiet zone - stop extraction here
          foundTrailingQuietZone = true;
          pos = spaceStart; // Reset pos to start of quiet zone
          break;
        }

        // Adaptive quiet zone: if this space is significantly larger than normal inter-bar spaces
        // (2x or more), treat it as a quiet zone
        if (bars.length >= MIN_BAR_COUNT && currentWidth >= adaptiveQuietZone) {
          foundTrailingQuietZone = true;
          pos = spaceStart;
          break;
        }

        // Check if we hit the image edge while counting this space
        if (pos >= this._row.length) {
          // Hit image edge while in whitespace - treat as infinite quiet zone
          // We've reached the end of the image, which counts as an implicit quiet zone
          foundTrailingQuietZone = true;
          pos = spaceStart; // Reset to start of quiet zone
          break;
        }

        // This is a normal inter-bar space
        spaces.push(currentWidth);

        // Update adaptive quiet zone based on average space width
        // A quiet zone should be at least 2x the average inter-bar space
        if (spaces.length >= 2) {
          var avgSpace = spaces.reduce(function (a, b) {
            return a + b;
          }, 0) / spaces.length;
          adaptiveQuietZone = avgSpace * 2;
        }
      }

      // If we exited the loop without finding a trailing quiet zone, barcode is invalid
      // (This catches barcodes that end exactly at the image edge)
      if (!foundTrailingQuietZone) {
        return null;
      }

      // Validate bar count
      if (bars.length < MIN_BAR_COUNT || bars.length > MAX_BAR_COUNT) {
        return null;
      }

      // We should have (n-1) spaces for n bars
      if (spaces.length !== bars.length - 1) {
        return null;
      }

      // Validate that spaces are uniform (pharmacode requirement)
      if (!this._validateSpaces(spaces)) {
        return null;
      }

      // Validate that bars have at most 2 distinct sizes (narrow and/or wide)
      if (!this._validateBarSizeCount(bars)) {
        return null;
      }

      // Apply smoothing to reduce edge-detection jitter on colored barcodes
      var smoothedBars = this._smoothBarWidths(bars);
      return {
        bars: smoothedBars,
        spaces: spaces,
        end: pos
      };
    }

    /**
     * Validate that bars have at most 2 distinct sizes (narrow and/or wide).
     * Pharmacode bars must be either all one size, or two sizes (narrow + wide).
     * If 3+ distinct sizes detected, this is not a valid pharmacode.
     */
  }, {
    key: "_validateBarSizeCount",
    value: function _validateBarSizeCount(bars) {
      if (bars.length === 0) {
        return false;
      }

      // Cluster bars into size groups with 35% tolerance to handle edge-detection jitter
      // This matches the tolerance used for space validation (CV <= 0.35)
      var tolerance = 0.35;
      var clusters = [];
      var _iterator = _createForOfIteratorHelper(bars),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var bar = _step.value;
          var foundCluster = false;
          var _iterator2 = _createForOfIteratorHelper(clusters),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var cluster = _step2.value;
              var clusterAvg = cluster.reduce(function (a, b) {
                return a + b;
              }, 0) / cluster.length;
              if (Math.abs(bar - clusterAvg) <= clusterAvg * tolerance) {
                cluster.push(bar);
                foundCluster = true;
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          if (!foundCluster) {
            clusters.push([bar]);
          }
        }

        // Must have exactly 1 or 2 clusters (not 3+)
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (clusters.length > 2) {
        return false;
      }
      return true;
    }

    /**
     * Check if space widths are uniform enough for a valid Pharmacode
     */
  }, {
    key: "_validateSpaces",
    value: function _validateSpaces(spaces) {
      if (spaces.length === 0) {
        return true; // Single bar (though invalid for Pharmacode)
      }
      var mean = spaces.reduce(function (a, b) {
        return a + b;
      }, 0) / spaces.length;
      if (mean === 0) {
        return false;
      }

      // Calculate coefficient of variation
      var variance = spaces.reduce(function (sum, s) {
        return sum + Math.pow(s - mean, 2);
      }, 0) / spaces.length;
      var stdDev = Math.sqrt(variance);
      var cv = stdDev / mean;
      return cv <= MAX_SPACE_VARIANCE;
    }

    /**
     * Validate that narrow and wide bars follow a consistent ratio (1:2, 1:2.5, or 1:3)
     * This is a spec requirement for pharmacodes
     */
  }, {
    key: "_validateBarRatios",
    value: function _validateBarRatios(bars, spaces) {
      // If all bars are essentially the same width (low variance), need to determine if narrow or wide
      var avgAll = bars.reduce(function (a, b) {
        return a + b;
      }, 0) / bars.length;
      var varAll = bars.reduce(function (a, b) {
        return a + Math.abs(b - avgAll);
      }, 0) / bars.length;
      var cvAll = avgAll === 0 ? 0 : varAll / avgAll;
      if (cvAll <= 0.1) {
        // Low variance: could be all-narrow or all-wide
        // Use space widths as a hint: spaces should be ~1.25x the narrow bar width
        var avgSpace = spaces.length > 0 ? spaces.reduce(function (a, b) {
          return a + b;
        }, 0) / spaces.length : 0;
        if (avgSpace > 0) {
          var spaceToBarRatio = avgSpace / avgAll;
          // If spaces are much smaller than bars, bars are likely wide (ratio should be ~0.3-0.5)
          // If spaces are comparable to bars or larger, bars are likely narrow (ratio should be ~1.0-1.5)
          if (spaceToBarRatio < 0.7) {
            // Bars are likely wide; infer narrow width from them
            // Use the closest allowed ratio
            var inferredNarrow = avgAll / 2.5; // Try middle ratio first
            return {
              narrowWidth: inferredNarrow,
              wideRatio: 2.5
            };
          }
        }

        // Default: treat as all-narrow
        return {
          narrowWidth: avgAll,
          wideRatio: 2.0
        };
      }
      // Explore multiple possible thresholds (midpoints between sorted unique widths)
      // and pick the one that best matches an allowed ratio with low per-bar deviation.
      var sortedUnique = Array.from(new Set(bars.slice().sort(function (a, b) {
        return a - b;
      })));
      if (sortedUnique.length < 2) {
        // All bars identical: treat as single-width (valid pharmacode of all narrow or all wide)
        var avgWidth = bars.reduce(function (a, b) {
          return a + b;
        }, 0) / bars.length;
        return {
          narrowWidth: avgWidth,
          wideRatio: 2.0
        };
      }
      var candidates = [];

      // Generate candidate thresholds at midpoints between consecutive unique widths
      for (var i = 0; i < sortedUnique.length - 1; i++) {
        var t = (sortedUnique[i] + sortedUnique[i + 1]) / 2;
        var n = [];
        var w = [];
        var _iterator3 = _createForOfIteratorHelper(bars),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var b = _step3.value;
            if (b < t) {
              n.push(b);
            } else {
              w.push(b);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        if (n.length === 0 || w.length === 0) {
          continue; // need both groups
        }
        var avgN = n.reduce(function (a, b) {
          return a + b;
        }, 0) / n.length;
        var avgW = w.reduce(function (a, b) {
          return a + b;
        }, 0) / w.length;
        var ratio = avgW / avgN;

        // Find closest allowed ratio
        var bestRatio = ALLOWED_WIDE_BAR_RATIOS[0];
        var bestDiff = Math.abs(ratio - bestRatio);
        for (var _i = 0, _ALLOWED_WIDE_BAR_RAT = ALLOWED_WIDE_BAR_RATIOS; _i < _ALLOWED_WIDE_BAR_RAT.length; _i++) {
          var r = _ALLOWED_WIDE_BAR_RAT[_i];
          var d = Math.abs(ratio - r);
          if (d < bestDiff) {
            bestDiff = d;
            bestRatio = r;
          }
        }
        candidates.push({
          threshold: t,
          narrowBars: n,
          wideBars: w,
          avgN: avgN,
          avgW: avgW,
          ratio: ratio,
          ratioDiff: bestDiff,
          matchedRatio: bestRatio
        });
      }

      // Sort candidates by how close the ratio is to allowed ratios
      candidates.sort(function (a, b) {
        return a.ratioDiff - b.ratioDiff;
      });
      for (var _i2 = 0, _candidates = candidates; _i2 < _candidates.length; _i2++) {
        var c = _candidates[_i2];
        // Check ratio within tolerance
        var tolerance = c.matchedRatio * WIDE_BAR_RATIO_TOLERANCE;
        if (Math.abs(c.ratio - c.matchedRatio) > tolerance) {
          continue;
        }

        // Per-bar consistency checks
        // Use 15% tolerance instead of 30% to reject bars with too much width variation
        // Real pharmacodes have consistent bar widths; tilted/curved ones show variation
        var narrowTolerance = c.avgN * 0.15;
        var wideTolerance = c.avgW * 0.15;
        var ok = true;
        var _iterator4 = _createForOfIteratorHelper(c.narrowBars),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _b = _step4.value;
            if (Math.abs(_b - c.avgN) > narrowTolerance) {
              ok = false;
              break;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        if (!ok) continue;
        var _iterator5 = _createForOfIteratorHelper(c.wideBars),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _b2 = _step5.value;
            if (Math.abs(_b2 - c.avgW) > wideTolerance) {
              ok = false;
              break;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        if (!ok) continue;

        // Accept first viable candidate (closest ratio)
        return {
          narrowWidth: c.avgN,
          wideRatio: c.matchedRatio
        };
      }
      return null;
    }

    /**
     * Validate periodicity of bar and space widths
     * Real pharmacodes have consistent bar/space widths with low variation
     * Tilted barcodes create varying widths due to angle-dependent cross-sections
     * Uses coefficient of variation (CV = stdDev / mean) to detect this
     */
  }, {
    key: "_validatePeriodicity",
    value: function _validatePeriodicity(bars, spaces) {
      // Calculate coefficient of variation for bars
      if (bars.length > 0) {
        var barMean = bars.reduce(function (a, b) {
          return a + b;
        }, 0) / bars.length;
        var barVariance = bars.reduce(function (a, b) {
          return a + Math.pow(b - barMean, 2);
        }, 0) / bars.length;
        var barStdDev = Math.sqrt(barVariance);
        var barCV = barMean !== 0 ? barStdDev / barMean : 0;

        // Reject if bar CV is too high (indicates tilted/curved barcode with varying cross-sections)
        // Threshold of 0.65 allows for reasonable variation in valid codes while still catching severe misalignments
        if (barCV > 0.65) {
          return false;
        }
      }

      // Calculate coefficient of variation for spaces
      if (spaces.length > 0) {
        var spaceMean = spaces.reduce(function (a, b) {
          return a + b;
        }, 0) / spaces.length;
        var spaceVariance = spaces.reduce(function (a, b) {
          return a + Math.pow(b - spaceMean, 2);
        }, 0) / spaces.length;
        var spaceStdDev = Math.sqrt(spaceVariance);
        var spaceCV = spaceMean !== 0 ? spaceStdDev / spaceMean : 0;

        // Reject if space CV is too high
        if (spaceCV > 0.55) {
          return false;
        }
      }
      return true;
    }

    /**
     * Verify that there is sufficient quiet zone at start and end
     * When area constraints are used, the quiet zone may be truncated,
     * so we check if we have at least SOME quiet zone or hit the scan boundary
     */
  }, {
    key: "_validateQuietZones",
    value: function _validateQuietZones(startInfo, narrowWidth, end) {
      var minQuietZone = narrowWidth * MIN_QUIET_ZONE_WIDTHS;

      // Check leading quiet zone
      // If we're very close to the start (within 2 pixels), we likely hit the area boundary
      // In that case, accept it as we can't verify the quiet zone
      if (startInfo.start >= 2 && startInfo.start < minQuietZone) {
        return false;
      }

      // Check trailing quiet zone
      // If we're at or very close to the end of the row, we likely hit the area boundary
      // In real extracted images, especially with resizing, we may not have perfect quiet zones
      // So we accept it if we're within 6 pixels of the end (scan boundary)
      var remainingSpace = this._row.length - end;

      // If we're very close to the edge (< 6px), we hit the scan boundary - accept it
      if (remainingSpace < 6) {
        return true;
      }

      // We have at least 6px of trailing space - check if it meets minimum quiet zone requirement
      if (remainingSpace < minQuietZone) {
        return false;
      }
      return true;
    }

    /**
     * Classify bars as narrow or wide and decode the value
     */
  }, {
    key: "_decodeBars",
    value: function _decodeBars(bars, narrowWidth) {
      // Use provided narrowWidth if available (from _validateBarRatios inference)
      // Otherwise, find the minimum bar width (likely narrow bar)
      var minWidth = narrowWidth !== null && narrowWidth !== void 0 ? narrowWidth : Math.min.apply(Math, toConsumableArray_default()(bars));

      // If all bars are similar width, it might be a valid Pharmacode with all narrow or all wide bars
      // But we need to determine the threshold
      var threshold = minWidth * WIDE_BAR_THRESHOLD;

      // Calculate the Pharmacode value using the correct algorithm
      // Position n starts at 0 on the RIGHT (last bar in array)
      // Narrow bar at position n adds 2^n
      // Wide bar at position n adds 2^(n+1)
      var value = 0;

      // Reverse bars to process right-to-left
      var reversedBars = bars.slice().reverse();
      for (var i = 0; i < reversedBars.length; i++) {
        var isWide = reversedBars[i] > threshold;
        if (isWide) {
          value += Math.pow(2, i + 1);
        } else {
          value += Math.pow(2, i);
        }
      }

      // Build human-readable bar pattern for debugging
      var pattern = '';
      for (var _i3 = reversedBars.length - 1; _i3 >= 0; _i3--) {
        pattern += reversedBars[_i3] > threshold ? 'W' : 'N';
      }
      return {
        value: value,
        pattern: pattern
      };
    }

    /**
     * Verify trailing whitespace (quiet zone)
     */
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(end, barWidth) {
      var trailingWhitespaceEnd = Math.min(end + barWidth * 2, this._row.length);
      return this._matchRange(end, trailingWhitespaceEnd, 0);
    }

    /**
     * Check pattern consistency: extract bars from slightly shifted positions.
     * Real barcodes should produce consistent bar patterns even with small shifts.
     * Text patterns are typically edge-based and will break with a small shift.
     */
  }, {
    key: "_validatePatternConsistency",
    value: function _validatePatternConsistency(startInfo, bars) {
      var originalStart = startInfo.start;
      var consistentOffsets = 0;
      var totalChecks = 0;

      // Check positions offset by 1 and 2 pixels (simulate scanning lines nearby)
      for (var _i4 = 0, _arr = [-2, -1, 1, 2]; _i4 < _arr.length; _i4++) {
        var offset = _arr[_i4];
        var shiftedStart = originalStart + offset;
        if (shiftedStart < 0 || shiftedStart >= this._row.length) {
          continue;
        }
        totalChecks++;

        // Try to extract bars from shifted position
        var shiftedExtracted = this._extractBarsAndSpaces(shiftedStart);
        if (!shiftedExtracted) {
          continue;
        }

        // If we got bars and they match in count, it's more likely a real barcode
        if (shiftedExtracted.bars.length === bars.length) {
          // Check if bar widths are roughly similar (within 25%)
          var barsMatch = true;
          for (var i = 0; i < bars.length; i++) {
            var diff = Math.abs(shiftedExtracted.bars[i] - bars[i]) / Math.max(bars[i], 1);
            if (diff > 0.25) {
              barsMatch = false;
              break;
            }
          }
          if (barsMatch) {
            consistentOffsets++;
          }
        }
      }

      // Real barcodes should be consistent across multiple shifted positions
      // Text patterns typically fail this test
      if (totalChecks > 0 && consistentOffsets >= totalChecks * 0.5) {
        return true; // Consistent across at least 50% of positions
      }
      return false;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      // Find the start of the barcode
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }

      // REJECT if barcode starts too late in the scan (>50% of line length)
      // Valid pharmacodes should be found near the image edge or early in the scan.
      // Starting too far into the image indicates we're picking up noise or a shifted pattern
      // (i.e., sampling mid-bar, which reverses the encoding).
      // This also rejects tilted barcodes that only appear straight at one specific angle.
      if (startInfo.start > this._row.length * 0.50) {
        return null;
      }

      // Extract bars and spaces
      var extracted = this._extractBarsAndSpaces(startInfo.start);
      if (!extracted) {
        return null;
      }
      var bars = extracted.bars,
        spaces = extracted.spaces,
        end = extracted.end;

      // Reject extremely short patterns (total width < 20px)
      // Calculate actual barcode width from sum of bars and spaces
      var barsWidth = bars.reduce(function (sum, w) {
        return sum + w;
      }, 0);
      var spacesWidth = spaces.reduce(function (sum, w) {
        return sum + w;
      }, 0);
      var totalBarcodeWidth = barsWidth + spacesWidth;
      if (totalBarcodeWidth < 20) {
        return null;
      }

      // EDGE-REACH REJECTION: Reject if extraction reaches image boundary
      // Valid pharmacodes require proper quiet zones per pharmaceutical spec (min 6mm  16px at typical DPI)
      // Extractions reaching the image edge (end >= row.length - 2) indicate incomplete/invalid patterns
      // This catches tilted and curved barcodes that only appear straight at one specific angle
      var EDGE_MARGIN = 0; // No margin: only reject if extraction goes PAST the row length (shouldn't happen but be safe)
      var remainingSpace = this._row.length - end;
      if (remainingSpace < EDGE_MARGIN) {
        return null;
      }

      // Validate space uniformity
      if (!this._validateSpaces(spaces)) {
        return null;
      }

      // Validate periodicity of bar and space widths to reject tilted/curved barcodes
      if (!this._validatePeriodicity(bars, spaces)) {
        return null;
      }

      // For short patterns, validate consistency across shifted positions
      // to reject text/noise patterns that appear as bars due to edge detection
      if (!this._validatePatternConsistency(startInfo, bars)) {
        return null;
      }

      // Validate bar width ratios are consistent (1:2, 1:2.5, or 1:3)
      var ratioInfo = this._validateBarRatios(bars, spaces);
      if (!ratioInfo) {
        return null;
      }

      // Validate quiet zones meet pharmaceutical spec
      if (!this._validateQuietZones(startInfo, ratioInfo.narrowWidth, end)) {
        return null;
      }

      // Decode the bars, passing the inferred narrowWidth for all-wide/all-narrow patterns
      var decoded = this._decodeBars(bars, ratioInfo.narrowWidth);
      if (!decoded) {
        return null;
      }
      var value = decoded.value;

      // Validate value range
      if (value < MIN_VALUE || value > MAX_VALUE) {
        return null;
      }

      // Verify trailing whitespace
      var avgBarWidth = bars.reduce(function (a, b) {
        return a + b;
      }, 0) / bars.length;
      if (!this._verifyTrailingWhitespace(end, avgBarWidth)) {
        // Soft fail - allow but note it
      }

      // Build the decoded codes array for debugging/visualization
      var decodedCodes = bars.map(function (width, index) {
        return {
          code: width > Math.min.apply(Math, toConsumableArray_default()(bars)) * WIDE_BAR_THRESHOLD ? 1 : 0,
          start: 0,
          // Could calculate actual positions if needed
          end: 0,
          error: 0
        };
      });
      return {
        code: value.toString(),
        start: startInfo.start,
        end: end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        pattern: decoded.pattern,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
defineProperty_default()(pharmacode_reader_PharmacodeReader, "adjacentLineValidationMatches", 1);
/* harmony default export */ var pharmacode_reader = (pharmacode_reader_PharmacodeReader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts







function upc_e_reader_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function upc_e_reader_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? upc_e_reader_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : upc_e_reader_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function upc_e_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, upc_e_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function upc_e_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (upc_e_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function upc_e_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }

var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  function UPCEReader() {
    var _this;
    classCallCheck_default()(this, UPCEReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = upc_e_reader_callSuper(this, UPCEReader, [].concat(args));
    defineProperty_default()(_this, "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);
    defineProperty_default()(_this, "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);
    defineProperty_default()(_this, "FORMAT", 'upc_e');
    return _this;
  }
  inherits_default()(UPCEReader, _EANReader);
  return createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);
      var codeFrequency = 0x0;
      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);
        if (!outCode) {
          return null;
        }
        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }
        result.push(outCode.code);
        decodedCodes.push(outCode);
      }
      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }
      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];
      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }
      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return upc_e_reader_superPropGet(UPCEReader, "_checksum", this, 3)([this._convertToUPCA(result)]);
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return upc_e_reader_superPropGet(UPCEReader, "_findEnd", this, 3)([offset, true]);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }]);
}(ean_reader);
/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts






function upc_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, upc_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function upc_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (upc_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  function UPCReader() {
    var _this;
    classCallCheck_default()(this, UPCReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = upc_reader_callSuper(this, UPCReader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'upc_a');
    return _this;
  }
  inherits_default()(UPCReader, _EANReader);
  return createClass_default()(UPCReader, [{
    key: "decode",
    value: function decode(row, start) {
      var result = ean_reader.prototype.decode.call(this);
      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }
      return null;
    }
  }]);
}(ean_reader);
/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */
Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */
  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;
  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }
  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }
  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }
  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;
  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }
    error -= deltaY;
    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }
  return {
    line: line,
    min: min,
    max: max
  };
};

/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */
Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j;

  // 1. find extrema
  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });
  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];
    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }
    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }
  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });
  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  }

  // iterate over extrema and convert to binary based on avg between minmax
  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }
    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }
  return {
    line: line,
    threshold: threshold
  };
};

/**
 * Used for development only
 */
Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d');
    // eslint-disable-next-line no-param-reassign
    canvas.width = line.length;
    // eslint-disable-next-line no-param-reassign
    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }
    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i;

    // eslint-disable-next-line no-param-reassign
    canvas.width = line.length;
    ctx.fillColor = 'black';
    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js


function barcode_decoder_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = barcode_decoder_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function barcode_decoder_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return barcode_decoder_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? barcode_decoder_arrayLikeToArray(r, a) : void 0; } }
function barcode_decoder_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

/* eslint-disable import/no-cycle */

/**
 * Barcode Decoder Module
 *
 * This module handles the decoding of barcodes using configured readers.
 *
 * READER ORDER GUARANTEE:
 * Readers are processed in the exact order they are specified in the `readers`
 * config array. The first reader to successfully decode the barcode wins.
 *
 * Example:
 *   readers: ['ean_reader', 'upc_e_reader', 'code_128_reader']
 *
 * Decoding order:
 *   1. ean_reader attempts to decode
 *   2. If ean_reader returns null, upc_e_reader attempts to decode
 *   3. If upc_e_reader returns null, code_128_reader attempts to decode
 *   4. First non-null result is returned
 *
 * EXTERNAL READERS:
 * External readers must be registered via registerReader() before use.
 * Once registered, they follow the same ordering rules as built-in readers.
 * Their position in the `readers` array determines their priority.
 *
 * To prioritize an external reader:
 *   Quagga.registerReader('my_reader', MyReader);
 *   config.decoder.readers = ['my_reader', 'ean_reader']; // my_reader tried first
 */


















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader,
  pharmacode_reader: pharmacode_reader
};
/* harmony default export */ var barcode_decoder = ({
  /**
   * Registers an external/custom barcode reader.
   * Once registered, the reader can be used in config.readers array.
   * The reader's position in config.readers determines its decoding priority.
   *
   * @param name - The identifier to use in config.readers (e.g., 'my_custom_reader')
   * @param reader - The reader class (must extend BarcodeReader)
   *
   * @example
   * // Register a custom reader
   * BarcodeDecoder.registerReader('my_reader', MyCustomReader);
   *
   * // Use it with high priority (first in array)
   * config.decoder.readers = ['my_reader', 'ean_reader', 'code_128_reader'];
   */
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();
    function initCanvas() {
      if ( true && typeof document !== 'undefined') {
        var _config$debug;
        var $debug = document.querySelector('#debug.detection');
        _canvas.dom.frequency = document.querySelector('canvas.frequency');
        if (!_canvas.dom.frequency) {
          _canvas.dom.frequency = document.createElement('canvas');
          _canvas.dom.frequency.className = 'frequency';
          if ($debug) {
            $debug.appendChild(_canvas.dom.frequency);
          }
        }
        if ( true && (_config$debug = config.debug) !== null && _config$debug !== void 0 && _config$debug.printReaderInfo) {
          console.warn('* barcode decoder initCanvas getcontext 2d');
        }
        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');
        if (!_canvas.dom.pattern) {
          _canvas.dom.pattern = document.createElement('canvas');
          _canvas.dom.pattern.className = 'patternBuffer';
          if ($debug) {
            $debug.appendChild(_canvas.dom.pattern);
          }
        }
        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');
        if (_canvas.dom.overlay) {
          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
        }
      }
    }

    /**
     * Initializes barcode readers from config.readers array.
     * Readers are instantiated and stored in the order they appear in config,
     * which determines their decoding priority (first in array = highest priority).
     */
    function initReaders() {
      var _config$debug3;
      config.readers.forEach(function (readerConfig) {
        var _config$debug2;
        var reader;
        var configuration = {};
        var supplements = [];
        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }
        if ( true && (_config$debug2 = config.debug) !== null && _config$debug2 !== void 0 && _config$debug2.printReaderInfo) {
          console.log('Before registering reader: ', reader);
        }
        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }
        try {
          var readerObj = new READERS[reader](configuration, supplements);
          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });
      if ( true && (_config$debug3 = config.debug) !== null && _config$debug3 !== void 0 && _config$debug3.printReaderInfo) {
        console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
          return JSON.stringify({
            format: reader.FORMAT,
            config: reader.config
          });
        }).join(', ')));
      }
    }
    function initConfig() {
      if ( true && typeof document !== 'undefined') {
        var i;
        var vis = [{
          node: _canvas.dom.frequency,
          prop: config.debug.showFrequency
        }, {
          node: _canvas.dom.pattern,
          prop: config.debug.showPattern
        }];
        for (i = 0; i < vis.length; i++) {
          if (vis[i].prop === true) {
            vis[i].node.style.display = 'block';
          } else {
            vis[i].node.style.display = 'none';
          }
        }
      }
    }

    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */
    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */
        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      }

      // check if inside image
      extendLine(ext);
      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }
      return line;
    }
    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    /**
     * Validate that barcode position is stable across adjacent Y-scanlines.
     * Real barcodes have consistent start position; tilted barcodes shift left/right as Y changes.
     * @param {Array} line The original scan line [p1, p2]
     * @param {Object} result The successful decode result with .start position
     * @param {Object} reader The reader instance that succeeded
     * @param {Object} inputImageWrapper The full image data
     * @returns {boolean} true if barcode position is stable (1 adjacent Y-line matches)
     */
    function validateAdjacentYLines(line, result, reader, inputImageWrapper) {
      // Extract original Y position and X start position
      var originalY = Math.round(line[1].y);
      var originalXStart = result.start;
      var constructorFn = reader.constructor;
      var requiredMatches = constructorFn && constructorFn.adjacentLineValidationMatches || 0;
      if (requiredMatches <= 0) {
        return true;
      }
      var matchCount = 0;
      var done = false;

      // Check Y1, Y2, Y3 to see if barcode appears at same X position
      for (var _i = 0, _arr = [1, 2, 3]; _i < _arr.length; _i++) {
        var yOffset = _arr[_i];
        if (done) {
          break;
        }
        for (var _i2 = 0, _arr2 = [-1, 1]; _i2 < _arr2.length; _i2++) {
          var direction = _arr2[_i2];
          if (done) {
            break;
          }
          var newY = originalY + yOffset * direction;

          // Bounds check
          if (newY < 0 || newY >= inputImageWrapper.size.y) {
            continue;
          }

          // Create new line at adjusted Y, keeping same X range
          var newP1 = {
            x: line[0].x,
            y: newY
          };
          var newP2 = {
            x: line[1].x,
            y: newY
          };
          try {
            // Extract grayscale at new Y
            var newBarcodeLine = bresenham.getBarcodeLine(inputImageWrapper, newP1, newP2);

            // Binarize
            bresenham.toBinaryLine(newBarcodeLine);

            // Set the row for _findStart() to search in
            reader._row = newBarcodeLine.line;

            // Try to find barcode start at this Y
            var startFound = reader._findStart();
            if (startFound !== null && startFound.start === originalXStart) {
              matchCount++;
              if (matchCount >= requiredMatches) {
                done = true;
                break;
              }
            }
          } catch (e) {
            // Ignore errors, treat failures as "no match" so we can try again on the next line
          }
        }
      }
      var isValid = matchCount >= requiredMatches;
      return isValid;
    }

    /**
     * Attempts to decode a barcode from a scan line.
     * Readers are tried in order (as specified in config.readers).
     * The first reader to return a non-null result wins.
     * @param {Array} line The scan line to decode
     * @returns {Object|null} Decoded result or null if no reader succeeded
     */
    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);
      if ( true && config.debug.showFrequency) {
        if (_canvas.ctx.overlay) {
          image_debug.drawPath(line, {
            x: 'x',
            y: 'y'
          }, _canvas.ctx.overlay, {
            color: 'red',
            lineWidth: 3
          });
        }
        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
      }
      bresenham.toBinaryLine(barcodeLine);
      if ( true && config.debug.showPattern) {
        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
      }

      // Iterate readers in order - first successful decode wins
      var successfulReaderIndex = -1;
      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        // Provide image context to readers that want it (e.g., pharmacode PGM dumps)
        if (typeof _barcodeReaders[i].setImageWrapper === 'function') {
          _barcodeReaders[i].setImageWrapper(inputImageWrapper);
        }
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
        if (result !== null) {
          successfulReaderIndex = i;
        }
      }
      if (result === null) {
        return null;
      }

      // Validate that barcode position is stable across adjacent Y-scanlines
      // This rejects tilted barcodes that only appear valid at one specific angle
      // Only apply to PharmacodeReader (which explicitly made _findStart public for this validation)
      if (successfulReaderIndex >= 0 && _barcodeReaders[successfulReaderIndex] instanceof pharmacode_reader) {
        if (!validateAdjacentYLines(line, result, _barcodeReaders[successfulReaderIndex], inputImageWrapper)) {
          return null;
        }
      }
      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }

    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */
    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);
      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */
        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }
      return result;
    }
    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    /**
     * Decodes from a full image using readers that support image-based decoding.
     * Readers are tried in order (as specified in config.readers).
     * @param {Object} imageWrapper The image to decode
     * @returns {Object|null} Decoded result or null
     */
    function _decodeFromImage2(_x) {
      return _decodeFromImage.apply(this, arguments);
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */
    function _decodeFromImage() {
      _decodeFromImage = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2(imageWrapper) {
        var result, _iterator, _step, reader, _t;
        return regenerator_default.a.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              result = null; // Iterate readers in order - first successful decode wins
              _iterator = barcode_decoder_createForOfIteratorHelper(_barcodeReaders);
              _context2.prev = 1;
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context2.next = 5;
                break;
              }
              reader = _step.value;
              if (!reader.decodeImage) {
                _context2.next = 4;
                break;
              }
              _context2.next = 3;
              return reader.decodeImage(imageWrapper);
            case 3:
              result = _context2.sent;
              if (!result) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("continue", 5);
            case 4:
              _context2.next = 2;
              break;
            case 5:
              _context2.next = 7;
              break;
            case 6:
              _context2.prev = 6;
              _t = _context2["catch"](1);
              _iterator.e(_t);
            case 7:
              _context2.prev = 7;
              _iterator.f();
              return _context2.finish(7);
            case 8:
              return _context2.abrupt("return", result);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[1, 6, 7, 8]]);
      }));
      return _decodeFromImage.apply(this, arguments);
    }
    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;
      if (true) {
        if (config.debug.drawBoundingBox && ctx) {
          image_debug.drawPath(box, {
            x: 0,
            y: 1
          }, ctx, {
            color: 'blue',
            lineWidth: 2
          });
        }
      }
      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));
      if (line === null) {
        return null;
      }
      result = tryDecode(line);
      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }
      if (result === null) {
        return null;
      }
      if ( true && result && config.debug.drawScanline && ctx) {
        image_debug.drawPath(line, {
          x: 'x',
          y: 'y'
        }, ctx, {
          color: 'red',
          lineWidth: 3
        });
      }
      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }
    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;
        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;
          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }
        return {
          barcodes: barcodes
        };
      },
      decodeFromImage: function decodeFromImage(imageWrapperIn) {
        return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
          var result;
          return regenerator_default.a.wrap(function (_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 1;
                return _decodeFromImage2(imageWrapperIn);
              case 1:
                result = _context.sent;
                return _context.abrupt("return", result);
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }))();
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }
        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/reader/index.ts

















// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};
  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }
    return events[eventName];
  }
  function clearEvents() {
    events = {};
  }
  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }
  function _subscribe(event, callback, async) {
    var subscription;
    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;
      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }
    getEvent(event).subscribers.push(subscription);
  }
  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers;

      // Publish one-time subscriptions
      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });

      // remove them from the subscriber
      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      });

      // publish the rest
      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);
        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__(81);
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties);

// EXTERNAL MODULE: ./node_modules/lodash/omit.js
var omit = __webpack_require__(82);
var omit_default = /*#__PURE__*/__webpack_require__.n(omit);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var wrapNativeSuper = __webpack_require__(83);
var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper);

// CONCATENATED MODULE: ./src/quagga/Exception.ts







function Exception_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, Exception_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function Exception_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (Exception_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var Exception_Exception = /*#__PURE__*/function (_Error) {
  function Exception(m, code) {
    var _this;
    classCallCheck_default()(this, Exception);
    _this = Exception_callSuper(this, Exception, [m]);
    defineProperty_default()(_this, "code", void 0);
    _this.code = code;
    Object.setPrototypeOf(_this, Exception.prototype);
    return _this;
  }

  /**
   * Custom JSON serialization to ensure error message is included.
   * The Error class's message property is non-enumerable by default,
   * so JSON.stringify would only include {code: -1} without this method.
   * This ensures consumers receive meaningful error information.
   */
  inherits_default()(Exception, _Error);
  return createClass_default()(Exception, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        message: this.message,
        code: this.code
      };
    }
  }]);
}(/*#__PURE__*/wrapNativeSuper_default()(Error));

// CONCATENATED MODULE: ./src/common/mediaDevices.ts

var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Exception_Exception("enumerateDevices is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Exception_Exception("getUserMedia is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts



var _excluded = ["deviceId"];
function camera_access_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function camera_access_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? camera_access_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : camera_access_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function camera_access_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = camera_access_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function camera_access_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return camera_access_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? camera_access_arrayLikeToArray(r, a) : void 0; } }
function camera_access_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

// TODO: when this file was written years ago, HTMLMediaElement.play() did not return a useful value
// to let us know when the video started playing.  Now, it does.  So, we shouldn't need to run this
// odd waitForVideo() function that polls to see if the video has started.



var streamRef;
function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;
    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (true) {
            console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
          }
          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Exception_Exception('Unable to play video stream. Is webcam working?', -1)); // TODO: add error code
      }
      attempts--;
    }
    checkVideo();
  });
}

/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */
function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}
function _initCamera() {
  _initCamera = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee4(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function (_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 1;
          return getUserMedia(constraints);
        case 1:
          stream = _context4.sent;
          streamRef = stream;
          if (!video) {
            _context4.next = 2;
            break;
          }
          video.setAttribute('autoplay', 'true');
          video.setAttribute('muted', 'true');
          video.setAttribute('playsinline', 'true'); // not listed on MDN...
          // eslint-disable-next-line no-param-reassign
          video.srcObject = stream;
          video.addEventListener('loadedmetadata', function () {
            video.play()["catch"](function (err) {
              console.warn('* Error while trying to play video stream:', err);
            });
          });
          return _context4.abrupt("return", waitForVideo(video));
        case 2:
          return _context4.abrupt("return", Promise.resolve());
        case 3:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _initCamera.apply(this, arguments);
}
function deprecatedConstraints(videoConstraints) {
  // Remove deprecated properties (facing, minAspectRatio, maxAspectRatio) while
  // preserving all valid MediaTrackConstraints including advanced, zoom, torch, etc.
  var normalized = omit_default()(videoConstraints, ['facing', 'minAspectRatio', 'maxAspectRatio']);
  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }
  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }
  return normalized;
}

// TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.
function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);
  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }
  return Promise.resolve({
    audio: false,
    video: video
  });
}

/**
 * Enumerates video input devices, optionally filtering by constraints.
 * @param videoConstraints Optional constraints to filter devices.
 * When provided, only devices that satisfy the given constraints will be returned.
 * This works by attempting to get a media stream for each device with the constraints
 * and returning only the devices that succeed.
 * @returns Promise resolving to an array of MediaDeviceInfo for video input devices.
 */
function enumerateVideoDevices(_x3) {
  return _enumerateVideoDevices.apply(this, arguments);
}
function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee5(videoConstraints) {
    var devices, videoDevices, constrainedDevices, processedConstraints, _, constraintsWithoutDeviceId, _iterator, _step, device, constraints, stream, _t3, _t4;
    return regenerator_default.a.wrap(function (_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 1;
          return enumerateDevices();
        case 1:
          devices = _context5.sent;
          videoDevices = devices.filter(function (device) {
            return device.kind === 'videoinput';
          }); // If no constraints are provided, return all video devices
          if (videoConstraints) {
            _context5.next = 2;
            break;
          }
          return _context5.abrupt("return", videoDevices);
        case 2:
          // Filter devices based on constraints by trying to get a media stream for each
          constrainedDevices = []; // Process constraints but exclude deviceId since we'll set it ourselves for each device
          processedConstraints = deprecatedConstraints(videoConstraints); // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _ = processedConstraints.deviceId, constraintsWithoutDeviceId = objectWithoutProperties_default()(processedConstraints, _excluded);
          _iterator = camera_access_createForOfIteratorHelper(videoDevices);
          _context5.prev = 3;
          _iterator.s();
        case 4:
          if ((_step = _iterator.n()).done) {
            _context5.next = 9;
            break;
          }
          device = _step.value;
          _context5.prev = 5;
          constraints = {
            audio: false,
            video: camera_access_objectSpread(camera_access_objectSpread({}, constraintsWithoutDeviceId), {}, {
              deviceId: {
                exact: device.deviceId
              }
            })
          };
          _context5.next = 6;
          return getUserMedia(constraints);
        case 6:
          stream = _context5.sent;
          // Stop all tracks immediately after testing
          stream.getTracks().forEach(function (track) {
            return track.stop();
          });
          constrainedDevices.push(device);
          _context5.next = 8;
          break;
        case 7:
          _context5.prev = 7;
          _t3 = _context5["catch"](5);
        case 8:
          _context5.next = 4;
          break;
        case 9:
          _context5.next = 11;
          break;
        case 10:
          _context5.prev = 10;
          _t4 = _context5["catch"](3);
          _iterator.e(_t4);
        case 11:
          _context5.prev = 11;
          _iterator.f();
          return _context5.finish(11);
        case 12:
          return _context5.abrupt("return", constrainedDevices);
        case 13:
        case "end":
          return _context5.stop();
      }
    }, _callee5, null, [[3, 10, 11, 12], [5, 7]]);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}
function getActiveTrack() {
  if (!streamRef) {
    return null;
  }
  var tracks = streamRef.getVideoTracks();
  return tracks && tracks !== null && tracks !== void 0 && tracks.length ? tracks[0] : null;
}

/**
 * Returns the active MediaStream, or null if no stream is active.
 * Use this when you need access to the full stream, for example to pass to WebRTC
 * or to clone the stream. For just the video track, use getActiveTrack() instead.
 * @returns The active MediaStream, or null if no camera is currently active.
 */
function getActiveStream() {
  var _streamRef;
  return (_streamRef = streamRef) !== null && _streamRef !== void 0 ? _streamRef : null;
}

/**
 * Used for accessing information about the active stream track and available video devices.
 */
var QuaggaJSCameraAccess = {
  requestedVideoElement: null,
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            QuaggaJSCameraAccess.requestedVideoElement = video;
            _context.next = 1;
            return pickConstraints(videoConstraints);
          case 1:
            newConstraints = _context.sent;
            return _context.abrupt("return", initCamera(video, newConstraints));
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  },
  release: function release() {
    var tracks = streamRef && streamRef.getVideoTracks();
    if (QuaggaJSCameraAccess.requestedVideoElement !== null) {
      QuaggaJSCameraAccess.requestedVideoElement.pause();
    }
    return new Promise(function (resolve) {
      setTimeout(function () {
        if (tracks && tracks.length) {
          tracks.forEach(function (track) {
            return track.stop();
          });
        }
        streamRef = null;
        QuaggaJSCameraAccess.requestedVideoElement = null;
        resolve();
      }, 0);
    });
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStream: getActiveStream,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack,
  disableTorch: function disableTorch() {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2() {
      var track, _t;
      return regenerator_default.a.wrap(function (_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
            // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?
            if (!track) {
              _context2.next = 4;
              break;
            }
            _context2.prev = 1;
            _context2.next = 2;
            return track.applyConstraints({
              advanced: [{
                torch: false
              }]
            });
          case 2:
            _context2.next = 4;
            break;
          case 3:
            _context2.prev = 3;
            _t = _context2["catch"](1);
            if (_t instanceof OverconstrainedError) {
              console.warn('quagga2/CameraAccess: Torch not supported on this device');
            }
            throw _t;
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 3]]);
    }))();
  },
  enableTorch: function enableTorch() {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee3() {
      var track, _t2;
      return regenerator_default.a.wrap(function (_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
            // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?
            if (!track) {
              _context3.next = 4;
              break;
            }
            _context3.prev = 1;
            _context3.next = 2;
            return track.applyConstraints({
              advanced: [{
                torch: true
              }]
            });
          case 2:
            _context3.next = 4;
            break;
          case 3:
            _context3.prev = 3;
            _t2 = _context3["catch"](1);
            if (_t2 instanceof OverconstrainedError) {
              console.warn('quagga2/CameraAccess: Torch not supported on this device');
            }
            throw _t2;
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 3]]);
    }))();
  }
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts

function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}
function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}
/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d', {
      willReadFrequently: !!config.willReadFrequently
    });
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;
    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }
    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|
        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;
          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug.drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }
          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"
    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
      // borderColor: 'rgba(0, 255, 0, 0.5)', // uncomment to draw area border
      // borderWidth: 2, // uncomment to draw area border
      // backgroundColor: 'rgba(0, 255, 0, 0.1)', // uncomment to tint the scan area
    },
    singleChannel: false,
    // true: only the red color-channel is read
    debug: {
      showImageDetails: false // logs frame grabber info, canvas size adjustments
    }
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false,
      printReaderInfo: false // logs reader registration and initialization
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      showPatchSize: false,
      // logs calculated patch size
      showImageDetails: false,
      // logs image wrapper size, canvas details
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large
  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"
    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large
  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts



var ExportConfig = function () {
  var QuaggaConfig;
  if (true) {
    QuaggaConfig = config_dev;
  } else {}
  return QuaggaConfig;
}();
/* harmony default export */ var config_config = (ExportConfig);
// CONCATENATED MODULE: ./src/input/frame_grabber_browser.js
// NOTE FOR ANYONE IN HERE IN THE FUTURE:
// webpack.config.js replaces the frame_grabber module with THIS module when it is building for a Browser environment.


var TO_RADIANS = Math.PI / 180;
function adjustCanvasSize(canvas, targetSize, debug) {
  if (canvas.width !== targetSize.x) {
    if ( true && debug !== null && debug !== void 0 && debug.showImageDetails) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }
    canvas.width = targetSize.x;
  }
  if (canvas.height !== targetSize.y) {
    if ( true && debug !== null && debug !== void 0 && debug.showImageDetails) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }
    canvas.height = targetSize.y;
  }
}
var FrameGrabber = {};
FrameGrabber.create = function (inputStream, canvas) {
  var _streamConfig$debug, _streamConfig$debug2;
  // console.warn('*** FrameGrabberBrowser create');
  var _that = {};
  var _streamConfig = inputStream.getConfig();
  var _videoSize = imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());
  var _canvasSize = inputStream.getCanvasSize();
  var _size = imageRef(inputStream.getWidth(), inputStream.getHeight());
  var topRight = inputStream.getTopRight();
  var _sx = topRight.x;
  var _sy = topRight.y;
  var _canvas;
  var _ctx = null;
  var _data = null;
  var willReadFrequently = _streamConfig.willReadFrequently;
  _canvas = canvas || document.createElement('canvas');
  _canvas.width = _canvasSize.x;
  _canvas.height = _canvasSize.y;
  if ( true && (_streamConfig$debug = _streamConfig.debug) !== null && _streamConfig$debug !== void 0 && _streamConfig$debug.showImageDetails) {
    console.warn('*** frame_grabber_browser: willReadFrequently=', willReadFrequently, 'canvas=', _canvas);
  }
  _ctx = _canvas.getContext('2d', {
    willReadFrequently: !!willReadFrequently
  }); // double not because we have an optional bool that needs to pass as a bool
  _data = new Uint8Array(_size.x * _size.y);
  if ( true && (_streamConfig$debug2 = _streamConfig.debug) !== null && _streamConfig$debug2 !== void 0 && _streamConfig$debug2.showImageDetails) {
    console.log('FrameGrabber', JSON.stringify({
      size: _size,
      topRight: topRight,
      videoSize: _videoSize,
      canvasSize: _canvasSize
    }));
  }

  /**
   * Uses the given array as frame-buffer
   */
  _that.attachData = function (data) {
    _data = data;
  };

  /**
   * Returns the used frame-buffer
   */
  _that.getData = function () {
    return _data;
  };

  // Bilinear interpolation for grayscale data (to match Node's behavior)
  function bilinearInterpolate(grayData, width, height, x, y) {
    var x0 = Math.floor(x);
    var y0 = Math.floor(y);
    var x1 = Math.min(x0 + 1, width - 1);
    var y1 = Math.min(y0 + 1, height - 1);
    var fx = x - x0;
    var fy = y - y0;
    var v00 = grayData[y0 * width + x0];
    var v10 = grayData[y0 * width + x1];
    var v01 = grayData[y1 * width + x0];
    var v11 = grayData[y1 * width + x1];
    var v0 = v00 * (1 - fx) + v10 * fx;
    var v1 = v01 * (1 - fx) + v11 * fx;
    return v0 * (1 - fy) + v1 * fy;
  }

  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   * 
   * For improved accuracy (matching Node's processing), non-half-sampled images
   * use bilinear interpolation on grayscale data instead of scaling RGB then converting.
   * 
   * IMPORTANT: The image is ALWAYS drawn to the visible canvas for overlays and display.
   */
  _that.grab = function () {
    var doHalfSample = _streamConfig.halfSample;
    var frame = inputStream.getFrame();
    var drawable = frame;
    var drawAngle = 0;
    if (drawable) {
      adjustCanvasSize(_canvas, _canvasSize, _streamConfig.debug);
      if (_streamConfig.type === 'ImageStream') {
        drawable = frame.img;
        if (frame.tags && frame.tags.orientation) {
          switch (frame.tags.orientation) {
            case 6:
              drawAngle = 90 * TO_RADIANS;
              break;
            case 8:
              drawAngle = -90 * TO_RADIANS;
              break;
          }
        }
      }

      // ALWAYS draw to visible canvas (for overlays, display, and toDataURL)
      if (drawAngle !== 0) {
        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);
        _ctx.rotate(drawAngle);
        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);
        _ctx.rotate(-drawAngle);
        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
      } else {
        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
      }
      if (doHalfSample) {
        // Half-sample path: use existing optimized approach
        var ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;
        grayAndHalfSampleFromCanvasData(ctxData, _size, _data);
      } else {
        // Non-half-sample: use improved bilinear interpolation for better accuracy
        // Process at original size, then scale grayscale data
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = _videoSize.x;
        tempCanvas.height = _videoSize.y;
        var tempCtx = tempCanvas.getContext('2d');
        if (drawAngle !== 0) {
          tempCtx.translate(_videoSize.x / 2, _videoSize.y / 2);
          tempCtx.rotate(drawAngle);
          tempCtx.drawImage(drawable, -_videoSize.y / 2, -_videoSize.x / 2, _videoSize.y, _videoSize.x);
        } else {
          tempCtx.drawImage(drawable, 0, 0, _videoSize.x, _videoSize.y);
        }

        // Convert to grayscale at original size
        var originalImageData = tempCtx.getImageData(0, 0, _videoSize.x, _videoSize.y).data;
        var grayData = new Uint8Array(_videoSize.x * _videoSize.y);
        computeGray(originalImageData, grayData, _streamConfig);

        // Scale grayscale data using bilinear interpolation
        var scaledGrayData = new Uint8Array(_canvasSize.x * _canvasSize.y);
        var stepSizeX = _videoSize.x / _canvasSize.x;
        var stepSizeY = _videoSize.y / _canvasSize.y;
        for (var y = 0; y < _canvasSize.y; y++) {
          for (var x = 0; x < _canvasSize.x; x++) {
            var srcX = x * stepSizeX;
            var srcY = y * stepSizeY;
            scaledGrayData[y * _canvasSize.x + x] = bilinearInterpolate(grayData, _videoSize.x, _videoSize.y, srcX, srcY) | 0;
          }
        }

        // Crop to target region
        for (var _y = 0; _y < _size.y; _y++) {
          for (var _x = 0; _x < _size.x; _x++) {
            var srcIdx = (_y + _sy) * _canvasSize.x + (_x + _sx);
            _data[_y * _size.x + _x] = scaledGrayData[srcIdx];
          }
        }
      }
      return true;
    }
    return false;
  };
  _that.getSize = function () {
    return _size;
  };
  return _that;
};
/* harmony default export */ var frame_grabber_browser = (FrameGrabber);
// CONCATENATED MODULE: ./src/input/exif_helper.js
// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
// need to port any part of this that doesn't work in Node to node?

// Tags scraped from https://github.com/exif-js/exif-js
var ExifTags = {
  0x0112: 'orientation'
};
var AvailableTags = Object.keys(ExifTags).map(function (key) {
  return ExifTags[key];
});
function findTagsInObjectURL(src) {
  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  if (/^blob:/i.test(src)) {
    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
      return findTagsInBuffer(buffer, tags);
    });
  }
  return Promise.resolve(null);
}
function base64ToArrayBuffer(dataUrl) {
  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);
  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }
  return buffer;
}
function readToBuffer(blob) {
  return new Promise(function (resolve) {
    var fileReader = new FileReader();
    fileReader.onload = function (e) {
      return resolve(e.target.result);
    };
    fileReader.readAsArrayBuffer(blob);
  });
}
function objectURLToBlob(url) {
  return new Promise(function (resolve, reject) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';
    http.onreadystatechange = function () {
      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
        resolve(this.response);
      }
    };
    http.onerror = reject;
    http.send();
  });
}
function findTagsInBuffer(file) {
  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  var dataView = new DataView(file);
  var length = file.byteLength;
  var exifTags = selectedTags.reduce(function (result, selectedTag) {
    var exifTag = Object.keys(ExifTags).filter(function (tag) {
      return ExifTags[tag] === selectedTag;
    })[0];
    if (exifTag) {
      result[exifTag] = selectedTag;
    }
    return result;
  }, {});
  var offset = 2;
  var marker;
  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false;
  }
  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false;
    }
    marker = dataView.getUint8(offset + 1);
    if (marker === 0xE1) {
      return readEXIFData(dataView, offset + 4, exifTags);
    }
    offset += 2 + dataView.getUint16(offset + 2);
  }
  return false;
}
function readEXIFData(file, start, exifTags) {
  if (getStringFromBuffer(file, start, 4) !== 'Exif') {
    return false;
  }
  var tiffOffset = start + 6;
  var bigEnd;
  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }
  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }
  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);
  if (firstIFDOffset < 0x00000008) {
    return false;
  }
  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
  return tags;
}
function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};
  for (var i = 0; i < entries; i++) {
    var entryOffset = dirStart + i * 12 + 2;
    var tag = strings[file.getUint16(entryOffset, !bigEnd)];
    if (tag) {
      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
    }
  }
  return tags;
}
function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);
  switch (type) {
    case 3:
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      }
  }
  return null;
}
function getStringFromBuffer(buffer, start, length) {
  var outstr = '';
  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }
  return outstr;
}
// CONCATENATED MODULE: ./src/input/image_loader.js


// Exported helper for filename generation
function generateImageFilename(directory, num) {
  return "".concat(directory, "image-").concat(num.toString().padStart(3, '0'), ".jpg");
}
var ImageLoader = {};
ImageLoader.load = function (directory, callback, offset, size, sequence, config) {
  var htmlImagesSrcArray = new Array(size);
  var htmlImagesArray = new Array(htmlImagesSrcArray.length);
  var i;
  var img;
  var num;
  if (sequence === false) {
    htmlImagesSrcArray[0] = directory;
  } else {
    for (i = 0; i < htmlImagesSrcArray.length; i++) {
      num = offset + i;
      htmlImagesSrcArray[i] = generateImageFilename(directory, num);
    }
  }
  htmlImagesArray.notLoaded = [];
  htmlImagesArray.addImage = function (image) {
    htmlImagesArray.notLoaded.push(image);
  };
  htmlImagesArray.loaded = function (loadedImg) {
    var notloadedImgs = htmlImagesArray.notLoaded;
    for (var x = 0; x < notloadedImgs.length; x++) {
      if (notloadedImgs[x] === loadedImg) {
        notloadedImgs.splice(x, 1);
        for (var y = 0; y < htmlImagesSrcArray.length; y++) {
          // Use encodeURI for matching filenames with spaces and special characters
          var imgName = encodeURI(htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/')));
          if (loadedImg.src.lastIndexOf(imgName) !== -1) {
            htmlImagesArray[y] = {
              img: loadedImg
            };
            break;
          }
        }
        break;
      }
    }
    if (notloadedImgs.length === 0) {
      var _config$debug;
      if ( true && config !== null && config !== void 0 && (_config$debug = config.debug) !== null && _config$debug !== void 0 && _config$debug.showImageDetails) {
        console.log("Images loaded: ".concat(htmlImagesArray.length, " image").concat(htmlImagesArray.length !== 1 ? 's' : '', " from ").concat(sequence === false ? directory : directory + ' (sequence)'));
      }
      if (sequence === false) {
        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
          htmlImagesArray[0].tags = tags;
          callback(htmlImagesArray);
        })["catch"](function (e) {
          console.log(e);
          callback(htmlImagesArray);
        });
      } else {
        callback(htmlImagesArray);
      }
    }
  };
  for (i = 0; i < htmlImagesSrcArray.length; i++) {
    img = new Image();
    htmlImagesArray.addImage(img);
    addOnloadHandler(img, htmlImagesArray);
    img.src = htmlImagesSrcArray[i];
  }
};
function addOnloadHandler(img, htmlImagesArray) {
  img.onload = function () {
    htmlImagesArray.loaded(this);
  };
  img.onerror = function () {
    htmlImagesArray.loaded(this);
  };
}
/* harmony default export */ var image_loader = (ImageLoader);
// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
/* eslint-disable @typescript-eslint/no-explicit-any */


var inputStreamFactory = {
  createVideoStream: function createVideoStream(video) {
    console.warn('**** InputStreamBrowser createVideoStream');
    var _config = null;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _calculatedWidth;
    var _calculatedHeight;
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    function initSize() {
      var _config2, _config3;
      var width = video.videoWidth;
      var height = video.videoHeight;

      // eslint-disable-next-line no-nested-ternary
      _calculatedWidth = (_config2 = _config) !== null && _config2 !== void 0 && _config2.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
      // eslint-disable-next-line no-nested-ternary
      _calculatedHeight = (_config3 = _config) !== null && _config3 !== void 0 && _config3.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
      _canvasSize.x = _calculatedWidth;
      _canvasSize.y = _calculatedHeight;
    }
    var inputStream = {
      getRealWidth: function getRealWidth() {
        return video.videoWidth;
      },
      getRealHeight: function getRealHeight() {
        return video.videoHeight;
      },
      getWidth: function getWidth() {
        return _calculatedWidth;
      },
      getHeight: function getHeight() {
        return _calculatedHeight;
      },
      setWidth: function setWidth(width) {
        _calculatedWidth = width;
      },
      setHeight: function setHeight(height) {
        _calculatedHeight = height;
      },
      setInputStream: function setInputStream(config) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = config;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
      },
      ended: function ended() {
        return video.ended;
      },
      getConfig: function getConfig() {
        return _config;
      },
      setAttribute: function setAttribute(name, value) {
        if (video) {
          video.setAttribute(name, value);
        }
      },
      pause: function pause() {
        video.pause();
      },
      play: function play() {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        video.play();
      },
      setCurrentTime: function setCurrentTime(time) {
        var _config4;
        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
          this.setAttribute('currentTime', time.toString());
        }
      },
      addEventListener: function addEventListener(event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }
          _eventHandlers[event].push(f);
        } else {
          video.addEventListener(event, f, bool);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        _eventNames.forEach(function (eventName) {
          var handlers = _eventHandlers[eventName];
          if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
              video.removeEventListener(eventName, handler);
            });
          }
        });
      },
      trigger: function trigger(eventName, args) {
        var j;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var handlers = _eventHandlers[eventName];
        if (eventName === 'canrecord') {
          initSize();
        }
        if (handlers && handlers.length > 0) {
          for (j = 0; j < handlers.length; j++) {
            handlers[j].apply(inputStream, args);
          }
        }
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        return video;
      }
    };
    return inputStream;
  },
  createLiveStream: function createLiveStream(video) {
    console.warn('**** InputStreamBrowser createLiveStream');
    if (video) {
      video.setAttribute('autoplay', 'true');
    }
    var that = inputStreamFactory.createVideoStream(video);
    that.ended = function ended() {
      return false;
    };
    return that;
  },
  createImageStream: function createImageStream() {
    // console.warn('**** InputStreamBrowser createImageStream');
    var _config = null;
    var width = 0;
    var height = 0;
    var frameIdx = 0;
    var paused = true;
    var loaded = false;
    var imgArray = null;
    var size = 0;
    var offset = 1;
    var baseUrl = null;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    function loadImages() {
      var _config7;
      loaded = false;
      image_loader.load(baseUrl, function (imgs) {
        var _config5, _config6;
        imgArray = imgs;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (imgs[0].tags && imgs[0].tags.orientation) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          switch (imgs[0].tags.orientation) {
            case 6:
            case 8:
              width = imgs[0].img.height;
              height = imgs[0].img.width;
              break;
            default:
              width = imgs[0].img.width;
              height = imgs[0].img.height;
          }
        } else {
          width = imgs[0].img.width;
          height = imgs[0].img.height;
        }
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = (_config5 = _config) !== null && _config5 !== void 0 && _config5.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
        // eslint-disable-next-line no-nested-ternary
        calculatedHeight = (_config6 = _config) !== null && _config6 !== void 0 && _config6.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        loaded = true;
        frameIdx = 0;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence, _config);
    }
    function publishEvent(eventName, args) {
      var j;
      var handlers = _eventHandlers[eventName];
      if (handlers && handlers.length > 0) {
        for (j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
        }
      }
    }

    // TODO: any code shared with the first InputStream above should be shared not copied
    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
    // eslint-disable-next-line no-var,vars-on-top
    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(newWidth) {
        calculatedWidth = newWidth;
      },
      setHeight: function setHeight(newHeight) {
        calculatedHeight = newHeight;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (stream.sequence === false) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          size = 1;
        } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          size = stream.length;
        }
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }
          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        var frame;
        if (!loaded) {
          return null;
        }
        if (!paused) {
          var _imgArray;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];
          if (frameIdx < size - 1) {
            frameIdx++;
          } else {
            setTimeout(function () {
              _ended = true;
              publishEvent('ended', []);
            }, 0);
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
// CONCATENATED MODULE: ./src/locator/tracer.js
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var tracer_Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;
    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;
      for (i = 0; i < searchDirections.length; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;
        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }
        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }
        current.dir = (current.dir + 1) % 8;
      }
      return false;
    }
    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }
    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };
      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;
        var totalPixelCount = imageWrapper.size.x * imageWrapper.size.y;
        var pixelCounter = 0;
        do {
          current.dir = (current.dir + 6) % 8;
          _trace(current, color, label, edgelabel);
          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }
          ldir = current.dir;
        } while ((current.cx !== sx || current.cy !== sy) && ++pixelCounter < totalPixelCount);
        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }
      return Fv;
    }
    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ var locator_tracer = (tracer_Tracer);
// CONCATENATED MODULE: ./src/locator/rasterizer.js


/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = locator_tracer.create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;
        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }
        colorMap[0] = imageData[0];
        cc = null;
        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];
          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;
            if (labelData[pos] === 0) {
              color = imageData[pos];
              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);
                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;
                    if (cc !== null) {
                      cc.prevpeer = p;
                    }
                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);
                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;
                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }
                    p.index = depthlabel;
                    sc = cc;
                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }
                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;
                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }
                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;
              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }
        sc = cc;
        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }
        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;
          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }
          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;
              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }
            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;
              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;
              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }
            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);
            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ var locator_rasterizer = (Rasterizer);
// CONCATENATED MODULE: ./src/locator/skeletonizer.js
/* eslint-disable no-param-reassign */
/* eslint-disable no-bitwise */
/* eslint-disable eqeqeq */
/* @preserve ASM BEGIN */
/**
 * Morphological skeletonization using iterative thinning algorithm.
 * Reduces binary images to single-pixel-wide skeletons while preserving topology.
 *
 * Memory layout in shared ArrayBuffer (4 regions of size):
 * - Region 0: Working image (subImagePtr = 0)
 * - Region 1: Eroded result (erodedImagePtr = size)
 * - Region 2: Temp/scratch space (tempImagePtr = 2*size)
 * - Region 3: Final skeleton output (skelImagePtr = 3*size)
 */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  /**
   * Morphological erosion with 5-pixel cross structuring element.
   * A pixel survives only if all 5 pixels in the cross pattern are set:
   * top-left, top-right, center, bottom-left, bottom-right.
   */
  function erode(inImagePtr, outImagePtr) {
    inImagePtr = inImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;
    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;
      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
        // Pixel survives erosion only if all 5 cross neighbors are set
        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  // Pixel-wise subtraction: out = a - b (captures the "peeled" layer)
  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr = aImagePtr | 0;
    bImagePtr = bImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  // Pixel-wise OR: out = a | b (accumulates skeleton layers)
  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr = aImagePtr | 0;
    bImagePtr = bImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  // Counts non-zero pixels to detect when erosion is complete
  function countNonZero(imagePtr) {
    imagePtr = imagePtr | 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }
    return sum | 0;
  }

  // Fills image region with a constant value
  function init(imagePtr, value) {
    imagePtr = imagePtr | 0;
    value = value | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  // Morphological dilation with 5-pixel cross - pixel is set if any neighbor is set
  function dilate(inImagePtr, outImagePtr) {
    inImagePtr = inImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;
    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;
      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  // Copies image data from src to dst region
  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr = srcImagePtr | 0;
    dstImagePtr = dstImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  /**
   * Zeros out the border pixels of the image.
   * First loop: handles top, left, and right edges simultaneously
   * Second loop: handles bottom edge
   */
  function zeroBorder(imagePtr) {
    imagePtr = imagePtr | 0;
    var x = 0;
    var y = 0;
    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  /**
   * Main skeletonization algorithm using iterative thinning:
   * 1. Erode the working image
   * 2. Dilate the eroded version
   * 3. Subtract dilated from original (extracts "peeled" layer)
   * 4. OR the peeled layer into skeleton accumulator
   * 5. Copy eroded image back to working image
   * 6. Repeat until working image is empty
   *
   * @returns {void} No return value - operates directly on shared buffer.
   *   Input image is read from buffer offset 0 (subImagePtr).
   *   Output skeleton is written to buffer offset 3*size (skelImagePtr).
   */
  function skeletonize() {
    var subImagePtr = 0; // Region 0: Working image (input, offset = 0)
    var erodedImagePtr = 0; // Region 1: Eroded result (offset = size)
    var tempImagePtr = 0; // Region 2: Scratch space (offset = 2*size)
    var skelImagePtr = 0; // Region 3: Final skeleton (output, offset = 3*size)
    var sum = 0;
    var done = 0;

    // Calculate byte offsets for each region in the shared buffer
    erodedImagePtr = imul(size, size) | 0; // Region 1: size bytes in
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0; // Region 2: 2*size bytes in
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // Region 3: 3*size bytes in

    // Initialize skeleton accumulator to zero
    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);
    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }
  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */

/* harmony default export */ var skeletonizer = (Skeletonizer);
/* eslint-enable eqeqeq */
// CONCATENATED MODULE: ./src/locator/barcode_locator.js








var barcode_locator_config;
var _currentImageWrapper;
var _skelImageWrapper;
var _subImageWrapper;
var _labelImageWrapper;
var _patchGrid;
var _patchLabelGrid;
var _imageToPatchGrid;
var _binaryImageWrapper;
var _patchSize;
var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};
var _inputImageWrapper;
var _skeletonizer;
function barcode_locator_initBuffers() {
  if (barcode_locator_config.halfSample) {
    _currentImageWrapper = new image_wrapper({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }
  _patchSize = calculatePatchSize(barcode_locator_config.patchSize, _currentImageWrapper.size);

  // eslint-disable-next-line no-bitwise
  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0;
  // eslint-disable-next-line no-bitwise
  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new image_wrapper(_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new image_wrapper(_patchSize, undefined, Array, true);

  // Calculate required buffer size (4 regions for asm.js skeletonizer)
  var skeletonImageDataSize = _patchSize.x * _patchSize.y * 4;
  // Round up to next power of 2 for asm.js heap requirement
  // Use minimum 64KB for optimal asm.js performance (avoids V8 warnings)
  var bufferSize = Math.max(65536, Math.pow(2, Math.ceil(Math.log2(skeletonImageDataSize))));
  var skeletonImageData = new ArrayBuffer(bufferSize);
  _subImageWrapper = new image_wrapper(_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new image_wrapper(_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = skeletonizer({
    Math: Math,
    Uint8Array: Uint8Array
  }, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new image_wrapper({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new image_wrapper(_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new image_wrapper(_imageToPatchGrid.size, undefined, Int32Array, true);
}
function barcode_locator_initCanvas() {
  var _config$debug;
  if (barcode_locator_config.useWorker || typeof document === 'undefined') {
    return;
  }
  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';
  if ( true && barcode_locator_config.debug.showCanvas === true) {
    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
  }
  var willReadFrequently = !!barcode_locator_config.willReadFrequently;
  if ( true && (_config$debug = barcode_locator_config.debug) !== null && _config$debug !== void 0 && _config$debug.showCanvas) {
    console.warn('* initCanvas willReadFrequently', willReadFrequently, barcode_locator_config);
  }
  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d', {
    willReadFrequently: willReadFrequently
  });
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}

/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */
function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale;

  // draw all patches which are to be taken into consideration
  overAvg = 0;
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;
    if ( true && barcode_locator_config.debug.showPatches) {
      image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: 'red'
      });
    }
  }
  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;
  if (overAvg < 0) {
    overAvg += 180;
  }
  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = mat2_namespaceObject.copy(mat2_namespaceObject.create(), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]);

  // iterate over patches and rotate by angle
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    for (j = 0; j < 4; j++) {
      vec2_namespaceObject.transformMat2(patch.box[j], patch.box[j], transMat);
    }
    if ( true && barcode_locator_config.debug.boxFromPatches.showTransformed) {
      image_debug.drawPath(patch.box, {
        x: 0,
        y: 1
      }, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }

  // find bounding box
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }
      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }
      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }
      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }
  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];
  if ( true && barcode_locator_config.debug.boxFromPatches.showTransformedBox) {
    image_debug.drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }
  scale = barcode_locator_config.halfSample ? 2 : 1;
  // reverse rotation;
  transMat = mat2_namespaceObject.invert(transMat, transMat);
  for (j = 0; j < 4; j++) {
    vec2_namespaceObject.transformMat2(box[j], box[j], transMat);
  }
  if ( true && barcode_locator_config.debug.boxFromPatches.showBB) {
    image_debug.drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }
  for (j = 0; j < 4; j++) {
    vec2_namespaceObject.scale(box[j], box[j], scale);
  }
  return box;
}

/**
 * Creates a binary image of the current image
 */
function binarizeImage() {
  otsuThreshold(_currentImageWrapper, _binaryImageWrapper);
  _binaryImageWrapper.zeroBorder();
  if ( true && barcode_locator_config.debug.showCanvas) {
    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
  }
}

/**
 * Iterate over the entire image
 * extract patches
 */
function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;
  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j;

      // seperate parts
      skeletonize(x, y);

      // Rasterize, find individual bars
      _skelImageWrapper.zeroBorder();
      array_helper.init(_labelImageWrapper.data, 0);
      rasterizer = locator_rasterizer.create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);
      if ( true && barcode_locator_config.debug.showLabels) {
        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
          x: x,
          y: y
        });
      }

      // calculate moments from the skeletonized patch
      moments = _labelImageWrapper.moments(rasterResult.count);

      // extract eligible patches
      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }
  if ( true && barcode_locator_config.debug.showFoundPatches) {
    for (i = 0; i < patchesFound.length; i++) {
      patch = patchesFound[i];
      image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }
  return patchesFound;
}

/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */
function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];
  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }
  sum = _patchLabelGrid.data.length;
  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }
  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  });

  // extract top areas with at least 5 patches present
  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}

/**
 *
 */
function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];
  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;
    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }
    box = boxFromPatches(patches);
    if (box) {
      boxes.push(box);

      // draw patch-labels if requested
      if ( true && barcode_locator_config.debug.showRemainingPatchLabels) {
        for (j = 0; j < patches.length; j++) {
          patch = patches[j];
          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
          hsv2rgb(hsv, rgb);
          image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
            color: "rgb(".concat(rgb.join(','), ")"),
            lineWidth: 2
          });
        }
      }
    }
  }
  return boxes;
}

/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */
function similarMoments(moments) {
  var clusters = cv_utils_cluster(moments, 0.90);
  var topCluster = topGeneric(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];
  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();
    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }
  return result;
}
function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, imageRef(x, y));
  _skeletonizer.skeletonize();

  // Show skeleton if requested
  if ( true && barcode_locator_config.debug.showSkeleton) {
    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, imageRef(x, y));
  }
}

/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */
function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);
  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    }

    // if at least 2 moments are found which have at least minComponentWeights covered
    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0;
      // determine the similarity of the moments
      for (k = 0; k < matchingMoments.length; k++) {
        var _matchingMoments$k$ra, _matchingMoments$k;
        avg += (_matchingMoments$k$ra = (_matchingMoments$k = matchingMoments[k]) === null || _matchingMoments$k === void 0 ? void 0 : _matchingMoments$k.rad) !== null && _matchingMoments$k$ra !== void 0 ? _matchingMoments$k$ra : 0;
      }

      // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set
      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [vec2_namespaceObject.clone([x, y]), vec2_namespaceObject.clone([x + _subImageWrapper.size.x, y]), vec2_namespaceObject.clone([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), vec2_namespaceObject.clone([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: vec2_namespaceObject.clone([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }
  return patchesFound;
}

/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */
function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];
  function notYetProcessed() {
    var i;
    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }
    return _patchLabelGrid.data.length;
  }
  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;
    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx];
      // assign label
      _patchLabelGrid.data[currentIdx] = label;
      for (dir = 0; dir < locator_tracer.searchDirections.length; dir++) {
        y = current.y + locator_tracer.searchDirections[dir][0];
        x = current.x + locator_tracer.searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x;

        // continue if patch empty
        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE;
          // eslint-disable-next-line no-continue
          continue;
        }
        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(vec2_namespaceObject.dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec));
          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  }

  // prepare for finding the right patches
  array_helper.init(_patchGrid.data, 0);
  array_helper.init(_patchLabelGrid.data, 0);
  array_helper.init(_imageToPatchGrid.data, null);
  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  }

  // rasterize the patches found to determine area
  _patchGrid.zeroBorder();

  // eslint-disable-next-line no-cond-assign
  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  }

  // draw patch-labels if requested
  if ( true && barcode_locator_config.debug.showPatchLabels) {
    for (j = 0; j < _patchLabelGrid.data.length; j++) {
      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
        patch = _imageToPatchGrid.data[j];
        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
        hsv2rgb(hsv, rgb);
        image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
          color: "rgb(".concat(rgb.join(','), ")"),
          lineWidth: 2
        });
      }
    }
  }
  return label;
}
/* harmony default export */ var barcode_locator = ({
  init: function init(inputImageWrapper, config) {
    barcode_locator_config = config;
    _inputImageWrapper = inputImageWrapper;
    barcode_locator_initBuffers();
    barcode_locator_initCanvas();
  },
  locate: function locate() {
    if (barcode_locator_config.halfSample) {
      halfSample(_inputImageWrapper, _currentImageWrapper);
    }
    binarizeImage();
    var patchesFound = findPatches();
    // return unless 5% or more patches are found
    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    }

    // rasterrize area by comparing angular similarity;
    var maxLabel = rasterizeAngularSimilarity(patchesFound);
    if (maxLabel < 1) {
      return null;
    }

    // search for area with the most patches (biggest connected area)
    var topLabels = findBiggestConnectedAreas(maxLabel);
    if (topLabels.length === 0) {
      return null;
    }
    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var _config$debug2;
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area;

    // calculate width and height based on area
    if (inputStream.getConfig().area) {
      area = computeImageArea(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }
    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = calculatePatchSize(config.patchSize, size);
    if ( true && (_config$debug2 = config.debug) !== null && _config$debug2 !== void 0 && _config$debug2.showPatchSize) {
      console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
    }
    inputStream.setWidth(Math.max(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x), patchSize.x));
    inputStream.setHeight(Math.max(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y), patchSize.y));
    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }
    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
// CONCATENATED MODULE: ./src/QuaggaContext.ts



var QuaggaContext_QuaggaContext = /*#__PURE__*/createClass_default()(function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);
  defineProperty_default()(this, "config", void 0);
  defineProperty_default()(this, "inputStream", void 0);
  defineProperty_default()(this, "framegrabber", void 0);
  defineProperty_default()(this, "inputImageWrapper", void 0);
  defineProperty_default()(this, "stopped", false);
  /**
   * Flag indicating that stop() was called while init() was still in progress.
   * This is used to handle race conditions in React StrictMode where components
   * are mounted/unmounted rapidly, causing init() to be called, then stop(),
   * then init() again before the first init() completes.
   */
  defineProperty_default()(this, "initAborted", false);
  defineProperty_default()(this, "boxSize", void 0);
  defineProperty_default()(this, "resultCollector", void 0);
  defineProperty_default()(this, "decoder", void 0);
  defineProperty_default()(this, "workerPool", []);
  defineProperty_default()(this, "onUIThread", true);
  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
});
var QuaggaContext_CanvasInfo = /*#__PURE__*/createClass_default()(function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);
  defineProperty_default()(this, "image", void 0);
  defineProperty_default()(this, "overlay", void 0);
});
var QuaggaContext_CanvasContainer = /*#__PURE__*/createClass_default()(function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);
  defineProperty_default()(this, "ctx", void 0);
  defineProperty_default()(this, "dom", void 0);
  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
});
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  }

  // Check if target is already a DOM element
  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  }
  // Use '#interactive.viewport' as a fallback selector (backwards compatibility)
  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initBuffers.ts




// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var _config, _config$debug;
  var inputImageWrapper = imageWrapper || new image_wrapper({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });
  if ( true && (_config = locator.config) !== null && _config !== void 0 && (_config$debug = _config.debug) !== null && _config$debug !== void 0 && _config$debug.showImageDetails) {
    console.log("image wrapper size ".concat(inputImageWrapper.size));
  }
  var boxSize = [vec2_namespaceObject.clone([0, 0]), vec2_namespaceObject.clone([0, inputImageWrapper.size.y]), vec2_namespaceObject.clone([inputImageWrapper.size.x, inputImageWrapper.size.y]), vec2_namespaceObject.clone([inputImageWrapper.size.x, 0])];
  barcode_locator.init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts

function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);
  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }
  return canvas;
}
function getCanvasAndContext(selector, className, options) {
  var _options$debug;
  var canvas = findOrCreateCanvas(selector, className);
  if ( true && (_options$debug = options.debug) !== null && _options$debug !== void 0 && _options$debug.showImageDetails) {
    console.warn('* initCanvas getCanvasAndContext');
  }
  var context = canvas.getContext('2d', {
    willReadFrequently: options.willReadFrequently
  });
  return {
    canvas: canvas,
    context: context
  };
}
function initCanvases(canvasSize, _ref) {
  var willReadFrequently = _ref.willReadFrequently,
    createOverlay = _ref.createOverlay,
    debug = _ref.debug;
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer', {
      willReadFrequently: willReadFrequently,
      debug: debug
    });
    image.canvas.width = canvasSize.x;
    image.canvas.height = canvasSize.y;

    // Only create overlay canvas if createOverlay is true (default behavior)
    var overlay = {
      canvas: null,
      context: null
    };
    if (createOverlay) {
      var overlayResult = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer', {
        willReadFrequently: willReadFrequently,
        debug: debug
      });
      overlayResult.canvas.width = canvasSize.x;
      overlayResult.canvas.height = canvasSize.y;
      overlay = overlayResult;
    }
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }
  return null;
}
function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu, _context$config3, _context$config3$canv, _context$config4, _context$config4$inpu, _context$config5, _context$config5$loca;
  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;

  // Default to true for backwards compatibility
  var createOverlay = (context === null || context === void 0 ? void 0 : (_context$config3 = context.config) === null || _context$config3 === void 0 ? void 0 : (_context$config3$canv = _context$config3.canvas) === null || _context$config3$canv === void 0 ? void 0 : _context$config3$canv.createOverlay) !== false;
  var container = initCanvases(context.inputStream.getCanvasSize(), {
    willReadFrequently: !!(context !== null && context !== void 0 && (_context$config4 = context.config) !== null && _context$config4 !== void 0 && (_context$config4$inpu = _context$config4.inputStream) !== null && _context$config4$inpu !== void 0 && _context$config4$inpu.willReadFrequently),
    createOverlay: createOverlay,
    debug: context === null || context === void 0 ? void 0 : (_context$config5 = context.config) === null || _context$config5 === void 0 ? void 0 : (_context$config5$loca = _context$config5.locator) === null || _context$config5$loca === void 0 ? void 0 : _context$config5$loca.debug
  });
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;
  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }
      if (dom.overlay && !viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }
  return container;
}
// CONCATENATED MODULE: ./src/quagga/qworker.ts

function qworker_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function qworker_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? qworker_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : qworker_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */

// TODO: need a typescript interface for FrameGrabber

var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;
  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];
    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);
      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }
      return true;
    } else {
      return false;
    }
  }
  return null;
}
function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
}

// @ts-ignore
function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];
    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  }
  // @ts-ignore
  var imageWrapper;

  // @ts-ignore
  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result
      // @ts-ignore
    }, [imageWrapper.data.buffer]);
  }
  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data
      // @ts-ignore
    }, [imageWrapper.data.buffer]);
  }

  // @ts-ignore
  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}
function generateWorkerBlob() {
  var blob, factorySource;

  /* jshint ignore:start */
  // @ts-ignore
  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */

  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}
function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };
  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);
      if (true) {
        console.log('Worker initialized');
      }
      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false;
      // TODO: how to thread publishResult into here? TypeScript says it's not here. https://github.com/ericblade/quagga2/issues/466#issuecomment-1724248080 says it's necessary?
      // @ts-ignore
      if (typeof publishResult !== 'undefined') {
        // @ts-ignore
        publishResult(e.data.result, workerThread.imageData);
      }
    } else if (e.data.event === 'error') {
      if (true) {
        console.log('Worker error: ' + e.data.message);
      }
    }
  };
  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;
  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();
      if (true) {
        console.log('Worker terminated!');
      }
    });
    workerPool = workerPool.slice(0, increaseBy);
    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);
      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };
    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var inputStreamFactory = arguments.length > 2 ? arguments[2] : undefined;
  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: inputStreamFactory.createVideoStream(video)
        };
      }
    case 'ImageStream':
      return {
        inputStream: inputStreamFactory.createImageStream()
      };
    case 'LiveStream':
      {
        var _video = null;
        if (viewport) {
          _video = viewport.querySelector('video');
          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }
        return {
          video: _video,
          inputStream: inputStreamFactory.createLiveStream(_video)
        };
      }
    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */

function moveBox(box, xOffset, yOffset) {
  var corner = box.length;
  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts



















var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;
    classCallCheck_default()(this, Quagga);
    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());
    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;
      // Check if init was aborted (e.g., by calling stop() during initialization)
      // This can happen in React StrictMode where components are mounted/unmounted rapidly
      if (_this.context.initAborted) {
        callback(new Error('Initialization was aborted'));
        return;
      }
      if (!_this.context.config) {
        callback(new Error('Configuration not initialized'));
        return;
      }
      // Check if inputStream is properly initialized before proceeding
      if (!_this.context.inputStream) {
        callback(new Error('Input stream not initialized'));
        return;
      }
      barcode_locator.checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);
      _this.initCanvas();
      _this.context.framegrabber = frame_grabber_browser.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);
      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }
      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;
        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }
        _this.ready(callback);
      });
    });
    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);
        if (!workersUpdated) {
          var _this$context$inputIm;
          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);
          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;
        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);
        _this.context.framegrabber.grab();
        _this.locateAndDecode();
      }
    });
    /**
     * Public method to draw a scanner area overlay using the current Quagga instance's overlay canvas.
     * Draws based on the instance's configured inputStream.area, using the actual adjusted boxSize
     * to match the real scanning area after patch alignment.
     * Only draws when locate is false and an area is configured with styling.
     */
    defineProperty_default()(this, "_cachedStyleValues", void 0);
    defineProperty_default()(this, "_resolvedStyle", void 0);
  }
  return createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }
      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
        inputImageWrapper = _initBuffers2.inputImageWrapper,
        boxSize = _initBuffers2.boxSize;
      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }
      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }
      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);
      if (!container) {
        return;
      }
      var ctx = container.ctx,
        dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }
      var _this$context$config$ = this.context.config.inputStream,
        inputType = _this$context$config$.type,
        constraints = _this$context$config$.constraints;
      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream_browser),
        video = _setupInputStream.video,
        inputStream = _setupInputStream.inputStream;
      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }
      if (inputStream) {
        inputStream.setAttribute('preload', 'auto');
        inputStream.setInputStream(this.context.config.inputStream);
        inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      }
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;
      return (_this$context$config3 = this.context.config) !== null && _this$context$config3 !== void 0 && _this$context$config3.locate ? barcode_locator.locate() : [[vec2_namespaceObject.clone(this.context.boxSize[0]), vec2_namespaceObject.clone(this.context.boxSize[1]), vec2_namespaceObject.clone(this.context.boxSize[2]), vec2_namespaceObject.clone(this.context.boxSize[3])]];
    }

    // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;
      var transformedBoxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;
      if (xOffset === 0 && yOffset === 0) {
        return;
      }
      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode, transformedBoxes);
        });
      }
      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }
      if (result.box && !transformedBoxes.has(result.box)) {
        moveBox(result.box, xOffset, yOffset);
        transformedBoxes.add(result.box);
      }
      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          // Skip if this box has already been transformed (either as result.box or through barcodes)
          if (!transformedBoxes.has(result.boxes[i])) {
            moveBox(result.boxes[i], xOffset, yOffset);
            transformedBoxes.add(result.boxes[i]);
          }
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;
      if (!imageData || !this.context.resultCollector) {
        return;
      }

      // TODO: Figure out what data structure holds a "barcodes" result, if any...
      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    }

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    }

    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  }, {
    key: "publishResult",
    value: function publishResult() {
      var _cfg$inputStream;
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;
      if (result && this.context.onUIThread) {
        var _result$barcodes;
        this.transformResult(result);
        this.addResult(result, imageData);
        // @ts-ignore
        resultToPublish = (result === null || result === void 0 ? void 0 : (_result$barcodes = result.barcodes) === null || _result$barcodes === void 0 ? void 0 : _result$barcodes.length) > 0 ? result.barcodes : result;
      }
      events.publish('processed', resultToPublish);
      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }

      // Redraw scanner area each frame when locate is false via public API.
      var cfg = this.context.config;
      if (cfg && cfg.locate === false && (_cfg$inputStream = cfg.inputStream) !== null && _cfg$inputStream !== void 0 && _cfg$inputStream.area) {
        this.drawScannerArea();
      }
    }
  }, {
    key: "locateAndDecode",
    value: function () {
      var _locateAndDecode = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
        var boxes, _this$context$inputIm3, decodeResult, imageResult, _this$context$inputIm4, _t;
        return regenerator_default.a.wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              boxes = this.getBoundingBoxes();
              if (!boxes) {
                _context.next = 3;
                break;
              }
              _context.next = 1;
              return this.context.decoder.decodeFromBoundingBoxes(boxes);
            case 1:
              _t = _context.sent;
              if (_t) {
                _context.next = 2;
                break;
              }
              _t = {};
            case 2:
              decodeResult = _t;
              decodeResult.boxes = boxes;
              this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
              _context.next = 5;
              break;
            case 3:
              _context.next = 4;
              return this.context.decoder.decodeFromImage(this.context.inputImageWrapper);
            case 4:
              imageResult = _context.sent;
              if (imageResult) {
                this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
              } else {
                this.publishResult();
              }
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function locateAndDecode() {
        return _locateAndDecode.apply(this, arguments);
      }
      return locateAndDecode;
    }()
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
        _this4 = this;
      var next = null;
      // frequency specifies a maximum rate, not an absolute. If the system cannot
      // achieve the requested frequency, scans will occur as fast as possible.
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;
      var _newFrame = function newFrame(timestamp) {
        next = next || timestamp;
        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;
            _this4.update();
          }
          window.requestAnimationFrame(_newFrame);
        }
      };
      _newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;
      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function () {
      var _stop = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2() {
        var _this$context$config7;
        var _this$context$inputSt;
        return regenerator_default.a.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.context.stopped = true;
              // Set initAborted flag if stop() is called while init() is still in progress
              // (i.e., before framegrabber is initialized). This prevents the canRecord
              // callback from continuing after stop() was called.
              if (!this.context.framegrabber) {
                this.context.initAborted = true;
              }
              adjustWorkerPool(0);
              if (!((_this$context$config7 = this.context.config) !== null && _this$context$config7 !== void 0 && _this$context$config7.inputStream && this.context.config.inputStream.type === 'LiveStream')) {
                _context2.next = 2;
                break;
              }
              _context2.next = 1;
              return camera_access.release();
            case 1:
              (_this$context$inputSt = this.context.inputStream) === null || _this$context$inputSt === void 0 ? void 0 : _this$context$inputSt.clearEventHandlers();
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function stop() {
        return _stop.apply(this, arguments);
      }
      return stop;
    }()
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }
      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);
      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }
      qworker_registerReader(name, reader);
    }
  }, {
    key: "drawScannerArea",
    value: function drawScannerArea() {
      var _this$context$config8, _this$context$config9, _this$context$config0;
      var area = (_this$context$config8 = this.context.config) === null || _this$context$config8 === void 0 ? void 0 : (_this$context$config9 = _this$context$config8.inputStream) === null || _this$context$config9 === void 0 ? void 0 : _this$context$config9.area;
      if (!area) return;
      var overlayCtx = this.context.canvasContainer.ctx.overlay;
      if (!overlayCtx) return;

      // Only draw when locate is false
      if (((_this$context$config0 = this.context.config) === null || _this$context$config0 === void 0 ? void 0 : _this$context$config0.locate) !== false) return;

      // Quick checks for visualization presence
      var hasAnyStyle = area.borderColor !== undefined && area.borderColor !== '' || area.borderWidth !== undefined && area.borderWidth > 0 || area.backgroundColor !== undefined && area.backgroundColor !== '';
      if (!hasAnyStyle) return;

      // When locate is false, use the actual adjusted boxSize that matches the scanning area
      if (!this.context.boxSize) return;

      // Get the offset for the constrained area
      var topRightOffset = this.context.inputStream.getTopRight();
      var offsetX = topRightOffset.x;
      var offsetY = topRightOffset.y;
      var box = this.context.boxSize;
      var topLeft = box[0];
      var bottomLeft = box[1];
      var topRight = box[3];

      // Add the offset to position correctly on canvas
      var x = topLeft[0] + offsetX;
      var y = topLeft[1] + offsetY;
      var width = topRight[0] - topLeft[0];
      var height = bottomLeft[1] - topLeft[1];
      var styleChanged = !this._cachedStyleValues || this._cachedStyleValues.borderColor !== area.borderColor || this._cachedStyleValues.borderWidth !== area.borderWidth || this._cachedStyleValues.backgroundColor !== area.backgroundColor;
      if (styleChanged) {
        var _area$borderColor, _area$borderWidth;
        this._cachedStyleValues = {
          borderColor: area.borderColor,
          borderWidth: area.borderWidth,
          backgroundColor: area.backgroundColor
        };
        var shouldDrawBorder = area.borderColor !== undefined || area.borderWidth !== undefined;
        var color = (_area$borderColor = area.borderColor) !== null && _area$borderColor !== void 0 ? _area$borderColor : 'rgba(0, 255, 0, 0.5)';
        var borderWidth = shouldDrawBorder ? (_area$borderWidth = area.borderWidth) !== null && _area$borderWidth !== void 0 ? _area$borderWidth : 2 : 0;
        var bg = area.backgroundColor;
        this._resolvedStyle = {
          color: color,
          width: borderWidth,
          bg: bg
        };
      }
      var style = this._resolvedStyle;
      if (style.bg) {
        overlayCtx.fillStyle = style.bg;
        overlayCtx.fillRect(x, y, width, height);
      }
      if (style.width > 0) {
        overlayCtx.strokeStyle = style.color;
        overlayCtx.lineWidth = style.width;
        overlayCtx.strokeRect(x, y, width, height);
      }
    }
  }]);
}();

// CONCATENATED MODULE: ./src/quagga.js


 // eslint-disable-line no-unused-vars









var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;
    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }
    // Reset the initAborted flag when starting a new init
    quaggaInstance.context.initAborted = false;
    quaggaInstance.context.config = merge_default()({}, config_config, config);
    // TODO #179: pending restructure in Issue #179, we are temp disabling workers
    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }
    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);
      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }
    return promise;
  },
  start: function start(config, cb) {
    // If config is provided, call init() then start()
    if (config) {
      var promise;
      if (!cb) {
        promise = new Promise(function (resolve, reject) {
          cb = function cb(err) {
            err ? reject(err) : resolve();
          };
        });
      }
      this.init(config, function (err) {
        if (err) {
          cb(err);
          return;
        }
        try {
          instance.start();
          cb();
        } catch (startErr) {
          cb(startErr);
        }
      });
      return promise;
    }
    // If init() hasn't been completed, throw an error
    if (!_context.framegrabber) {
      throw new Error('start() was called before init() completed. ' + 'Call init() first, or call start(config) to combine init and start.');
    }
    return instance.start();
  },
  stop: function stop() {
    return instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }
    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }
    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }
    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }
    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }
    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },
  get canvas() {
    return _context.canvasContainer;
  },
  drawScannerArea: function drawScannerArea() {
    return instance.drawScannerArea();
  },
  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;
    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  true && config.debug ? 0 : 1,
      locator: {
        halfSample: false
      }
    }, config);
    // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/
    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    }
    // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.
    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }
    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          // Sync the decodeSingle instance's canvas to the global _context so Quagga.canvas works
          _context.canvasContainer = quaggaInstance.context.canvasContainer;
          events.once('processed', function (result) {
            quaggaInstance.stop();
            if (resultCallback) {
              resultCallback.call(null, result);
            }
            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },
  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },
  Readers: reader_namespaceObject,
  CameraAccess: camera_access,
  ImageDebug: image_debug,
  ImageWrapper: image_wrapper,
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface);
// export BarcodeReader and other utilities for external plugins


/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvT3ZlcmxvYWRZaWVsZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckRlZmluZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckFzeW5jR2VuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9vbWl0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vdHlwZWRlZnMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckFzeW5jLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yS2V5cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVJlZ0V4cC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5zZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19wYXJlbnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3VzdG9tT21pdENsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY29uc3RydWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0Mi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jbHVzdGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vY3ZfdXRpbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2VfZGVidWcudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9iYXJjb2RlX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyLzJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV85M19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvcGhhcm1hY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9kZWNvZGVyL2JyZXNlbmhhbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvZGVjb2Rlci9iYXJjb2RlX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9pbmRleC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2V2ZW50cy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL0V4Y2VwdGlvbi50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL21lZGlhRGV2aWNlcy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcuZGV2LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLm5vZGUudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcucHJvZC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlcl9icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9leGlmX2hlbHBlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW1hZ2VfbG9hZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtX2Jyb3dzZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvUXVhZ2dhQ29udGV4dC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2dldFZpZXdQb3J0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdEJ1ZmZlcnMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9pbml0Q2FudmFzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvcXdvcmtlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3NldHVwSW5wdXRTdHJlYW0udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS90cmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9xdWFnZ2EudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJNYXRoIiwiaW11bCIsImEiLCJiIiwiYWgiLCJhbCIsImJoIiwiYmwiLCJPYmplY3QiLCJhc3NpZ24iLCJ0YXJnZXQiLCJUeXBlRXJyb3IiLCJ0byIsImluZGV4IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwibmV4dFNvdXJjZSIsIm5leHRLZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbml0IiwiYXJyIiwidmFsIiwiZmlsbCIsInNodWZmbGUiLCJpIiwiaiIsImZsb29yIiwicmFuZG9tIiwiX3JlZiIsInRvUG9pbnRMaXN0Iiwicm93cyIsInJlZHVjZSIsInAiLCJuIiwicm93IiwiY29uY2F0Iiwiam9pbiIsInB1c2giLCJ0aHJlc2hvbGQiLCJzY29yZUZ1bmMiLCJxdWV1ZSIsInByZXYiLCJuZXh0IiwiYXBwbHkiLCJtYXhJbmRleCIsIm1heCIsInN1bSIsImNyZWF0ZSIsInBvaW50IiwicG9pbnRzIiwiY2VudGVyIiwicmFkIiwidmVjIiwidmVjMiIsImNsb25lIiwicG9pbnRNYXAiLCJhZGQiLCJwb2ludFRvQWRkIiwiaWQiLCJ1cGRhdGVDZW50ZXIiLCJjb3MiLCJzaW4iLCJmaXRzIiwib3RoZXJQb2ludCIsInNpbWlsYXJpdHkiLCJhYnMiLCJkb3QiLCJnZXRQb2ludHMiLCJnZXRDZW50ZXIiLCJjcmVhdGVQb2ludCIsIm5ld1BvaW50IiwicHJvcGVydHkiLCJpbWFnZVJlZiIsIngiLCJ5IiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsInZlYzMiLCJyb3VuZCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlMiIsImltYWdlV3JhcHBlciIsImludGVncmFsV3JhcHBlciIsImltYWdlRGF0YSIsImRhdGEiLCJ3aWR0aCIsInNpemUiLCJoZWlnaHQiLCJpbnRlZ3JhbEltYWdlRGF0YSIsInBvc0EiLCJwb3NCIiwicG9zQyIsInBvc0QiLCJjb21wdXRlSW50ZWdyYWxJbWFnZSIsInYiLCJ1IiwidGhyZXNob2xkSW1hZ2UiLCJ0YXJnZXRXcmFwcGVyIiwidGFyZ2V0RGF0YSIsImNvbXB1dGVIaXN0b2dyYW0iLCJiaXRzUGVyUGl4ZWwiLCJiaXRTaGlmdCIsImJ1Y2tldENudCIsImhpc3QiLCJJbnQzMkFycmF5Iiwic2hhcnBlbkxpbmUiLCJsaW5lIiwibGVmdCIsInJpZ2h0IiwiZGV0ZXJtaW5lT3RzdVRocmVzaG9sZCIsInVuZGVmaW5lZCIsInB4IiwiZW5kIiwibXgiLCJkZXRlcm1pbmVUaHJlc2hvbGQiLCJ2ZXQiLCJwMSIsInAyIiwicDEyIiwibTEiLCJtMiIsIm0xMiIsImsiLCJBcnJheUhlbHBlciIsIm90c3VUaHJlc2hvbGQiLCJjb21wdXRlQmluYXJ5SW1hZ2UiLCJrZXJuZWwiLCJBIiwiQiIsIkMiLCJEIiwiYXZnIiwiY2x1c3RlciIsInRoaXNDbHVzdGVyIiwiY2x1c3RlcnMiLCJhZGRUb0NsdXN0ZXIiLCJmb3VuZCIsIkNsdXN0ZXIyIiwiVHJhY2VyIiwidHJhY2UiLCJpdGVyYXRpb24iLCJtYXhJdGVyYXRpb25zIiwidG9wIiwicmVzdWx0IiwiY2VudGVyUG9zIiwiY3VycmVudFBvcyIsImlkeCIsImZvcndhcmQiLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwic3VidHJhY3QiLCJhSW1hZ2VXcmFwcGVyIiwiYkltYWdlV3JhcHBlciIsInJlc3VsdEltYWdlV3JhcHBlciIsImFJbWFnZURhdGEiLCJiSW1hZ2VEYXRhIiwiY0ltYWdlRGF0YSIsImJpdHdpc2VPciIsImNvdW50Tm9uWmVybyIsInRvcEdlbmVyaWMiLCJsaXN0IiwibWluSWR4IiwibWluIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiZ3JheUFycmF5RnJvbUltYWdlIiwiaHRtbEltYWdlIiwib2Zmc2V0WCIsImN0eCIsImFycmF5IiwiZHJhd0ltYWdlIiwiY3R4RGF0YSIsImdldEltYWdlRGF0YSIsImNvbXB1dGVHcmF5IiwiZ3JheUFycmF5RnJvbUNvbnRleHQiLCJvZmZzZXQiLCJncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhIiwiY2FudmFzRGF0YSIsIm91dEFycmF5IiwidG9wUm93SWR4IiwiYm90dG9tUm93SWR4IiwiZW5kSWR4Iiwib3V0V2lkdGgiLCJvdXRJbWdJZHgiLCJpbldpZHRoIiwiY29uZmlnIiwibCIsInNpbmdsZUNoYW5uZWwiLCJhbHBoYSIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJjb25zb2xlIiwid2FybiIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiX2N0eCRnZXRJbWFnZURhdGEiLCJoYWxmU2FtcGxlIiwiaW5JbWdXcmFwcGVyIiwib3V0SW1nV3JhcHBlciIsImluSW1nIiwib3V0SW1nIiwiaHN2MnJnYiIsImhzdiIsInJnYiIsImgiLCJzIiwiYyIsIm0iLCJyIiwiZyIsIl9jb21wdXRlRGl2aXNvcnMiLCJpc0Zpbml0ZSIsImxhcmdlRGl2aXNvcnMiLCJkaXZpc29ycyIsInNxcnROIiwic3FydCIsInVuc2hpZnQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwidmFsdWUiLCJkaW1lbnNpb24iLCJwYXJzZUZsb2F0IiwidW5pdCIsImluZGV4T2YiLCJfZGltZW5zaW9uc0NvbnZlcnRlcnMiLCJjb250ZXh0IiwiYm90dG9tIiwiY29tcHV0ZUltYWdlQXJlYSIsImlucHV0V2lkdGgiLCJpbnB1dEhlaWdodCIsImFyZWEiLCJwYXJzZWRBcmVhIiwia2V5cyIsImtleSIsInBhcnNlZCIsImNhbGN1bGF0ZWQiLCJzeCIsInN5Iiwic3ciLCJzaCIsImFzc2VydE51bWJlclBvc2l0aXZlIiwiRXJyb3IiLCJJbWFnZVdyYXBwZXIiLCJBcnJheVR5cGUiLCJpbml0aWFsaXplIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2RlZmluZVByb3BlcnR5IiwiX2NyZWF0ZUNsYXNzIiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJpbWdSZWYiLCJib3JkZXIiLCJzdWJJbWFnZUFzQ29weSIsIl9pbWFnZVdyYXBwZXIkc2l6ZSIsInNpemVYIiwic2l6ZVkiLCJnZXQiLCJnZXRTYWZlIiwiaW5kZXhNYXBwaW5nIiwic2V0IiwiemVyb0JvcmRlciIsIl90aGlzJHNpemUiLCJtb21lbnRzIiwibGFiZWxDb3VudCIsInlzcSIsImxhYmVsU3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwidG1wIiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJpc05hTiIsImF0YW4iLCJnZXRBc1JHQkEiLCJzY2FsZSIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50Iiwic2hvdyIsImZyYW1lIiwibmV3RnJhbWUiLCJJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJvdmVybGF5IiwiaW5TY2FsZSIsImFkanVzdGVkU2NhbGUiLCJ3aGl0ZVJnYiIsImJsYWNrUmdiIiwiX3Jlc3VsdCIsIl9yZXN1bHQyIiwiX3NsaWNlZFRvQXJyYXkiLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwiQmFyY29kZURpcmVjdGlvbiIsIkJhcmNvZGVSZWFkZXIiLCJzdXBwbGVtZW50cyIsIl9yb3ciLCJfbmV4dFVuc2V0Iiwic3RhcnQiLCJfbWF0Y2hQYXR0ZXJuIiwiY291bnRlciIsImNvZGUiLCJtYXhTaW5nbGVFcnJvciIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiZXJyb3IiLCJzaW5nbGVFcnJvciIsIm1vZHVsbyIsImJhcldpZHRoIiwiY291bnQiLCJzY2FsZWQiLCJfbmV4dFNldCIsIl9jb3JyZWN0QmFycyIsImNvcnJlY3Rpb24iLCJpbmRpY2VzIiwiZGVjb2RlUGF0dGVybiIsInBhdHRlcm4iLCJkZWNvZGUiLCJyZXZlcnNlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbWF0Y2hSYW5nZSIsIl9maWxsQ291bnRlcnMiLCJpc1doaXRlIiwiY291bnRlcnMiLCJjb3VudGVyUG9zIiwiX3RvQ291bnRlcnMiLCJudW1Db3VudGVycyIsImRlY29kZUltYWdlIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsIk4iLCJXIiwiU1RBUlRfUEFUVEVSTiIsIlNUT1BfUEFUVEVSTiIsIkNPREVfUEFUVEVSTiIsIlNUQVJUX1BBVFRFUk5fTEVOR1RIIiwiVHdvT2ZGaXZlUmVhZGVyIiwiX0JhcmNvZGVSZWFkZXIiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiX2NhbGxTdXBlciIsIl9pbmhlcml0cyIsIl9maW5kUGF0dGVybiIsInRyeUhhcmRlciIsImJlc3RNYXRjaCIsImVwc2lsb24iLCJBVkdfQ09ERV9FUlJPUiIsIl9maW5kU3RhcnQiLCJzdGFydEluZm8iLCJuYXJyb3dCYXJXaWR0aCIsImxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQiLCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlIiwiZW5kSW5mbyIsInRyYWlsaW5nV2hpdGVzcGFjZUVuZCIsIl9maW5kRW5kIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJfZGVjb2RlQ29kZSIsIl9kZWNvZGVQYXlsb2FkIiwiZGVjb2RlZENvZGVzIiwiY291bnRlckxlbmd0aCIsImJhclNwYWNlUmF0aW8iLCJBTFBIQUJFVCIsIkNIQVJBQ1RFUl9FTkNPRElOR1MiLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsIk5ld0NvZGFiYXJSZWFkZXIiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwiX2NvdW50ZXJzIiwiX3RvUGF0dGVybiIsImJhclRocmVzaG9sZCIsInNwYWNlVGhyZXNob2xkIiwiYml0bWFzayIsIl9pc1N0YXJ0RW5kIiwiX3N1bUNvdW50ZXJzIiwic3RhcnRDb3VudGVyIiwiZW5kQ291bnRlciIsIl9wYXR0ZXJuVG9DaGFyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJfdmVyaWZ5V2hpdGVzcGFjZSIsIl9jaGFyVG9QYXR0ZXJuIiwiY2hhciIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsIl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuIiwiY2F0ZWdvcml6YXRpb24iLCJzcGFjZSIsIm5hcnJvdyIsImNvdW50cyIsIndpZGUiLCJiYXIiLCJraW5kIiwiY2F0IiwiZm9yRWFjaCIsIm5ld2tpbmQiLCJjZWlsIiwiX3ZhbGlkYXRlUmVzdWx0IiwidGhyZXNob2xkcyIsIm5leHRTdGFydCIsImRlY29kZWRDaGFyIiwiQ29kZTEyOFJlYWRlciIsIl9jb3JyZWN0IiwiY2FsY3VsYXRlQ29ycmVjdGlvbiIsIk1PRFVMRV9JTkRJQ0VTIiwiU1RBUlRfQ09ERV9BIiwiU1RBUlRfQ09ERV9DIiwiX3RoaXMyIiwiY2hlY2tzdW0iLCJjb2Rlc2V0IiwiQ09ERV9BIiwiU1RBUlRfQ09ERV9CIiwiQ09ERV9CIiwiQ09ERV9DIiwiZG9uZSIsInNoaWZ0TmV4dCIsInJlbW92ZUxhc3RDaGFyYWN0ZXIiLCJtdWx0aXBsaWVyIiwicmF3UmVzdWx0IiwiU1RPUF9DT0RFIiwiQ09ERV9TSElGVCIsIkZOQzEiLCJGTkMxX0NIQVIiLCJzcGxpY2UiLCJzZWxmIiwiZXhwZWN0ZWQiLCJub3JtYWxpemVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwiQUxQSEFCRVRIX1NUUklORyIsIlVpbnQxNkFycmF5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwibWFwIiwiQVNURVJJU0siLCJDb2RlMzlSZWFkZXIiLCJwYXR0ZXJuU3RhcnQiLCJ3aGl0ZVNwYWNlTXVzdFN0YXJ0IiwibWF4TmFycm93V2lkdGgiLCJudW1XaWRlQmFycyIsIndpZGVCYXJXaWR0aCIsIl9maW5kTmV4dFdpZHRoIiwibWluV2lkdGgiLCJsYXN0U3RhcnQiLCJwYXR0ZXJuU2l6ZSIsInBvcCIsInBhdHRlcm5zIiwiQUVJTyIsIkFaMDkiLCJjb2RlMzJzZXQiLCJDb2RlMzJSZWFkZXIiLCJfQ29kZTM5UmVhZGVyIiwiX2RlY29kZUNvZGUzMiIsInRlc3QiLCJyZXMiLCJjb2RlMzIiLCJzbGljZSIsIl9jaGVja0NoZWNrc3VtIiwiX3N1cGVyUHJvcEdldCIsInJlcGxhY2UiLCJJT1EiLCJDb2RlMzlWSU5SZWFkZXIiLCJsb2ciLCJDb2RlOTNSZWFkZXIiLCJfdmVyaWZ5RW5kIiwiX2RlY29kZUV4dGVuZGVkIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJfbWF0Y2hDaGVja0NoYXIiLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJfdmVyaWZ5Q2hlY2tzdW1zIiwiQ09ERV9HX1NUQVJUIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwibWVyZ2UiLCJjb2RlcmFuZ2UiLCJfY2FsY3VsYXRlRmlyc3REaWdpdCIsImNvZGVGcmVxdWVuY3kiLCJpbkNvZGUiLCJvdXRDb2RlIiwiX29iamVjdFNwcmVhZCIsImZpcnN0RGlnaXQiLCJtaWRkbGVQYXR0ZXJuIiwiX2NoZWNrc3VtIiwiX2RlY29kZUV4dGVuc2lvbnMiLCJlcnIiLCJyZXN1bHRJbmZvIiwic3VwcGxlbWVudCIsImxhc3RDb2RlIiwiRUFOMlJlYWRlciIsIl9FQU5SZWFkZXIiLCJwYXJzZUludCIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsIkVBTjVSZWFkZXIiLCJFQU44UmVhZGVyIiwiSTJvZjVSZWFkZXIiLCJvcHRzIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY291bnRlclN1bSIsImNvZGVTdW0iLCJjb3JyZWN0aW9uUmF0aW8iLCJNQVhfQ09SUkVDVElPTl9GQUNUT1IiLCJjb3JyZWN0aW9uUmF0aW9JbnZlcnNlIiwiX2RlY29kZVBhaXIiLCJjb3VudGVyUGFpciIsImNvZGVzIiwiTUlOX0JBUl9DT1VOVCIsIk1BWF9CQVJfQ09VTlQiLCJNSU5fVkFMVUUiLCJXSURFX0JBUl9USFJFU0hPTEQiLCJNQVhfU1BBQ0VfVkFSSUFOQ0UiLCJNSU5fUVVJRVRfWk9ORV9XSURUSFMiLCJBTExPV0VEX1dJREVfQkFSX1JBVElPUyIsIldJREVfQkFSX1JBVElPX1RPTEVSQU5DRSIsIlBoYXJtYWNvZGVSZWFkZXIiLCJtaW5RdWlldFpvbmUiLCJzZWFyY2hQb3MiLCJiYXJTdGFydCIsImJhckVuZCIsInJlcXVpcmVkUXVpZXRab25lIiwicXVpZXRab25lU3RhcnQiLCJtYXhTcGFjZVRvTmV4dEJhciIsIm5leHRCYXJTdGFydCIsInNwYWNlVG9OZXh0QmFyIiwiX3Ntb290aEJhcldpZHRocyIsImJhcnMiLCJzbW9vdGhlZCIsImN1cnIiLCJtZWRpYW4iLCJzb3J0IiwiZGV2aWF0aW9uIiwiX2V4dHJhY3RCYXJzQW5kU3BhY2VzIiwic3RhcnRQb3MiLCJzcGFjZXMiLCJjdXJyZW50V2lkdGgiLCJmb3VuZFRyYWlsaW5nUXVpZXRab25lIiwiZXN0aW1hdGVkTmFycm93V2lkdGgiLCJzdHJpY3RRdWlldFpvbmUiLCJhZGFwdGl2ZVF1aWV0Wm9uZSIsInNwYWNlU3RhcnQiLCJhdmdTcGFjZSIsIl92YWxpZGF0ZVNwYWNlcyIsIl92YWxpZGF0ZUJhclNpemVDb3VudCIsInNtb290aGVkQmFycyIsInRvbGVyYW5jZSIsIl9pdGVyYXRvciIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiX3N0ZXAiLCJmb3VuZENsdXN0ZXIiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiY2x1c3RlckF2ZyIsImUiLCJmIiwibWVhbiIsInZhcmlhbmNlIiwicG93Iiwic3RkRGV2IiwiY3YiLCJfdmFsaWRhdGVCYXJSYXRpb3MiLCJhdmdBbGwiLCJ2YXJBbGwiLCJjdkFsbCIsInNwYWNlVG9CYXJSYXRpbyIsImluZmVycmVkTmFycm93IiwibmFycm93V2lkdGgiLCJ3aWRlUmF0aW8iLCJzb3J0ZWRVbmlxdWUiLCJTZXQiLCJhdmdXaWR0aCIsImNhbmRpZGF0ZXMiLCJ0IiwidyIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJhdmdOIiwiYXZnVyIsInJhdGlvIiwiYmVzdFJhdGlvIiwiYmVzdERpZmYiLCJfaSIsIl9BTExPV0VEX1dJREVfQkFSX1JBVCIsImQiLCJuYXJyb3dCYXJzIiwid2lkZUJhcnMiLCJyYXRpb0RpZmYiLCJtYXRjaGVkUmF0aW8iLCJfaTIiLCJfY2FuZGlkYXRlcyIsIm5hcnJvd1RvbGVyYW5jZSIsIndpZGVUb2xlcmFuY2UiLCJvayIsIl9pdGVyYXRvcjQiLCJfc3RlcDQiLCJfaXRlcmF0b3I1IiwiX3N0ZXA1IiwiX3ZhbGlkYXRlUGVyaW9kaWNpdHkiLCJiYXJNZWFuIiwiYmFyVmFyaWFuY2UiLCJiYXJTdGREZXYiLCJiYXJDViIsInNwYWNlTWVhbiIsInNwYWNlVmFyaWFuY2UiLCJzcGFjZVN0ZERldiIsInNwYWNlQ1YiLCJfdmFsaWRhdGVRdWlldFpvbmVzIiwicmVtYWluaW5nU3BhY2UiLCJfZGVjb2RlQmFycyIsInJldmVyc2VkQmFycyIsImlzV2lkZSIsIl92YWxpZGF0ZVBhdHRlcm5Db25zaXN0ZW5jeSIsIm9yaWdpbmFsU3RhcnQiLCJjb25zaXN0ZW50T2Zmc2V0cyIsInRvdGFsQ2hlY2tzIiwiX2k0IiwiX2FyciIsInNoaWZ0ZWRTdGFydCIsInNoaWZ0ZWRFeHRyYWN0ZWQiLCJiYXJzTWF0Y2giLCJkaWZmIiwiZXh0cmFjdGVkIiwiYmFyc1dpZHRoIiwic3BhY2VzV2lkdGgiLCJ0b3RhbEJhcmNvZGVXaWR0aCIsIkVER0VfTUFSR0lOIiwicmF0aW9JbmZvIiwiZGVjb2RlZCIsImF2Z0JhcldpZHRoIiwidG9TdHJpbmciLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwiX2NvbnZlcnRUb1VQQ0EiLCJ1cGNhIiwibGFzdERpZ2l0IiwiVVBDUmVhZGVyIiwiY2hhckF0Iiwic3Vic3RyaW5nIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJESVIiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJyZWFkIiwiZGVsdGFYIiwiZGVsdGFZIiwieVN0ZXAiLCJ0b0JpbmFyeUxpbmUiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiZGlyIiwiclRocmVzaG9sZCIsImRlYnVnIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInBoYXJtYWNvZGVfcmVhZGVyIiwicmVnaXN0ZXJSZWFkZXIiLCJuYW1lIiwicmVhZGVyIiwiaW5wdXRJbWFnZVdyYXBwZXIiLCJfY2FudmFzIiwiZnJlcXVlbmN5IiwiZG9tIiwiX2JhcmNvZGVSZWFkZXJzIiwiaW5pdENhbnZhcyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIl9jb25maWckZGVidWciLCIkZGVidWciLCJxdWVyeVNlbGVjdG9yIiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJwcmludFJlYWRlckluZm8iLCJfY29uZmlnJGRlYnVnMyIsInJlYWRlcnMiLCJyZWFkZXJDb25maWciLCJfY29uZmlnJGRlYnVnMiIsImNvbmZpZ3VyYXRpb24iLCJfdHlwZW9mIiwicmVhZGVyT2JqIiwiSlNPTiIsInN0cmluZ2lmeSIsInZpcyIsIm5vZGUiLCJwcm9wIiwic2hvd0ZyZXF1ZW5jeSIsInNob3dQYXR0ZXJuIiwiZGlzcGxheSIsImdldEV4dGVuZGVkTGluZSIsImFuZ2xlIiwiZXh0IiwiZXh0ZW5kTGluZSIsImFtb3VudCIsImV4dGVuc2lvbiIsImdldExpbmUiLCJib3giLCJ2YWxpZGF0ZUFkamFjZW50WUxpbmVzIiwib3JpZ2luYWxZIiwib3JpZ2luYWxYU3RhcnQiLCJjb25zdHJ1Y3RvckZuIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZE1hdGNoZXMiLCJhZGphY2VudExpbmVWYWxpZGF0aW9uTWF0Y2hlcyIsIm1hdGNoQ291bnQiLCJ5T2Zmc2V0IiwiX2FycjIiLCJuZXdZIiwibmV3UDEiLCJuZXdQMiIsIm5ld0JhcmNvZGVMaW5lIiwic3RhcnRGb3VuZCIsImlzVmFsaWQiLCJ0cnlEZWNvZGUiLCJiYXJjb2RlTGluZSIsIkltYWdlRGVidWciLCJzdWNjZXNzZnVsUmVhZGVySW5kZXgiLCJzZXRJbWFnZVdyYXBwZXIiLCJjb2RlUmVzdWx0IiwidHJ5RGVjb2RlQnJ1dGVGb3JjZSIsImxpbmVBbmdsZSIsInNpZGVMZW5ndGgiLCJzbGljZXMiLCJ4ZGlyIiwieWRpciIsImdldExpbmVMZW5ndGgiLCJkZWNvZGVGcm9tSW1hZ2UiLCJfeCIsIl9kZWNvZGVGcm9tSW1hZ2UiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJtYXJrIiwiX2NhbGxlZTIiLCJfdCIsIndyYXAiLCJfY29udGV4dDIiLCJzZW50IiwiYWJydXB0IiwiZmluaXNoIiwic3RvcCIsImRlY29kZUZyb21Cb3VuZGluZ0JveCIsImRyYXdCb3VuZGluZ0JveCIsImxpbmVMZW5ndGgiLCJhdGFuMiIsImRyYXdTY2FubGluZSIsImRlY29kZUZyb21Cb3VuZGluZ0JveGVzIiwiYm94ZXMiLCJiYXJjb2RlcyIsIm11bHRpcGxlIiwiaW1hZ2VXcmFwcGVySW4iLCJfY2FsbGVlIiwiX2NvbnRleHQiLCJzZXRSZWFkZXJzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudHMiLCJnZXRFdmVudCIsImV2ZW50TmFtZSIsInN1YnNjcmliZXJzIiwiY2xlYXJFdmVudHMiLCJwdWJsaXNoU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiYXN5bmMiLCJfc3Vic2NyaWJlIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwiZmlsdGVyIiwic3Vic2NyaWJlciIsIm9uY2UiLCJ1bnN1YnNjcmliZSIsIkV4Y2VwdGlvbiIsIl9FcnJvciIsInNldFByb3RvdHlwZU9mIiwidG9KU09OIiwibWVzc2FnZSIsIl93cmFwTmF0aXZlU3VwZXIiLCJFUlJPUl9ERVNDIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsIlByb21pc2UiLCJyZWplY3QiLCJnZXRVc2VyTWVkaWEiLCJjb25zdHJhaW50cyIsInN0cmVhbVJlZiIsIndhaXRGb3JWaWRlbyIsInZpZGVvIiwicmVzb2x2ZSIsImF0dGVtcHRzIiwiY2hlY2tWaWRlbyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImluaXRDYW1lcmEiLCJfeDIiLCJfaW5pdENhbWVyYSIsIl9jYWxsZWU0Iiwic3RyZWFtIiwiX2NvbnRleHQ0Iiwic2V0QXR0cmlidXRlIiwic3JjT2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwib21pdCIsIm1pbkFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJmYWNpbmciLCJmYWNpbmdNb2RlIiwicGlja0NvbnN0cmFpbnRzIiwiZGV2aWNlSWQiLCJhdWRpbyIsImVudW1lcmF0ZVZpZGVvRGV2aWNlcyIsIl94MyIsIl9lbnVtZXJhdGVWaWRlb0RldmljZXMiLCJfY2FsbGVlNSIsImRldmljZXMiLCJ2aWRlb0RldmljZXMiLCJjb25zdHJhaW5lZERldmljZXMiLCJwcm9jZXNzZWRDb25zdHJhaW50cyIsIl8iLCJjb25zdHJhaW50c1dpdGhvdXREZXZpY2VJZCIsImRldmljZSIsIl90MyIsIl90NCIsIl9jb250ZXh0NSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9leGNsdWRlZCIsImV4YWN0IiwiZ2V0VHJhY2tzIiwidHJhY2siLCJnZXRBY3RpdmVUcmFjayIsInRyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZ2V0QWN0aXZlU3RyZWFtIiwiX3N0cmVhbVJlZiIsIlF1YWdnYUpTQ2FtZXJhQWNjZXNzIiwicmVxdWVzdGVkVmlkZW9FbGVtZW50IiwicmVxdWVzdCIsIm5ld0NvbnN0cmFpbnRzIiwicmVsZWFzZSIsInBhdXNlIiwiZ2V0QWN0aXZlU3RyZWFtTGFiZWwiLCJkaXNhYmxlVG9yY2giLCJhcHBseUNvbnN0cmFpbnRzIiwiYWR2YW5jZWQiLCJ0b3JjaCIsIk92ZXJjb25zdHJhaW5lZEVycm9yIiwiZW5hYmxlVG9yY2giLCJfY2FsbGVlMyIsIl90MiIsIl9jb250ZXh0MyIsImNvbnRhaW5zIiwic29tZSIsImV2ZXJ5IiwicGFzc2VzRmlsdGVyIiwiX2NvbmZpZyRjYXBhY2l0eSIsIndpbGxSZWFkRnJlcXVlbnRseSIsInJlc3VsdHMiLCJjYXBhY2l0eSIsImNhcHR1cmUiLCJtYXRjaGVzQ29uc3RyYWludHMiLCJibGFja2xpc3QiLCJhZGRSZXN1bHQiLCJpbWFnZVNpemUiLCJ0b0RhdGFVUkwiLCJnZXRSZXN1bHRzIiwiRGV2Q29uZmlnIiwiaW5wdXRTdHJlYW0iLCJ0eXBlIiwic2hvd0ltYWdlRGV0YWlscyIsImxvY2F0ZSIsImNyZWF0ZU92ZXJsYXkiLCJkZWNvZGVyIiwibG9jYXRvciIsInNob3dDYW52YXMiLCJzaG93UGF0Y2hlcyIsInNob3dGb3VuZFBhdGNoZXMiLCJzaG93U2tlbGV0b24iLCJzaG93TGFiZWxzIiwic2hvd1BhdGNoTGFiZWxzIiwic2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzIiwic2hvd1BhdGNoU2l6ZSIsImJveEZyb21QYXRjaGVzIiwic2hvd1RyYW5zZm9ybWVkIiwic2hvd1RyYW5zZm9ybWVkQm94Iiwic2hvd0JCIiwiTm9kZUNvbmZpZyIsInNlcXVlbmNlIiwiUHJvZENvbmZpZyIsIkV4cG9ydENvbmZpZyIsIlF1YWdnYUNvbmZpZyIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIkZyYW1lR3JhYmJlciIsIl9zdHJlYW1Db25maWckZGVidWciLCJfc3RyZWFtQ29uZmlnJGRlYnVnMiIsIl90aGF0IiwiX3N0cmVhbUNvbmZpZyIsImdldENvbmZpZyIsIl92aWRlb1NpemUiLCJnZXRSZWFsV2lkdGgiLCJnZXRSZWFsSGVpZ2h0IiwiX2NhbnZhc1NpemUiLCJnZXRDYW52YXNTaXplIiwiX3NpemUiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsInRvcFJpZ2h0IiwiZ2V0VG9wUmlnaHQiLCJfc3giLCJfc3kiLCJfY3R4IiwiX2RhdGEiLCJ2aWRlb1NpemUiLCJjYW52YXNTaXplIiwiYXR0YWNoRGF0YSIsImdldERhdGEiLCJiaWxpbmVhckludGVycG9sYXRlIiwiZ3JheURhdGEiLCJmeCIsImZ5IiwidjAwIiwidjEwIiwidjAxIiwidjExIiwidjAiLCJ2MSIsImdyYWIiLCJkb0hhbGZTYW1wbGUiLCJnZXRGcmFtZSIsImRyYXdhYmxlIiwiZHJhd0FuZ2xlIiwidGFncyIsIm9yaWVudGF0aW9uIiwidHJhbnNsYXRlIiwicm90YXRlIiwidGVtcENhbnZhcyIsInRlbXBDdHgiLCJvcmlnaW5hbEltYWdlRGF0YSIsInNjYWxlZEdyYXlEYXRhIiwic3RlcFNpemVYIiwic3RlcFNpemVZIiwic3JjWCIsInNyY1kiLCJzcmNJZHgiLCJnZXRTaXplIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsIm9iamVjdFVSTFRvQmxvYiIsInRoZW4iLCJyZWFkVG9CdWZmZXIiLCJidWZmZXIiLCJmaW5kVGFnc0luQnVmZmVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRhdGFVcmwiLCJiYXNlNjQiLCJiaW5hcnkiLCJhdG9iIiwibGVuIiwiQXJyYXlCdWZmZXIiLCJ2aWV3IiwiYmxvYiIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJ1cmwiLCJodHRwIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJzdGF0dXMiLCJyZXNwb25zZSIsIm9uZXJyb3IiLCJzZW5kIiwiZmlsZSIsInNlbGVjdGVkVGFncyIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJieXRlTGVuZ3RoIiwiZXhpZlRhZ3MiLCJzZWxlY3RlZFRhZyIsImV4aWZUYWciLCJ0YWciLCJtYXJrZXIiLCJnZXRVaW50OCIsInJlYWRFWElGRGF0YSIsImdldFVpbnQxNiIsImdldFN0cmluZ0Zyb21CdWZmZXIiLCJ0aWZmT2Zmc2V0IiwiYmlnRW5kIiwiZmlyc3RJRkRPZmZzZXQiLCJnZXRVaW50MzIiLCJyZWFkVGFncyIsInRpZmZTdGFydCIsImRpclN0YXJ0Iiwic3RyaW5ncyIsImVudHJpZXMiLCJlbnRyeU9mZnNldCIsInJlYWRUYWdWYWx1ZSIsIm51bVZhbHVlcyIsIm91dHN0ciIsImdlbmVyYXRlSW1hZ2VGaWxlbmFtZSIsImRpcmVjdG9yeSIsIm51bSIsInBhZFN0YXJ0IiwiSW1hZ2VMb2FkZXIiLCJsb2FkIiwiaHRtbEltYWdlc1NyY0FycmF5IiwiaHRtbEltYWdlc0FycmF5Iiwibm90TG9hZGVkIiwiYWRkSW1hZ2UiLCJpbWFnZSIsImxvYWRlZCIsImxvYWRlZEltZyIsIm5vdGxvYWRlZEltZ3MiLCJpbWdOYW1lIiwiZW5jb2RlVVJJIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJhZGRPbmxvYWRIYW5kbGVyIiwiaW5wdXRTdHJlYW1GYWN0b3J5IiwiY3JlYXRlVmlkZW9TdHJlYW0iLCJfY29uZmlnIiwiX2V2ZW50TmFtZXMiLCJfZXZlbnRIYW5kbGVycyIsIl9jYWxjdWxhdGVkV2lkdGgiLCJfY2FsY3VsYXRlZEhlaWdodCIsIl90b3BSaWdodCIsImluaXRTaXplIiwiX2NvbmZpZzIiLCJfY29uZmlnMyIsInNldFdpZHRoIiwic2V0SGVpZ2h0Iiwic2V0SW5wdXRTdHJlYW0iLCJlbmRlZCIsInNldEN1cnJlbnRUaW1lIiwidGltZSIsIl9jb25maWc0IiwiYm9vbCIsImNsZWFyRXZlbnRIYW5kbGVycyIsImhhbmRsZXJzIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmlnZ2VyIiwic2V0VG9wUmlnaHQiLCJzZXRDYW52YXNTaXplIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiZnJhbWVJZHgiLCJwYXVzZWQiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsIl9jb25maWc3IiwiaW1ncyIsIl9jb25maWc1IiwiX2NvbmZpZzYiLCJwdWJsaXNoRXZlbnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImluZCIsIl9pbWdBcnJheSIsInNlYXJjaERpcmVjdGlvbnMiLCJsYWJlbFdyYXBwZXIiLCJsYWJlbERhdGEiLCJlZGdlbGFiZWwiLCJjeSIsImN4IiwidmVydGV4MkQiLCJjb250b3VyVHJhY2luZyIsIkZ2IiwiQ3YiLCJQIiwibGRpciIsInRvdGFsUGl4ZWxDb3VudCIsInBpeGVsQ291bnRlciIsIlJhc3Rlcml6ZXIiLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJyYXN0ZXJpemUiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRyYXdDb250b3VyIiwiZmlyc3RDb250b3VyIiwicHEiLCJpcSIsInEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiaW1hZ2VzIiwiaW5JbWFnZVB0ciIsIm91dEltYWdlUHRyIiwiYUltYWdlUHRyIiwiYkltYWdlUHRyIiwiaW1hZ2VQdHIiLCJtZW1jcHkiLCJzcmNJbWFnZVB0ciIsImRzdEltYWdlUHRyIiwic2tlbGV0b25pemUiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwiX2N1cnJlbnRJbWFnZVdyYXBwZXIiLCJfc2tlbEltYWdlV3JhcHBlciIsIl9zdWJJbWFnZVdyYXBwZXIiLCJfbGFiZWxJbWFnZVdyYXBwZXIiLCJfcGF0Y2hHcmlkIiwiX3BhdGNoTGFiZWxHcmlkIiwiX2ltYWdlVG9QYXRjaEdyaWQiLCJfYmluYXJ5SW1hZ2VXcmFwcGVyIiwiX3BhdGNoU2l6ZSIsIl9jYW52YXNDb250YWluZXIiLCJfbnVtUGF0Y2hlcyIsIl9pbnB1dEltYWdlV3JhcHBlciIsIl9za2VsZXRvbml6ZXIiLCJpbml0QnVmZmVycyIsInNrZWxldG9uSW1hZ2VEYXRhU2l6ZSIsImJ1ZmZlclNpemUiLCJsb2cyIiwic2tlbGV0b25JbWFnZURhdGEiLCJza2VsZXRvbml6ZXIiLCJ1c2VXb3JrZXIiLCJwYXRjaGVzIiwib3ZlckF2ZyIsInBhdGNoIiwidHJhbnNNYXQiLCJtaW54IiwibWlueSIsIm1heHgiLCJtYXh5IiwibWF0MiIsImNvcHkiLCJ0cmFuc2Zvcm1NYXQyIiwiaW52ZXJ0IiwiYmluYXJpemVJbWFnZSIsImZpbmRQYXRjaGVzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsImRlc2NyaWJlUGF0Y2giLCJmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzIiwibWF4TGFiZWwiLCJsYWJlbEhpc3QiLCJ0b3BMYWJlbHMiLCJlbCIsImZpbmRCb3hlcyIsInNpbWlsYXJNb21lbnRzIiwidG9wQ2x1c3RlciIsInBhdGNoUG9zIiwiZWxpZ2libGVNb21lbnRzIiwibWF0Y2hpbmdNb21lbnRzIiwibWluQ29tcG9uZW50V2VpZ2h0IiwiX21hdGNoaW5nTW9tZW50cyRrJHJhIiwiX21hdGNoaW5nTW9tZW50cyRrIiwicmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkiLCJjdXJySWR4Iiwibm90WWV0UHJvY2Vzc2VkIiwiY3VycmVudElkeCIsImN1cnJlbnRQYXRjaCIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsInRoaXNIYWxmU2FtcGxlIiwiUXVhZ2dhQ29udGV4dCIsIkNhbnZhc0NvbnRhaW5lciIsIkNhbnZhc0luZm8iLCJnZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJub2RlVHlwZSIsInNlbGVjdG9yIiwiYm94U2l6ZSIsIkJhcmNvZGVMb2NhdG9yIiwiZmluZE9yQ3JlYXRlQ2FudmFzIiwiZ2V0Q2FudmFzQW5kQ29udGV4dCIsIm9wdGlvbnMiLCJfb3B0aW9ucyRkZWJ1ZyIsImluaXRDYW52YXNlcyIsIm92ZXJsYXlSZXN1bHQiLCJfY29udGV4dCRjb25maWciLCJfY29udGV4dCRjb25maWckaW5wdXQiLCJfY29udGV4dCRjb25maWcyIiwiX2NvbnRleHQkY29uZmlnMiRpbnB1IiwiX2NvbnRleHQkY29uZmlnMyIsIl9jb250ZXh0JGNvbmZpZzMkY2FudiIsIl9jb250ZXh0JGNvbmZpZzQiLCJfY29udGV4dCRjb25maWc0JGlucHUiLCJfY29udGV4dCRjb25maWc1IiwiX2NvbnRleHQkY29uZmlnNSRsb2NhIiwidmlld3BvcnQiLCJjb250YWluZXIiLCJ3b3JrZXJQb29sIiwidXBkYXRlV29ya2VycyIsImZyYW1lR3JhYmJlciIsImF2YWlsYWJsZVdvcmtlciIsIndvcmtlclRocmVhZCIsImJ1c3kiLCJ3b3JrZXIiLCJwb3N0TWVzc2FnZSIsImNtZCIsImNvbmZpZ0ZvcldvcmtlciIsIndvcmtlckludGVyZmFjZSIsImZhY3RvcnkiLCJRdWFnZ2EiLCJvblByb2Nlc3NlZCIsIndvcmtlckludGVyZmFjZVJlYWR5Iiwib25tZXNzYWdlIiwibnVtT2ZXb3JrZXJzIiwiZ2VuZXJhdGVXb3JrZXJCbG9iIiwiZmFjdG9yeVNvdXJjZSIsIl9fZmFjdG9yeVNvdXJjZV9fIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImluaXRXb3JrZXIiLCJjYiIsImJsb2JVUkwiLCJXb3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJwdWJsaXNoUmVzdWx0IiwiYWRqdXN0V29ya2VyUG9vbCIsImluY3JlYXNlQnkiLCJ3b3JrZXJzVG9UZXJtaW5hdGUiLCJ0ZXJtaW5hdGUiLCJ3b3JrZXJJbml0aWFsaXplZCIsInNldHVwSW5wdXRTdHJlYW0iLCJtb3ZlQm94IiwieE9mZnNldCIsImNvcm5lciIsIm1vdmVMaW5lIiwiX3RoaXMkY29udGV4dCRjb25maWciLCJpbml0QWJvcnRlZCIsImZyYW1lZ3JhYmJlciIsImNhbnZhc0NvbnRhaW5lciIsIlFXb3JrZXJzIiwiX3RoaXMkY29udGV4dCRjb25maWcyIiwiaW5pdGlhbGl6ZURhdGEiLCJyZWFkeSIsIm9uVUlUaHJlYWQiLCJ3b3JrZXJzVXBkYXRlZCIsIl90aGlzJGNvbnRleHQkaW5wdXRJbSIsImxvY2F0ZUFuZERlY29kZSIsIl90aGlzJGNvbnRleHQkaW5wdXRJbTIiLCJfaW5pdEJ1ZmZlcnMyIiwiX2luaXRCdWZmZXJzIiwiQmFyY29kZURlY29kZXIiLCJfZ2V0Vmlld1BvcnQiLCJfaW5pdENhbnZhcyIsImluaXRJbnB1dFN0cmVhbSIsIl90aGlzJGNvbnRleHQkY29uZmlnJCIsImlucHV0VHlwZSIsIl9zZXR1cElucHV0U3RyZWFtIiwiSW5wdXRTdHJlYW0iLCJDYW1lcmFBY2Nlc3MiLCJjYW5SZWNvcmQiLCJiaW5kIiwiZ2V0Qm91bmRpbmdCb3hlcyIsIl90aGlzJGNvbnRleHQkY29uZmlnMyIsInRyYW5zZm9ybVJlc3VsdCIsInRyYW5zZm9ybWVkQm94ZXMiLCJiYXJjb2RlIiwiaGFzIiwiX3RoaXMzIiwicmVzdWx0Q29sbGVjdG9yIiwiaGFzQ29kZVJlc3VsdCIsIl9jZmckaW5wdXRTdHJlYW0iLCJyZXN1bHRUb1B1Ymxpc2giLCJfcmVzdWx0JGJhcmNvZGVzIiwiRXZlbnRzIiwiY2ZnIiwiZHJhd1NjYW5uZXJBcmVhIiwiX2xvY2F0ZUFuZERlY29kZSIsIl90aGlzJGNvbnRleHQkaW5wdXRJbTMiLCJkZWNvZGVSZXN1bHQiLCJpbWFnZVJlc3VsdCIsIl90aGlzJGNvbnRleHQkaW5wdXRJbTQiLCJzdGFydENvbnRpbnVvdXNVcGRhdGUiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzQiLCJfdGhpczQiLCJkZWxheSIsInN0b3BwZWQiLCJ0aW1lc3RhbXAiLCJ1cGRhdGUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIl90aGlzJGNvbnRleHQkY29uZmlnNSIsIl90aGlzJGNvbnRleHQkY29uZmlnNiIsIl9zdG9wIiwiX3RoaXMkY29udGV4dCRjb25maWc3IiwiX3RoaXMkY29udGV4dCRpbnB1dFN0IiwiX3RoaXMkY29udGV4dCRjb25maWc4IiwiX3RoaXMkY29udGV4dCRjb25maWc5IiwiX3RoaXMkY29udGV4dCRjb25maWcwIiwib3ZlcmxheUN0eCIsImhhc0FueVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsImJhY2tncm91bmRDb2xvciIsInRvcFJpZ2h0T2Zmc2V0Iiwib2Zmc2V0WSIsInRvcExlZnQiLCJib3R0b21MZWZ0Iiwic3R5bGVDaGFuZ2VkIiwiX2NhY2hlZFN0eWxlVmFsdWVzIiwiX2FyZWEkYm9yZGVyQ29sb3IiLCJfYXJlYSRib3JkZXJXaWR0aCIsInNob3VsZERyYXdCb3JkZXIiLCJiZyIsIl9yZXNvbHZlZFN0eWxlIiwiaW5zdGFuY2UiLCJRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSIsInF1YWdnYUluc3RhbmNlIiwicHJvbWlzZSIsIkNvbmZpZyIsInN0YXJ0RXJyIiwib25EZXRlY3RlZCIsIm9mZkRldGVjdGVkIiwib2ZmUHJvY2Vzc2VkIiwicmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3IiLCJkZWNvZGVTaW5nbGUiLCJyZXN1bHRDYWxsYmFjayIsImRlZmF1bHQiLCJSZWFkZXJzIiwiUmVzdWx0Q29sbGVjdG9yIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FB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LENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVB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QU1wSix1QkFBWSxHQUFHLENBQ2pCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FB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akVtQyxNQUFNLENBQUM3Z0IsSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUFDbnVCLE1BQU0sRUFBSztZQUNqQzJ4QyxjQUFjLENBQUNybEIsSUFBSSxDQUFDLENBQUM7WUFDckIsSUFBSThsQixjQUFjLEVBQUU7Y0FDaEJBLGNBQWMsQ0FBQ2o2QyxJQUFJLENBQUMsSUFBSSxFQUFFNkgsTUFBTSxDQUFDO1lBQ3JDO1lBQ0FzdkIsT0FBTyxDQUFDdHZCLE1BQU0sQ0FBQztVQUNuQixDQUFDLEVBQUUsSUFBSSxDQUFDO1VBQ1IyeEMsY0FBYyxDQUFDeGpDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLENBQUMsRUFBRSxJQUFJLEVBQUV3akMsY0FBYyxDQUFDO01BQzVCLENBQUMsQ0FBQyxPQUFPOTJCLEdBQUcsRUFBRTtRQUNWbVUsTUFBTSxDQUFDblUsR0FBRyxDQUFDO01BQ2Y7SUFDSixDQUFDLENBQUM7RUFDTixDQUFDO0VBQ0Q7RUFDQTtFQUNBLElBQUl3M0IsT0FBT0EsQ0FBQSxFQUFHO0lBQ1YsT0FBT1gsdUJBQXVCO0VBQ2xDLENBQUM7RUFDRFksT0FBTyxFQUFQQSxzQkFBTztFQUNQckUsWUFBWSxFQUFaQSxhQUFZO0VBQ1puakIsVUFBVSxFQUFWQSxXQUFVO0VBQ1Y3aEIsWUFBWSxFQUFaQSxhQUFZO0VBQ1pzcEMsZUFBZSxFQUFmQSxnQkFBZUE7QUFDbkIsQ0FBQztBQUVjYixtR0FBdUIsRUFBQztBQUN2QyIsImZpbGUiOiJxdWFnZ2EuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDkwKTtcbiIsInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX2dldFByb3RvdHlwZU9mKHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZSAmJiBzZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiLy8gVE9ETyhCYWJlbCA4KTogUmVtb3ZlIHRoaXMgZmlsZS5cblxudmFyIHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWVcIikoKTtcbm1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9wYWNrYWdlcy9ydW50aW1lL3J1bnRpbWUuanMjTDczNj1cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKG4sIHQsIGUsIHIsIG8sIGEsIGMpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaSA9IG5bYV0oYyksXG4gICAgICB1ID0gaS52YWx1ZTtcbiAgfSBjYXRjaCAobikge1xuICAgIHJldHVybiB2b2lkIGUobik7XG4gIH1cbiAgaS5kb25lID8gdCh1KSA6IFByb21pc2UucmVzb2x2ZSh1KS50aGVuKHIsIG8pO1xufVxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3Iobikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ID0gdGhpcyxcbiAgICAgIGUgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyLCBvKSB7XG4gICAgICB2YXIgYSA9IG4uYXBwbHkodCwgZSk7XG4gICAgICBmdW5jdGlvbiBfbmV4dChuKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdGhyb3cobikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBuKTtcbiAgICAgIH1cbiAgICAgIF9uZXh0KHZvaWQgMCk7XG4gICAgfSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF90eXBlb2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2UuanNcIik7XG5mdW5jdGlvbiBfZ2V0KCkge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0LmJpbmQoKSA6IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgdmFyIHAgPSBzdXBlclByb3BCYXNlKGUsIHQpO1xuICAgIGlmIChwKSB7XG4gICAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7XG4gICAgICByZXR1cm4gbi5nZXQgPyBuLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gZSA6IHIpIDogbi52YWx1ZTtcbiAgICB9XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX2dldC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCIpO1xudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIik7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMocikgfHwgaXRlcmFibGVUb0FycmF5KHIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IGFycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKFwiLi90b1ByaW1pdGl2ZS5qc1wiKTtcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX092ZXJsb2FkWWllbGQoZSwgZCkge1xuICB0aGlzLnYgPSBlLCB0aGlzLmsgPSBkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfT3ZlcmxvYWRZaWVsZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciByZWdlbmVyYXRvckRlZmluZSA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yRGVmaW5lLmpzXCIpO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkge1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2Jsb2IvbWFpbi9wYWNrYWdlcy9iYWJlbC1oZWxwZXJzL0xJQ0VOU0UgKi9cbiAgdmFyIGUsXG4gICAgdCxcbiAgICByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICBuID0gci5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICBvID0gci50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgZnVuY3Rpb24gaShyLCBuLCBvLCBpKSB7XG4gICAgdmFyIGMgPSBuICYmIG4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gbiA6IEdlbmVyYXRvcixcbiAgICAgIHUgPSBPYmplY3QuY3JlYXRlKGMucHJvdG90eXBlKTtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJfaW52b2tlXCIsIGZ1bmN0aW9uIChyLCBuLCBvKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgYyxcbiAgICAgICAgdSxcbiAgICAgICAgZiA9IDAsXG4gICAgICAgIHAgPSBvIHx8IFtdLFxuICAgICAgICB5ID0gITEsXG4gICAgICAgIEcgPSB7XG4gICAgICAgICAgcDogMCxcbiAgICAgICAgICBuOiAwLFxuICAgICAgICAgIHY6IGUsXG4gICAgICAgICAgYTogZCxcbiAgICAgICAgICBmOiBkLmJpbmQoZSwgNCksXG4gICAgICAgICAgZDogZnVuY3Rpb24gZCh0LCByKSB7XG4gICAgICAgICAgICByZXR1cm4gaSA9IHQsIGMgPSAwLCB1ID0gZSwgRy5uID0gciwgYTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBmdW5jdGlvbiBkKHIsIG4pIHtcbiAgICAgICAgZm9yIChjID0gciwgdSA9IG4sIHQgPSAwOyAheSAmJiBmICYmICFvICYmIHQgPCBwLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdmFyIG8sXG4gICAgICAgICAgICBpID0gcFt0XSxcbiAgICAgICAgICAgIGQgPSBHLnAsXG4gICAgICAgICAgICBsID0gaVsyXTtcbiAgICAgICAgICByID4gMyA/IChvID0gbCA9PT0gbikgJiYgKHUgPSBpWyhjID0gaVs0XSkgPyA1IDogKGMgPSAzLCAzKV0sIGlbNF0gPSBpWzVdID0gZSkgOiBpWzBdIDw9IGQgJiYgKChvID0gciA8IDIgJiYgZCA8IGlbMV0pID8gKGMgPSAwLCBHLnYgPSBuLCBHLm4gPSBpWzFdKSA6IGQgPCBsICYmIChvID0gciA8IDMgfHwgaVswXSA+IG4gfHwgbiA+IGwpICYmIChpWzRdID0gciwgaVs1XSA9IG4sIEcubiA9IGwsIGMgPSAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8gfHwgciA+IDEpIHJldHVybiBhO1xuICAgICAgICB0aHJvdyB5ID0gITAsIG47XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHAsIGwpIHtcbiAgICAgICAgaWYgKGYgPiAxKSB0aHJvdyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgICBmb3IgKHkgJiYgMSA9PT0gcCAmJiBkKHAsIGwpLCBjID0gcCwgdSA9IGw7ICh0ID0gYyA8IDIgPyBlIDogdSkgfHwgIXk7KSB7XG4gICAgICAgICAgaSB8fCAoYyA/IGMgPCAzID8gKGMgPiAxICYmIChHLm4gPSAtMSksIGQoYywgdSkpIDogRy5uID0gdSA6IEcudiA9IHUpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDIsIGkpIHtcbiAgICAgICAgICAgICAgaWYgKGMgfHwgKG8gPSBcIm5leHRcIiksIHQgPSBpW29dKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodCA9IHQuY2FsbChpLCB1KSkpIHRocm93IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIGlmICghdC5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB1ID0gdC52YWx1ZSwgYyA8IDIgJiYgKGMgPSAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIDEgPT09IGMgJiYgKHQgPSBpW1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoaSksIGMgPCAyICYmICh1ID0gVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBvICsgXCInIG1ldGhvZFwiKSwgYyA9IDEpO1xuICAgICAgICAgICAgICBpID0gZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHQgPSAoeSA9IEcubiA8IDApID8gdSA6IHIuY2FsbChuLCBHKSkgIT09IGEpIGJyZWFrO1xuICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgIGkgPSBlLCBjID0gMSwgdSA9IHQ7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGYgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB0LFxuICAgICAgICAgIGRvbmU6IHlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfShyLCBvLCBpKSwgITApLCB1O1xuICB9XG4gIHZhciBhID0ge307XG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuICB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgYyA9IFtdW25dID8gdCh0KFtdW25dKCkpKSA6IChyZWdlbmVyYXRvckRlZmluZSh0ID0ge30sIG4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCB0KSxcbiAgICB1ID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYyk7XG4gIGZ1bmN0aW9uIGYoZSkge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGUuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHJlZ2VuZXJhdG9yRGVmaW5lKGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodSksIGU7XG4gIH1cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCByZWdlbmVyYXRvckRlZmluZSh1LCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgcmVnZW5lcmF0b3JEZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiwgcmVnZW5lcmF0b3JEZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIHJlZ2VuZXJhdG9yRGVmaW5lKHUpLCByZWdlbmVyYXRvckRlZmluZSh1LCBvLCBcIkdlbmVyYXRvclwiKSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pLCAobW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3IgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6IGksXG4gICAgICBtOiBmXG4gICAgfTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3IsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgbiwgdCkge1xuICB2YXIgaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdHJ5IHtcbiAgICBpKHt9LCBcIlwiLCB7fSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpID0gMDtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvckRlZmluZSA9IGZ1bmN0aW9uIHJlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIG4sIHQpIHtcbiAgICBmdW5jdGlvbiBvKHIsIG4pIHtcbiAgICAgIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKHIsIG4sIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHIgPyBpID8gaShlLCByLCB7XG4gICAgICB2YWx1ZTogbixcbiAgICAgIGVudW1lcmFibGU6ICF0LFxuICAgICAgY29uZmlndXJhYmxlOiAhdCxcbiAgICAgIHdyaXRhYmxlOiAhdFxuICAgIH0pIDogZVtyXSA9IG4gOiAobyhcIm5leHRcIiwgMCksIG8oXCJ0aHJvd1wiLCAxKSwgbyhcInJldHVyblwiLCAyKSk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX3JlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIG4sIHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JEZWZpbmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgcmVnZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvci5qc1wiKTtcbnZhciByZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IuanNcIik7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JBc3luY0dlbihyLCBlLCB0LCBvLCBuKSB7XG4gIHJldHVybiBuZXcgcmVnZW5lcmF0b3JBc3luY0l0ZXJhdG9yKHJlZ2VuZXJhdG9yKCkudyhyLCBlLCB0LCBvKSwgbiB8fCBQcm9taXNlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yQXN5bmNHZW4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgT3ZlcmxvYWRZaWVsZCA9IHJlcXVpcmUoXCIuL092ZXJsb2FkWWllbGQuanNcIik7XG52YXIgcmVnZW5lcmF0b3JEZWZpbmUgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckRlZmluZS5qc1wiKTtcbmZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IodCwgZSkge1xuICBmdW5jdGlvbiBuKHIsIG8sIGksIGYpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGMgPSB0W3JdKG8pLFxuICAgICAgICB1ID0gYy52YWx1ZTtcbiAgICAgIHJldHVybiB1IGluc3RhbmNlb2YgT3ZlcmxvYWRZaWVsZCA/IGUucmVzb2x2ZSh1LnYpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgbihcIm5leHRcIiwgdCwgaSwgZik7XG4gICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICBuKFwidGhyb3dcIiwgdCwgaSwgZik7XG4gICAgICB9KSA6IGUucmVzb2x2ZSh1KS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGMudmFsdWUgPSB0LCBpKGMpO1xuICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG4oXCJ0aHJvd1wiLCB0LCBpLCBmKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIGYodCk7XG4gICAgfVxuICB9XG4gIHZhciByO1xuICB0aGlzLm5leHQgfHwgKHJlZ2VuZXJhdG9yRGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgcmVnZW5lcmF0b3JEZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQGFzeW5jSXRlcmF0b3JcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSksIHJlZ2VuZXJhdG9yRGVmaW5lKHRoaXMsIFwiX2ludm9rZVwiLCBmdW5jdGlvbiAodCwgbywgaSkge1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgbih0LCBpLCBlLCByKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gciA9IHIgPyByLnRoZW4oZiwgZikgOiBmKCk7XG4gIH0sICEwKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXN5bmNJdGVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlcy5qc1wiKTtcbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXCIpO1xudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0LmpzXCIpO1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMocikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgPSByZXF1aXJlKFwiLi9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzXCIpO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHtcbiAgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9O1xuICB2YXIgbyxcbiAgICByLFxuICAgIGkgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykgbyA9IG5bcl0sIC0xID09PSB0LmluZGV4T2YobykgJiYge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pO1xuICB9XG4gIHJldHVybiBpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpLFxuICAgIGJhc2VVbnNldCA9IHJlcXVpcmUoJy4vX2Jhc2VVbnNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGN1c3RvbU9taXRDbG9uZSA9IHJlcXVpcmUoJy4vX2N1c3RvbU9taXRDbG9uZScpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xudmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0pO1xuICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9taXQ7XG4iLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xudmFyIGlzTmF0aXZlRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCIpO1xudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdC5qc1wiKTtcbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIodCkge1xuICB2YXIgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgTWFwID8gbmV3IE1hcCgpIDogdm9pZCAwO1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcih0KSB7XG4gICAgaWYgKG51bGwgPT09IHQgfHwgIWlzTmF0aXZlRnVuY3Rpb24odCkpIHJldHVybiB0O1xuICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICBpZiAodm9pZCAwICE9PSByKSB7XG4gICAgICBpZiAoci5oYXModCkpIHJldHVybiByLmdldCh0KTtcbiAgICAgIHIuc2V0KHQsIFdyYXBwZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdCh0LCBhcmd1bWVudHMsIGdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH1cbiAgICB9KSwgc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgdCk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX3dyYXBOYXRpdmVTdXBlcih0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCIvKlxuICogdHlwZWRlZnMuanNcbiAqIE5vcm1hbGl6ZXMgYnJvd3Nlci1zcGVjaWZpYyBwcmVmaXhlcyBhbmQgcHJvdmlkZSBzb21lIGJhc2ljIHBvbHlmaWxsc1xuICovXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgZnVuY3Rpb24gKC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG4gICAgfVxufVxuXG5pZiAodHlwZW9mIE1hdGguaW11bCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBNYXRoLmltdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBjb25zdCBhaCA9IChhID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGFsID0gYSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYmggPSAoYiA+Pj4gMTYpICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBibCA9IGIgJiAweGZmZmY7XG4gICAgICAgIC8vIHRoZSBzaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnRcbiAgICAgICAgLy8gdGhlIGZpbmFsIHwwIGNvbnZlcnRzIHRoZSB1bnNpZ25lZCB2YWx1ZSBpbnRvIGEgc2lnbmVkIHZhbHVlXG4gICAgICAgIHJldHVybiAoKGFsICogYmwpICsgKCgoYWggKiBibCArIGFsICogYmgpIDw8IDE2KSA+Pj4gMCkgfCAwKTtcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xufVxuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkgeyAvLyAubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcblxuJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHsgLy8gVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgICAgIGNvbnN0IG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZSAhPT0gbnVsbCkgeyAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgaW4gbmV4dFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0U291cmNlLCBuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9O1xufVxuIiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gITAsXG4gICAgICBvID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9ICEwLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1ByaW1pdGl2ZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbnZhciByZWdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmNHZW4gPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jR2VuLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvci5qc1wiKTtcbnZhciByZWdlbmVyYXRvcktleXMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvcktleXMuanNcIik7XG52YXIgcmVnZW5lcmF0b3JWYWx1ZXMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvclZhbHVlcy5qc1wiKTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciByID0gcmVnZW5lcmF0b3IoKSxcbiAgICBlID0gci5tKF9yZWdlbmVyYXRvclJ1bnRpbWUpLFxuICAgIHQgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpIDogZS5fX3Byb3RvX18pLmNvbnN0cnVjdG9yO1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICB2YXIgZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgciAmJiByLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiAhIWUgJiYgKGUgPT09IHQgfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUpKTtcbiAgfVxuICB2YXIgbyA9IHtcbiAgICBcInRocm93XCI6IDEsXG4gICAgXCJyZXR1cm5cIjogMixcbiAgICBcImJyZWFrXCI6IDMsXG4gICAgXCJjb250aW51ZVwiOiAzXG4gIH07XG4gIGZ1bmN0aW9uIGEocikge1xuICAgIHZhciBlLCB0O1xuICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgZSB8fCAoZSA9IHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICByZXR1cm4gdChuLmEsIDIpO1xuICAgICAgICB9LFxuICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gbi52O1xuICAgICAgICB9LFxuICAgICAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdChyLCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQobi5hLCBvW3JdLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChyLCBvLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIGUucmVzdWx0TmFtZSA9IG8sIHQobi5kLCByZWdlbmVyYXRvclZhbHVlcyhyKSwgYSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHIpIHtcbiAgICAgICAgICByZXR1cm4gdChuLmYsIHIpO1xuICAgICAgICB9XG4gICAgICB9LCB0ID0gZnVuY3Rpb24gdChyLCBfdCwgbykge1xuICAgICAgICBuLnAgPSBlLnByZXYsIG4ubiA9IGUubmV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcihfdCwgbyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZS5uZXh0ID0gbi5uO1xuICAgICAgICB9XG4gICAgICB9KSwgZS5yZXN1bHROYW1lICYmIChlW2UucmVzdWx0TmFtZV0gPSBuLnYsIGUucmVzdWx0TmFtZSA9IHZvaWQgMCksIGUuc2VudCA9IG4udiwgZS5uZXh0ID0gbi5uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHIuY2FsbCh0aGlzLCBlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG4ucCA9IGUucHJldiwgbi5uID0gZS5uZXh0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cmFwOiBmdW5jdGlvbiB3cmFwKGUsIHQsIG4sIG8pIHtcbiAgICAgICAgcmV0dXJuIHIudyhhKGUpLCB0LCBuLCBvICYmIG8ucmV2ZXJzZSgpKTtcbiAgICAgIH0sXG4gICAgICBpc0dlbmVyYXRvckZ1bmN0aW9uOiBuLFxuICAgICAgbWFyazogci5tLFxuICAgICAgYXdyYXA6IGZ1bmN0aW9uIGF3cmFwKHIsIGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybG9hZFlpZWxkKHIsIGUpO1xuICAgICAgfSxcbiAgICAgIEFzeW5jSXRlcmF0b3I6IHJlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvcixcbiAgICAgIGFzeW5jOiBmdW5jdGlvbiBhc3luYyhyLCBlLCB0LCBvLCB1KSB7XG4gICAgICAgIHJldHVybiAobihlKSA/IHJlZ2VuZXJhdG9yQXN5bmNHZW4gOiByZWdlbmVyYXRvckFzeW5jKShhKHIpLCBlLCB0LCBvLCB1KTtcbiAgICAgIH0sXG4gICAgICBrZXlzOiByZWdlbmVyYXRvcktleXMsXG4gICAgICB2YWx1ZXM6IHJlZ2VuZXJhdG9yVmFsdWVzXG4gICAgfTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHJlZ2VuZXJhdG9yQXN5bmNHZW4gPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jR2VuLmpzXCIpO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yQXN5bmMobiwgZSwgciwgdCwgbykge1xuICB2YXIgYSA9IHJlZ2VuZXJhdG9yQXN5bmNHZW4obiwgZSwgciwgdCwgbyk7XG4gIHJldHVybiBhLm5leHQoKS50aGVuKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uZG9uZSA/IG4udmFsdWUgOiBhLm5leHQoKTtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvckFzeW5jLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX3JlZ2VuZXJhdG9yS2V5cyhlKSB7XG4gIHZhciBuID0gT2JqZWN0KGUpLFxuICAgIHIgPSBbXTtcbiAgZm9yICh2YXIgdCBpbiBuKSByLnVuc2hpZnQodCk7XG4gIHJldHVybiBmdW5jdGlvbiBlKCkge1xuICAgIGZvciAoOyByLmxlbmd0aDspIGlmICgodCA9IHIucG9wKCkpIGluIG4pIHJldHVybiBlLnZhbHVlID0gdCwgZS5kb25lID0gITEsIGU7XG4gICAgcmV0dXJuIGUuZG9uZSA9ICEwLCBlO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JLZXlzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yVmFsdWVzKGUpIHtcbiAgaWYgKG51bGwgIT0gZSkge1xuICAgIHZhciB0ID0gZVtcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdLFxuICAgICAgciA9IDA7XG4gICAgaWYgKHQpIHJldHVybiB0LmNhbGwoZSk7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5uZXh0KSByZXR1cm4gZTtcbiAgICBpZiAoIWlzTmFOKGUubGVuZ3RoKSkgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBlICYmIHIgPj0gZS5sZW5ndGggJiYgKGUgPSB2b2lkIDApLCB7XG4gICAgICAgICAgdmFsdWU6IGUgJiYgZVtyKytdLFxuICAgICAgICAgIGRvbmU6ICFlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKF90eXBlb2YoZSkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclZhbHVlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZSh0LCBvKSB7XG4gIGZvciAoOyAhe30uaGFzT3duUHJvcGVydHkuY2FsbCh0LCBvKSAmJiBudWxsICE9PSAodCA9IGdldFByb3RvdHlwZU9mKHQpKTspO1xuICByZXR1cm4gdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2UsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkocik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc01hcCA9IHJlcXVpcmUoJy4vaXNNYXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1NldCA9IHJlcXVpcmUoJy4vaXNTZXQnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGJhc2VJc01hcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgbGFzdCA9IHJlcXVpcmUoJy4vbGFzdCcpLFxuICAgIHBhcmVudCA9IHJlcXVpcmUoJy4vX3BhcmVudCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbnNldDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCJ2YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN1c3RvbU9taXRDbG9uZTtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbih0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIC0xICE9PSBGdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpO1xuICB9IGNhdGNoIChuKSB7XG4gICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVGdW5jdGlvbiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanNcIik7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QodCwgZSwgcikge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB2YXIgbyA9IFtudWxsXTtcbiAgby5wdXNoLmFwcGx5KG8sIGUpO1xuICB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpO1xuICByZXR1cm4gciAmJiBzZXRQcm90b3R5cGVPZihwLCByLnByb3RvdHlwZSksIHA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICB0cnkge1xuICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgfSBjYXRjaCAodCkge31cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cykoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8qKlxuICogQ29tbW9uIHV0aWxpdGllc1xuICogQG1vZHVsZSBnbE1hdHJpeFxuICovXG5cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCB2YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG5leHBvcnQgdmFyIEFOR0xFX09SREVSID0gXCJ6eXhcIjtcblxuLyoqXG4gKiBTeW1tZXRyaWMgcm91bmRcbiAqIHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yb3VuZC1oYWxmLXVwLXN5bW1ldHJpYyN1c2VyLWNvbnRlbnQtZGV0YWlsZWQtYmFja2dyb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIHZhbHVlIHRvIHJvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChhKSB7XG4gIGlmIChhID49IDApIHJldHVybiBNYXRoLnJvdW5kKGEpO1xuICByZXR1cm4gYSAlIDAuNSA9PT0gMCA/IE1hdGguZmxvb3IoYSkgOiBNYXRoLnJvdW5kKGEpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSkge1xuICBBUlJBWV9UWVBFID0gdHlwZTtcbn1cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xudmFyIHJhZGlhbiA9IDE4MCAvIE1hdGguUEk7XG5cbi8qKlxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IFJhZGlhbiBUbyBEZWdyZWVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBSYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZShhKSB7XG4gIHJldHVybiBhICogcmFkaWFuO1xufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3NcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSAgICAgICAgICBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gYiAgICAgICAgICBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZSAgQWJzb2x1dGUgb3IgcmVsYXRpdmUgdG9sZXJhbmNlIChkZWZhdWx0IGdsTWF0cml4LkVQU0lMT04pXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogRVBTSUxPTjtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSB0b2xlcmFuY2UgKiBNYXRoLm1heCgxLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufSIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIDJ4MiBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0MlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlXG4gIC8vIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTEgPSBhWzFdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYTE7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGFbMV07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MiB8IG51bGx9IG91dCwgb3IgbnVsbCBpZiBzb3VyY2UgbWF0cml4IGlzIG5vdCBpbnZlcnRpYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhMyAqIGRldDtcbiAgb3V0WzFdID0gLWExICogZGV0O1xuICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gIG91dFszXSA9IGEwICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lY2Vzc2FyeSBpZiBvdXQgPT0gYVxuICB2YXIgYTAgPSBhWzBdO1xuICBvdXRbMF0gPSBhWzNdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGEwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV0sXG4gICAgYTIgPSBhWzJdLFxuICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV0sXG4gICAgYTIgPSBhWzJdLFxuICAgIGEzID0gYVszXTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSArIGFbMl0gKiBhWzJdICsgYVszXSAqIGFbM10pO1xufVxuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBMRFUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXSAvIGFbMF07XG4gIFVbMF0gPSBhWzBdO1xuICBVWzFdID0gYVsxXTtcbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTtcbiAgcmV0dXJuIFtMLCBELCBVXTtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIHN5bW1ldHJpYyByb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gZ2xNYXRyaXgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IGdsTWF0cml4LnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHk7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlID09PSB1bmRlZmluZWQgPyAxLjAgOiBzY2FsZTtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCBiLCByYWQpIHtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICB2YXIgcDAgPSBhWzBdIC0gYlswXSxcbiAgICBwMSA9IGFbMV0gLSBiWzFdLFxuICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgIGNvc0MgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgb3V0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNtYWxsZXN0IGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdLFxuICAgIGJ4ID0gYlswXSxcbiAgICBieSA9IGJbMV07XG4gIHJldHVybiBNYXRoLmFicyhNYXRoLmF0YW4yKGF5ICogYnggLSBheCAqIGJ5LCBheCAqIGJ4ICsgYXkgKiBieSkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2lnbmVkIGFuZ2xlIGluIHRoZSBpbnRlcnZhbCBbLXBpLHBpXSBiZXR3ZWVuIHR3byAyRCB2ZWN0b3JzIChwb3NpdGl2ZSBpZiBgYWAgaXMgdG8gdGhlIHJpZ2h0IG9mIGBiYClcbiAqIFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3JcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzaWduZWQgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkQW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXSxcbiAgICBieCA9IGJbMF0sXG4gICAgYnkgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hdGFuMihheCAqIGJ5IC0gYXkgKiBieCwgYXggKiBieCArIGF5ICogYnkpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBzeW1tZXRyaWMgcm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IGdsTWF0cml4LnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBnbE1hdHJpeC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gZ2xNYXRyaXgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdLFxuICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICBieSA9IGJbMV0sXG4gICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYW5nbGUgPSBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoZG90KGEsIGIpLCAtMSksIDEpKTtcbiAgdmFyIHNpblRvdGFsID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oKDEgLSB0KSAqIGFuZ2xlKSAvIHNpblRvdGFsO1xuICB2YXIgcmF0aW9CID0gTWF0aC5zaW4odCAqIGFuZ2xlKSAvIHNpblRvdGFsO1xuICBvdXRbMF0gPSByYXRpb0EgKiBhWzBdICsgcmF0aW9CICogYlswXTtcbiAgb3V0WzFdID0gcmF0aW9BICogYVsxXSArIHJhdGlvQiAqIGJbMV07XG4gIG91dFsyXSA9IHJhdGlvQSAqIGFbMl0gKyByYXRpb0IgKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIHZhciBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIHZhciBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEuMCA6IHNjYWxlO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXSxcbiAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV0sXG4gICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIG5vcm1hbGl6ZWQgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgLy8gRmFzdCBWZWN0b3IgUm90YXRpb24gdXNpbmcgUXVhdGVybmlvbnMgYnkgUm9iZXJ0IEVpc2VsZVxuICAvLyBodHRwczovL3Jhdy5vcmcvcHJvb2YvdmVjdG9yLXJvdGF0aW9uLXVzaW5nLXF1YXRlcm5pb25zL1xuXG4gIHZhciBxeCA9IHFbMF0sXG4gICAgcXkgPSBxWzFdLFxuICAgIHF6ID0gcVsyXSxcbiAgICBxdyA9IHFbM107XG4gIHZhciB2eCA9IGFbMF0sXG4gICAgdnkgPSBhWzFdLFxuICAgIHZ6ID0gYVsyXTtcblxuICAvLyB0ID0gcSB4IHZcbiAgdmFyIHR4ID0gcXkgKiB2eiAtIHF6ICogdnk7XG4gIHZhciB0eSA9IHF6ICogdnggLSBxeCAqIHZ6O1xuICB2YXIgdHogPSBxeCAqIHZ5IC0gcXkgKiB2eDtcblxuICAvLyB0ID0gMnRcbiAgdHggPSB0eCArIHR4O1xuICB0eSA9IHR5ICsgdHk7XG4gIHR6ID0gdHogKyB0ejtcblxuICAvLyB2ICsgdyB0ICsgcSB4IHRcbiAgb3V0WzBdID0gdnggKyBxdyAqIHR4ICsgcXkgKiB0eiAtIHF6ICogdHk7XG4gIG91dFsxXSA9IHZ5ICsgcXcgKiB0eSArIHF6ICogdHggLSBxeCAqIHR6O1xuICBvdXRbMl0gPSB2eiArIHF3ICogdHogKyBxeCAqIHR5IC0gcXkgKiB0eDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFswXTtcbiAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhyYWQpIC0gcFsyXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMl0gPSBwWzFdICogTWF0aC5zaW4ocmFkKSArIHBbMl0gKiBNYXRoLmNvcyhyYWQpO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdLFxuICAgIGF6ID0gYVsyXSxcbiAgICBieCA9IGJbMF0sXG4gICAgYnkgPSBiWzFdLFxuICAgIGJ6ID0gYlsyXSxcbiAgICBtYWcgPSBNYXRoLnNxcnQoKGF4ICogYXggKyBheSAqIGF5ICsgYXogKiBheikgKiAoYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6KSksXG4gICAgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjMyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiKVwiO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSBcIi4vbWF0Mi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MmQgZnJvbSBcIi4vbWF0MmQuanNcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0My5qc1wiO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiLi9tYXQ0LmpzXCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL3F1YXQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQyIGZyb20gXCIuL3F1YXQyLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gXCIuL3ZlYzIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vdmVjMy5qc1wiO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tIFwiLi92ZWM0LmpzXCI7XG5leHBvcnQgeyBnbE1hdHJpeCwgbWF0MiwgbWF0MmQsIG1hdDMsIG1hdDQsIHF1YXQsIHF1YXQyLCB2ZWMyLCB2ZWMzLCB2ZWM0IH07IiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB7IFR5cGVkQXJyYXkgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0KGFycjogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sIHZhbDogbnVtYmVyKSB7XG4gICAgICAgIGFyci5maWxsKHZhbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElOLVBMQUNFIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gICAgICovXG4gICAgc2h1ZmZsZShhcnI6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgLy8gRHVyc3RlbmZlbGQgc2h1ZmZsZSBhbGdvcml0aG1cbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQ1MDk1NC9ob3ctdG8tcmFuZG9taXplLXNodWZmbGUtYS1qYXZhc2NyaXB0LWFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgW2FycltpXSwgYXJyW2pdXSA9IFthcnJbal0sIGFycltpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuXG4gICAgdG9Qb2ludExpc3QoYXJyOiBBcnJheTxBcnJheTxudW1iZXI+Pikge1xuICAgICAgICBjb25zdCByb3dzID0gYXJyLnJlZHVjZSgocCwgbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gYFske24uam9pbignLCcpfV1gO1xuICAgICAgICAgICAgcC5wdXNoKHJvdyk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSwgW10gYXMgQXJyYXk8c3RyaW5nPik7XG4gICAgICAgIHJldHVybiBgWyR7cm93cy5qb2luKCcsXFxyXFxuJyl9XWA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGVsZW1lbnRzIHdoaWNoJ3Mgc2NvcmUgaXMgYmlnZ2VyIHRoYW4gdGhlIHRocmVzaG9sZFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocmVzaG9sZChhcnI6IEFycmF5PG51bWJlcj4sIHRocmVzaG9sZDogbnVtYmVyLCBzY29yZUZ1bmM6ICgoc2NvcmU6IG51bWJlcikgPT4gbnVtYmVyKSkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IGFyci5yZWR1Y2UoKHByZXY6IEFycmF5PG51bWJlcj4sIG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHByZXYucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9LFxuXG4gICAgbWF4SW5kZXgoYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSA+IGFyclttYXhdKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH0sXG5cbiAgICBtYXgoYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH0sXG5cbiAgICBzdW0oYXJyOiBBcnJheTxudW1iZXI+IHwgVHlwZWRBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gYXJyO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG59O1xuIiwiLy8gVE9ETzogY2x1c3Rlci5qcyBhbmQgY3ZfdXRpbHMuanMgYXJlIHByZXR0eSB0aWdodGx5IGludGVydHdpbmVkLCBtYWtpbmcgZm9yIGEgY29tcGxleCBjb252ZXJzaW9uXG4vLyBpbnRvIHR5cGVzY3JpcHQuIGJlIHdhcm5lZC4gOi0pXG5cbmltcG9ydCB7IHZlYzIgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGZvciBncm91cGluZyBzaW1pbGFyIG9yaWVudGF0aW9ucyBvZiBkYXRhcG9pbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUocG9pbnQsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFswLCAwXSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvaW50TWFwID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgIHBvaW50TWFwW3BvaW50VG9BZGQuaWRdID0gcG9pbnRUb0FkZDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgICAgICAgbGV0IGk7IGxldFxuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNlbnRlci52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyhjZW50ZXIucmFkKSwgTWF0aC5zaW4oY2VudGVyLnJhZCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBhZGQocG9pbnQpO1xuICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQocG9pbnRUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRzKG90aGVyUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb3NpbmUgc2ltaWxhcml0eSB0byBjZW50ZXItYW5nbGVcbiAgICAgICAgICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3Qob3RoZXJQb2ludC5wb2ludC52ZWMsIGNlbnRlci52ZWMpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENlbnRlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvaW50KG5ld1BvaW50LCBpZCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxuICAgICAgICAgICAgcG9pbnQ6IG5ld1BvaW50LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmltcG9ydCB7IHZlYzIsIHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcbmltcG9ydCBDbHVzdGVyMiBmcm9tICcuL2NsdXN0ZXInO1xuXG4vKipcbiAqIEBwYXJhbSB4IHgtY29vcmRpbmF0ZVxuICogQHBhcmFtIHkgeS1jb29yZGluYXRlXG4gKiBAcmV0dXJuIEltYWdlUmVmZXJlbmNlIHt4LHl9IENvb3JkaW5hdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltYWdlUmVmKHgsIHkpIHtcbiAgICBjb25zdCB0aGF0ID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0b1ZlYzIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5jbG9uZShbdGhpcy54LCB0aGlzLnldKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9WZWMzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzMuY2xvbmUoW3RoaXMueCwgdGhpcy55LCAxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJvdW5kKCkge1xuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ID4gMC4wID8gTWF0aC5mbG9vcih0aGlzLnggKyAwLjUpIDogTWF0aC5mbG9vcih0aGlzLnggLSAwLjUpO1xuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55ID4gMC4wID8gTWF0aC5mbG9vcih0aGlzLnkgKyAwLjUpIDogTWF0aC5mbG9vcih0aGlzLnkgLSAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gdGhhdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBpbnRlZ3JhbCBpbWFnZSBvZiBhIGdpdmVuIGdyYXlzY2FsZSBpbWFnZS5cbiAqIEBwYXJhbSBpbWFnZURhdGFDb250YWluZXIge0ltYWdlRGF0YUNvbnRhaW5lcn0gdGhlIGltYWdlIHRvIGJlIGludGVncmF0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlZ3JhbEltYWdlMihpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7IGxldCBwb3NBID0gMDsgbGV0IHBvc0IgPSAwOyBsZXQgcG9zQyA9IDA7IGxldCBwb3NEID0gMDsgbGV0IHg7IGxldFxuICAgICAgICB5O1xuXG4gICAgLy8gc3VtIHVwIGZpcnN0IGNvbHVtblxuICAgIHBvc0IgPSB3aWR0aDtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAoeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3Bvc0FdO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XG4gICAgICAgIHBvc0EgKz0gd2lkdGg7XG4gICAgICAgIHBvc0IgKz0gd2lkdGg7XG4gICAgfVxuXG4gICAgcG9zQSA9IDA7XG4gICAgcG9zQiA9IDE7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3Bvc0FdO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XG4gICAgICAgIHBvc0ErKztcbiAgICAgICAgcG9zQisrO1xuICAgIH1cblxuICAgIGZvciAoeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBwb3NBID0geSAqIHdpZHRoICsgMTtcbiAgICAgICAgcG9zQiA9ICh5IC0gMSkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0MgPSB5ICogd2lkdGg7XG4gICAgICAgIHBvc0QgPSAoeSAtIDEpICogd2lkdGg7XG4gICAgICAgIGZvciAoeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NBXVxuICAgICAgICAgICAgICAgICs9IGltYWdlRGF0YVtwb3NBXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQ10gLSBpbnRlZ3JhbEltYWdlRGF0YVtwb3NEXTtcbiAgICAgICAgICAgIHBvc0ErKztcbiAgICAgICAgICAgIHBvc0IrKztcbiAgICAgICAgICAgIHBvc0MrKztcbiAgICAgICAgICAgIHBvc0QrKztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICBsZXQgc3VtID0gMDtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCByb3dcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtpXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbaV0gPSBzdW07XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdiA9IDE7IHYgPCBoZWlnaHQ7IHYrKykge1xuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpbWFnZURhdGFbdiAqIHdpZHRoICsgdV07XG4gICAgICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSBzdW0gKyBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIDEpICogd2lkdGggKyB1XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocmVzaG9sZEltYWdlKGltYWdlV3JhcHBlciwgdGhyZXNob2xkLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgaWYgKCF0YXJnZXRXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB0YXJnZXRXcmFwcGVyID0gaW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTsgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZURhdGE7IGNvbnN0XG4gICAgICAgIHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdGFyZ2V0RGF0YVtsZW5ndGhdID0gaW1hZ2VEYXRhW2xlbmd0aF0gPCB0aHJlc2hvbGQgPyAxIDogMDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKSB7XG4gICAgaWYgKCFiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGJpdHNQZXJQaXhlbCA9IDg7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhO1xuICAgIGNvbnN0IGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcbiAgICBjb25zdCBidWNrZXRDbnQgPSAxIDw8IGJpdHNQZXJQaXhlbDtcbiAgICBjb25zdCBoaXN0ID0gbmV3IEludDMyQXJyYXkoYnVja2V0Q250KTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBoaXN0W2ltYWdlRGF0YVtsZW5ndGhdID4+IGJpdFNoaWZ0XSsrO1xuICAgIH1cbiAgICByZXR1cm4gaGlzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYXJwZW5MaW5lKGxpbmUpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gbGluZTtcbiAgICBsZXQgbGVmdCA9IGxpbmVbMF07XG4gICAgbGV0IGNlbnRlciA9IGxpbmVbMV07XG4gICAgbGV0IHJpZ2h0O1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICByaWdodCA9IGxpbmVbaSArIDFdO1xuICAgICAgICAvLyAgLTEgNCAtMSBrZXJuZWxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGxpbmVbaSAtIDFdID0gKCgoY2VudGVyICogMikgLSBsZWZ0IC0gcmlnaHQpKSAmIDI1NTtcbiAgICAgICAgbGVmdCA9IGNlbnRlcjtcbiAgICAgICAgY2VudGVyID0gcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCA9IDgpIHtcbiAgICBsZXQgaGlzdDtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG5cbiAgICBmdW5jdGlvbiBweChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaGlzdFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG14KGluaXQsIGVuZCkge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGkgKiBoaXN0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVUaHJlc2hvbGQoKSB7XG4gICAgICAgIGNvbnN0IHZldCA9IFswXTtcbiAgICAgICAgbGV0IHAxO1xuICAgICAgICBsZXQgcDI7XG4gICAgICAgIGxldCBwMTI7XG4gICAgICAgIGxldCBtMTtcbiAgICAgICAgbGV0IG0yO1xuICAgICAgICBsZXQgbTEyO1xuICAgICAgICBjb25zdCBtYXggPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcblxuICAgICAgICBoaXN0ID0gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAxOyBrIDwgbWF4OyBrKyspIHtcbiAgICAgICAgICAgIHAxID0gcHgoMCwgayk7XG4gICAgICAgICAgICBwMiA9IHB4KGsgKyAxLCBtYXgpO1xuICAgICAgICAgICAgcDEyID0gcDEgKiBwMjtcbiAgICAgICAgICAgIGlmIChwMTIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwMTIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbTEgPSBteCgwLCBrKSAqIHAyO1xuICAgICAgICAgICAgbTIgPSBteChrICsgMSwgbWF4KSAqIHAxO1xuICAgICAgICAgICAgbTEyID0gbTEgLSBtMjtcbiAgICAgICAgICAgIHZldFtrXSA9IG0xMiAqIG0xMiAvIHAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXlIZWxwZXIubWF4SW5kZXgodmV0KTtcbiAgICB9XG5cbiAgICBjb25zdCB0aHJlc2hvbGQgPSBkZXRlcm1pbmVUaHJlc2hvbGQoKTtcbiAgICByZXR1cm4gdGhyZXNob2xkIDw8IGJpdFNoaWZ0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlcik7XG5cbiAgICB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcik7XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn1cblxuLy8gbG9jYWwgdGhyZXNob2xkaW5nXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUJpbmFyeUltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpO1xuXG4gICAgaWYgKCF0YXJnZXRXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB0YXJnZXRXcmFwcGVyID0gaW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7IGxldCB2OyBsZXQgdTsgY29uc3Qga2VybmVsID0gMzsgbGV0IEE7IGxldCBCOyBsZXQgQzsgbGV0IEQ7IGxldCBhdmc7IGNvbnN0XG4gICAgICAgIHNpemUgPSAoa2VybmVsICogMiArIDEpICogKGtlcm5lbCAqIDIgKyAxKTtcblxuICAgIC8vIGNsZWFyIG91dCB0b3AgJiBib3R0b20tYm9yZGVyXG4gICAgZm9yICh2ID0gMDsgdiA8PSBrZXJuZWw7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKChoZWlnaHQgLSAxKSAtIHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgb3V0IGxlZnQgJiByaWdodCBib3JkZXJcbiAgICBmb3IgKHYgPSBrZXJuZWw7IHYgPCBoZWlnaHQgLSBrZXJuZWw7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAwOyB1IDw9IGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyAod2lkdGggLSAxIC0gdSldID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodiA9IGtlcm5lbCArIDE7IHYgPCBoZWlnaHQgLSBrZXJuZWwgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0ga2VybmVsICsgMTsgdSA8IHdpZHRoIC0ga2VybmVsOyB1KyspIHtcbiAgICAgICAgICAgIEEgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIGtlcm5lbCAtIDEpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcbiAgICAgICAgICAgIEIgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIGtlcm5lbCAtIDEpICogd2lkdGggKyAodSArIGtlcm5lbCldO1xuICAgICAgICAgICAgQyA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBEID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSArIGtlcm5lbCldO1xuICAgICAgICAgICAgc3VtID0gRCAtIEMgLSBCICsgQTtcbiAgICAgICAgICAgIGF2ZyA9IHN1bSAvIChzaXplKTtcbiAgICAgICAgICAgIHRhcmdldERhdGFbdiAqIHdpZHRoICsgdV0gPSBpbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPiAoYXZnICsgNSkgPyAwIDogMTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsdXN0ZXIocG9pbnRzLCB0aHJlc2hvbGQsIHByb3BlcnR5KSB7XG4gICAgbGV0IGk7IGxldCBrOyBsZXQgdGhpc0NsdXN0ZXI7IGxldCBwb2ludDsgY29uc3RcbiAgICAgICAgY2x1c3RlcnMgPSBbXTtcblxuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHByb3BlcnR5ID0gJ3JhZCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVG9DbHVzdGVyKG5ld1BvaW50KSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY2x1c3RlcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHRoaXNDbHVzdGVyID0gY2x1c3RlcnNba107XG4gICAgICAgICAgICBpZiAodGhpc0NsdXN0ZXIuZml0cyhuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzQ2x1c3Rlci5hZGQobmV3UG9pbnQpO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGVhY2ggY2xvdWRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gQ2x1c3RlcjIuY3JlYXRlUG9pbnQocG9pbnRzW2ldLCBpLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICghYWRkVG9DbHVzdGVyKHBvaW50KSkge1xuICAgICAgICAgICAgY2x1c3RlcnMucHVzaChDbHVzdGVyMi5jcmVhdGUocG9pbnQsIHRocmVzaG9sZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbHVzdGVycztcbn1cblxuZXhwb3J0IGNvbnN0IFRyYWNlciA9IHtcbiAgICB0cmFjZShwb2ludHMsIHZlYykge1xuICAgICAgICBsZXQgaXRlcmF0aW9uO1xuICAgICAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICAgIGxldCB0b3AgPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgY2VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGlkeCwgZm9yd2FyZCkge1xuICAgICAgICAgICAgbGV0IHRvO1xuICAgICAgICAgICAgbGV0IHRvSWR4O1xuICAgICAgICAgICAgbGV0IHByZWRpY3RlZFBvcztcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFggPSAxO1xuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkWSA9IE1hdGguYWJzKHZlY1sxXSAvIDEwKTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaChwb3MsIHByZWRpY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MueCA+IChwcmVkaWN0ZWQueCAtIHRocmVzaG9sZFgpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueCA8IChwcmVkaWN0ZWQueCArIHRocmVzaG9sZFgpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueSA+IChwcmVkaWN0ZWQueSAtIHRocmVzaG9sZFkpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueSA8IChwcmVkaWN0ZWQueSArIHRocmVzaG9sZFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZXh0IGluZGV4IGlzIHdpdGhpbiB0aGUgdmVjIHNwZWNpZmljYXRpb25zXG4gICAgICAgICAgICAvLyBpZiBub3QsIGNoZWNrIGFzIGxvbmcgYXMgdGhlIHRocmVzaG9sZCBpcyBtZXRcblxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHBvaW50c1tpZHhdO1xuICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCArIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55ICsgdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54IC0gdmVjWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBmcm9tLnkgLSB2ZWNbMV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gaWR4ICsgMSA6IGlkeCAtIDE7XG4gICAgICAgICAgICB0byA9IHBvaW50c1t0b0lkeF07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICh0byAmJiAoZm91bmQgPSBtYXRjaCh0bywgcHJlZGljdGVkUG9zKSkgIT09IHRydWUgJiYgKE1hdGguYWJzKHRvLnkgLSBmcm9tLnkpIDwgdmVjWzFdKSkge1xuICAgICAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IHRvSWR4ICsgMSA6IHRvSWR4IC0gMTtcbiAgICAgICAgICAgICAgICB0byA9IHBvaW50c1t0b0lkeF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IHRvSWR4IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9uczsgaXRlcmF0aW9uKyspIHtcbiAgICAgICAgICAgIC8vIHJhbmRvbWx5IHNlbGVjdCBwb2ludCB0byBzdGFydCB3aXRoXG4gICAgICAgICAgICBjZW50ZXJQb3MgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb2ludHMubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gdHJhY2UgZm9yd2FyZFxuICAgICAgICAgICAgdG9wID0gW107XG4gICAgICAgICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgdHJ1ZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZW50ZXJQb3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCBmYWxzZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9wLmxlbmd0aCA+IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IERJTEFURSA9IDE7XG5leHBvcnQgY29uc3QgRVJPREUgPSAyO1xuXG5leHBvcnQgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID4gMCA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xuICAgIGxldCB2O1xuICAgIGxldCB1O1xuICAgIGNvbnN0IGluSW1hZ2VEYXRhID0gaW5JbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3Qgd2lkdGggPSBpbkltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgeVN0YXJ0MTtcbiAgICBsZXQgeVN0YXJ0MjtcbiAgICBsZXQgeFN0YXJ0MTtcbiAgICBsZXQgeFN0YXJ0MjtcblxuICAgIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XG4gICAgICAgICAgICB5U3RhcnQxID0gdiAtIDE7XG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XG4gICAgICAgICAgICB4U3RhcnQyID0gdSArIDE7XG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPT09IDUgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSAtIGJJbWFnZURhdGFbbGVuZ3RoXTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGxldCB7IGxlbmd0aCB9ID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIHx8IGJJbWFnZURhdGFbbGVuZ3RoXTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGltYWdlV3JhcHBlcjtcbiAgICBsZXQgc3VtID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBzdW0gKz0gZGF0YVtsZW5ndGhdO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wR2VuZXJpYyhsaXN0LCB0b3AsIHNjb3JlRnVuYykge1xuICAgIGxldCBpOyBsZXQgbWluSWR4ID0gMDsgbGV0IG1pbiA9IDA7IGNvbnN0IHF1ZXVlID0gW107IGxldCBzY29yZTsgbGV0IGhpdDsgbGV0XG4gICAgICAgIHBvcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b3A7IGkrKykge1xuICAgICAgICBxdWV1ZVtpXSA9IHtcbiAgICAgICAgICAgIHNjb3JlOiAwLFxuICAgICAgICAgICAgaXRlbTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzY29yZSA9IHNjb3JlRnVuYy5hcHBseSh0aGlzLCBbbGlzdFtpXV0pO1xuICAgICAgICBpZiAoc2NvcmUgPiBtaW4pIHtcbiAgICAgICAgICAgIGhpdCA9IHF1ZXVlW21pbklkeF07XG4gICAgICAgICAgICBoaXQuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgIGhpdC5pdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKHBvcyA9IDA7IHBvcyA8IHRvcDsgcG9zKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbcG9zXS5zY29yZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBxdWV1ZVtwb3NdLnNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBtaW5JZHggPSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgY3R4LCBhcnJheSkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpO1xuICAgIGNvbnN0IGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tQ29udGV4dChjdHgsIHNpemUsIG9mZnNldCwgYXJyYXkpIHtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksIHNpemUueCwgc2l6ZS55KS5kYXRhO1xuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY2FudmFzRGF0YSwgc2l6ZSwgb3V0QXJyYXkpIHtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gc2l6ZS54O1xuICAgIGNvbnN0IGVuZElkeCA9IE1hdGguZmxvb3IoY2FudmFzRGF0YS5sZW5ndGggLyA0KTtcbiAgICBjb25zdCBvdXRXaWR0aCA9IHNpemUueCAvIDI7XG4gICAgbGV0IG91dEltZ0lkeCA9IDA7XG4gICAgY29uc3QgaW5XaWR0aCA9IHNpemUueDtcbiAgICBsZXQgaTtcblxuICAgIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW1nSWR4XSA9IChcbiAgICAgICAgICAgICAgICAoMC4yOTkgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMV1cbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMV1cbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMV1cbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDJdKSkgLyA0O1xuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICAgICAgICB0b3BSb3dJZHggKz0gMjtcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHRvcFJvd0lkeCArPSBpbldpZHRoO1xuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlR3JheShpbWFnZURhdGEsIG91dEFycmF5LCBjb25maWcpIHtcbiAgICBjb25zdCBsID0gKGltYWdlRGF0YS5sZW5ndGggLyA0KSB8IDA7XG4gICAgY29uc3Qgc2luZ2xlQ2hhbm5lbCA9IGNvbmZpZyAmJiBjb25maWcuc2luZ2xlQ2hhbm5lbCA9PT0gdHJ1ZTtcblxuICAgIGlmIChzaW5nbGVDaGFubmVsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IGltYWdlRGF0YVtpICogNCArIDNdO1xuICAgICAgICAgICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAyNTU7IC8vIFRyZWF0IHRyYW5zcGFyZW50IHBpeGVscyBhcyB3aGl0ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFscGhhID0gaW1hZ2VEYXRhW2kgKiA0ICsgM107XG4gICAgICAgICAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBvdXRBcnJheVtpXSA9IDI1NTsgLy8gVHJlYXQgdHJhbnNwYXJlbnQgcGl4ZWxzIGFzIHdoaXRlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIG91dEFycmF5W2ldID0gMC4yOTkgKiBpbWFnZURhdGFbaSAqIDQgKyAwXSArIDAuNTg3ICogaW1hZ2VEYXRhW2kgKiA0ICsgMV0gKyAwLjExNCAqIGltYWdlRGF0YVtpICogNCArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEltYWdlQXJyYXkoc3JjLCBjYWxsYmFjaywgY2FudmFzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpIHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgY29uc29sZS53YXJuKCcqIGxvYWRJbWFnZUFycmF5IGdldENvbnRleHQgMmQnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY29tcHV0ZUdyYXkoZGF0YSwgYXJyYXkpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGFycmF5LCB7XG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQsXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IHNyYztcbn1cblxuLyoqXG4gKiBAcGFyYW0gaW5JbWcge0ltYWdlV3JhcHBlcn0gaW5wdXQgaW1hZ2UgdG8gYmUgc2FtcGxlZFxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbGZTYW1wbGUoaW5JbWdXcmFwcGVyLCBvdXRJbWdXcmFwcGVyKSB7XG4gICAgY29uc3QgaW5JbWcgPSBpbkltZ1dyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBpbldpZHRoID0gaW5JbWdXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBvdXRJbWcgPSBvdXRJbWdXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IGluV2lkdGg7XG4gICAgY29uc3QgZW5kSWR4ID0gaW5JbWcubGVuZ3RoO1xuICAgIGNvbnN0IG91dFdpZHRoID0gaW5XaWR0aCAvIDI7XG4gICAgbGV0IG91dEltZ0lkeCA9IDA7XG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIG91dEltZ1tvdXRJbWdJZHhdID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoaW5JbWdbdG9wUm93SWR4XSArIGluSW1nW3RvcFJvd0lkeCArIDFdICsgaW5JbWdbYm90dG9tUm93SWR4XSArIGluSW1nW2JvdHRvbVJvd0lkeCArIDFdKSAvIDQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICAgICAgICB0b3BSb3dJZHggKz0gMjtcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHRvcFJvd0lkeCArPSBpbldpZHRoO1xuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc3YycmdiKGhzdiwgcmdiID0gWzAsIDAsIDBdKSB7XG4gICAgY29uc3QgaCA9IGhzdlswXTtcbiAgICBjb25zdCBzID0gaHN2WzFdO1xuICAgIGNvbnN0IHYgPSBoc3ZbMl07XG4gICAgY29uc3QgYyA9IHYgKiBzO1xuICAgIGNvbnN0IHggPSBjICogKDEgLSBNYXRoLmFicygoaCAvIDYwKSAlIDIgLSAxKSk7XG4gICAgY29uc3QgbSA9IHYgLSBjO1xuICAgIGxldCByID0gMDtcbiAgICBsZXQgZyA9IDA7XG4gICAgbGV0IGIgPSAwO1xuXG4gICAgaWYgKGggPCA2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgZyA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBnID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcbiAgICAgICAgZyA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xuICAgICAgICBnID0geDtcbiAgICAgICAgYiA9IGM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcbiAgICAgICAgciA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMF0gPSAoKHIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlsxXSA9ICgoZyArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzJdID0gKChiICsgbSkgKiAyNTUpIHwgMDtcbiAgICByZXR1cm4gcmdiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVEaXZpc29ycyhuKSB7XG4gICAgLy8gSGFuZGxlIGVkZ2UgY2FzZXNcbiAgICAvLyBOYU46IE5vdCBhIG51bWJlciAtIG5vIG1lYW5pbmdmdWwgZGl2aXNvcnNcbiAgICAvLyBJbmZpbml0eTogSW5maW5pdGUgdmFsdWVzIGhhdmUgbm8gZmluaXRlIGRpdmlzb3JzXG4gICAgLy8gTm9uLXBvc2l0aXZlOiBEaXZpc29ycyBhcmUgdHlwaWNhbGx5IGRlZmluZWQgZm9yIHBvc2l0aXZlIGludGVnZXJzIG9ubHlcbiAgICAvLyBXaGlsZSBuZWdhdGl2ZSBudW1iZXJzIHRlY2huaWNhbGx5IGhhdmUgZGl2aXNvcnMsIHJldHVybmluZyB0aGVtIHdvdWxkIGNvbXBsaWNhdGVcbiAgICAvLyB0aGUgQVBJICh3b3VsZCBuZWVkIHRvIHJldHVybiBib3RoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBkaXZpc29ycywgb3IgbWFrZSBhc3N1bXB0aW9ucylcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShuKSB8fCBuIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgbGFyZ2VEaXZpc29ycyA9IFtdO1xuICAgIGNvbnN0IGRpdmlzb3JzID0gW107XG4gICAgY29uc3Qgc3FydE4gPSBNYXRoLnNxcnQobik7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzcXJ0TjsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBjb21wbGVtZW50YXJ5IGRpdmlzb3IgaWYgaXQncyBkaWZmZXJlbnQgKG5vdCBhIHBlcmZlY3Qgc3F1YXJlIHJvb3QpXG4gICAgICAgICAgICBpZiAoaSAhPT0gbiAvIGkpIHtcbiAgICAgICAgICAgICAgICBsYXJnZURpdmlzb3JzLnVuc2hpZnQoTWF0aC5mbG9vcihuIC8gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXZpc29ycy5jb25jYXQobGFyZ2VEaXZpc29ycyk7XG59XG5cbmZ1bmN0aW9uIF9jb21wdXRlSW50ZXJzZWN0aW9uKGFycjEsIGFycjIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBhcnIxLmxlbmd0aCAmJiBqIDwgYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycjFbaV0gPT09IGFycjJbal0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycjFbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKGFycjFbaV0gPiBhcnIyW2pdKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBhdGNoU2l6ZShwYXRjaFNpemUsIGltZ1NpemUpIHtcbiAgICBjb25zdCBkaXZpc29yc1ggPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueCk7XG4gICAgY29uc3QgZGl2aXNvcnNZID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLnkpO1xuICAgIGNvbnN0IHdpZGVTaWRlID0gTWF0aC5tYXgoaW1nU2l6ZS54LCBpbWdTaXplLnkpO1xuICAgIGNvbnN0IGNvbW1vbiA9IF9jb21wdXRlSW50ZXJzZWN0aW9uKGRpdmlzb3JzWCwgZGl2aXNvcnNZKTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc0xpc3QgPSBbOCwgMTAsIDE1LCAyMCwgMzIsIDYwLCA4MF07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNNYXAgPSB7XG4gICAgICAgICd4LXNtYWxsJzogNSxcbiAgICAgICAgc21hbGw6IDQsXG4gICAgICAgIG1lZGl1bTogMyxcbiAgICAgICAgbGFyZ2U6IDIsXG4gICAgICAgICd4LWxhcmdlJzogMSxcbiAgICB9O1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzSWR4ID0gbnJPZlBhdGNoZXNNYXBbcGF0Y2hTaXplXSB8fCBuck9mUGF0Y2hlc01hcC5tZWRpdW07XG4gICAgY29uc3QgbnJPZlBhdGNoZXMgPSBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdO1xuICAgIGNvbnN0IGRlc2lyZWRQYXRjaFNpemUgPSBNYXRoLmZsb29yKHdpZGVTaWRlIC8gbnJPZlBhdGNoZXMpO1xuICAgIGxldCBvcHRpbWFsUGF0Y2hTaXplO1xuXG4gICAgZnVuY3Rpb24gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGRpdmlzb3JzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGZvdW5kID0gZGl2aXNvcnNbTWF0aC5mbG9vcihkaXZpc29ycy5sZW5ndGggLyAyKV07XG5cbiAgICAgICAgd2hpbGUgKGkgPCAoZGl2aXNvcnMubGVuZ3RoIC0gMSkgJiYgZGl2aXNvcnNbaV0gPCBkZXNpcmVkUGF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGl2aXNvcnNbaV0gLSBkZXNpcmVkUGF0Y2hTaXplKSA+IE1hdGguYWJzKGRpdmlzb3JzW2kgLSAxXSAtIGRlc2lyZWRQYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA8IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCArIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XVxuICAgICAgICAgICAgJiYgZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kID4gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4IC0gMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmb3VuZCwgeTogZm91bmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGNvbW1vbik7XG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XG4gICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoX2NvbXB1dGVEaXZpc29ycyh3aWRlU2lkZSkpO1xuICAgICAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoKF9jb21wdXRlRGl2aXNvcnMoZGVzaXJlZFBhdGNoU2l6ZSAqIG5yT2ZQYXRjaGVzKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrOiBpZiBubyBvcHRpbWFsIHBhdGNoIHNpemUgZm91bmQsIHVzZSBpbWFnZSBzaXplIChvciAxeDEgbWluaW11bSlcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgdmFsaWQge3gsIHl9IG9iamVjdFxuICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICBvcHRpbWFsUGF0Y2hTaXplID0ge1xuICAgICAgICAgICAgeDogTWF0aC5tYXgoMSwgaW1nU2l6ZS54KSxcbiAgICAgICAgICAgIHk6IE1hdGgubWF4KDEsIGltZ1NpemUueSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpbWFsUGF0Y2hTaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSksXG4gICAgICAgIHVuaXQ6IHZhbHVlLmluZGV4T2YoJyUnKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSA/ICclJyA6ICclJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZXhwb3J0IGNvbnN0IF9kaW1lbnNpb25zQ29udmVydGVycyA9IHtcbiAgICB0b3AoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSA6IG51bGw7XG4gICAgfSxcbiAgICByaWdodChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggLSAoY29udGV4dC53aWR0aCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgYm90dG9tKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgLSAoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkpIDogbnVsbDtcbiAgICB9LFxuICAgIGxlZnQoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZUFyZWEoaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIGFyZWEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0geyB3aWR0aDogaW5wdXRXaWR0aCwgaGVpZ2h0OiBpbnB1dEhlaWdodCB9O1xuXG4gICAgY29uc3QgcGFyc2VkQXJlYSA9IE9iamVjdC5rZXlzKGFyZWEpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgLy8gU2tpcCBzdHlsaW5nIHByb3BlcnRpZXMgdGhhdCBhcmVuJ3QgZGltZW5zaW9uIGNvbnZlcnRlcnNcbiAgICAgICAgaWYgKCFfZGltZW5zaW9uc0NvbnZlcnRlcnNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQge1xuICAgIFhZU2l6ZSxcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgVHlwZWRBcnJheSxcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxuICAgIE1vbWVudCxcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcblxudHlwZSBQb3NpdGl2ZU51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGFzc2VydE51bWJlclBvc2l0aXZlKHZhbDogbnVtYmVyKTogYXNzZXJ0cyB2YWwgaXMgUG9zaXRpdmVOdW1iZXIge1xuICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyLCByZWNlaXZlZCAke3ZhbH1gKTtcbiAgICB9XG59XG5cbmNsYXNzIEltYWdlV3JhcHBlciBpbXBsZW1lbnRzIFNwYXJzZUltYWdlV3JhcHBlciB7XG4gICAgZGF0YTogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj47XG5cbiAgICBzaXplOiBYWVNpemU7XG5cbiAgICBpbmRleE1hcHBpbmc/OiBXcmFwcGVySW5kZXhNYXBwaW5nO1xuXG4gICAgLy8gUmVwcmVzZW50cyBhIGJhc2ljIGltYWdlIGNvbWJpbmluZyB0aGUgZGF0YSBhbmQgc2l6ZS4gSW4gYWRkaXRpb24sIHNvbWUgbWV0aG9kcyBmb3JcbiAgICAvLyBtYW5pcHVsYXRpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4uXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHNpemU6IFhZU2l6ZSxcbiAgICAgICAgZGF0YT86IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LFxuICAgICAgICBBcnJheVR5cGU6IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB8IEFycmF5Q29uc3RydWN0b3IgPSBVaW50OEFycmF5LFxuICAgICAgICBpbml0aWFsaXplPzogYm9vbGVhbixcbiAgICApIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgKEFycmF5VHlwZSkoc2l6ZS54ICogc2l6ZS55KTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdCh0aGlzLmRhdGEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIC8vIHRlc3RzIGlmIGEgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbWFnZSwgZXh0ZW5kZWQgb3V0IGJ5IGEgYm9yZGVyIG9uIGVhY2ggc2lkZVxuICAgIGluSW1hZ2VXaXRoQm9yZGVyKGltZ1JlZjogWFlTaXplLCBib3JkZXI6IFBvc2l0aXZlTnVtYmVyID0gMCk6IGJvb2xlYW4ge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShib3JkZXIpO1xuICAgICAgICByZXR1cm4gKGltZ1JlZi54ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPj0gMClcbiAgICAgICAgICAgICYmIChpbWdSZWYueCA8ICh0aGlzLnNpemUueCArIChib3JkZXIgKiAyKSkpXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPCAodGhpcy5zaXplLnkgKyAoYm9yZGVyICogMikpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IGZyb20gVEhJUyBJbWFnZVdyYXBwZXIgdG8gdGhlIG5ldyBpbWFnZVdyYXBwZXIgcGFyYW1ldGVyLCBzdGFydGluZyBhdCBmcm9tLCBzdG9wcGluZyBhdFxuICAgIC8vIGVuZCBvZiBuZXcgaW1hZ2VXcmFwcGVyIHNpemUuXG4gICAgc3ViSW1hZ2VBc0NvcHkoaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIsIGZyb206IFhZU2l6ZSk6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueCk7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueSk7XG4gICAgICAgIGNvbnN0IHsgeDogc2l6ZVgsIHk6IHNpemVZIH0gPSBpbWFnZVdyYXBwZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplWDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemVZOyB5KyspIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YVt5ICogc2l6ZVggKyB4XSA9IHRoaXMuZGF0YVsoZnJvbS55ICsgeSkgKiB0aGlzLnNpemUueCArIGZyb20ueCArIHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZVdyYXBwZXI7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gcmVhbGx5IHByb2JhYmx5IHNob3VsZCBjYWxsIGludG8gSW1hZ2VXcmFwcGVyIHNvbWV3aGVyZSB0byBtYWtlXG4gICAgICAgIC8vIHN1cmUgdGhhdCBhbGwgb2YgaXQncyBwYXJhbWV0ZXJzIGFyZSBzZXQgcHJvcGVybHksIHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vIEltYWdlV3JhcHBlci5VcGRhdGVGcm9tKClcbiAgICAgICAgLy8gdGhhdCBtaWdodCB0YWtlIGEgcHJvdmlkZWQgZGF0YSBhbmQgc2l6ZSwgYW5kIG1ha2Ugc3VyZSB0aGVyZSdzIG5vIGludmFsaWQgaW5kZXhNYXBwaW5nXG4gICAgICAgIC8vIGhhbmdpbmcgYXJvdW5kLCBhbmQgc3VjaC5cbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZSBhIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGltYWdlXG4gICAgZ2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZSBhIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGltYWdlIChzYWZlLCB3aGF0ZXZlciB0aGF0XG4gICAgLy8gbWVhbnMpXG4gICAgZ2V0U2FmZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIGNhY2hlIGluZGV4TWFwcGluZyBiZWNhdXNlIGlmIHdlJ3JlIHVzaW5nIGl0IG9uY2UsIHdlJ2xsIHByb2JhYmx5IG5lZWQgaXQgYSBidW5jaCBtb3JlXG4gICAgICAgIC8vIHRvb1xuICAgICAgICBpZiAoIXRoaXMuaW5kZXhNYXBwaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZyA9IHtcbiAgICAgICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZS54OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2ldID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2kgKyB0aGlzLnNpemUueF0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpICsgdGhpcy5zaXplLnldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWyh0aGlzLmluZGV4TWFwcGluZy55W3kgKyB0aGlzLnNpemUueV0pICogdGhpcy5zaXplLnggKyB0aGlzLmluZGV4TWFwcGluZy54W3ggKyB0aGlzLnNpemUueF1dO1xuICAgIH1cblxuICAgIC8vIFNldHMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgaW1hZ2UgdG8gdGhlIGdpdmVuIGdyYXlzY2FsZSB2YWx1ZVxuICAgIHNldCh4OiBudW1iZXIsIHk6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XSA9IHZhbHVlO1xuICAgICAgICBkZWxldGUgdGhpcy5pbmRleE1hcHBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFNldHMgdGhlIGJvcmRlciBvZiB0aGUgaW1hZ2UgKDEgcGl4ZWwpIHRvIHplcm9cbiAgICB6ZXJvQm9yZGVyKCk6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIGNvbnN0IHsgeDogd2lkdGgsIHk6IGhlaWdodCB9ID0gdGhpcy5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IHRoaXMuZGF0YVsoaGVpZ2h0IC0gMSkgKiB3aWR0aCArIGldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICAgICAgdGhpcy5kYXRhW2kgKiB3aWR0aF0gPSB0aGlzLmRhdGFbaSAqIHdpZHRoICsgKHdpZHRoIC0gMSldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5pbmRleE1hcHBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gaXMgZW50aXJlbHkgdG9vIGxhcmdlIGZvciBtZSB0byByZWFzb24gb3V0IHJpZ2h0IGF0IHRoaXMgbW9tZW50IHRoYXQgaSdtIGhhbmRsaW5nXG4gICAgLy8gYWxsIHRoZSByZXN0IG9mIGl0LCBzbyB0aGlzIGlzIGEgdmVyYmF0aW0gY29weSBvZiB0aGUgamF2YXNjcmlwdCBzb3VyY2UsIHdpdGggb25seSB0d2Vha3NcbiAgICAvLyBuZWNlc3NhcnkgdG8gZ2V0IGl0IHRvIHJ1biwgbm8gdGhvdWdodCBwdXQgaW50byBpdCB5ZXQuXG4gICAgbW9tZW50cyhsYWJlbENvdW50OiBudW1iZXIpOiBBcnJheTxNb21lbnQ+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICBsZXQgdmFsO1xuICAgICAgICBsZXQgeXNxO1xuICAgICAgICBjb25zdCBsYWJlbFN1bTogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGxhYmVsO1xuICAgICAgICBsZXQgbXUxMTtcbiAgICAgICAgbGV0IG11MDI7XG4gICAgICAgIGxldCBtdTIwO1xuICAgICAgICBsZXQgeF87XG4gICAgICAgIGxldCB5XztcbiAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxNb21lbnQ+ID0gW107XG4gICAgICAgIGNvbnN0IHsgUEkgfSA9IE1hdGg7XG4gICAgICAgIGNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5cbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsU3VtW2ldID0ge1xuICAgICAgICAgICAgICAgIG0wMDogMCxcbiAgICAgICAgICAgICAgICBtMDE6IDAsXG4gICAgICAgICAgICAgICAgbTEwOiAwLFxuICAgICAgICAgICAgICAgIG0xMTogMCxcbiAgICAgICAgICAgICAgICBtMDI6IDAsXG4gICAgICAgICAgICAgICAgbTIwOiAwLFxuICAgICAgICAgICAgICAgIHRoZXRhOiAwLFxuICAgICAgICAgICAgICAgIHJhZDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHlzcSA9IHkgKiB5O1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBkYXRhW3kgKiB3aWR0aCArIHhdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1bdmFsIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDEgKz0geTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTEwICs9IHg7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMSArPSB4ICogeTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAyICs9IHlzcTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTIwICs9IHggKiB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1baV07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGxhYmVsLm0wMCkgJiYgbGFiZWwubTAwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgeF8gPSBsYWJlbC5tMTAgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICAgICAgeV8gPSBsYWJlbC5tMDEgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICAgICAgbXUxMSA9IGxhYmVsLm0xMSAvIGxhYmVsLm0wMCAtIHhfICogeV87XG4gICAgICAgICAgICAgICAgbXUwMiA9IGxhYmVsLm0wMiAvIGxhYmVsLm0wMCAtIHlfICogeV87XG4gICAgICAgICAgICAgICAgbXUyMCA9IGxhYmVsLm0yMCAvIGxhYmVsLm0wMCAtIHhfICogeF87XG4gICAgICAgICAgICAgICAgdG1wID0gKG11MDIgLSBtdTIwKSAvICgyICogbXUxMSk7XG4gICAgICAgICAgICAgICAgdG1wID0gMC41ICogTWF0aC5hdGFuKHRtcCkgKyAobXUxMSA+PSAwID8gUElfNCA6IC1QSV80KSArIFBJO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbiAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSA9ICh0bXAgKiAxODAgLyBQSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbC50aGV0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudGhldGEgKz0gMTgwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYWJlbC5yYWQgPSB0bXAgPiBQSSA/IHRtcCAtIFBJIDogdG1wO1xuICAgICAgICAgICAgICAgIGxhYmVsLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKHRtcCksIE1hdGguc2luKHRtcCldKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gYSBVaW50OENsYW1wZWRBcnJheSBjb250YWluaW5nIHRoaXMgZ3JheXNjYWxlIGltYWdlIGNvbnZlcnRlZCB0byBSR0JBIGZvcm1cbiAgICBnZXRBc1JHQkEoc2NhbGUgPSAxLjApOiBVaW50OENsYW1wZWRBcnJheSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OENsYW1wZWRBcnJheSg0ICogdGhpcy5zaXplLnggKiB0aGlzLnNpemUueSk7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemUueDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSB5ICogdGhpcy5zaXplLnggKyB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAwXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDFdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgdGhpcyBJbWFnZVdyYXBwZXIgaW4gYSBnaXZlbiBDYW52YXMgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHNjYWxlXG4gICAgc2hvdyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZSA9IDEuMCk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLndhcm4oJyogaW1hZ2V3cmFwcGVyIHNob3cgZ2V0Y29udGV4dCAyZCcpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRBc1JHQkEoc2NhbGUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplLng7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gbmV3IEltYWdlRGF0YShkYXRhIGFzIFVpbnQ4Q2xhbXBlZEFycmF5PEFycmF5QnVmZmVyPiwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgU3ViSW1hZ2UgYW5kIHVzaW5nIGl0J3Mgc2hvdygpIG1ldGhvZC4gV2h5PyBJIGRvbid0IGhhdmUgdGhlIGFuc3dlciB0byB0aGF0XG4gICAgLy8geWV0LiAgSSBzdXNwZWN0IHRoZSBIU1YvUkdCIG9wZXJhdGlvbnMgaW52b2x2ZWQgaGVyZSBhcmUgbWFraW5nIGl0IHNpZ25pZmljYW50bHkgZGlmZmVyZW50LFxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcbiAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICBvdmVybGF5KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGluU2NhbGU6IG51bWJlciwgZnJvbTogWFlTaXplKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xuICAgICAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIGNvbnN0IGJsYWNrUmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnNvbGUud2FybignKiBpbWFnZXdyYXBwZXIgb3ZlcmxheSBnZXRjb250ZXh0IDJkJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGZyYW1lO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IHRoaXMuZGF0YTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxlbmd0aCAqIDQ7XG4gICAgICAgICAgICBbZGF0YVtwb3NdLCBkYXRhW3BvcyArIDFdLCBkYXRhW3BvcyArIDJdXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGRhdGFbcG9zICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IFhZUG9zaXRpb24gc2hvdWxkIGJlIGFuIFhZT2JqZWN0LCBidXQgdGhhdCBicmVha3MgWFlEZWZpbml0aW9uLCB3aGljaCBicmVha3MgZHJhd1BhdGgoKSBiZWxvdy5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENhbnZhc1N0eWxlIHtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xufVxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xuICAgIHk6IGtleW9mIFhZUG9zaXRpb247XG59XG5cbmRlY2xhcmUgdHlwZSBQYXRoID0gQXJyYXk8WFlQb3NpdGlvbj47XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdChwb3M6IFhZUG9zaXRpb24sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjYW52YXNEYXRhO1xuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWN5Y2xlXG5pbXBvcnQgeyBJbWFnZVdyYXBwZXIgfSBmcm9tICdxdWFnZ2EnO1xuaW1wb3J0IHsgUXVhZ2dhSlNSZXN1bHRPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYSc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbi8vIGZvciBzb21lIHJlYXNvbiB0aGlzIHRocm93cyBhIHNoYWRvdyBlcnJvciBvbiBpdHNlbGY/IVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuZXhwb3J0IGVudW0gQmFyY29kZURpcmVjdGlvbiB7XG4gICAgRm9yd2FyZCA9IDEsXG4gICAgUmV2ZXJzZSA9IC0xXG59XG5cbmV4cG9ydCB0eXBlIEJhcmNvZGVSZWFkZXJUeXBlID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgQmFyY29kZUZvcm1hdCA9IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUmVhZGVyQ29uZmlnIHtcbiAgICBub3JtYWxpemVCYXJTcGFjZVdpZHRoPzogYm9vbGVhbixcbiAgICBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXJUeXBlPixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlQ29ycmVjdGlvbiB7XG4gICAgYmFyOiBudW1iZXIsXG4gICAgc3BhY2U6IG51bWJlcixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUG9zaXRpb24ge1xuICAgIGVuZDogbnVtYmVyLFxuICAgIGVuZENvdW50ZXI/OiBudW1iZXIsXG4gICAgZXJyb3I/OiBudW1iZXIsXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGFydENvdW50ZXI/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlSW5mbyBleHRlbmRzIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgY29kZTogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlIHtcbiAgICBjb2RlOiBzdHJpbmcsXG4gICAgY29kZXNldD86IG51bWJlcixcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXG4gICAgZGVjb2RlZENvZGVzPzogQXJyYXk8c3RyaW5nIHwgQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+LFxuICAgIGRpcmVjdGlvbj86IEJhcmNvZGVEaXJlY3Rpb24sXG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kSW5mbz86IEJhcmNvZGVQb3NpdGlvbixcbiAgICBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsXG4gICAgcGF0dGVybj86IHN0cmluZyxcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLFxuICAgIHN1cHBsZW1lbnQ/OiBCYXJjb2RlLFxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFyY29kZVJlYWRlciB7XG4gICAgX3JvdzogQXJyYXk8bnVtYmVyPiA9IFtdO1xuXG4gICAgY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG5cbiAgICBzdXBwbGVtZW50czogQXJyYXk8QmFyY29kZVJlYWRlcj4gPSBbXTtcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMDtcblxuICAgIEZPUk1BVDogQmFyY29kZUZvcm1hdCA9ICd1bmtub3duJztcblxuICAgIENPTkZJR19LRVlTOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG4gICAgLy8gVE9ETzogc2hvdWxkIGFkZCBBTFBIQUJFVEhfU1RSSU5HLCBBTFBIQUJFVCwgQ0hBUkFDVEVSX0VOQ09ESU5HUyB0byBiYXNlIGNsYXNzLCBpZiB0aGV5XG4gICAgLy8gYXJlIHVzZWZ1bCBpbiBtb3N0IHJlYWRlcnMuXG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGw7XG5cbiAgICBzdGF0aWMgZ2V0IEV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFN0YXJ0Tm90Rm91bmRFeGNlcHRpb246ICdTdGFydC1JbmZvIHdhcyBub3QgZm91bmQhJyxcbiAgICAgICAgICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogJ0NvZGUgY291bGQgbm90IGJlIGZvdW5kIScsXG4gICAgICAgICAgICBQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb246ICdQYXR0ZXJuIGNvdWxkIG5vdCBiZSBmb3VuZCEnLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJlYWRlci1zcGVjaWZpYyBhZGphY2VudC1saW5lIHZhbGlkYXRpb24gdGhyZXNob2xkICgwID0+IGRpc2FibGVkKVxuICAgIHN0YXRpYyBhZGphY2VudExpbmVWYWxpZGF0aW9uTWF0Y2hlcyA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcbiAgICAgICAgdGhpcy5fcm93ID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBpZiAoc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcGxlbWVudHMgPSBzdXBwbGVtZW50cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfbmV4dFVuc2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgc3RhcnQgPSAwKTogbnVtYmVyIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9tYXRjaFBhdHRlcm4oY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG1heFNpbmdsZUVycm9yID0gdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgbGV0IHNpbmdsZUVycm9yID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBtb2R1bG8gPSAwO1xuICAgICAgICBsZXQgYmFyV2lkdGggPSAwO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgc2NhbGVkID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgbW9kdWxvICs9IGNvZGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1bSA8IG1vZHVsbykge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cblxuICAgICAgICBiYXJXaWR0aCA9IHN1bSAvIG1vZHVsbztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIG1heFNpbmdsZUVycm9yICo9IGJhcldpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcbiAgICAgICAgICAgIHNjYWxlZCA9IGNvZGVbaV0gKiBiYXJXaWR0aDtcbiAgICAgICAgICAgIHNpbmdsZUVycm9yID0gTWF0aC5hYnMoY291bnQgLSBzY2FsZWQpIC8gc2NhbGVkO1xuICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvciAvIG1vZHVsbztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX25leHRTZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY29ycmVjdEJhcnMoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogbnVtYmVyLCBpbmRpY2VzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gaW5kaWNlcztcbiAgICAgICAgbGV0IHRtcCA9IDA7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgdG1wID0gY291bnRlcltpbmRpY2VzW2xlbmd0aF1dICogKDEgLSAoKDEgLSBjb3JyZWN0aW9uKSAvIDIpKTtcbiAgICAgICAgICAgIGlmICh0bXAgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY291bnRlcltpbmRpY2VzW2xlbmd0aF1dID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZVBhdHRlcm4ocGF0dGVybjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybicsIHBhdHRlcm4pO1xuICAgICAgICB0aGlzLl9yb3cgPSBwYXR0ZXJuO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybiBjYWxsaW5nIGRlY29kZScsIHR5cGVvZiB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLkZPUk1BVCwgSlNPTi5zdHJpbmdpZnkodGhpcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kZWNvZGUoKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0IHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kZWNvZGUoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXZlcnNlZCByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5SZXZlcnNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZm9ybWF0ID0gdGhpcy5GT1JNQVQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9tYXRjaFJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBzdGFydCA9IHN0YXJ0IDwgMCA/IDAgOiBzdGFydDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmlsbENvdW50ZXJzKG9mZnNldDogbnVtYmVyID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3JvdyksIGVuZDogbnVtYmVyID0gdGhpcy5fcm93Lmxlbmd0aCwgaXNXaGl0ZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3RvQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5IHwgQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W3N0YXJ0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIEFycmF5SGVscGVyLmluaXQoY291bnRlcnMsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUvaW1wbGVtZW50IHRoaXMgaW4geW91ciBjdXN0b20gcmVhZGVycy5cbiAgICBwcm90ZWN0ZWQgZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIpOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdm9pZFxuICAgICAgICB2b2lkIGltYWdlV3JhcHBlcjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJjb2RlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBOID0gMTtcbmNvbnN0IFcgPSAzO1xuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFtXLCBOLCBXLCBOLCBOLCBOXTtcbmNvbnN0IFNUT1BfUEFUVEVSTiA9IFtXLCBOLCBOLCBOLCBXXTtcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcbiAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgW1csIE4sIE4sIE4sIFddLFxuICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgW04sIE4sIFcsIE4sIFddLFxuICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgW04sIE4sIE4sIFcsIFddLFxuICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICBbTiwgVywgTiwgVywgTl0sXG5dO1xuY29uc3QgU1RBUlRfUEFUVEVSTl9MRU5HVEggPSBTVEFSVF9QQVRURVJOLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XG5cbmNsYXNzIFR3b09mRml2ZVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG5cbiAgICBGT1JNQVQgPSAnMm9mNSc7XG5cbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XG5cbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIsIGlzV2hpdGUgPSBmYWxzZSwgdHJ5SGFyZGVyID0gZmFsc2UpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gW107XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGxldCBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyBTVEFSVF9QQVRURVJOX0xFTkdUSCk7XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiA1O1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gVE9ETzogcmV2ZXJzZSwgZm9sbG93ZWQgYnkgc29tZSBjYWxjcywgZm9sbG93ZWQgYnkgYW5vdGhlciByZXZlcnNlPyByZWFsbHk/XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYCR7Y29kZS5jb2RlfWApO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbi8vIGNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OS0kOi8uK0FCQ0QnO1xuY29uc3QgQUxQSEFCRVQgPSBbNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDQ1LCAzNiwgNTgsIDQ3LCA0NiwgNDMsIDY1LCA2NiwgNjcsIDY4XTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPVxuICAgIFsweDAwMywgMHgwMDYsIDB4MDA5LCAweDA2MCwgMHgwMTIsIDB4MDQyLCAweDAyMSwgMHgwMjQsIDB4MDMwLCAweDA0OCwgMHgwMGMsIDB4MDE4LFxuICAgICAgICAweDA0NSwgMHgwNTEsIDB4MDU0LCAweDAxNSwgMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgU1RBUlRfRU5EID0gWzB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcbmNvbnN0IE1JTl9FTkNPREVEX0NIQVJTID0gNDtcbmNvbnN0IE1BWF9BQ0NFUFRBQkxFID0gMi4wO1xuY29uc3QgUEFERElORyA9IDEuNTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZFNpemUge1xuICAgIHNpemU6IG51bWJlcixcbiAgICBjb3VudHM6IG51bWJlcixcbiAgICBtaW46IG51bWJlcixcbiAgICBtYXg6IG51bWJlcixcbn07XG5cbmludGVyZmFjZSBUaHJlc2hvbGQge1xuICAgIHNwYWNlOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxuICAgIGJhcjoge1xuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXG4gICAgfSxcbn07XG5cbmNsYXNzIE5ld0NvZGFiYXJSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBfY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICBGT1JNQVQgPSAnY29kYWJhcic7XG5cbiAgICBwcm90ZWN0ZWQgX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgICAgICBpZiAoY291bnRlciA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRlciA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKChtaW4gKyBtYXgpIC8gMi4wKSB8IDA7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdG9QYXR0ZXJuKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gNztcbiAgICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgbnVtQ291bnRlcnM7XG5cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFyVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKTtcbiAgICAgICAgY29uc3Qgc3BhY2VUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0ICsgMSwgZW5kKTtcblxuICAgICAgICBsZXQgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSk7XG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnRlcnNbb2Zmc2V0ICsgaV0gPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRtYXNrID4+PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfaXNTdGFydEVuZChwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTVEFSVF9FTkQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChTVEFSVF9FTkRbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfc3VtQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGkpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBMb29rIGZvciB3aGl0ZXNwYWNlIGFoZWFkXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5fc3VtQ291bnRlcnMoMCwgaSk7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudGVyOiBpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb3VudGVyOiBpICsgOCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA3OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5V2hpdGVzcGFjZShzdGFydENvdW50ZXI6IG51bWJlciwgZW5kQ291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGlmICgoc3RhcnRDb3VudGVyIC0gMSA8PSAwKVxuICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoc3RhcnRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgIGlmICgoZW5kQ291bnRlciArIDggPj0gdGhpcy5fY291bnRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW2VuZENvdW50ZXIgKyA3XSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChlbmRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY2hhclRvUGF0dGVybihjaGFyOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKEFMUEhBQkVUW2ldID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDSEFSQUNURVJfRU5DT0RJTkdTW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAweDA7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcml6YXRpb246IFRocmVzaG9sZCA9IHtcbiAgICAgICAgICAgICAgICBzcGFjZToge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAyID8gY2F0ZWdvcml6YXRpb24uYmFyIDogY2F0ZWdvcml6YXRpb24uc3BhY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgICAgIGNhdC5zaXplICs9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGNhdC5jb3VudHMrKztcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgIH1cblxuICAgICAgICAoWydzcGFjZScsICdiYXInXSBhcyBjb25zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5taW4gPVxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG5ld2tpbmQubmFycm93LnNpemUgLyBuZXdraW5kLm5hcnJvdy5jb3VudHMgKyBuZXdraW5kLndpZGUuc2l6ZSAvIG5ld2tpbmQud2lkZS5jb3VudHMpIC8gMik7XG4gICAgICAgICAgICBuZXdraW5kLm5hcnJvdy5tYXggPSBNYXRoLmNlaWwobmV3a2luZC53aWRlLm1pbik7XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWF4ID0gTWF0aC5jZWlsKChuZXdraW5kLndpZGUuc2l6ZSAqIE1BWF9BQ0NFUFRBQkxFICsgUEFERElORykgLyBuZXdraW5kLndpZGUuY291bnRzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhdGVnb3JpemF0aW9uO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gdGhpcy5fdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlcik7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG5cbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoKTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXI7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG5leHRTdGFydCA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZFxuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IE1JTl9FTkNPREVEX0NIQVJTIHx8ICF0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVSZXN1bHQocmVzdWx0LCBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGggPyB0aGlzLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0LnN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCwgLy8gVE9ETzogaSB0aGluayBpdCBzaG91bGQgbm90IGJlIHJlcXVpcmVkIHRvIHJldHVybiBmb3JtYXQgZnJvbSB0aGlzLCBhcyBiYXJjb2RlX3JlYWRlciBmb3JjZSBzZXRzIHRoZSBmb3JtYXQgYW55d2F5XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTmV3Q29kYWJhclJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVDb3JyZWN0aW9uLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBDT0RFX1NISUZUID0gOTg7XG4gICAgQ09ERV9DID0gOTk7XG4gICAgQ09ERV9CID0gMTAwO1xuICAgIENPREVfQSA9IDEwMTtcbiAgICBGTkMxID0gMTAyO1xuICAgIFNUQVJUX0NPREVfQSA9IDEwMztcbiAgICBTVEFSVF9DT0RFX0IgPSAxMDQ7XG4gICAgU1RBUlRfQ09ERV9DID0gMTA1O1xuICAgIFNUT1BfQ09ERSA9IDEwNjtcbiAgICAvLyBBU0NJSSAyOSBpcyB0aGUgR3JvdXAgU2VwYXJhdG9yIGNoYXJhY3RlciB1c2VkIHRvIHJlcHJlc2VudCBGTkMxIGluIEdTMS0xMjggYmFyY29kZXNcbiAgICBGTkMxX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMywgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMywgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMywgMV0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMywgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMywgMV0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMywgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMywgMSwgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMywgMywgMSwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMywgMSwgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMywgMywgMiwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMywgMSwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgNCwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbNCwgMSwgMywgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMSwgNCwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMywgMywgMSwgMSwgMSwgMl0sXG4gICAgICAgIF07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjY0O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcbiAgICBGT1JNQVQgPSAnY29kZV8xMjgnO1xuICAgIE1PRFVMRV9JTkRJQ0VTID0geyBiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XSB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3QoY291bnRlciwgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmNvZGUgPT09IC0xIHx8IGJlc3RNYXRjaC5lcnJvciA+IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY29ycmVjdChjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBCYXJjb2RlQ29ycmVjdGlvbikge1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLnNwYWNlLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogX2ZpbmRTdGFydCBhbmQgZGVjb2RlQ29kZSBzaGFyZSBzaW1pbGFyIGNvZGUsIGNhbiB3ZSByZS11c2Ugc29tZT9cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSB0aGlzLlNUQVJUX0NPREVfQTsgY29kZSA8PSB0aGlzLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIC8vICAgICBkb25lID0gZmFsc2UsXG4gICAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIG11bHRpcGxpZXIgPSAwLFxuICAgICAgICAvLyAgICAgY2hlY2tzdW0gPSAwLFxuICAgICAgICAvLyAgICAgY29kZXNldCxcbiAgICAgICAgLy8gICAgIHJhd1Jlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHVuc2hpZnQsXG4gICAgICAgIC8vICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLmJhcixcbiAgICAgICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLnNwYWNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICBsZXQgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgICAgIGxldCBjb2Rlc2V0ID0gKChjOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShjb2RlLmNvZGUpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGxldCB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICBsZXQgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMDtcbiAgICAgICAgbGV0IHJhd1Jlc3VsdDogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0gW107IC8vIFRPRE86IGkgdGhpbmsgdGhpcyBzaG91bGQgYmUgc3RyaW5nIG9ubHksIGJ1dCBpdCBjcmVhdGVzIHByb2JsZW1zIGlmIGl0IGlzXG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlIS5lbmQsIGNvZGUhLmNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByYXdSZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyKys7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IG11bHRpcGxpZXIgKiBjb2RlLmNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rlc2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5GTkMxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuRk5DMV9DSEFSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5GTkMxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLkZOQzFfQ0hBUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgPCAxMCA/ICcwJyArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkZOQzE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5GTkMxX0NIQVIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gY29kZXNldCA9PT0gdGhpcy5DT0RFX0EgPyB0aGlzLkNPREVfQiA6IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZS5lbmQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGNvZGUpKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjaGVja3N1bSAlIDEwMyAhPT0gcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXG4gICAgICAgIGlmIChyZW1vdmVMYXN0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgY29kZXNldDogY29kZXNldCBhcyBudW1iZXIsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kSW5mbzogY29kZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZUluZm8gfCBudWxsIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgcHVibGljIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkICs9IG5vcm1hbGl6ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTEyOFJlYWRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IHR5cGUgQmFyY29kZVBvc2l0aW9uLCB0eXBlIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKChjaGFyKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LCAweDEwOSwgMHgwNDksXG4gICAgMHgxNDgsIDB4MDE5LCAweDExOCwgMHgwNTgsIDB4MDBELCAweDEwQywgMHgwNEMsIDB4MDFDLCAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsXG4gICAgMHgwNDYsIDB4MDE2LCAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDA5NCwgMHgwQTgsIDB4MEEyLCAweDA4QSwgMHgwMkEsXG5dKTtcbmNvbnN0IEFTVEVSSVNLID0gMHgwOTQ7XG5cbmNsYXNzIENvZGUzOVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5JztcblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1heE5hcnJvd1dpZHRoID0gMDtcbiAgICAgICAgbGV0IG51bVdpZGVCYXJzID0gbnVtQ291bnRlcnM7XG4gICAgICAgIGxldCB3aWRlQmFyV2lkdGggPSAwO1xuXG4gICAgICAgIHdoaWxlIChudW1XaWRlQmFycyA+IDMpIHtcbiAgICAgICAgICAgIG1heE5hcnJvd1dpZHRoID0gdGhpcy5fZmluZE5leHRXaWR0aChjb3VudGVycywgbWF4TmFycm93V2lkdGgpO1xuICAgICAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiBudW1XaWRlQmFycyA+IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlcnNbaV0gKiAyKSA+PSB3aWRlQmFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZE5leHRXaWR0aChjb3VudGVyczogVWludDE2QXJyYXksIGN1cnJlbnQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBtaW5XaWR0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldIDwgbWluV2lkdGggJiYgY291bnRlcnNbaV0gPiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW5XaWR0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcGF0dGVyblNpemUgPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xuICAgICAgICBpZiAoKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCAqIDMpID49IHBhdHRlcm5TaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZSgpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0OiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTxBcnJheUJ1ZmZlcj47XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBBRUlPOiAvW0FFSU9dL2csXG4gICAgQVowOTogL1tBLVowLTldLyxcbn07XG5cbmNvbnN0IGNvZGUzMnNldCA9ICcwMTIzNDU2Nzg5QkNERkdISktMTU5QUVJTVFVWV1hZWic7XG5cbmNsYXNzIENvZGUzMlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzJfcmVhZGVyJztcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZTMyKGNvZGU6IHN0cmluZykge1xuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcyAqIDMyICsgY29kZTMyc2V0LmluZGV4T2YoY29kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGUzMiA9IGAke3Jlc31gO1xuICAgICAgICBpZiAoY29kZTMyLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnQScgKyBjb2RlMzI7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIHByb3RlY3RlZCBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhY29kZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGUgPSByZXN1bHQuY29kZTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUzMiA9IHRoaXMuX2RlY29kZUNvZGUzMihjb2RlKTtcblxuICAgICAgICBpZiAoIWNvZGUzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGUzMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzMlJlYWRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCB7IEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIElPUTogL1tJT1FdL2csXG4gICAgQVowOTogL1tBLVowLTldezE3fS8sXG59O1xuXG5jbGFzcyBDb2RlMzlWSU5SZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5X3Zpbic7XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgcHJvdGVjdGVkIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIC8vIENyaWJiZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuICAgIHB1YmxpYyBkZWNvZGUoKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHsgY29kZSB9ID0gcmVzdWx0O1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLklPUSwgJycpO1xuXG4gICAgICAgIGlmICghY29kZS5tYXRjaChwYXR0ZXJucy5BWjA5KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgQVowOSBwYXR0ZXJuIGNvZGU6JywgY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXG4gICAgMHgxQTgsIDB4MUE0LCAweDFBMiwgMHgxOTQsIDB4MTkyLCAweDE4QSwgMHgxNjgsIDB4MTY0LCAweDE2MiwgMHgxMzQsXG4gICAgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXG4gICAgMHgxNkUsIDB4MTc2LCAweDFBRSwgMHgxMjYsIDB4MURBLCAweDFENiwgMHgxMzIsIDB4MTVFLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xuXG5jbGFzcyBDb2RlOTNSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XG4gICAgcHJvdGVjdGVkIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VtID0gY291bnRlcnMucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkID0gTWF0aC5yb3VuZChjb3VudGVyc1tpXSAqIDkgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gKHBhdHRlcm4gPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA8PD0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5RW5kKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KTogc3RyaW5nW10gfCBudWxsIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2hhckFycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBjaGFyQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAnZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBuZXh0Q2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnRicgJiYgbmV4dENoYXIgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgNDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnVCcgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIGNvZGVfOTNfcmVhZGVyIF9kZWNvZGVFeHRlbmRlZCBoaXQgZGVmYXVsdCBjYXNlLCB0aGlzIG1heSBiZSBhbiBlcnJvcicsIGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+LCBpbmRleDogbnVtYmVyLCBtYXhXZWlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBhcnJheVRvQ2hlY2sgPSBjaGFyQXJyYXkuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xuICAgICAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9ICgoKGkgKiAtMSkgKyAobGVuZ3RoIC0gMSkpICUgbWF4V2VpZ2h0KSArIDE7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEFMUEhBQkVULmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyAod2VpZ2h0ICogdmFsdWUpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBjb25zdCBjaGVja0NoYXIgPSBBTFBIQUJFVFsod2VpZ2h0ZWRTdW1zICUgNDcpXTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNoZWNrc3VtcyhjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDIsIDIwKVxuICAgICAgICAgICAgJiYgdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMSwgMTUpO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiB8IG51bGwgPSBbXTtcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0O1xuICAgICAgICBsZXQgZGVjb2RlZENoYXI6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTxBcnJheUJ1ZmZlcj47XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUVuZChsYXN0U3RhcnQsIG5leHRTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgICAgICAvLyB5ZXMsIHRoaXMgaXMgYW4gYXNzaWduIGluc2lkZSBhbiBpZi5cbiAgICAgICAgaWYgKChyZXN1bHQgPSB0aGlzLl9kZWNvZGVFeHRlbmRlZChyZXN1bHQpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlOTNSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcbmNvbnN0IENPREVfR19TVEFSVCA9IDEwO1xuZXhwb3J0IHsgQ09ERV9HX1NUQVJUIH07XG5jb25zdCBTVEFSVF9QQVRURVJOID0gWzEsIDEsIDFdO1xuY29uc3QgTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XG5leHBvcnQgeyBNSURETEVfUEFUVEVSTiB9O1xuY29uc3QgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMl07XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgWzMsIDIsIDEsIDFdLFxuICAgIFsyLCAyLCAyLCAxXSxcbiAgICBbMiwgMSwgMiwgMl0sXG4gICAgWzEsIDQsIDEsIDFdLFxuICAgIFsxLCAxLCAzLCAyXSxcbiAgICBbMSwgMiwgMywgMV0sXG4gICAgWzEsIDEsIDEsIDRdLFxuICAgIFsxLCAzLCAxLCAyXSxcbiAgICBbMSwgMiwgMSwgM10sXG4gICAgWzMsIDEsIDEsIDJdLFxuICAgIFsxLCAxLCAyLCAzXSxcbiAgICBbMSwgMiwgMiwgMl0sXG4gICAgWzIsIDIsIDEsIDJdLFxuICAgIFsxLCAxLCA0LCAxXSxcbiAgICBbMiwgMywgMSwgMV0sXG4gICAgWzEsIDMsIDIsIDFdLFxuICAgIFs0LCAxLCAxLCAxXSxcbiAgICBbMiwgMSwgMywgMV0sXG4gICAgWzMsIDEsIDIsIDFdLFxuICAgIFsyLCAxLCAxLCAzXSxcbl07XG5jb25zdCBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbmNvbnN0IEFWR19DT0RFX0VSUk9SID0gMC40ODtcblxuY2xhc3MgRUFOUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8xMyc7XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxLCAxLCAxXTsgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICBzdXBlcihtZXJnZSh7IHN1cHBsZW1lbnRzOiBbXSB9LCBjb25maWcpLCBzdXBwbGVtZW50cyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm4nLCBwYXR0ZXJuLCBvZmZzZXQsIGlzV2hpdGUsIHRyeUhhcmRlciwgZXBzaWxvbik7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uICYmIGJlc3RNYXRjaC5lcnJvciAmJiBlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gY291bnRlci5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBmaW5kUGF0dGVybiBhbmQgZGVjb2RlQ29kZSBhcHBlYXIgdG8gc2hhcmUgcXVpdGUgc2ltaWxhciBjb2RlLCBjYW4gaXQgYmUgcmVkdWNlZD9cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29kZXJhbmdlPzogbnVtYmVyKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUnLCBzdGFydCwgY29kZXJhbmdlKTtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZUluZm8gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgaWYgKCFjb2RlcmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGJlZm9yZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIGNvZGVyYW5nZSA9IENPREVfUEFUVEVSTi5sZW5ndGg7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBhZnRlciBsZW5ndGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBjb2RlcmFuZ2U7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFN0YXJ0Jyk7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBzdGFydEluZm89JywgSlNPTi5zdHJpbmdpZnkoc3RhcnRJbmZvKSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpO1xuXG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIHN0YXJ0SW5mbycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBjYWxjdWxhdGVGaXJzdERpZ2l0JywgY29kZUZyZXF1ZW5jeSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDT0RFX0ZSRVFVRU5DWVtpXSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXlsb2FkJywgaW5Db2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9Jywgb3V0Q29kZSk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtPSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMCA8PCAoNSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaXJzdERpZ2l0ID0gdGhpcy5fY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0RGlnaXQ9JywgZmlyc3REaWdpdCk7XG4gICAgICAgIGlmIChmaXJzdERpZ2l0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoZmlyc3REaWdpdCk7XG5cbiAgICAgICAgbGV0IG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgb3V0Q29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcblxuICAgICAgICBpZiAobWlkZGxlUGF0dGVybiA9PT0gbnVsbCB8fCAhbWlkZGxlUGF0dGVybi5lbmQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2RlY29kZUNvZGUobWlkZGxlUGF0dGVybiEuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgICAgICBpZiAoIW1pZGRsZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgobWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIHJlc3VsdD0nLCBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVkQ29kZXM9JywgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgcmV0dXJuIG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm87XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB2ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCk7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kRW5kJywgb2Zmc2V0LCBpc1doaXRlKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGlzV2hpdGUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIF9jaGVja3N1bScsIHJlc3VsdCk7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gKj0gMztcblxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjaGVja3N1bScsIHN1bSAlIDEwID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RlY29kZUV4dGVuc2lvbnMob2Zmc2V0OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBzdGFydCwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zJywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGVyZSBhcmUgJywgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGgsICcgc3VwcGxlbWVudHMnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZXh0ZW5zaW9ucyBsb29wJywgaSwgdGhpcy5zdXBwbGVtZW50c1tpXSwgdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3VwcGxlbWVudHNbaV0uZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZSByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnN1cHBsZW1lbnRzW2ldLkZPUk1BVCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIGRlY29kZUV4dGVuc2lvbnMgZXJyb3IgaW4gJywgdGhpcy5zdXBwbGVtZW50c1tpXSwgJzogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgcm93KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPigpO1xuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XG4gICAgICAgIGxldCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZVBvc2l0aW9uIHwgQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxuICAgICAgICB9O1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIC8vIENoZWNrc3VtXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhpcy5zdXBwbGVtZW50cz0nLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcGxlbWVudCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMgcmV0dXJucycsIHN1cHBsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdENvZGUgPSBzdXBwbGVtZW50LmRlY29kZWRDb2Rlc1tzdXBwbGVtZW50LmRlY29kZWRDb2Rlcy5sZW5ndGggLSAxXSBhcyBCYXJjb2RlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSArIHN1cHBsZW1lbnQuY29kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5cbmNsYXNzIEVBTjJSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fMic7XG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbignJykpICUgNCkgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjJSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IENIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsyNCwgMjAsIDE4LCAxNywgMTIsIDYsIDMsIDEwLCA5LCA1XTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENIRUNLX0RJR0lUX0VOQ09ESU5HU1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIHJldHVybiBzdW0gJSAxMDtcbn1cblxuY2xhc3MgRUFONVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl81JztcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDQgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkgIT09IGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjVSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCwgTUlERExFX1BBVFRFUk4gfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzgnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gaW5Db2RlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcbiIsIi8vIFRPRE86IGkyb2Y1X3JlYWRlciBhbmQgMm9mNV9yZWFkZXIgc2hhcmUgdmVyeSBzaW1pbGFyIGNvZGUsIG1ha2UgdXNlIG9mIHRoYXRcblxuaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5cbmNsYXNzIEkyb2Y1UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgcHJpdmF0ZSBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzg7XG5cbiAgICBTVEFSVF9QQVRURVJOID0gW04sIE4sIE4sIE5dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFtOLCBOLCBXXTtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICAgICAgW1csIE4sIE4sIE4sIFddLFxuICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIFcsIE4sIFddLFxuICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIE4sIFcsIFddLFxuICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgIFtOLCBXLCBOLCBXLCBOXSxcbiAgICBdO1xuICAgIE1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiA9IDU7XG4gICAgRk9STUFUID0gJ2kyb2Y1JztcblxuICAgIGNvbnN0cnVjdG9yKG9wdHM6IEJhcmNvZGVSZWFkZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiBmYWxzZSB9LCBvcHRzKSk7XG4gICAgICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuU0lOR0xFX0NPREVfRVJST1IgPSAwLjM4O1xuICAgICAgICAgICAgdGhpcy5BVkdfQ09ERV9FUlJPUiA9IDAuMDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoUGF0dGVybihjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlclN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvID0gdGhpcy5NQVhfQ09SUkVDVElPTl9GQUNUT1I7XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlID0gMSAvIGNvcnJlY3Rpb25SYXRpbztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclN1bVtpICUgMl0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xuXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblsxXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIGNvZGUpO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuID0gZmFsc2UsIHRyeUhhcmRlcjogYm9vbGVhbiA9IGZhbHNlKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgQXJyYXk8bnVtYmVyPihwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaXNXaGl0ZSA9IGlzV2hpdGUgfHwgZmFsc2U7XG4gICAgICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIDQpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZEVuZCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyOiBBcnJheTxBcnJheTxudW1iZXI+Pik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xuICAgICAgICBjb25zdCBjb2RlczogQXJyYXk8QmFyY29kZUluZm8+ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKGNvdW50ZXI6IEFycmF5PG51bWJlcj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVJbmZvID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlclBhaXIgPSBbWzAsIDAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMCwgMF1dO1xuICAgICAgICBsZXQgY29kZXM6IEJhcmNvZGVJbmZvW10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMV1baV0gPSBjb3VudGVyc1twb3MgKyAxXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1sxXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzID0gdGhpcy5fZGVjb2RlUGFpcihjb3VudGVyUGFpcik7XG4gICAgICAgICAgICBpZiAoIWNvZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZXNbaV0uY29kZSArICcnKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4oKTtcblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHxcbiAgICAgICAgICAgICAgICByZXN1bHQubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbi8qKlxuICogUGhhcm1hY29kZSAoUGhhcm1hY2V1dGljYWwgQmluYXJ5IENvZGUpIFJlYWRlclxuICpcbiAqIFBoYXJtYWNvZGUgaXMgYSBiaW5hcnkgYmFyY29kZSB1c2VkIGluIHBoYXJtYWNldXRpY2FsIHBhY2thZ2luZy5cbiAqIEl0IGVuY29kZXMgbnVtYmVycyBmcm9tIDMgdG8gMTMxMDcwIHVzaW5nIG5hcnJvdyBhbmQgd2lkZSBiYXJzLlxuICpcbiAqIEVuY29kaW5nIHJ1bGVzOlxuICogLSBSZWFkaW5nIGZyb20gcmlnaHQgdG8gbGVmdCAobGVhc3Qgc2lnbmlmaWNhbnQgZmlyc3QpXG4gKiAtIE5hcnJvdyBiYXIgYXQgcG9zaXRpb24gaSBhZGRzIDJeaSB0byB0aGUgdmFsdWVcbiAqIC0gV2lkZSBiYXIgYXQgcG9zaXRpb24gaSBhZGRzIDJeKGkrMSkgdG8gdGhlIHZhbHVlXG4gKiAtIEJhcnMgYXJlIHNlcGFyYXRlZCBieSB1bmlmb3JtLXdpZHRoIHNwYWNlc1xuICogLSBNaW5pbXVtIDIgYmFycywgbWF4aW11bSAxNiBiYXJzXG4gKiAtIFZhbGlkIHJhbmdlOiAzIHRvIDEzMTA3MFxuICpcbiAqIEV4YW1wbGU6IFZhbHVlIDc1NVxuICogQmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIGJhcnMgKGZyb20gbGVmdCB0byByaWdodCBpbiBiYXJjb2RlKTpcbiAqIHdpZGUsIG5hcnJvdywgd2lkZSwgbmFycm93LCBuYXJyb3csIHdpZGUsIG5hcnJvdywgd2lkZSwgbmFycm93XG4gKlxuICogUmVmZXJlbmNlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaGFybWFjb2RlXG4gKi9cblxuLy8gTWluaW11bSBudW1iZXIgb2YgYmFycyBpbiBhIHZhbGlkIFBoYXJtYWNvZGVcbmNvbnN0IE1JTl9CQVJfQ09VTlQgPSAyO1xuLy8gTWF4aW11bSBudW1iZXIgb2YgYmFycyBpbiBhIHZhbGlkIFBoYXJtYWNvZGVcbmNvbnN0IE1BWF9CQVJfQ09VTlQgPSAxNjtcbi8vIE1pbmltdW0gdmFsaWQgUGhhcm1hY29kZSB2YWx1ZVxuY29uc3QgTUlOX1ZBTFVFID0gMztcbi8vIE1heGltdW0gdmFsaWQgUGhhcm1hY29kZSB2YWx1ZVxuY29uc3QgTUFYX1ZBTFVFID0gMTMxMDcwO1xuXG4vLyBUaHJlc2hvbGQgcmF0aW8gdG8gZGlzdGluZ3Vpc2ggbmFycm93IGZyb20gd2lkZSBiYXJzXG4vLyBBIGJhciB3aWRlciB0aGFuIHRoaXMgcmF0aW8gb2YgdGhlIG5hcnJvdyBiYXIgd2lkdGggaXMgY29uc2lkZXJlZCB3aWRlXG5jb25zdCBXSURFX0JBUl9USFJFU0hPTEQgPSAxLjY7XG5cbi8vIE1heGltdW0gYWxsb3dlZCB2YXJpYXRpb24gaW4gc3BhY2Ugd2lkdGhzIChjb2VmZmljaWVudCBvZiB2YXJpYXRpb24pXG4vLyBSZWR1Y2VkIGZyb20gMC40IHRvIGhlbHAgd2l0aCBmYWxzZSBwb3NpdGl2ZXMsIGJ1dCBhbGxvd2luZyBzb21lIHRvbGVyYW5jZVxuY29uc3QgTUFYX1NQQUNFX1ZBUklBTkNFID0gMC4zNTtcblxuLy8gTWluaW11bSBxdWlldCB6b25lIHJlcXVpcmVtZW50IGluIGJhcmNvZGUgd2lkdGhzIChwaGFybWFjZXV0aWNhbCBzcGVjOiA2bW0gbWluKVxuLy8gV2UgdXNlIDF4IG5hcnJvdyBiYXIgd2lkdGggYXMgYSBtaW5pbXVtIHF1aWV0IHpvbmVcbmNvbnN0IE1JTl9RVUlFVF9aT05FX1dJRFRIUyA9IDE7XG5cbi8vIEFsbG93ZWQgbmFycm93L3dpZGUgYmFyIHJhdGlvcyAoMToyLCAxOjIuNSwgMTozKVxuLy8gVGhlc2UgYXJlIG11bHRpcGxpZXJzIGFwcGxpZWQgdG8gbmFycm93IGJhciB3aWR0aFxuY29uc3QgQUxMT1dFRF9XSURFX0JBUl9SQVRJT1MgPSBbMi4wLCAyLjUsIDMuMF07XG5jb25zdCBXSURFX0JBUl9SQVRJT19UT0xFUkFOQ0UgPSAwLjA1OyAvLyBBbGxvdyA1JSBkZXZpYXRpb24gZnJvbSB0aGUgZGV0ZWN0ZWQgcmF0aW9cblxuY2xhc3MgUGhhcm1hY29kZVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdwaGFybWFjb2RlJztcblxuICAgIHN0YXRpYyBhZGphY2VudExpbmVWYWxpZGF0aW9uTWF0Y2hlcyA9IDE7XG5cbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNztcblxuICAgIEFWR19DT0RFX0VSUk9SID0gMC40ODtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgc3RhcnQgb2YgdGhlIGJhcmNvZGUgKGZpcnN0IGJsYWNrIGJhciBhZnRlciBsZWFkaW5nIHdoaXRlc3BhY2UpXG4gICAgICogUHVibGljIHNvIHRoYXQgYmFyY29kZV9kZWNvZGVyIGNhbiB1c2UgaXQgZm9yIHRpbHRlZCBiYXJjb2RlIHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gU3RyYXRlZ3k6IHNjYW4gbGVmdOKGknJpZ2h0OyBhY2NlcHQgdGhlIGZpcnN0IGJhciB0aGF0OlxuICAgICAgICAvLyAxLiBIYXMgYSBzdWZmaWNpZW50IGxlYWRpbmcgcXVpZXQgem9uZSAo4omlIDLDlyBiYXIgd2lkdGgsIG1pbiAyMHB4KVxuICAgICAgICAvLyAyLiBJcyBmb2xsb3dlZCBieSBhbm90aGVyIGJhciBhdCBhIHJlYXNvbmFibGUgZGlzdGFuY2UgKOKJpCAxMMOXIGJhciB3aWR0aClcbiAgICAgICAgLy8gICAgVGhpcyByZWplY3RzIGlzb2xhdGVkIG5vaXNlIGJhcnMgc3Vycm91bmRlZCBieSBsYXJnZSB3aGl0ZSBzcGFjZXMuXG5cbiAgICAgICAgY29uc3QgbWluUXVpZXRab25lID0gMjA7XG4gICAgICAgIGxldCBzZWFyY2hQb3MgPSAwO1xuXG4gICAgICAgIHdoaWxlIChzZWFyY2hQb3MgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBiYXJTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzZWFyY2hQb3MpO1xuICAgICAgICAgICAgaWYgKGJhclN0YXJ0ID49IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm8gbW9yZSBibGFjayBwaXhlbHNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZW5kIG9mIHRoaXMgYmxhY2sgcnVuXG4gICAgICAgICAgICBsZXQgYmFyRW5kID0gYmFyU3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoYmFyRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCAmJiB0aGlzLl9yb3dbYmFyRW5kXSkge1xuICAgICAgICAgICAgICAgIGJhckVuZCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBiYXJXaWR0aCA9IGJhckVuZCAtIGJhclN0YXJ0O1xuXG4gICAgICAgICAgICAvLyBTa2lwIG5hcnJvdyBub2lzZSBiYXJzXG4gICAgICAgICAgICBpZiAoYmFyV2lkdGggPCA1KSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoUG9zID0gYmFyRW5kICsgMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgbGVhZGluZyBxdWlldCB6b25lXG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZFF1aWV0Wm9uZSA9IE1hdGgubWF4KGJhcldpZHRoICogMiwgbWluUXVpZXRab25lKTtcbiAgICAgICAgICAgIGNvbnN0IHF1aWV0Wm9uZVN0YXJ0ID0gYmFyU3RhcnQgLSByZXF1aXJlZFF1aWV0Wm9uZTtcbiAgICAgICAgICAgIGlmIChxdWlldFpvbmVTdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQb3MgPSBiYXJFbmQgKyAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hdGNoUmFuZ2UocXVpZXRab25lU3RhcnQsIGJhclN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBvcyA9IGJhckVuZCArIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcndhcmQtbG9vazogQ2hlY2sgdGhhdCB0aGUgbmV4dCBiYXIgYXBwZWFycyB3aXRoaW4gYSByZWFzb25hYmxlIGRpc3RhbmNlLlxuICAgICAgICAgICAgLy8gQSByZWFsIGJhcmNvZGUgaGFzIGJhcnMgZm9sbG93ZWQgYnkgbmFycm93IHNwYWNlcyAoNS0xNXB4KSwgbm90IGh1Z2UgZ2Fwcy5cbiAgICAgICAgICAgIC8vIEFsbG93IHVwIHRvIDEww5cgYmFyIHdpZHRoIGZvciB0aGUgc3BhY2UgKGJlaW5nIGdlbmVyb3VzIGZvciB2ZXJ5IG5hcnJvdyBiYXJzKS5cbiAgICAgICAgICAgIGNvbnN0IG1heFNwYWNlVG9OZXh0QmFyID0gTWF0aC5tYXgoYmFyV2lkdGggKiAxMCwgNTApO1xuICAgICAgICAgICAgY29uc3QgbmV4dEJhclN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGJhckVuZCk7XG4gICAgICAgICAgICBpZiAobmV4dEJhclN0YXJ0ID49IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBuZXh0IGJhcjsgdGhpcyBpcyBhbiBpc29sYXRlZCBiYXIsIGxpa2VseSBub2lzZVxuICAgICAgICAgICAgICAgIHNlYXJjaFBvcyA9IGJhckVuZCArIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNwYWNlVG9OZXh0QmFyID0gbmV4dEJhclN0YXJ0IC0gYmFyRW5kO1xuICAgICAgICAgICAgaWYgKHNwYWNlVG9OZXh0QmFyID4gbWF4U3BhY2VUb05leHRCYXIpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGFjZSBpcyB0b28gbGFyZ2U7IHRoaXMgaXMgbGlrZWx5IGFuIGlzb2xhdGVkIGJhclxuICAgICAgICAgICAgICAgIHNlYXJjaFBvcyA9IGJhckVuZCArIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBiYXJTdGFydCwgZW5kOiBiYXJFbmQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNtb290aCBiYXIgd2lkdGhzIHRvIHJlZHVjZSBlZGdlLWRldGVjdGlvbiBqaXR0ZXIgZnJvbSBjb2xvcmVkIGJhcmNvZGVzLlxuICAgICAqIEFwcGxpZXMgbWVkaWFuIGZpbHRlciB0byBhZGphY2VudCBiYXJzOiBpZiBhIGJhciBpcyAx4oCTM3B4IGRpZmZlcmVudCBmcm9tIG5laWdoYm9ycyxcbiAgICAgKiBzbmFwIGl0IHRvIHRoZSBtZWRpYW4gb2YgbG9jYWwgYmFycyB0byBzdGFiaWxpemUgbWVhc3VyZW1lbnRzLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc21vb3RoQmFyV2lkdGhzKGJhcnM6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgICAgICBpZiAoYmFycy5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgcmV0dXJuIGJhcnM7IC8vIE5vdCBlbm91Z2ggYmFycyB0byBzbW9vdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNtb290aGVkID0gYmFycy5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNtb290aGVkLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IHNtb290aGVkW2kgLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBzbW9vdGhlZFtpXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzbW9vdGhlZFtpICsgMV07XG5cbiAgICAgICAgICAgIC8vIElmIGN1cnJlbnQgYmFyIGlzIHNpZ25pZmljYW50bHkgZGlmZmVyZW50IGZyb20gbmVpZ2hib3JzLCBzbmFwIHRvIG1lZGlhblxuICAgICAgICAgICAgY29uc3QgbWVkaWFuID0gW3ByZXYsIGN1cnIsIG5leHRdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGRldmlhdGlvbiA9IE1hdGguYWJzKGN1cnIgLSBtZWRpYW4pO1xuXG4gICAgICAgICAgICAvLyBJZiBkZXZpYXRpb24gaXMgc21hbGwgKDHigJMzcHgpLCBzbmFwIHRvIG1lZGlhbiB0byByZWR1Y2Ugbm9pc2VcbiAgICAgICAgICAgIGlmIChkZXZpYXRpb24gPiAwICYmIGRldmlhdGlvbiA8PSAzKSB7XG4gICAgICAgICAgICAgICAgc21vb3RoZWRbaV0gPSBtZWRpYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNtb290aGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYWxsIGJhciBhbmQgc3BhY2Ugd2lkdGhzIGZyb20gdGhlIHBhdHRlcm4uXG4gICAgICogVXNlcyByZWFsLXRpbWUgcXVpZXQgem9uZSBkZXRlY3Rpb24gdG8gc3RvcCBleHRyYWN0aW9uIGJlZm9yZSByZWFjaGluZyBpbWFnZSBlZGdlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZXh0cmFjdEJhcnNBbmRTcGFjZXMoc3RhcnRQb3M6IG51bWJlcik6IHsgYmFyczogbnVtYmVyW10sIHNwYWNlczogbnVtYmVyW10sIGVuZDogbnVtYmVyIH0gfCBudWxsIHtcbiAgICAgICAgY29uc3QgYmFyczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgY29uc3Qgc3BhY2VzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAgIGxldCBwb3MgPSBzdGFydFBvcztcbiAgICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgICAgIGxldCBmb3VuZFRyYWlsaW5nUXVpZXRab25lID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBmaXJzdCBiYXJcbiAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMuX3Jvdy5sZW5ndGggJiYgdGhpcy5fcm93W3Bvc10pIHtcbiAgICAgICAgICAgIGN1cnJlbnRXaWR0aCsrO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmFycy5wdXNoKGN1cnJlbnRXaWR0aCk7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBmaXJzdCBzcGFjZSAobmVlZGVkIHRvIGVzdGFibGlzaCBzcGFjZSB3aWR0aCBhbmQgZXN0aW1hdGUgbmFycm93IGJhcilcbiAgICAgICAgY3VycmVudFdpZHRoID0gMDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMuX3Jvdy5sZW5ndGggJiYgIXRoaXMuX3Jvd1twb3NdKSB7XG4gICAgICAgICAgICBjdXJyZW50V2lkdGgrKztcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50V2lkdGggPT09IDAgfHwgcG9zID49IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBObyBzcGFjZSBhZnRlciBmaXJzdCBiYXIsIG9yIGhpdCBlZGdlXG4gICAgICAgIH1cbiAgICAgICAgc3BhY2VzLnB1c2goY3VycmVudFdpZHRoKTtcblxuICAgICAgICAvLyBFc3RpbWF0ZSBuYXJyb3cgYmFyIHdpZHRoIGZvciBxdWlldCB6b25lIGRldGVjdGlvblxuICAgICAgICAvLyBJZiBmaXJzdCBiYXIgPCBmaXJzdCBzcGFjZSwgYXNzdW1lIGZpcnN0IGJhciBpcyBuYXJyb3dcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBlc3RpbWF0ZSBuYXJyb3cgZnJvbSBzcGFjZSAoc3BhY2Ug4omIIDEuMjUgKiBuYXJyb3cpXG4gICAgICAgIGNvbnN0IGVzdGltYXRlZE5hcnJvd1dpZHRoID0gYmFyc1swXSA8IHNwYWNlc1swXSA/IGJhcnNbMF0gOiBzcGFjZXNbMF0gKiAwLjg7XG5cbiAgICAgICAgLy8gUGhhcm1hY2V1dGljYWwgc3BlYzogcXVpZXQgem9uZSBtdXN0IGJlID49IDZtbSDiiYggNnggbmFycm93IGJhciAoc3RyaWN0KVxuICAgICAgICBjb25zdCBzdHJpY3RRdWlldFpvbmUgPSBlc3RpbWF0ZWROYXJyb3dXaWR0aCAqIDY7XG4gICAgICAgIC8vIEFkYXB0aXZlIHF1aWV0IHpvbmU6IDIuNXggdGhlIHR5cGljYWwgaW50ZXItYmFyIHNwYWNlIHdpZHRoXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGNhdGNoIGxlZ2l0aW1hdGUgcXVpZXQgem9uZXMgd2hpbGUgYXZvaWRpbmcgZmFsc2UgcG9zaXRpdmVzXG4gICAgICAgIGxldCBhZGFwdGl2ZVF1aWV0Wm9uZSA9IHNwYWNlc1swXSAqIDIuNTtcblxuICAgICAgICAvLyBDb250aW51ZSBleHRyYWN0aW5nIGFsdGVybmF0aW5nIGJhcnMgYW5kIHNwYWNlc1xuICAgICAgICAvLyBTdG9wIEJFRk9SRSByZWFjaGluZyBNQVhfQkFSX0NPVU5UKzEgdG8gYXZvaWQgZXh0cmFjdGluZyB0b28gbWFueSBiYXJzXG4gICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLl9yb3cubGVuZ3RoICYmIGJhcnMubGVuZ3RoIDwgTUFYX0JBUl9DT1VOVCkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBiYXJcbiAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5fcm93Lmxlbmd0aCAmJiB0aGlzLl9yb3dbcG9zXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCsrO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlYWNoZWQgZW5kIG9mIGJhcmNvZGUgKG5vIG1vcmUgYmFycylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhcnMucHVzaChjdXJyZW50V2lkdGgpO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHNwYWNlXG4gICAgICAgICAgICBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VTdGFydCA9IHBvcztcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLl9yb3cubGVuZ3RoICYmICF0aGlzLl9yb3dbcG9zXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCsrO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gc3BhY2UgYWZ0ZXIgdGhpcyBiYXIgLSBiYXJjb2RlIGVuZGVkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgc3BhY2UgaXMgYSBxdWlldCB6b25lIChzdHJpY3QgcGhhcm1hY2V1dGljYWwgc3BlYylcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggPj0gc3RyaWN0UXVpZXRab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgc3RyaWN0IHRyYWlsaW5nIHF1aWV0IHpvbmUgLSBzdG9wIGV4dHJhY3Rpb24gaGVyZVxuICAgICAgICAgICAgICAgIGZvdW5kVHJhaWxpbmdRdWlldFpvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNwYWNlU3RhcnQ7IC8vIFJlc2V0IHBvcyB0byBzdGFydCBvZiBxdWlldCB6b25lXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkYXB0aXZlIHF1aWV0IHpvbmU6IGlmIHRoaXMgc3BhY2UgaXMgc2lnbmlmaWNhbnRseSBsYXJnZXIgdGhhbiBub3JtYWwgaW50ZXItYmFyIHNwYWNlc1xuICAgICAgICAgICAgLy8gKDJ4IG9yIG1vcmUpLCB0cmVhdCBpdCBhcyBhIHF1aWV0IHpvbmVcbiAgICAgICAgICAgIGlmIChiYXJzLmxlbmd0aCA+PSBNSU5fQkFSX0NPVU5UICYmIGN1cnJlbnRXaWR0aCA+PSBhZGFwdGl2ZVF1aWV0Wm9uZSkge1xuICAgICAgICAgICAgICAgIGZvdW5kVHJhaWxpbmdRdWlldFpvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhpdCB0aGUgaW1hZ2UgZWRnZSB3aGlsZSBjb3VudGluZyB0aGlzIHNwYWNlXG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBIaXQgaW1hZ2UgZWRnZSB3aGlsZSBpbiB3aGl0ZXNwYWNlIC0gdHJlYXQgYXMgaW5maW5pdGUgcXVpZXQgem9uZVxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW1hZ2UsIHdoaWNoIGNvdW50cyBhcyBhbiBpbXBsaWNpdCBxdWlldCB6b25lXG4gICAgICAgICAgICAgICAgZm91bmRUcmFpbGluZ1F1aWV0Wm9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcG9zID0gc3BhY2VTdGFydDsgLy8gUmVzZXQgdG8gc3RhcnQgb2YgcXVpZXQgem9uZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbm9ybWFsIGludGVyLWJhciBzcGFjZVxuICAgICAgICAgICAgc3BhY2VzLnB1c2goY3VycmVudFdpZHRoKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFkYXB0aXZlIHF1aWV0IHpvbmUgYmFzZWQgb24gYXZlcmFnZSBzcGFjZSB3aWR0aFxuICAgICAgICAgICAgLy8gQSBxdWlldCB6b25lIHNob3VsZCBiZSBhdCBsZWFzdCAyeCB0aGUgYXZlcmFnZSBpbnRlci1iYXIgc3BhY2VcbiAgICAgICAgICAgIGlmIChzcGFjZXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmdTcGFjZSA9IHNwYWNlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYWRhcHRpdmVRdWlldFpvbmUgPSBhdmdTcGFjZSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBleGl0ZWQgdGhlIGxvb3Agd2l0aG91dCBmaW5kaW5nIGEgdHJhaWxpbmcgcXVpZXQgem9uZSwgYmFyY29kZSBpcyBpbnZhbGlkXG4gICAgICAgIC8vIChUaGlzIGNhdGNoZXMgYmFyY29kZXMgdGhhdCBlbmQgZXhhY3RseSBhdCB0aGUgaW1hZ2UgZWRnZSlcbiAgICAgICAgaWYgKCFmb3VuZFRyYWlsaW5nUXVpZXRab25lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGJhciBjb3VudFxuICAgICAgICBpZiAoYmFycy5sZW5ndGggPCBNSU5fQkFSX0NPVU5UIHx8IGJhcnMubGVuZ3RoID4gTUFYX0JBUl9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBzaG91bGQgaGF2ZSAobi0xKSBzcGFjZXMgZm9yIG4gYmFyc1xuICAgICAgICBpZiAoc3BhY2VzLmxlbmd0aCAhPT0gYmFycy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgc3BhY2VzIGFyZSB1bmlmb3JtIChwaGFybWFjb2RlIHJlcXVpcmVtZW50KVxuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlU3BhY2VzKHNwYWNlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCBiYXJzIGhhdmUgYXQgbW9zdCAyIGRpc3RpbmN0IHNpemVzIChuYXJyb3cgYW5kL29yIHdpZGUpXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVCYXJTaXplQ291bnQoYmFycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgc21vb3RoaW5nIHRvIHJlZHVjZSBlZGdlLWRldGVjdGlvbiBqaXR0ZXIgb24gY29sb3JlZCBiYXJjb2Rlc1xuICAgICAgICBjb25zdCBzbW9vdGhlZEJhcnMgPSB0aGlzLl9zbW9vdGhCYXJXaWR0aHMoYmFycyk7XG5cbiAgICAgICAgcmV0dXJuIHsgYmFyczogc21vb3RoZWRCYXJzLCBzcGFjZXMsIGVuZDogcG9zIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhhdCBiYXJzIGhhdmUgYXQgbW9zdCAyIGRpc3RpbmN0IHNpemVzIChuYXJyb3cgYW5kL29yIHdpZGUpLlxuICAgICAqIFBoYXJtYWNvZGUgYmFycyBtdXN0IGJlIGVpdGhlciBhbGwgb25lIHNpemUsIG9yIHR3byBzaXplcyAobmFycm93ICsgd2lkZSkuXG4gICAgICogSWYgMysgZGlzdGluY3Qgc2l6ZXMgZGV0ZWN0ZWQsIHRoaXMgaXMgbm90IGEgdmFsaWQgcGhhcm1hY29kZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3ZhbGlkYXRlQmFyU2l6ZUNvdW50KGJhcnM6IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChiYXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2x1c3RlciBiYXJzIGludG8gc2l6ZSBncm91cHMgd2l0aCAzNSUgdG9sZXJhbmNlIHRvIGhhbmRsZSBlZGdlLWRldGVjdGlvbiBqaXR0ZXJcbiAgICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSB0b2xlcmFuY2UgdXNlZCBmb3Igc3BhY2UgdmFsaWRhdGlvbiAoQ1YgPD0gMC4zNSlcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gMC4zNTtcbiAgICAgICAgY29uc3QgY2x1c3RlcnM6IG51bWJlcltdW10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGJhciBvZiBiYXJzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRDbHVzdGVyID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsdXN0ZXIgb2YgY2x1c3RlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbHVzdGVyQXZnID0gY2x1c3Rlci5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGNsdXN0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhiYXIgLSBjbHVzdGVyQXZnKSA8PSBjbHVzdGVyQXZnICogdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIucHVzaChiYXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENsdXN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kQ2x1c3Rlcikge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goW2Jhcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTXVzdCBoYXZlIGV4YWN0bHkgMSBvciAyIGNsdXN0ZXJzIChub3QgMyspXG4gICAgICAgIGlmIChjbHVzdGVycy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBzcGFjZSB3aWR0aHMgYXJlIHVuaWZvcm0gZW5vdWdoIGZvciBhIHZhbGlkIFBoYXJtYWNvZGVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3ZhbGlkYXRlU3BhY2VzKHNwYWNlczogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHNwYWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBTaW5nbGUgYmFyICh0aG91Z2ggaW52YWxpZCBmb3IgUGhhcm1hY29kZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lYW4gPSBzcGFjZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBzcGFjZXMubGVuZ3RoO1xuICAgICAgICBpZiAobWVhbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNvZWZmaWNpZW50IG9mIHZhcmlhdGlvblxuICAgICAgICBjb25zdCB2YXJpYW5jZSA9IHNwYWNlcy5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgTWF0aC5wb3cocyAtIG1lYW4sIDIpLCAwKSAvIHNwYWNlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN0ZERldiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG4gICAgICAgIGNvbnN0IGN2ID0gc3RkRGV2IC8gbWVhbjtcblxuICAgICAgICByZXR1cm4gY3YgPD0gTUFYX1NQQUNFX1ZBUklBTkNFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoYXQgbmFycm93IGFuZCB3aWRlIGJhcnMgZm9sbG93IGEgY29uc2lzdGVudCByYXRpbyAoMToyLCAxOjIuNSwgb3IgMTozKVxuICAgICAqIFRoaXMgaXMgYSBzcGVjIHJlcXVpcmVtZW50IGZvciBwaGFybWFjb2Rlc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBfdmFsaWRhdGVCYXJSYXRpb3MoYmFyczogbnVtYmVyW10sIHNwYWNlczogbnVtYmVyW10pOiB7IG5hcnJvd1dpZHRoOiBudW1iZXIsIHdpZGVSYXRpbzogbnVtYmVyIH0gfCBudWxsIHtcbiAgICAgICAgLy8gSWYgYWxsIGJhcnMgYXJlIGVzc2VudGlhbGx5IHRoZSBzYW1lIHdpZHRoIChsb3cgdmFyaWFuY2UpLCBuZWVkIHRvIGRldGVybWluZSBpZiBuYXJyb3cgb3Igd2lkZVxuICAgICAgICBjb25zdCBhdmdBbGwgPSBiYXJzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gYmFycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHZhckFsbCA9IGJhcnMucmVkdWNlKChhLCBiKSA9PiBhICsgTWF0aC5hYnMoYiAtIGF2Z0FsbCksIDApIC8gYmFycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGN2QWxsID0gYXZnQWxsID09PSAwID8gMCA6IHZhckFsbCAvIGF2Z0FsbDtcblxuICAgICAgICBpZiAoY3ZBbGwgPD0gMC4xKSB7XG4gICAgICAgICAgICAvLyBMb3cgdmFyaWFuY2U6IGNvdWxkIGJlIGFsbC1uYXJyb3cgb3IgYWxsLXdpZGVcbiAgICAgICAgICAgIC8vIFVzZSBzcGFjZSB3aWR0aHMgYXMgYSBoaW50OiBzcGFjZXMgc2hvdWxkIGJlIH4xLjI1eCB0aGUgbmFycm93IGJhciB3aWR0aFxuICAgICAgICAgICAgY29uc3QgYXZnU3BhY2UgPSBzcGFjZXMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgKHNwYWNlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNwYWNlcy5sZW5ndGgpIDpcbiAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICBpZiAoYXZnU3BhY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VUb0JhclJhdGlvID0gYXZnU3BhY2UgLyBhdmdBbGw7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3BhY2VzIGFyZSBtdWNoIHNtYWxsZXIgdGhhbiBiYXJzLCBiYXJzIGFyZSBsaWtlbHkgd2lkZSAocmF0aW8gc2hvdWxkIGJlIH4wLjMtMC41KVxuICAgICAgICAgICAgICAgIC8vIElmIHNwYWNlcyBhcmUgY29tcGFyYWJsZSB0byBiYXJzIG9yIGxhcmdlciwgYmFycyBhcmUgbGlrZWx5IG5hcnJvdyAocmF0aW8gc2hvdWxkIGJlIH4xLjAtMS41KVxuICAgICAgICAgICAgICAgIGlmIChzcGFjZVRvQmFyUmF0aW8gPCAwLjcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFycyBhcmUgbGlrZWx5IHdpZGU7IGluZmVyIG5hcnJvdyB3aWR0aCBmcm9tIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBjbG9zZXN0IGFsbG93ZWQgcmF0aW9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mZXJyZWROYXJyb3cgPSBhdmdBbGwgLyAyLjU7IC8vIFRyeSBtaWRkbGUgcmF0aW8gZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFycm93V2lkdGg6IGluZmVycmVkTmFycm93LCB3aWRlUmF0aW86IDIuNSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVmYXVsdDogdHJlYXQgYXMgYWxsLW5hcnJvd1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFycm93V2lkdGg6IGF2Z0FsbCwgd2lkZVJhdGlvOiAyLjAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHBsb3JlIG11bHRpcGxlIHBvc3NpYmxlIHRocmVzaG9sZHMgKG1pZHBvaW50cyBiZXR3ZWVuIHNvcnRlZCB1bmlxdWUgd2lkdGhzKVxuICAgICAgICAvLyBhbmQgcGljayB0aGUgb25lIHRoYXQgYmVzdCBtYXRjaGVzIGFuIGFsbG93ZWQgcmF0aW8gd2l0aCBsb3cgcGVyLWJhciBkZXZpYXRpb24uXG4gICAgICAgIGNvbnN0IHNvcnRlZFVuaXF1ZSA9IEFycmF5LmZyb20obmV3IFNldChiYXJzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYSAtIGIpKSk7XG4gICAgICAgIGlmIChzb3J0ZWRVbmlxdWUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgLy8gQWxsIGJhcnMgaWRlbnRpY2FsOiB0cmVhdCBhcyBzaW5nbGUtd2lkdGggKHZhbGlkIHBoYXJtYWNvZGUgb2YgYWxsIG5hcnJvdyBvciBhbGwgd2lkZSlcbiAgICAgICAgICAgIGNvbnN0IGF2Z1dpZHRoID0gYmFycy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGJhcnMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFycm93V2lkdGg6IGF2Z1dpZHRoLCB3aWRlUmF0aW86IDIuMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSBDYW5kaWRhdGUgPSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQ6IG51bWJlcjtcbiAgICAgICAgICAgIG5hcnJvd0JhcnM6IG51bWJlcltdO1xuICAgICAgICAgICAgd2lkZUJhcnM6IG51bWJlcltdO1xuICAgICAgICAgICAgYXZnTjogbnVtYmVyO1xuICAgICAgICAgICAgYXZnVzogbnVtYmVyO1xuICAgICAgICAgICAgcmF0aW86IG51bWJlcjtcbiAgICAgICAgICAgIHJhdGlvRGlmZjogbnVtYmVyO1xuICAgICAgICAgICAgbWF0Y2hlZFJhdGlvOiBudW1iZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlczogQ2FuZGlkYXRlW10gPSBbXTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBjYW5kaWRhdGUgdGhyZXNob2xkcyBhdCBtaWRwb2ludHMgYmV0d2VlbiBjb25zZWN1dGl2ZSB1bmlxdWUgd2lkdGhzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkVW5pcXVlLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IChzb3J0ZWRVbmlxdWVbaV0gKyBzb3J0ZWRVbmlxdWVbaSArIDFdKSAvIDI7XG4gICAgICAgICAgICBjb25zdCBuOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdzogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiBiYXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGIgPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIG4ucHVzaChiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3LnB1c2goYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobi5sZW5ndGggPT09IDAgfHwgdy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gbmVlZCBib3RoIGdyb3Vwc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhdmdOID0gbi5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIG4ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYXZnVyA9IHcucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyB3Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gYXZnVyAvIGF2Z047XG5cbiAgICAgICAgICAgIC8vIEZpbmQgY2xvc2VzdCBhbGxvd2VkIHJhdGlvXG4gICAgICAgICAgICBsZXQgYmVzdFJhdGlvID0gQUxMT1dFRF9XSURFX0JBUl9SQVRJT1NbMF07XG4gICAgICAgICAgICBsZXQgYmVzdERpZmYgPSBNYXRoLmFicyhyYXRpbyAtIGJlc3RSYXRpbyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgQUxMT1dFRF9XSURFX0JBUl9SQVRJT1MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gTWF0aC5hYnMocmF0aW8gLSByKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA8IGJlc3REaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3REaWZmID0gZDtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFJhdGlvID0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiB0LFxuICAgICAgICAgICAgICAgIG5hcnJvd0JhcnM6IG4sXG4gICAgICAgICAgICAgICAgd2lkZUJhcnM6IHcsXG4gICAgICAgICAgICAgICAgYXZnTixcbiAgICAgICAgICAgICAgICBhdmdXLFxuICAgICAgICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgICAgICAgIHJhdGlvRGlmZjogYmVzdERpZmYsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFJhdGlvOiBiZXN0UmF0aW8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgY2FuZGlkYXRlcyBieSBob3cgY2xvc2UgdGhlIHJhdGlvIGlzIHRvIGFsbG93ZWQgcmF0aW9zXG4gICAgICAgIGNhbmRpZGF0ZXMuc29ydCgoYSwgYikgPT4gYS5yYXRpb0RpZmYgLSBiLnJhdGlvRGlmZik7XG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHJhdGlvIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGMubWF0Y2hlZFJhdGlvICogV0lERV9CQVJfUkFUSU9fVE9MRVJBTkNFO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGMucmF0aW8gLSBjLm1hdGNoZWRSYXRpbykgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGVyLWJhciBjb25zaXN0ZW5jeSBjaGVja3NcbiAgICAgICAgICAgIC8vIFVzZSAxNSUgdG9sZXJhbmNlIGluc3RlYWQgb2YgMzAlIHRvIHJlamVjdCBiYXJzIHdpdGggdG9vIG11Y2ggd2lkdGggdmFyaWF0aW9uXG4gICAgICAgICAgICAvLyBSZWFsIHBoYXJtYWNvZGVzIGhhdmUgY29uc2lzdGVudCBiYXIgd2lkdGhzOyB0aWx0ZWQvY3VydmVkIG9uZXMgc2hvdyB2YXJpYXRpb25cbiAgICAgICAgICAgIGNvbnN0IG5hcnJvd1RvbGVyYW5jZSA9IGMuYXZnTiAqIDAuMTU7XG4gICAgICAgICAgICBjb25zdCB3aWRlVG9sZXJhbmNlID0gYy5hdmdXICogMC4xNTtcbiAgICAgICAgICAgIGxldCBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgYy5uYXJyb3dCYXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGIgLSBjLmF2Z04pID4gbmFycm93VG9sZXJhbmNlKSB7IG9rID0gZmFsc2U7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9rKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiBjLndpZGVCYXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGIgLSBjLmF2Z1cpID4gd2lkZVRvbGVyYW5jZSkgeyBvayA9IGZhbHNlOyBicmVhazsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvaykgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIEFjY2VwdCBmaXJzdCB2aWFibGUgY2FuZGlkYXRlIChjbG9zZXN0IHJhdGlvKVxuICAgICAgICAgICAgcmV0dXJuIHsgbmFycm93V2lkdGg6IGMuYXZnTiwgd2lkZVJhdGlvOiBjLm1hdGNoZWRSYXRpbyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgcGVyaW9kaWNpdHkgb2YgYmFyIGFuZCBzcGFjZSB3aWR0aHNcbiAgICAgKiBSZWFsIHBoYXJtYWNvZGVzIGhhdmUgY29uc2lzdGVudCBiYXIvc3BhY2Ugd2lkdGhzIHdpdGggbG93IHZhcmlhdGlvblxuICAgICAqIFRpbHRlZCBiYXJjb2RlcyBjcmVhdGUgdmFyeWluZyB3aWR0aHMgZHVlIHRvIGFuZ2xlLWRlcGVuZGVudCBjcm9zcy1zZWN0aW9uc1xuICAgICAqIFVzZXMgY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uIChDViA9IHN0ZERldiAvIG1lYW4pIHRvIGRldGVjdCB0aGlzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92YWxpZGF0ZVBlcmlvZGljaXR5KGJhcnM6IG51bWJlcltdLCBzcGFjZXM6IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBjb2VmZmljaWVudCBvZiB2YXJpYXRpb24gZm9yIGJhcnNcbiAgICAgICAgaWYgKGJhcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYmFyTWVhbiA9IGJhcnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBiYXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJhclZhcmlhbmNlID0gYmFycy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBNYXRoLnBvdyhiIC0gYmFyTWVhbiwgMiksIDApIC8gYmFycy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiYXJTdGREZXYgPSBNYXRoLnNxcnQoYmFyVmFyaWFuY2UpO1xuICAgICAgICAgICAgY29uc3QgYmFyQ1YgPSBiYXJNZWFuICE9PSAwID8gYmFyU3RkRGV2IC8gYmFyTWVhbiA6IDA7XG5cbiAgICAgICAgICAgIC8vIFJlamVjdCBpZiBiYXIgQ1YgaXMgdG9vIGhpZ2ggKGluZGljYXRlcyB0aWx0ZWQvY3VydmVkIGJhcmNvZGUgd2l0aCB2YXJ5aW5nIGNyb3NzLXNlY3Rpb25zKVxuICAgICAgICAgICAgLy8gVGhyZXNob2xkIG9mIDAuNjUgYWxsb3dzIGZvciByZWFzb25hYmxlIHZhcmlhdGlvbiBpbiB2YWxpZCBjb2RlcyB3aGlsZSBzdGlsbCBjYXRjaGluZyBzZXZlcmUgbWlzYWxpZ25tZW50c1xuICAgICAgICAgICAgaWYgKGJhckNWID4gMC42NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBjb2VmZmljaWVudCBvZiB2YXJpYXRpb24gZm9yIHNwYWNlc1xuICAgICAgICBpZiAoc3BhY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlTWVhbiA9IHNwYWNlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBzcGFjZVZhcmlhbmNlID0gc3BhY2VzLnJlZHVjZSgoYSwgYikgPT4gYSArIE1hdGgucG93KGIgLSBzcGFjZU1lYW4sIDIpLCAwKSAvIHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBzcGFjZVN0ZERldiA9IE1hdGguc3FydChzcGFjZVZhcmlhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlQ1YgPSBzcGFjZU1lYW4gIT09IDAgPyBzcGFjZVN0ZERldiAvIHNwYWNlTWVhbiA6IDA7XG5cbiAgICAgICAgICAgIC8vIFJlamVjdCBpZiBzcGFjZSBDViBpcyB0b28gaGlnaFxuICAgICAgICAgICAgaWYgKHNwYWNlQ1YgPiAwLjU1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoYXQgdGhlcmUgaXMgc3VmZmljaWVudCBxdWlldCB6b25lIGF0IHN0YXJ0IGFuZCBlbmRcbiAgICAgKiBXaGVuIGFyZWEgY29uc3RyYWludHMgYXJlIHVzZWQsIHRoZSBxdWlldCB6b25lIG1heSBiZSB0cnVuY2F0ZWQsXG4gICAgICogc28gd2UgY2hlY2sgaWYgd2UgaGF2ZSBhdCBsZWFzdCBTT01FIHF1aWV0IHpvbmUgb3IgaGl0IHRoZSBzY2FuIGJvdW5kYXJ5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92YWxpZGF0ZVF1aWV0Wm9uZXMoc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24sIG5hcnJvd1dpZHRoOiBudW1iZXIsIGVuZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG1pblF1aWV0Wm9uZSA9IG5hcnJvd1dpZHRoICogTUlOX1FVSUVUX1pPTkVfV0lEVEhTO1xuXG4gICAgICAgIC8vIENoZWNrIGxlYWRpbmcgcXVpZXQgem9uZVxuICAgICAgICAvLyBJZiB3ZSdyZSB2ZXJ5IGNsb3NlIHRvIHRoZSBzdGFydCAod2l0aGluIDIgcGl4ZWxzKSwgd2UgbGlrZWx5IGhpdCB0aGUgYXJlYSBib3VuZGFyeVxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIGFjY2VwdCBpdCBhcyB3ZSBjYW4ndCB2ZXJpZnkgdGhlIHF1aWV0IHpvbmVcbiAgICAgICAgaWYgKHN0YXJ0SW5mby5zdGFydCA+PSAyICYmIHN0YXJ0SW5mby5zdGFydCA8IG1pblF1aWV0Wm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdHJhaWxpbmcgcXVpZXQgem9uZVxuICAgICAgICAvLyBJZiB3ZSdyZSBhdCBvciB2ZXJ5IGNsb3NlIHRvIHRoZSBlbmQgb2YgdGhlIHJvdywgd2UgbGlrZWx5IGhpdCB0aGUgYXJlYSBib3VuZGFyeVxuICAgICAgICAvLyBJbiByZWFsIGV4dHJhY3RlZCBpbWFnZXMsIGVzcGVjaWFsbHkgd2l0aCByZXNpemluZywgd2UgbWF5IG5vdCBoYXZlIHBlcmZlY3QgcXVpZXQgem9uZXNcbiAgICAgICAgLy8gU28gd2UgYWNjZXB0IGl0IGlmIHdlJ3JlIHdpdGhpbiA2IHBpeGVscyBvZiB0aGUgZW5kIChzY2FuIGJvdW5kYXJ5KVxuICAgICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmQ7XG5cbiAgICAgICAgLy8gSWYgd2UncmUgdmVyeSBjbG9zZSB0byB0aGUgZWRnZSAoPCA2cHgpLCB3ZSBoaXQgdGhlIHNjYW4gYm91bmRhcnkgLSBhY2NlcHQgaXRcbiAgICAgICAgaWYgKHJlbWFpbmluZ1NwYWNlIDwgNikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBoYXZlIGF0IGxlYXN0IDZweCBvZiB0cmFpbGluZyBzcGFjZSAtIGNoZWNrIGlmIGl0IG1lZXRzIG1pbmltdW0gcXVpZXQgem9uZSByZXF1aXJlbWVudFxuICAgICAgICBpZiAocmVtYWluaW5nU3BhY2UgPCBtaW5RdWlldFpvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYXNzaWZ5IGJhcnMgYXMgbmFycm93IG9yIHdpZGUgYW5kIGRlY29kZSB0aGUgdmFsdWVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUJhcnMoYmFyczogbnVtYmVyW10sIG5hcnJvd1dpZHRoPzogbnVtYmVyKTogeyB2YWx1ZTogbnVtYmVyLCBwYXR0ZXJuOiBzdHJpbmcgfSB8IG51bGwge1xuICAgICAgICAvLyBVc2UgcHJvdmlkZWQgbmFycm93V2lkdGggaWYgYXZhaWxhYmxlIChmcm9tIF92YWxpZGF0ZUJhclJhdGlvcyBpbmZlcmVuY2UpXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZmluZCB0aGUgbWluaW11bSBiYXIgd2lkdGggKGxpa2VseSBuYXJyb3cgYmFyKVxuICAgICAgICBjb25zdCBtaW5XaWR0aCA9IG5hcnJvd1dpZHRoID8/IE1hdGgubWluKC4uLmJhcnMpO1xuXG4gICAgICAgIC8vIElmIGFsbCBiYXJzIGFyZSBzaW1pbGFyIHdpZHRoLCBpdCBtaWdodCBiZSBhIHZhbGlkIFBoYXJtYWNvZGUgd2l0aCBhbGwgbmFycm93IG9yIGFsbCB3aWRlIGJhcnNcbiAgICAgICAgLy8gQnV0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gbWluV2lkdGggKiBXSURFX0JBUl9USFJFU0hPTEQ7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBQaGFybWFjb2RlIHZhbHVlIHVzaW5nIHRoZSBjb3JyZWN0IGFsZ29yaXRobVxuICAgICAgICAvLyBQb3NpdGlvbiBuIHN0YXJ0cyBhdCAwIG9uIHRoZSBSSUdIVCAobGFzdCBiYXIgaW4gYXJyYXkpXG4gICAgICAgIC8vIE5hcnJvdyBiYXIgYXQgcG9zaXRpb24gbiBhZGRzIDJeblxuICAgICAgICAvLyBXaWRlIGJhciBhdCBwb3NpdGlvbiBuIGFkZHMgMl4obisxKVxuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuXG4gICAgICAgIC8vIFJldmVyc2UgYmFycyB0byBwcm9jZXNzIHJpZ2h0LXRvLWxlZnRcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRCYXJzID0gYmFycy5zbGljZSgpLnJldmVyc2UoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldmVyc2VkQmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXNXaWRlID0gcmV2ZXJzZWRCYXJzW2ldID4gdGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKGlzV2lkZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IE1hdGgucG93KDIsIGkgKyAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gTWF0aC5wb3coMiwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBodW1hbi1yZWFkYWJsZSBiYXIgcGF0dGVybiBmb3IgZGVidWdnaW5nXG4gICAgICAgIGxldCBwYXR0ZXJuID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSByZXZlcnNlZEJhcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gcmV2ZXJzZWRCYXJzW2ldID4gdGhyZXNob2xkID8gJ1cnIDogJ04nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHBhdHRlcm4gfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdHJhaWxpbmcgd2hpdGVzcGFjZSAocXVpZXQgem9uZSlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmQ6IG51bWJlciwgYmFyV2lkdGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBNYXRoLm1pbihlbmQgKyBiYXJXaWR0aCAqIDIsIHRoaXMuX3Jvdy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hSYW5nZShlbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgcGF0dGVybiBjb25zaXN0ZW5jeTogZXh0cmFjdCBiYXJzIGZyb20gc2xpZ2h0bHkgc2hpZnRlZCBwb3NpdGlvbnMuXG4gICAgICogUmVhbCBiYXJjb2RlcyBzaG91bGQgcHJvZHVjZSBjb25zaXN0ZW50IGJhciBwYXR0ZXJucyBldmVuIHdpdGggc21hbGwgc2hpZnRzLlxuICAgICAqIFRleHQgcGF0dGVybnMgYXJlIHR5cGljYWxseSBlZGdlLWJhc2VkIGFuZCB3aWxsIGJyZWFrIHdpdGggYSBzbWFsbCBzaGlmdC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3ZhbGlkYXRlUGF0dGVybkNvbnNpc3RlbmN5KHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLCBiYXJzOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0O1xuICAgICAgICBsZXQgY29uc2lzdGVudE9mZnNldHMgPSAwO1xuICAgICAgICBsZXQgdG90YWxDaGVja3MgPSAwO1xuXG4gICAgICAgIC8vIENoZWNrIHBvc2l0aW9ucyBvZmZzZXQgYnkgwrExIGFuZCDCsTIgcGl4ZWxzIChzaW11bGF0ZSBzY2FubmluZyBsaW5lcyBuZWFyYnkpXG4gICAgICAgIGZvciAoY29uc3Qgb2Zmc2V0IG9mIFstMiwgLTEsIDEsIDJdKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdGVkU3RhcnQgPSBvcmlnaW5hbFN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNoaWZ0ZWRTdGFydCA8IDAgfHwgc2hpZnRlZFN0YXJ0ID49IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG90YWxDaGVja3MrKztcblxuICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgYmFycyBmcm9tIHNoaWZ0ZWQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ZWRFeHRyYWN0ZWQgPSB0aGlzLl9leHRyYWN0QmFyc0FuZFNwYWNlcyhzaGlmdGVkU3RhcnQpO1xuICAgICAgICAgICAgaWYgKCFzaGlmdGVkRXh0cmFjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGdvdCBiYXJzIGFuZCB0aGV5IG1hdGNoIGluIGNvdW50LCBpdCdzIG1vcmUgbGlrZWx5IGEgcmVhbCBiYXJjb2RlXG4gICAgICAgICAgICBpZiAoc2hpZnRlZEV4dHJhY3RlZC5iYXJzLmxlbmd0aCA9PT0gYmFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBiYXIgd2lkdGhzIGFyZSByb3VnaGx5IHNpbWlsYXIgKHdpdGhpbiAyNSUpXG4gICAgICAgICAgICAgICAgbGV0IGJhcnNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhzaGlmdGVkRXh0cmFjdGVkLmJhcnNbaV0gLSBiYXJzW2ldKSAvIE1hdGgubWF4KGJhcnNbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDAuMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcnNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhcnNNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zaXN0ZW50T2Zmc2V0cysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlYWwgYmFyY29kZXMgc2hvdWxkIGJlIGNvbnNpc3RlbnQgYWNyb3NzIG11bHRpcGxlIHNoaWZ0ZWQgcG9zaXRpb25zXG4gICAgICAgIC8vIFRleHQgcGF0dGVybnMgdHlwaWNhbGx5IGZhaWwgdGhpcyB0ZXN0XG4gICAgICAgIGlmICh0b3RhbENoZWNrcyA+IDAgJiYgY29uc2lzdGVudE9mZnNldHMgPj0gdG90YWxDaGVja3MgKiAwLjUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBDb25zaXN0ZW50IGFjcm9zcyBhdCBsZWFzdCA1MCUgb2YgcG9zaXRpb25zXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhlIGJhcmNvZGVcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJFSkVDVCBpZiBiYXJjb2RlIHN0YXJ0cyB0b28gbGF0ZSBpbiB0aGUgc2NhbiAoPjUwJSBvZiBsaW5lIGxlbmd0aClcbiAgICAgICAgLy8gVmFsaWQgcGhhcm1hY29kZXMgc2hvdWxkIGJlIGZvdW5kIG5lYXIgdGhlIGltYWdlIGVkZ2Ugb3IgZWFybHkgaW4gdGhlIHNjYW4uXG4gICAgICAgIC8vIFN0YXJ0aW5nIHRvbyBmYXIgaW50byB0aGUgaW1hZ2UgaW5kaWNhdGVzIHdlJ3JlIHBpY2tpbmcgdXAgbm9pc2Ugb3IgYSBzaGlmdGVkIHBhdHRlcm5cbiAgICAgICAgLy8gKGkuZS4sIHNhbXBsaW5nIG1pZC1iYXIsIHdoaWNoIHJldmVyc2VzIHRoZSBlbmNvZGluZykuXG4gICAgICAgIC8vIFRoaXMgYWxzbyByZWplY3RzIHRpbHRlZCBiYXJjb2RlcyB0aGF0IG9ubHkgYXBwZWFyIHN0cmFpZ2h0IGF0IG9uZSBzcGVjaWZpYyBhbmdsZS5cbiAgICAgICAgaWYgKHN0YXJ0SW5mby5zdGFydCA+IHRoaXMuX3Jvdy5sZW5ndGggKiAwLjUwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJhY3QgYmFycyBhbmQgc3BhY2VzXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHRoaXMuX2V4dHJhY3RCYXJzQW5kU3BhY2VzKHN0YXJ0SW5mby5zdGFydCk7XG4gICAgICAgIGlmICghZXh0cmFjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgYmFycywgc3BhY2VzLCBlbmQgfSA9IGV4dHJhY3RlZDtcblxuICAgICAgICAvLyBSZWplY3QgZXh0cmVtZWx5IHNob3J0IHBhdHRlcm5zICh0b3RhbCB3aWR0aCA8IDIwcHgpXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgYmFyY29kZSB3aWR0aCBmcm9tIHN1bSBvZiBiYXJzIGFuZCBzcGFjZXNcbiAgICAgICAgY29uc3QgYmFyc1dpZHRoID0gYmFycy5yZWR1Y2UoKHN1bSwgdykgPT4gc3VtICsgdywgMCk7XG4gICAgICAgIGNvbnN0IHNwYWNlc1dpZHRoID0gc3BhY2VzLnJlZHVjZSgoc3VtLCB3KSA9PiBzdW0gKyB3LCAwKTtcbiAgICAgICAgY29uc3QgdG90YWxCYXJjb2RlV2lkdGggPSBiYXJzV2lkdGggKyBzcGFjZXNXaWR0aDtcbiAgICAgICAgaWYgKHRvdGFsQmFyY29kZVdpZHRoIDwgMjApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRURHRS1SRUFDSCBSRUpFQ1RJT046IFJlamVjdCBpZiBleHRyYWN0aW9uIHJlYWNoZXMgaW1hZ2UgYm91bmRhcnlcbiAgICAgICAgLy8gVmFsaWQgcGhhcm1hY29kZXMgcmVxdWlyZSBwcm9wZXIgcXVpZXQgem9uZXMgcGVyIHBoYXJtYWNldXRpY2FsIHNwZWMgKG1pbiA2bW0g4omIIDE2cHggYXQgdHlwaWNhbCBEUEkpXG4gICAgICAgIC8vIEV4dHJhY3Rpb25zIHJlYWNoaW5nIHRoZSBpbWFnZSBlZGdlIChlbmQgPj0gcm93Lmxlbmd0aCAtIDIpIGluZGljYXRlIGluY29tcGxldGUvaW52YWxpZCBwYXR0ZXJuc1xuICAgICAgICAvLyBUaGlzIGNhdGNoZXMgdGlsdGVkIGFuZCBjdXJ2ZWQgYmFyY29kZXMgdGhhdCBvbmx5IGFwcGVhciBzdHJhaWdodCBhdCBvbmUgc3BlY2lmaWMgYW5nbGVcbiAgICAgICAgY29uc3QgRURHRV9NQVJHSU4gPSAwOyAvLyBObyBtYXJnaW46IG9ubHkgcmVqZWN0IGlmIGV4dHJhY3Rpb24gZ29lcyBQQVNUIHRoZSByb3cgbGVuZ3RoIChzaG91bGRuJ3QgaGFwcGVuIGJ1dCBiZSBzYWZlKVxuICAgICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmQ7XG4gICAgICAgIGlmIChyZW1haW5pbmdTcGFjZSA8IEVER0VfTUFSR0lOKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHNwYWNlIHVuaWZvcm1pdHlcbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVNwYWNlcyhzcGFjZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHBlcmlvZGljaXR5IG9mIGJhciBhbmQgc3BhY2Ugd2lkdGhzIHRvIHJlamVjdCB0aWx0ZWQvY3VydmVkIGJhcmNvZGVzXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVQZXJpb2RpY2l0eShiYXJzLCBzcGFjZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBzaG9ydCBwYXR0ZXJucywgdmFsaWRhdGUgY29uc2lzdGVuY3kgYWNyb3NzIHNoaWZ0ZWQgcG9zaXRpb25zXG4gICAgICAgIC8vIHRvIHJlamVjdCB0ZXh0L25vaXNlIHBhdHRlcm5zIHRoYXQgYXBwZWFyIGFzIGJhcnMgZHVlIHRvIGVkZ2UgZGV0ZWN0aW9uXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVQYXR0ZXJuQ29uc2lzdGVuY3koc3RhcnRJbmZvLCBiYXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBiYXIgd2lkdGggcmF0aW9zIGFyZSBjb25zaXN0ZW50ICgxOjIsIDE6Mi41LCBvciAxOjMpXG4gICAgICAgIGNvbnN0IHJhdGlvSW5mbyA9IHRoaXMuX3ZhbGlkYXRlQmFyUmF0aW9zKGJhcnMsIHNwYWNlcyk7XG4gICAgICAgIGlmICghcmF0aW9JbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHF1aWV0IHpvbmVzIG1lZXQgcGhhcm1hY2V1dGljYWwgc3BlY1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlUXVpZXRab25lcyhzdGFydEluZm8sIHJhdGlvSW5mby5uYXJyb3dXaWR0aCwgZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNvZGUgdGhlIGJhcnMsIHBhc3NpbmcgdGhlIGluZmVycmVkIG5hcnJvd1dpZHRoIGZvciBhbGwtd2lkZS9hbGwtbmFycm93IHBhdHRlcm5zXG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB0aGlzLl9kZWNvZGVCYXJzKGJhcnMsIHJhdGlvSW5mby5uYXJyb3dXaWR0aCk7XG4gICAgICAgIGlmICghZGVjb2RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBkZWNvZGVkO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHZhbHVlIHJhbmdlXG4gICAgICAgIGlmICh2YWx1ZSA8IE1JTl9WQUxVRSB8fCB2YWx1ZSA+IE1BWF9WQUxVRSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICBjb25zdCBhdmdCYXJXaWR0aCA9IGJhcnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBiYXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kLCBhdmdCYXJXaWR0aCkpIHtcbiAgICAgICAgICAgIC8vIFNvZnQgZmFpbCAtIGFsbG93IGJ1dCBub3RlIGl0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCB0aGUgZGVjb2RlZCBjb2RlcyBhcnJheSBmb3IgZGVidWdnaW5nL3Zpc3VhbGl6YXRpb25cbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4gPSBiYXJzLm1hcCgod2lkdGgsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgY29kZTogd2lkdGggPiAoTWF0aC5taW4oLi4uYmFycykgKiBXSURFX0JBUl9USFJFU0hPTEQpID8gMSA6IDAsXG4gICAgICAgICAgICBzdGFydDogMCwgLy8gQ291bGQgY2FsY3VsYXRlIGFjdHVhbCBwb3NpdGlvbnMgaWYgbmVlZGVkXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICBlcnJvcjogMCxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiB2YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIHBhdHRlcm46IGRlY29kZWQucGF0dGVybixcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaGFybWFjb2RlUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENFUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBDT0RFX0ZSRVFVRU5DWSA9IFtcbiAgICAgICAgWyA1NiwgNTIsIDUwLCA0OSwgNDQsIDM4LCAzNSwgNDIsIDQxLCAzNyBdLFxuICAgICAgICBbNywgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl1dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XTtcbiAgICBGT1JNQVQgPSAndXBjX2UnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID0gKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAoMSA8PCAoNSAtIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRDb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5OiBudW1iZXIsIHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBmb3IgKGxldCBuclN5c3RlbSA9IDA7IG5yU3lzdGVtIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IG5yU3lzdGVtKyspe1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NvbnZlcnRUb1VQQ0EocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCB1cGNhID0gW3Jlc3VsdFswXV07XG4gICAgICAgIGNvbnN0IGxhc3REaWdpdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMl07XG5cbiAgICAgICAgaWYgKGxhc3REaWdpdCA8PSAyKSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDMpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoW2xhc3REaWdpdCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoMywgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMykge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA0KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSg0LCA2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSA0KSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDUpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDAsIHJlc3VsdFs1XV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA2KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCBsYXN0RGlnaXRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgcmV0dXJuIHVwY2E7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdXBlci5fY2hlY2tzdW0odGhpcy5fY29udmVydFRvVVBDQShyZXN1bHQpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9maW5kRW5kKG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ0VSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAndXBjX2EnO1xuICAgIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRUFOUmVhZGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb2RlICYmIHJlc3VsdC5jb2RlLmxlbmd0aCA9PT0gMTMgJiYgcmVzdWx0LmNvZGUuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gcmVzdWx0LmNvZGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ1JlYWRlcjtcbiIsImNvbnN0IEJyZXNlbmhhbSA9IHt9O1xuXG5jb25zdCBTbG9wZSA9IHtcbiAgICBESVI6IHtcbiAgICAgICAgVVA6IDEsXG4gICAgICAgIERPV046IC0xLFxuICAgIH0sXG59O1xuLyoqXG4gKiBTY2FucyBhIGxpbmUgb2YgdGhlIGdpdmVuIGltYWdlIGZyb20gcG9pbnQgcDEgdG8gcDIgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmdcbiAqIGdyYXktc2NhbGUgdmFsdWVzICgwLTI1NSkgb2YgdGhlIHVuZGVybHlpbmcgcGl4ZWxzIGluIGFkZGl0aW9uIHRvIHRoZSBtaW5cbiAqIGFuZCBtYXggdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlclxuICogQHBhcmFtIHtPYmplY3R9IHAxIFRoZSBzdGFydCBwb2ludCB7eCx5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIFRoZSBlbmQgcG9pbnQge3gseX1cbiAqIEByZXR1cm5zIHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lID0gZnVuY3Rpb24gKGltYWdlV3JhcHBlciwgcDEsIHAyKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGxldCB4MCA9IHAxLnggfCAwO1xuICAgIGxldCB5MCA9IHAxLnkgfCAwO1xuICAgIGxldCB4MSA9IHAyLnggfCAwO1xuICAgIGxldCB5MSA9IHAyLnkgfCAwO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBzdGVlcCA9IE1hdGguYWJzKHkxIC0geTApID4gTWF0aC5hYnMoeDEgLSB4MCk7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCB5O1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHg7XG4gICAgY29uc3QgbGluZSA9IFtdO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgdmFsO1xuICAgIGxldCBtaW4gPSAyNTU7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcbiAgICAgICAgdmFsID0gaW1hZ2VEYXRhW2IgKiB3aWR0aCArIGFdO1xuICAgICAgICBtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG4gICAgICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcbiAgICAgICAgbGluZS5wdXNoKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHkwO1xuICAgICAgICB5MCA9IHRtcDtcblxuICAgICAgICB0bXAgPSB4MTtcbiAgICAgICAgeDEgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGlmICh4MCA+IHgxKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICB4MSA9IHRtcDtcblxuICAgICAgICB0bXAgPSB5MDtcbiAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhWCA9IHgxIC0geDA7XG4gICAgY29uc3QgZGVsdGFZID0gTWF0aC5hYnMoeTEgLSB5MCk7XG4gICAgZXJyb3IgPSAoZGVsdGFYIC8gMikgfCAwO1xuICAgIHkgPSB5MDtcbiAgICBjb25zdCB5U3RlcCA9IHkwIDwgeTEgPyAxIDogLTE7XG4gICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XG4gICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICAgICAgcmVhZCh5LCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgLT0gZGVsdGFZO1xuICAgICAgICBpZiAoZXJyb3IgPCAwKSB7XG4gICAgICAgICAgICB5ICs9IHlTdGVwO1xuICAgICAgICAgICAgZXJyb3IgKz0gZGVsdGFYO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHJlc3VsdCBmcm9tIGdldEJhcmNvZGVMaW5lIGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAqIGFsc28gY29uc2lkZXJpbmcgdGhlIGZyZXF1ZW5jeSBhbmQgc2xvcGUgb2YgdGhlIHNpZ25hbCBmb3IgbW9yZSByb2J1c3QgcmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS50b0JpbmFyeUxpbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgY29uc3QgeyBtaW4gfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IG1heCB9ID0gcmVzdWx0O1xuICAgIGNvbnN0IHsgbGluZSB9ID0gcmVzdWx0O1xuICAgIGxldCBzbG9wZTtcbiAgICBsZXQgc2xvcGUyO1xuICAgIGNvbnN0IGNlbnRlciA9IG1pbiArIChtYXggLSBtaW4pIC8gMjtcbiAgICBjb25zdCBleHRyZW1hID0gW107XG4gICAgbGV0IGN1cnJlbnREaXI7XG4gICAgbGV0IGRpcjtcbiAgICBsZXQgdGhyZXNob2xkID0gKG1heCAtIG1pbikgLyAxMjtcbiAgICBjb25zdCByVGhyZXNob2xkID0gLXRocmVzaG9sZDtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcblxuICAgIC8vIDEuIGZpbmQgZXh0cmVtYVxuICAgIGN1cnJlbnREaXIgPSBsaW5lWzBdID4gY2VudGVyID8gU2xvcGUuRElSLlVQIDogU2xvcGUuRElSLkRPV047XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICB2YWw6IGxpbmVbMF0sXG4gICAgfSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgIHNsb3BlID0gKGxpbmVbaSArIDFdIC0gbGluZVtpXSk7XG4gICAgICAgIHNsb3BlMiA9IChsaW5lW2kgKyAyXSAtIGxpbmVbaSArIDFdKTtcbiAgICAgICAgaWYgKChzbG9wZSArIHNsb3BlMikgPCByVGhyZXNob2xkICYmIGxpbmVbaSArIDFdIDwgKGNlbnRlciAqIDEuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5ET1dOO1xuICAgICAgICB9IGVsc2UgaWYgKChzbG9wZSArIHNsb3BlMikgPiB0aHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPiAoY2VudGVyICogMC41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLlVQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyID0gY3VycmVudERpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGlyICE9PSBkaXIpIHtcbiAgICAgICAgICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgIHZhbDogbGluZVtpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudERpciA9IGRpcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IGxpbmUubGVuZ3RoLFxuICAgICAgICB2YWw6IGxpbmVbbGluZS5sZW5ndGggLSAxXSxcbiAgICB9KTtcblxuICAgIGZvciAoaiA9IGV4dHJlbWFbMF0ucG9zOyBqIDwgZXh0cmVtYVsxXS5wb3M7IGorKykge1xuICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IGNlbnRlciA/IDAgOiAxO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBleHRyZW1hIGFuZCBjb252ZXJ0IHRvIGJpbmFyeSBiYXNlZCBvbiBhdmcgYmV0d2VlbiBtaW5tYXhcbiAgICBmb3IgKGkgPSAxOyBpIDwgZXh0cmVtYS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGV4dHJlbWFbaSArIDFdLnZhbCA+IGV4dHJlbWFbaV0udmFsKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpXS52YWwgKyAoKGV4dHJlbWFbaSArIDFdLnZhbCAtIGV4dHJlbWFbaV0udmFsKSAvIDMpICogMikgfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaSArIDFdLnZhbCArICgoZXh0cmVtYVtpXS52YWwgLSBleHRyZW1hW2kgKyAxXS52YWwpIC8gMykpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcbiAgICAgICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgfTtcbn07XG5cbi8qKlxuICogVXNlZCBmb3IgZGV2ZWxvcG1lbnQgb25seVxuICovXG5CcmVzZW5oYW0uZGVidWcgPSB7XG4gICAgcHJpbnRGcmVxdWVuY3kobGluZSwgY2FudmFzKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHByaW50UGF0dGVybihsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7IGxldFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIGN0eC5maWxsQ29sb3IgPSAnYmxhY2snO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoaSwgMCwgMSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCcmVzZW5oYW07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tY3ljbGUgKi9cblxuLyoqXG4gKiBCYXJjb2RlIERlY29kZXIgTW9kdWxlXG4gKlxuICogVGhpcyBtb2R1bGUgaGFuZGxlcyB0aGUgZGVjb2Rpbmcgb2YgYmFyY29kZXMgdXNpbmcgY29uZmlndXJlZCByZWFkZXJzLlxuICpcbiAqIFJFQURFUiBPUkRFUiBHVUFSQU5URUU6XG4gKiBSZWFkZXJzIGFyZSBwcm9jZXNzZWQgaW4gdGhlIGV4YWN0IG9yZGVyIHRoZXkgYXJlIHNwZWNpZmllZCBpbiB0aGUgYHJlYWRlcnNgXG4gKiBjb25maWcgYXJyYXkuIFRoZSBmaXJzdCByZWFkZXIgdG8gc3VjY2Vzc2Z1bGx5IGRlY29kZSB0aGUgYmFyY29kZSB3aW5zLlxuICpcbiAqIEV4YW1wbGU6XG4gKiAgIHJlYWRlcnM6IFsnZWFuX3JlYWRlcicsICd1cGNfZV9yZWFkZXInLCAnY29kZV8xMjhfcmVhZGVyJ11cbiAqXG4gKiBEZWNvZGluZyBvcmRlcjpcbiAqICAgMS4gZWFuX3JlYWRlciBhdHRlbXB0cyB0byBkZWNvZGVcbiAqICAgMi4gSWYgZWFuX3JlYWRlciByZXR1cm5zIG51bGwsIHVwY19lX3JlYWRlciBhdHRlbXB0cyB0byBkZWNvZGVcbiAqICAgMy4gSWYgdXBjX2VfcmVhZGVyIHJldHVybnMgbnVsbCwgY29kZV8xMjhfcmVhZGVyIGF0dGVtcHRzIHRvIGRlY29kZVxuICogICA0LiBGaXJzdCBub24tbnVsbCByZXN1bHQgaXMgcmV0dXJuZWRcbiAqXG4gKiBFWFRFUk5BTCBSRUFERVJTOlxuICogRXh0ZXJuYWwgcmVhZGVycyBtdXN0IGJlIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyUmVhZGVyKCkgYmVmb3JlIHVzZS5cbiAqIE9uY2UgcmVnaXN0ZXJlZCwgdGhleSBmb2xsb3cgdGhlIHNhbWUgb3JkZXJpbmcgcnVsZXMgYXMgYnVpbHQtaW4gcmVhZGVycy5cbiAqIFRoZWlyIHBvc2l0aW9uIGluIHRoZSBgcmVhZGVyc2AgYXJyYXkgZGV0ZXJtaW5lcyB0aGVpciBwcmlvcml0eS5cbiAqXG4gKiBUbyBwcmlvcml0aXplIGFuIGV4dGVybmFsIHJlYWRlcjpcbiAqICAgUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyKCdteV9yZWFkZXInLCBNeVJlYWRlcik7XG4gKiAgIGNvbmZpZy5kZWNvZGVyLnJlYWRlcnMgPSBbJ215X3JlYWRlcicsICdlYW5fcmVhZGVyJ107IC8vIG15X3JlYWRlciB0cmllZCBmaXJzdFxuICovXG5cbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgQ29kYWJhclJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kYWJhcl9yZWFkZXInO1xuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMTI4X3JlYWRlcic7XG5pbXBvcnQgQ29kZTMyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzMyX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGU5M1JlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV85M19yZWFkZXInO1xuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl8yX3JlYWRlcic7XG5pbXBvcnQgRUFONVJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzVfcmVhZGVyJztcbmltcG9ydCBFQU44UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgUGhhcm1hY29kZVJlYWRlciBmcm9tICcuLi9yZWFkZXIvcGhhcm1hY29kZV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgVVBDUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfcmVhZGVyJztcbmltcG9ydCBCcmVzZW5oYW0gZnJvbSAnLi9icmVzZW5oYW0nO1xuXG5jb25zdCBSRUFERVJTID0ge1xuICAgIGNvZGVfMTI4X3JlYWRlcjogQ29kZTEyOFJlYWRlcixcbiAgICBlYW5fcmVhZGVyOiBFQU5SZWFkZXIsXG4gICAgZWFuXzVfcmVhZGVyOiBFQU41UmVhZGVyLFxuICAgIGVhbl8yX3JlYWRlcjogRUFOMlJlYWRlcixcbiAgICBlYW5fOF9yZWFkZXI6IEVBTjhSZWFkZXIsXG4gICAgY29kZV8zOV9yZWFkZXI6IENvZGUzOVJlYWRlcixcbiAgICBjb2RlXzM5X3Zpbl9yZWFkZXI6IENvZGUzOVZJTlJlYWRlcixcbiAgICBjb2RhYmFyX3JlYWRlcjogQ29kYWJhclJlYWRlcixcbiAgICB1cGNfcmVhZGVyOiBVUENSZWFkZXIsXG4gICAgdXBjX2VfcmVhZGVyOiBVUENFUmVhZGVyLFxuICAgIGkyb2Y1X3JlYWRlcjogSTJvZjVSZWFkZXIsXG4gICAgJzJvZjVfcmVhZGVyJzogVHdvT2ZGaXZlUmVhZGVyLFxuICAgIGNvZGVfOTNfcmVhZGVyOiBDb2RlOTNSZWFkZXIsXG4gICAgY29kZV8zMl9yZWFkZXI6IENvZGUzMlJlYWRlcixcbiAgICBwaGFybWFjb2RlX3JlYWRlcjogUGhhcm1hY29kZVJlYWRlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gZXh0ZXJuYWwvY3VzdG9tIGJhcmNvZGUgcmVhZGVyLlxuICAgICAqIE9uY2UgcmVnaXN0ZXJlZCwgdGhlIHJlYWRlciBjYW4gYmUgdXNlZCBpbiBjb25maWcucmVhZGVycyBhcnJheS5cbiAgICAgKiBUaGUgcmVhZGVyJ3MgcG9zaXRpb24gaW4gY29uZmlnLnJlYWRlcnMgZGV0ZXJtaW5lcyBpdHMgZGVjb2RpbmcgcHJpb3JpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBpZGVudGlmaWVyIHRvIHVzZSBpbiBjb25maWcucmVhZGVycyAoZS5nLiwgJ215X2N1c3RvbV9yZWFkZXInKVxuICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIGNsYXNzIChtdXN0IGV4dGVuZCBCYXJjb2RlUmVhZGVyKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBSZWdpc3RlciBhIGN1c3RvbSByZWFkZXJcbiAgICAgKiBCYXJjb2RlRGVjb2Rlci5yZWdpc3RlclJlYWRlcignbXlfcmVhZGVyJywgTXlDdXN0b21SZWFkZXIpO1xuICAgICAqXG4gICAgICogLy8gVXNlIGl0IHdpdGggaGlnaCBwcmlvcml0eSAoZmlyc3QgaW4gYXJyYXkpXG4gICAgICogY29uZmlnLmRlY29kZXIucmVhZGVycyA9IFsnbXlfcmVhZGVyJywgJ2Vhbl9yZWFkZXInLCAnY29kZV8xMjhfcmVhZGVyJ107XG4gICAgICovXG4gICAgcmVnaXN0ZXJSZWFkZXI6IChuYW1lLCByZWFkZXIpID0+IHtcbiAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICB9LFxuICAgIGNyZWF0ZShjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IF9jYW52YXMgPSB7XG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbToge1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfYmFyY29kZVJlYWRlcnMgPSBbXTtcblxuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgIGluaXRDb25maWcoKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnLmRldGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5mcmVxdWVuY3knKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLmZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5LmNsYXNzTmFtZSA9ICdmcmVxdWVuY3knO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zz8ucHJpbnRSZWFkZXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBiYXJjb2RlIGRlY29kZXIgaW5pdENhbnZhcyBnZXRjb250ZXh0IDJkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LmZyZXF1ZW5jeSA9IF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5wYXR0ZXJuQnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybi5jbGFzc05hbWUgPSAncGF0dGVybkJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5wYXR0ZXJuID0gX2NhbnZhcy5kb20ucGF0dGVybi5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ub3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5kcmF3aW5nQnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKF9jYW52YXMuZG9tLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgub3ZlcmxheSA9IF9jYW52YXMuZG9tLm92ZXJsYXkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYmFyY29kZSByZWFkZXJzIGZyb20gY29uZmlnLnJlYWRlcnMgYXJyYXkuXG4gICAgICAgICAqIFJlYWRlcnMgYXJlIGluc3RhbnRpYXRlZCBhbmQgc3RvcmVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhciBpbiBjb25maWcsXG4gICAgICAgICAqIHdoaWNoIGRldGVybWluZXMgdGhlaXIgZGVjb2RpbmcgcHJpb3JpdHkgKGZpcnN0IGluIGFycmF5ID0gaGlnaGVzdCBwcmlvcml0eSkuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpbml0UmVhZGVycygpIHtcbiAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzLmZvckVhY2goKHJlYWRlckNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWFkZXI7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgc3VwcGxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWcuZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0gcmVhZGVyQ29uZmlnLmNvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWc/LnByaW50UmVhZGVySW5mbykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmVmb3JlIHJlZ2lzdGVyaW5nIHJlYWRlcjogJywgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxlbWVudHMgPSBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3VwcGxlbWVudHMubWFwKChzdXBwbGVtZW50KSA9PiBuZXcgUkVBREVSU1tzdXBwbGVtZW50XSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyT2JqID0gbmV3IFJFQURFUlNbcmVhZGVyXShjb25maWd1cmF0aW9uLCBzdXBwbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKHJlYWRlck9iaik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogRXJyb3IgY29uc3RydWN0aW5nIHJlYWRlciAnLCByZWFkZXIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnPy5wcmludFJlYWRlckluZm8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVnaXN0ZXJlZCBSZWFkZXJzOiAke19iYXJjb2RlUmVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChyZWFkZXIpID0+IEpTT04uc3RyaW5naWZ5KHsgZm9ybWF0OiByZWFkZXIuRk9STUFULCBjb25maWc6IHJlYWRlci5jb25maWcgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENvbmZpZygpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLmZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4sXG4gICAgICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNbaV0ucHJvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4dGVuZCB0aGUgbGluZSBvbiBib3RoIGVuZHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkTGluZShsaW5lLCBhbmdsZSwgZXh0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBleHRlbmRMaW5lKGFtb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogYW1vdW50ICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICB4OiBhbW91bnQgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGluc2lkZSBpbWFnZVxuICAgICAgICAgICAgZXh0ZW5kTGluZShleHQpO1xuICAgICAgICAgICAgd2hpbGUgKGV4dCA+IDEgJiYgKCFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzBdKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVsxXSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgZXh0IC09IE1hdGguY2VpbChleHQgLyAyKTtcbiAgICAgICAgICAgICAgICBleHRlbmRMaW5lKC1leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lKGJveCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgeDogKGJveFsxXVswXSAtIGJveFswXVswXSkgLyAyICsgYm94WzBdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbMV1bMV0gLSBib3hbMF1bMV0pIC8gMiArIGJveFswXVsxXSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiAoYm94WzNdWzBdIC0gYm94WzJdWzBdKSAvIDIgKyBib3hbMl1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFszXVsxXSAtIGJveFsyXVsxXSkgLyAyICsgYm94WzJdWzFdLFxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgdGhhdCBiYXJjb2RlIHBvc2l0aW9uIGlzIHN0YWJsZSBhY3Jvc3MgYWRqYWNlbnQgWS1zY2FubGluZXMuXG4gICAgICAgICAqIFJlYWwgYmFyY29kZXMgaGF2ZSBjb25zaXN0ZW50IHN0YXJ0IHBvc2l0aW9uOyB0aWx0ZWQgYmFyY29kZXMgc2hpZnQgbGVmdC9yaWdodCBhcyBZIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmUgVGhlIG9yaWdpbmFsIHNjYW4gbGluZSBbcDEsIHAyXVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBzdWNjZXNzZnVsIGRlY29kZSByZXN1bHQgd2l0aCAuc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlYWRlciBUaGUgcmVhZGVyIGluc3RhbmNlIHRoYXQgc3VjY2VlZGVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dEltYWdlV3JhcHBlciBUaGUgZnVsbCBpbWFnZSBkYXRhXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGJhcmNvZGUgcG9zaXRpb24gaXMgc3RhYmxlICjiiaUxIGFkamFjZW50IFktbGluZSBtYXRjaGVzKVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVBZGphY2VudFlMaW5lcyhsaW5lLCByZXN1bHQsIHJlYWRlciwgaW5wdXRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3Qgb3JpZ2luYWwgWSBwb3NpdGlvbiBhbmQgWCBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxZID0gTWF0aC5yb3VuZChsaW5lWzFdLnkpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxYU3RhcnQgPSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvckZuID0gcmVhZGVyLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRNYXRjaGVzID0gKGNvbnN0cnVjdG9yRm4gJiYgY29uc3RydWN0b3JGbi5hZGphY2VudExpbmVWYWxpZGF0aW9uTWF0Y2hlcykgfHwgMDtcblxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkTWF0Y2hlcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtYXRjaENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIFnCsTEsIFnCsTIsIFnCsTMgdG8gc2VlIGlmIGJhcmNvZGUgYXBwZWFycyBhdCBzYW1lIFggcG9zaXRpb25cbiAgICAgICAgICAgIGZvciAoY29uc3QgeU9mZnNldCBvZiBbMSwgMiwgM10pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rpb24gb2YgWy0xLCAxXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3WSA9IG9yaWdpbmFsWSArICh5T2Zmc2V0ICogZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCb3VuZHMgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1kgPCAwIHx8IG5ld1kgPj0gaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgbGluZSBhdCBhZGp1c3RlZCBZLCBrZWVwaW5nIHNhbWUgWCByYW5nZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQMSA9IHsgeDogbGluZVswXS54LCB5OiBuZXdZIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1AyID0geyB4OiBsaW5lWzFdLngsIHk6IG5ld1kgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBncmF5c2NhbGUgYXQgbmV3IFlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JhcmNvZGVMaW5lID0gQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lKGlucHV0SW1hZ2VXcmFwcGVyLCBuZXdQMSwgbmV3UDIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCaW5hcml6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgQnJlc2VuaGFtLnRvQmluYXJ5TGluZShuZXdCYXJjb2RlTGluZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgcm93IGZvciBfZmluZFN0YXJ0KCkgdG8gc2VhcmNoIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuX3JvdyA9IG5ld0JhcmNvZGVMaW5lLmxpbmU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGJhcmNvZGUgc3RhcnQgYXQgdGhpcyBZXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydEZvdW5kID0gcmVhZGVyLl9maW5kU3RhcnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Rm91bmQgIT09IG51bGwgJiYgc3RhcnRGb3VuZC5zdGFydCA9PT0gb3JpZ2luYWxYU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoQ291bnQgPj0gcmVxdWlyZWRNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMsIHRyZWF0IGZhaWx1cmVzIGFzIFwibm8gbWF0Y2hcIiBzbyB3ZSBjYW4gdHJ5IGFnYWluIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IG1hdGNoQ291bnQgPj0gcmVxdWlyZWRNYXRjaGVzO1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0ZW1wdHMgdG8gZGVjb2RlIGEgYmFyY29kZSBmcm9tIGEgc2NhbiBsaW5lLlxuICAgICAgICAgKiBSZWFkZXJzIGFyZSB0cmllZCBpbiBvcmRlciAoYXMgc3BlY2lmaWVkIGluIGNvbmZpZy5yZWFkZXJzKS5cbiAgICAgICAgICogVGhlIGZpcnN0IHJlYWRlciB0byByZXR1cm4gYSBub24tbnVsbCByZXN1bHQgd2lucy5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgc2NhbiBsaW5lIHRvIGRlY29kZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IERlY29kZWQgcmVzdWx0IG9yIG51bGwgaWYgbm8gcmVhZGVyIHN1Y2NlZWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5jdHgub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgX2NhbnZhcy5jdHgub3ZlcmxheSwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50RnJlcXVlbmN5KGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJyZXNlbmhhbS50b0JpbmFyeUxpbmUoYmFyY29kZUxpbmUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybikge1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludFBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgcmVhZGVycyBpbiBvcmRlciAtIGZpcnN0IHN1Y2Nlc3NmdWwgZGVjb2RlIHdpbnNcbiAgICAgICAgICAgIGxldCBzdWNjZXNzZnVsUmVhZGVySW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBpbWFnZSBjb250ZXh0IHRvIHJlYWRlcnMgdGhhdCB3YW50IGl0IChlLmcuLCBwaGFybWFjb2RlIFBHTSBkdW1wcylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9iYXJjb2RlUmVhZGVyc1tpXS5zZXRJbWFnZVdyYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzW2ldLnNldEltYWdlV3JhcHBlcihpbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2Z1bFJlYWRlckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgYmFyY29kZSBwb3NpdGlvbiBpcyBzdGFibGUgYWNyb3NzIGFkamFjZW50IFktc2NhbmxpbmVzXG4gICAgICAgICAgICAvLyBUaGlzIHJlamVjdHMgdGlsdGVkIGJhcmNvZGVzIHRoYXQgb25seSBhcHBlYXIgdmFsaWQgYXQgb25lIHNwZWNpZmljIGFuZ2xlXG4gICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHRvIFBoYXJtYWNvZGVSZWFkZXIgKHdoaWNoIGV4cGxpY2l0bHkgbWFkZSBfZmluZFN0YXJ0IHB1YmxpYyBmb3IgdGhpcyB2YWxpZGF0aW9uKVxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NmdWxSZWFkZXJJbmRleCA+PSAwICYmIF9iYXJjb2RlUmVhZGVyc1tzdWNjZXNzZnVsUmVhZGVySW5kZXhdIGluc3RhbmNlb2YgUGhhcm1hY29kZVJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVBZGphY2VudFlMaW5lcyhsaW5lLCByZXN1bHQsIF9iYXJjb2RlUmVhZGVyc1tzdWNjZXNzZnVsUmVhZGVySW5kZXhdLCBpbnB1dEltYWdlV3JhcHBlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KGJveFsxXVswXSAtIGJveFswXVswXSwgMikgKyBNYXRoLnBvdygoYm94WzFdWzFdIC0gYm94WzBdWzFdKSwgMikpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBzbGljZXMgPSAxNjtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRpcjtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb247XG4gICAgICAgICAgICBjb25zdCB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHlkaXIgPSBNYXRoLmNvcyhsaW5lQW5nbGUpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgc2xpY2VzICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBsaW5lIHBlcnBlbmRpY3VsYXIgdG8gYW5nbGVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgZGlyID0gc2lkZUxlbmd0aCAvIHNsaWNlcyAqIGkgKiAoaSAlIDIgPT09IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogZGlyICogeGRpcixcbiAgICAgICAgICAgICAgICAgICAgeDogZGlyICogeWRpcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS55IC0gbGluZVswXS55KSwgMilcbiAgICAgICAgICAgICAgICArIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGZyb20gYSBmdWxsIGltYWdlIHVzaW5nIHJlYWRlcnMgdGhhdCBzdXBwb3J0IGltYWdlLWJhc2VkIGRlY29kaW5nLlxuICAgICAgICAgKiBSZWFkZXJzIGFyZSB0cmllZCBpbiBvcmRlciAoYXMgc3BlY2lmaWVkIGluIGNvbmZpZy5yZWFkZXJzKS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlciBUaGUgaW1hZ2UgdG8gZGVjb2RlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gRGVjb2RlZCByZXN1bHQgb3IgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJdGVyYXRlIHJlYWRlcnMgaW4gb3JkZXIgLSBmaXJzdCBzdWNjZXNzZnVsIGRlY29kZSB3aW5zXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBfYmFyY29kZVJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhZGVyLmRlY29kZUltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlYWRlci5kZWNvZGVJbWFnZShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpdGggdGhlIGhlbHAgb2YgdGhlIGNvbmZpZ3VyZWQgcmVhZGVycyAoQ29kZTEyOCBvciBFQU4pIHRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gZGV0ZWN0IGFcbiAgICAgICAgICogdmFsaWQgYmFyY29kZSBwYXR0ZXJuIHdpdGhpbiB0aGUgZ2l2ZW4gYXJlYS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJveCBUaGUgYXJlYSB0byBzZWFyY2ggaW5cbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gdGhlIHJlc3VsdCB7Y29kZVJlc3VsdCwgbGluZSwgYW5nbGUsIHBhdHRlcm4sIHRocmVzaG9sZH1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcbiAgICAgICAgICAgIGxldCBsaW5lO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gX2NhbnZhcy5jdHgub3ZlcmxheTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnLmRyYXdCb3VuZGluZ0JveCAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBjdHgsIHsgY29sb3I6ICdibHVlJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZSA9IGdldExpbmUoYm94KTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBnZXRMaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgbGluZUFuZ2xlID0gTWF0aC5hdGFuMihsaW5lWzFdLnkgLSBsaW5lWzBdLnksIGxpbmVbMV0ueCAtIGxpbmVbMF0ueCk7XG4gICAgICAgICAgICBsaW5lID0gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGxpbmVBbmdsZSwgTWF0aC5mbG9vcihsaW5lTGVuZ3RoICogMC4xKSk7XG4gICAgICAgICAgICBpZiAobGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiByZXN1bHQgJiYgY29uZmlnLmRlYnVnLmRyYXdTY2FubGluZSAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgY3R4LCB7IGNvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgYW5nbGU6IGxpbmVBbmdsZSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiByZXN1bHQuYmFyY29kZUxpbmUubGluZSxcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHJlc3VsdC5iYXJjb2RlTGluZS50aHJlc2hvbGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaTsgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJjb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlwbGUgfSA9IGNvbmZpZztcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib3ggPSBib3g7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2Rlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXJJbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXJJbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWdpc3RlciBleGlzdGluZyByZWFkZXInLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRSZWFkZXJzKHJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb25maWcucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgTmV3Q29kYWJhclJlYWRlciBmcm9tICcuL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4vY29kZV8xMjhfcmVhZGVyJztcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi9jb2RlXzMyX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVZJTlJlYWRlciBmcm9tICcuL2NvZGVfMzlfdmluX3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4vY29kZV85M19yZWFkZXInO1xuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi9lYW5fMl9yZWFkZXInO1xuaW1wb3J0IEVBTjVSZWFkZXIgZnJvbSAnLi9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi9lYW5fOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4vaTJvZjVfcmVhZGVyJztcbmltcG9ydCBQaGFybWFjb2RlUmVhZGVyIGZyb20gJy4vcGhhcm1hY29kZV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi91cGNfZV9yZWFkZXInO1xuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuL3VwY19yZWFkZXInO1xuXG5leHBvcnQge1xuICAgIEJhcmNvZGVSZWFkZXIsXG4gICAgVHdvT2ZGaXZlUmVhZGVyLFxuICAgIE5ld0NvZGFiYXJSZWFkZXIsXG4gICAgQ29kZTEyOFJlYWRlcixcbiAgICBDb2RlMzJSZWFkZXIsXG4gICAgQ29kZTM5UmVhZGVyLFxuICAgIENvZGUzOVZJTlJlYWRlcixcbiAgICBDb2RlOTNSZWFkZXIsXG4gICAgRUFOMlJlYWRlcixcbiAgICBFQU41UmVhZGVyLFxuICAgIEVBTjhSZWFkZXIsXG4gICAgRUFOUmVhZGVyLFxuICAgIEkyb2Y1UmVhZGVyLFxuICAgIFBoYXJtYWNvZGVSZWFkZXIsXG4gICAgVVBDRVJlYWRlcixcbiAgICBVUENSZWFkZXIsICAgIFxufVxuIiwidHlwZSBFdmVudE5hbWUgPSBzdHJpbmc7XG5cbmludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICAgIGFzeW5jPzogYm9vbGVhbjtcbiAgICBjYWxsYmFjazogRnVuY3Rpb247XG4gICAgb25jZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBFdmVudERhdGEge1xuICAgIHN1YnNjcmliZXJzOiBBcnJheTxTdWJzY3JpcHRpb24+O1xufVxuXG5pbnRlcmZhY2UgRXZlbnRzIHtcbiAgICBba2V5OiBzdHJpbmddOiBFdmVudERhdGE7XG59XG5cbmludGVyZmFjZSBFdmVudEludGVyZmFjZSB7XG4gICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZDtcbiAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkO1xuICAgIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHVuc3Vic2NyaWJlKGV2ZW50TmFtZT86IEV2ZW50TmFtZSwgY2FsbGJhY2s/OiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbik6IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBFdmVudEludGVyZmFjZSgpOiBFdmVudEludGVyZmFjZSB7XG4gICAgbGV0IGV2ZW50czogRXZlbnRzID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudChldmVudE5hbWU6IEV2ZW50TmFtZSk6IEV2ZW50RGF0YSB7XG4gICAgICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50c1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyRXZlbnRzKCk6IHZvaWQge1xuICAgICAgICBldmVudHMgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLCBkYXRhOiBuZXZlcik6IHZvaWQge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9LCA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgd2FzIG5vdCBzcGVjaWZpZWQgb24gb3B0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0RXZlbnQoZXZlbnQpLnN1YnNjcmliZXJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgICAgIHJldHVybiBfc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpO1xuICAgICAgICB9LFxuICAgICAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3Vic2NyaWJlcnMgfSA9IGV2ZW50O1xuXG4gICAgICAgICAgICAvLyBQdWJsaXNoIG9uZS10aW1lIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gISFzdWJzY3JpYmVyLm9uY2UpLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEgYXMgbmV2ZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGVtIGZyb20gdGhlIHN1YnNjcmliZXJcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhc3Vic2NyaWJlci5vbmNlKTtcblxuICAgICAgICAgICAgLy8gcHVibGlzaCB0aGUgcmVzdFxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSBhcyBuZXZlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgICAgIF9zdWJzY3JpYmUoZXZlbnQsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYyxcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc3Vic2NyaWJlKGV2ZW50TmFtZT86IEV2ZW50TmFtZSwgY2FsbGJhY2s/OiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbik6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJFdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufSgpKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb2RlPzogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IobTogc3RyaW5nLCBjb2RlPzogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRXhjZXB0aW9uLnByb3RvdHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEpTT04gc2VyaWFsaXphdGlvbiB0byBlbnN1cmUgZXJyb3IgbWVzc2FnZSBpcyBpbmNsdWRlZC5cbiAgICAgKiBUaGUgRXJyb3IgY2xhc3MncyBtZXNzYWdlIHByb3BlcnR5IGlzIG5vbi1lbnVtZXJhYmxlIGJ5IGRlZmF1bHQsXG4gICAgICogc28gSlNPTi5zdHJpbmdpZnkgd291bGQgb25seSBpbmNsdWRlIHtjb2RlOiAtMX0gd2l0aG91dCB0aGlzIG1ldGhvZC5cbiAgICAgKiBUaGlzIGVuc3VyZXMgY29uc3VtZXJzIHJlY2VpdmUgbWVhbmluZ2Z1bCBlcnJvciBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKTogeyBtZXNzYWdlOiBzdHJpbmc7IGNvZGU/OiBudW1iZXI7IG5hbWU6IHN0cmluZyB9IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCJpbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL3F1YWdnYS9FeGNlcHRpb24nO1xuXG5jb25zdCBFUlJPUl9ERVNDID0gJ1RoaXMgbWF5IG1lYW4gdGhhdCB0aGUgdXNlciBoYXMgZGVjbGluZWQgY2FtZXJhIGFjY2Vzcywgb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtZWRpYSBBUElzLiBJZiB5b3UgYXJlIHJ1bm5pbmcgaW4gaU9TLCB5b3UgbXVzdCB1c2UgU2FmYXJpLic7XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnVtZXJhdGVEZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yID0gbmV3IEV4Y2VwdGlvbihgZW51bWVyYXRlRGV2aWNlcyBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWAsIC0xKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPE1lZGlhU3RyZWFtPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yID0gbmV3IEV4Y2VwdGlvbihgZ2V0VXNlck1lZGlhIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCwgLTEpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cbiIsIi8vIFRPRE86IHdoZW4gdGhpcyBmaWxlIHdhcyB3cml0dGVuIHllYXJzIGFnbywgSFRNTE1lZGlhRWxlbWVudC5wbGF5KCkgZGlkIG5vdCByZXR1cm4gYSB1c2VmdWwgdmFsdWVcbi8vIHRvIGxldCB1cyBrbm93IHdoZW4gdGhlIHZpZGVvIHN0YXJ0ZWQgcGxheWluZy4gIE5vdywgaXQgZG9lcy4gIFNvLCB3ZSBzaG91bGRuJ3QgbmVlZCB0byBydW4gdGhpc1xuLy8gb2RkIHdhaXRGb3JWaWRlbygpIGZ1bmN0aW9uIHRoYXQgcG9sbHMgdG8gc2VlIGlmIHRoZSB2aWRlbyBoYXMgc3RhcnRlZC5cbmltcG9ydCBvbWl0IGZyb20gJ2xvZGFzaC9vbWl0JztcbmltcG9ydCB7IGdldFVzZXJNZWRpYSwgZW51bWVyYXRlRGV2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9tZWRpYURldmljZXMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9xdWFnZ2EvRXhjZXB0aW9uJztcbmltcG9ydCB0eXBlIHtcbiAgICBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCxcbiAgICBRdWFnZ2FKU0NhbWVyYUFjY2VzcyBhcyBDYW1lcmFBY2Nlc3NUeXBlLFxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxubGV0IHN0cmVhbVJlZjogTWVkaWFTdHJlYW0gfCBudWxsO1xuXG5mdW5jdGlvbiB3YWl0Rm9yVmlkZW8odmlkZW86IEhUTUxWaWRlb0VsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAxMDtcblxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZpZGVvKCk6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh2aWRlby52aWRlb1dpZHRoID4gMTAgJiYgdmlkZW8udmlkZW9IZWlnaHQgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgKiBkZXY6IGNoZWNrVmlkZW8gZm91bmQgJHt2aWRlby52aWRlb1dpZHRofXB4IHggJHt2aWRlby52aWRlb0hlaWdodH1weGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjaGVja1ZpZGVvLCA1MDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFeGNlcHRpb24oJ1VuYWJsZSB0byBwbGF5IHZpZGVvIHN0cmVhbS4gSXMgd2ViY2FtIHdvcmtpbmc/JywgLTEpKTsgLy8gVE9ETzogYWRkIGVycm9yIGNvZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dGVtcHRzLS07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWaWRlbygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY2FtZXJhLXN0cmVhbSB0byBhIGdpdmVuIHZpZGVvLWVsZW1lbnRcbiAqIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgY29udGVudCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICBzdHJlYW1SZWYgPSBzdHJlYW07XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ211dGVkJywgJ3RydWUnKTtcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7IC8vIG5vdCBsaXN0ZWQgb24gTUROLi4uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgdmlkZW8ucGxheSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIHBsYXkgdmlkZW8gc3RyZWFtOicsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3YWl0Rm9yVmlkZW8odmlkZW8pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB7XG4gICAgLy8gUmVtb3ZlIGRlcHJlY2F0ZWQgcHJvcGVydGllcyAoZmFjaW5nLCBtaW5Bc3BlY3RSYXRpbywgbWF4QXNwZWN0UmF0aW8pIHdoaWxlXG4gICAgLy8gcHJlc2VydmluZyBhbGwgdmFsaWQgTWVkaWFUcmFja0NvbnN0cmFpbnRzIGluY2x1ZGluZyBhZHZhbmNlZCwgem9vbSwgdG9yY2gsIGV0Yy5cbiAgICBjb25zdCBub3JtYWxpemVkOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgPSBvbWl0KHZpZGVvQ29uc3RyYWludHMsIFsnZmFjaW5nJywgJ21pbkFzcGVjdFJhdGlvJywgJ21heEFzcGVjdFJhdGlvJ10pO1xuXG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgJiYgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyA+IDApIHtcbiAgICAgICAgbm9ybWFsaXplZC5hc3BlY3RSYXRpbyA9IHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW87XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ21pbkFzcGVjdFJhdGlvXFwnIGlzIGRlcHJlY2F0ZWQ7IFVzZSBcXCdhc3BlY3RSYXRpb1xcJyBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5mYWNpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuZmFjaW5nTW9kZSA9IHZpZGVvQ29uc3RyYWludHMuZmFjaW5nO1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogQ29uc3RyYWludCBcXCdmYWNpbmdcXCcgaXMgZGVwcmVjYXRlZC4gVXNlIFxcJ2ZhY2luZ01vZGVcXCcgaW5zdGVhZFxcJycpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gVE9ETzogIzE5MiBJIGRvbid0IHRoaW5rIHRoZXJlJ3MgYW55IGdvb2QgcmVhc29uIHBpY2tDb25zdHJhaW50cyBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSxcbi8vIEkgdGhpbmsgaXQgd2FzIGp1c3QgdGhhdCB3YXkgc28gaXQgY291bGQgYmUgY2hhaW5lZCB0byBvdGhlciBmdW5jdGlvbnMgdGhhdCBkaWQgcmV0dXJuIGEgUHJvbWlzZS5cbi8vIFRoYXQncyBub3QgbmVjZXNzYXJ5IHdpdGggYXN5bmMgZnVuY3Rpb25zIGJlaW5nIGEgdGhpbmcsIHNvIHRoYXQgc2hvdWxkIGJlIGZpeGVkLlxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCA9IHt9KTogUHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPiB7XG4gICAgY29uc3QgdmlkZW8gPSBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG5cbiAgICBpZiAodmlkZW8gJiYgdmlkZW8uZGV2aWNlSWQgJiYgdmlkZW8uZmFjaW5nTW9kZSkge1xuICAgICAgICBkZWxldGUgdmlkZW8uZmFjaW5nTW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGF1ZGlvOiBmYWxzZSwgdmlkZW8gfSk7XG59XG5cbi8qKlxuICogRW51bWVyYXRlcyB2aWRlbyBpbnB1dCBkZXZpY2VzLCBvcHRpb25hbGx5IGZpbHRlcmluZyBieSBjb25zdHJhaW50cy5cbiAqIEBwYXJhbSB2aWRlb0NvbnN0cmFpbnRzIE9wdGlvbmFsIGNvbnN0cmFpbnRzIHRvIGZpbHRlciBkZXZpY2VzLlxuICogV2hlbiBwcm92aWRlZCwgb25seSBkZXZpY2VzIHRoYXQgc2F0aXNmeSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2lsbCBiZSByZXR1cm5lZC5cbiAqIFRoaXMgd29ya3MgYnkgYXR0ZW1wdGluZyB0byBnZXQgYSBtZWRpYSBzdHJlYW0gZm9yIGVhY2ggZGV2aWNlIHdpdGggdGhlIGNvbnN0cmFpbnRzXG4gKiBhbmQgcmV0dXJuaW5nIG9ubHkgdGhlIGRldmljZXMgdGhhdCBzdWNjZWVkLlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgTWVkaWFEZXZpY2VJbmZvIGZvciB2aWRlbyBpbnB1dCBkZXZpY2VzLlxuICovXG5hc3luYyBmdW5jdGlvbiBlbnVtZXJhdGVWaWRlb0RldmljZXMoXG4gICAgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkLFxuKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IGVudW1lcmF0ZURldmljZXMoKTtcbiAgICBjb25zdCB2aWRlb0RldmljZXMgPSBkZXZpY2VzLmZpbHRlcigoZGV2aWNlOiBNZWRpYURldmljZUluZm8pID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpO1xuXG4gICAgLy8gSWYgbm8gY29uc3RyYWludHMgYXJlIHByb3ZpZGVkLCByZXR1cm4gYWxsIHZpZGVvIGRldmljZXNcbiAgICBpZiAoIXZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIHZpZGVvRGV2aWNlcztcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgZGV2aWNlcyBiYXNlZCBvbiBjb25zdHJhaW50cyBieSB0cnlpbmcgdG8gZ2V0IGEgbWVkaWEgc3RyZWFtIGZvciBlYWNoXG4gICAgY29uc3QgY29uc3RyYWluZWREZXZpY2VzOiBBcnJheTxNZWRpYURldmljZUluZm8+ID0gW107XG5cbiAgICAvLyBQcm9jZXNzIGNvbnN0cmFpbnRzIGJ1dCBleGNsdWRlIGRldmljZUlkIHNpbmNlIHdlJ2xsIHNldCBpdCBvdXJzZWx2ZXMgZm9yIGVhY2ggZGV2aWNlXG4gICAgY29uc3QgcHJvY2Vzc2VkQ29uc3RyYWludHMgPSBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNvbnN0IHsgZGV2aWNlSWQ6IF8sIC4uLmNvbnN0cmFpbnRzV2l0aG91dERldmljZUlkIH0gPSBwcm9jZXNzZWRDb25zdHJhaW50cztcblxuICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIHZpZGVvRGV2aWNlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnN0cmFpbnRzV2l0aG91dERldmljZUlkLFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlLmRldmljZUlkIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgICAgICAgLy8gU3RvcCBhbGwgdHJhY2tzIGltbWVkaWF0ZWx5IGFmdGVyIHRlc3RpbmdcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICAgIGNvbnN0cmFpbmVkRGV2aWNlcy5wdXNoKGRldmljZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gRGV2aWNlIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgY29uc3RyYWludHMsIHNraXAgaXQuXG4gICAgICAgICAgICAvLyBUaGlzIGNhdGNoIGlzIGludGVudGlvbmFsbHkgZW1wdHkgYXMgd2UncmUgdXNpbmcgZ2V0VXNlck1lZGlhIHRvIHRlc3QgaWZcbiAgICAgICAgICAgIC8vIGVhY2ggZGV2aWNlIHN1cHBvcnRzIHRoZSBjb25zdHJhaW50cy4gRXJyb3JzIGhlcmUgaW5kaWNhdGUgdGhlIGRldmljZVxuICAgICAgICAgICAgLy8gZG9lc24ndCBtZWV0IHRoZSByZXF1aXJlbWVudHMgKE92ZXJjb25zdHJhaW5lZEVycm9yKSBvciBvdGhlciBpc3N1ZXNcbiAgICAgICAgICAgIC8vIHRoYXQgbWVhbiB3ZSBzaG91bGQgZXhjbHVkZSB0aGlzIGRldmljZSBmcm9tIHRoZSByZXN1bHRzLlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnN0cmFpbmVkRGV2aWNlcztcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlVHJhY2soKTogTWVkaWFTdHJlYW1UcmFjayB8IG51bGwge1xuICAgIGlmICghc3RyZWFtUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICByZXR1cm4gdHJhY2tzICYmIHRyYWNrcz8ubGVuZ3RoID8gdHJhY2tzWzBdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3RpdmUgTWVkaWFTdHJlYW0sIG9yIG51bGwgaWYgbm8gc3RyZWFtIGlzIGFjdGl2ZS5cbiAqIFVzZSB0aGlzIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIHRoZSBmdWxsIHN0cmVhbSwgZm9yIGV4YW1wbGUgdG8gcGFzcyB0byBXZWJSVENcbiAqIG9yIHRvIGNsb25lIHRoZSBzdHJlYW0uIEZvciBqdXN0IHRoZSB2aWRlbyB0cmFjaywgdXNlIGdldEFjdGl2ZVRyYWNrKCkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFRoZSBhY3RpdmUgTWVkaWFTdHJlYW0sIG9yIG51bGwgaWYgbm8gY2FtZXJhIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZVN0cmVhbSgpOiBNZWRpYVN0cmVhbSB8IG51bGwge1xuICAgIHJldHVybiBzdHJlYW1SZWYgPz8gbnVsbDtcbn1cblxuLyoqXG4gKiBVc2VkIGZvciBhY2Nlc3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjdGl2ZSBzdHJlYW0gdHJhY2sgYW5kIGF2YWlsYWJsZSB2aWRlbyBkZXZpY2VzLlxuICovXG5jb25zdCBRdWFnZ2FKU0NhbWVyYUFjY2VzczogQ2FtZXJhQWNjZXNzVHlwZSA9IHtcbiAgICByZXF1ZXN0ZWRWaWRlb0VsZW1lbnQ6IG51bGwsXG4gICAgYXN5bmMgcmVxdWVzdCh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIHZpZGVvQ29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudCA9IHZpZGVvO1xuICAgICAgICBjb25zdCBuZXdDb25zdHJhaW50cyA9IGF3YWl0IHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgcmV0dXJuIGluaXRDYW1lcmEodmlkZW8sIG5ld0NvbnN0cmFpbnRzKTtcbiAgICB9LFxuICAgIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZiAmJiBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50LnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW1SZWYgPSBudWxsO1xuICAgICAgICAgICAgICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxuICAgIGdldEFjdGl2ZVN0cmVhbSxcbiAgICBnZXRBY3RpdmVTdHJlYW1MYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmxhYmVsIDogJyc7XG4gICAgfSxcbiAgICBnZXRBY3RpdmVUcmFjayxcbiAgICBhc3luYyBkaXNhYmxlVG9yY2goKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGFjcXVpcmUgY2FtZXJhIGFjY2VzcyBldmVuIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBjYW1lcmEgb3Blbj9cbiAgICAgICAgLy8gVE9ETzogd2hhdCBoYXBwZW5zIG9uIGlPUyBvciBhbm90aGVyIGRldmljZSB3aGVyZSB0b3JjaCBpc24ndCBzdXBwb3J0ZWQgYXQgYWxsPyBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3I/XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFjay5hcHBseUNvbnN0cmFpbnRzKHsgYWR2YW5jZWQ6IFt7IHRvcmNoOiBmYWxzZSB9XSB9IGFzIE1lZGlhVHJhY2tDb25zdHJhaW50U2V0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBPdmVyY29uc3RyYWluZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3F1YWdnYTIvQ2FtZXJhQWNjZXNzOiBUb3JjaCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZW5hYmxlVG9yY2goKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGFjcXVpcmUgY2FtZXJhIGFjY2VzcyBldmVuIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBjYW1lcmEgb3Blbj9cbiAgICAgICAgLy8gVE9ETzogd2hhdCBoYXBwZW5zIG9uIGlPUyBvciBhbm90aGVyIGRldmljZSB3aGVyZSB0b3JjaCBpc24ndCBzdXBwb3J0ZWQgYXQgYWxsPyBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3I/XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFjay5hcHBseUNvbnN0cmFpbnRzKHsgYWR2YW5jZWQ6IFt7IHRvcmNoOiB0cnVlIH1dIH0gYXMgTWVkaWFUcmFja0NvbnN0cmFpbnRTZXQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIE92ZXJjb25zdHJhaW5lZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncXVhZ2dhMi9DYW1lcmFBY2Nlc3M6IFRvcmNoIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzO1xuIiwiaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCB0eXBlIHtcbiAgICBRdWFnZ2FKU0NvZGVSZXN1bHQsXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IsXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3JGaWx0ZXJGdW5jdGlvbixcbiAgICBYWVNpemUsXG4gICAgUXVhZ2dhSW1hZ2VEYXRhLFxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuZnVuY3Rpb24gY29udGFpbnMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LCBsaXN0OiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGxpc3QgJiYgbGlzdC5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKSBhcyBBcnJheTxrZXlvZiBRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xuICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoa2V5KSA9PiBpdGVtW2tleV0gPT09IGNvZGVSZXN1bHRba2V5XSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhc3Nlc0ZpbHRlcihcbiAgICBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsXG4gICAgZmlsdGVyOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uIHwgdW5kZWZpbmVkLFxuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgPyBmaWx0ZXIoY29kZVJlc3VsdCkgOiB0cnVlO1xufVxuXG5pbnRlcmZhY2UgUmVzdWx0Q29sbGVjdG9yIHtcbiAgICBhZGRSZXN1bHQ6IChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpID0+IHZvaWQ7XG4gICAgZ2V0UmVzdWx0czogKCkgPT4gQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0Pjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShjb25maWc6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yKTogUmVzdWx0Q29sbGVjdG9yIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgd2lsbFJlYWRGcmVxdWVudGx5OiAhIWNvbmZpZy53aWxsUmVhZEZyZXF1ZW50bHkgfSkgYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgICAgICBjb25zdCByZXN1bHRzOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+ID0gW107XG4gICAgICAgIGxldCBjYXBhY2l0eSA9IGNvbmZpZy5jYXBhY2l0eSA/PyAyMDtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgICAgIHJldHVybiAhIWNhcGFjaXR5XG4gICAgICAgICAgICAgICAgJiYgY29kZVJlc3VsdFxuICAgICAgICAgICAgICAgICYmICFjb250YWlucyhjb2RlUmVzdWx0LCBjb25maWcuYmxhY2tsaXN0IGFzIEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFJlc3VsdChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IGFueSA9IHsgfTsgLy8gdGhpcyBpcyAnYW55JyB0byBhdm9pZCBoYXZpbmcgdG8gY29uc3RydWN0IGEgd2hvbGUgUXVhZ2dhSlNDb2RlUmVzdWx0IDp8XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eS0tO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCA9IGNvZGVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZVNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdWx0cygpOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBEZXZDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgLy8gb3IgdXNlclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgICAgICB9LFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgICAgICAvLyBib3JkZXJDb2xvcjogJ3JnYmEoMCwgMjU1LCAwLCAwLjUpJywgLy8gdW5jb21tZW50IHRvIGRyYXcgYXJlYSBib3JkZXJcbiAgICAgICAgICAgIC8vIGJvcmRlcldpZHRoOiAyLCAvLyB1bmNvbW1lbnQgdG8gZHJhdyBhcmVhIGJvcmRlclxuICAgICAgICAgICAgLy8gYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAyNTUsIDAsIDAuMSknLCAvLyB1bmNvbW1lbnQgdG8gdGludCB0aGUgc2NhbiBhcmVhXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBzaG93SW1hZ2VEZXRhaWxzOiBmYWxzZSwgLy8gbG9ncyBmcmFtZSBncmFiYmVyIGluZm8sIGNhbnZhcyBzaXplIGFkanVzdG1lbnRzXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgY2FudmFzOiB7XG4gICAgICAgIGNyZWF0ZU92ZXJsYXk6IHRydWUsIC8vIHNldCB0byBmYWxzZSB0byBza2lwIGNyZWF0aW5nIG92ZXJsYXkgY2FudmFzIChkcmF3aW5nQnVmZmVyKVxuICAgIH0sXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIGRyYXdCb3VuZGluZ0JveDogZmFsc2UsXG4gICAgICAgICAgICBzaG93RnJlcXVlbmN5OiBmYWxzZSxcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0dGVybjogZmFsc2UsXG4gICAgICAgICAgICBwcmludFJlYWRlckluZm86IGZhbHNlLCAvLyBsb2dzIHJlYWRlciByZWdpc3RyYXRpb24gYW5kIGluaXRpYWxpemF0aW9uXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBzaG93Q2FudmFzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGb3VuZFBhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1NrZWxldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dSZW1haW5pbmdQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hTaXplOiBmYWxzZSwgLy8gbG9ncyBjYWxjdWxhdGVkIHBhdGNoIHNpemVcbiAgICAgICAgICAgIHNob3dJbWFnZURldGFpbHM6IGZhbHNlLCAvLyBsb2dzIGltYWdlIHdyYXBwZXIgc2l6ZSwgY2FudmFzIGRldGFpbHNcbiAgICAgICAgICAgIGJveEZyb21QYXRjaGVzOiB7XG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCQjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZXZDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBOb2RlQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxuICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIGNhbnZhczoge1xuICAgICAgICBjcmVhdGVPdmVybGF5OiB0cnVlLCAvLyBzZXQgdG8gZmFsc2UgdG8gc2tpcCBjcmVhdGluZyBvdmVybGF5IGNhbnZhcyAoZHJhd2luZ0J1ZmZlcilcbiAgICB9LFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBQcm9kQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIGNhbnZhczoge1xuICAgICAgICBjcmVhdGVPdmVybGF5OiB0cnVlLCAvLyBzZXQgdG8gZmFsc2UgdG8gc2tpcCBjcmVhdGluZyBvdmVybGF5IGNhbnZhcyAoZHJhd2luZ0J1ZmZlcilcbiAgICB9LFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb2RDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IERldkNvbmZpZyBmcm9tICcuL2NvbmZpZy5kZXYnO1xuaW1wb3J0IE5vZGVDb25maWcgZnJvbSAnLi9jb25maWcubm9kZSc7XG5pbXBvcnQgUHJvZENvbmZpZyBmcm9tICcuL2NvbmZpZy5wcm9kJztcblxuY29uc3QgRXhwb3J0Q29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9ICgoKSA9PiB7XG4gICAgbGV0IFF1YWdnYUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBFTlYgPT09ICd1bmRlZmluZWQnIHx8IEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBRdWFnZ2FDb25maWcgPSBEZXZDb25maWc7XG4gICAgfSBlbHNlIGlmIChFTlYubm9kZSkge1xuICAgICAgICBRdWFnZ2FDb25maWcgPSBOb2RlQ29uZmlnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFF1YWdnYUNvbmZpZyA9IFByb2RDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBRdWFnZ2FDb25maWc7XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBFeHBvcnRDb25maWc7XG4iLCIvLyBOT1RFIEZPUiBBTllPTkUgSU4gSEVSRSBJTiBUSEUgRlVUVVJFOlxuLy8gd2VicGFjay5jb25maWcuanMgcmVwbGFjZXMgdGhlIGZyYW1lX2dyYWJiZXIgbW9kdWxlIHdpdGggVEhJUyBtb2R1bGUgd2hlbiBpdCBpcyBidWlsZGluZyBmb3IgYSBCcm93c2VyIGVudmlyb25tZW50LlxuXG5pbXBvcnQge1xuICAgIGltYWdlUmVmLFxuICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEsXG4gICAgY29tcHV0ZUdyYXksXG59IGZyb20gJy4uL2NvbW1vbi9jdl91dGlscyc7XG5cbmNvbnN0IFRPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG5mdW5jdGlvbiBhZGp1c3RDYW52YXNTaXplKGNhbnZhcywgdGFyZ2V0U2l6ZSwgZGVidWcpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB0YXJnZXRTaXplLngpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBkZWJ1Zz8uc2hvd0ltYWdlRGV0YWlscykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGFyZ2V0U2l6ZS54O1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gdGFyZ2V0U2l6ZS55KSB7XG4gICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgZGVidWc/LnNob3dJbWFnZURldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRTaXplLnk7XG4gICAgfVxufVxuXG5jb25zdCBGcmFtZUdyYWJiZXIgPSB7fTtcblxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSwgY2FudmFzKSB7XG4gICAgLy8gY29uc29sZS53YXJuKCcqKiogRnJhbWVHcmFiYmVyQnJvd3NlciBjcmVhdGUnKTtcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xuICAgIGNvbnN0IF9zdHJlYW1Db25maWcgPSBpbnB1dFN0cmVhbS5nZXRDb25maWcoKTtcbiAgICBjb25zdCBfdmlkZW9TaXplID0gaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0UmVhbFdpZHRoKCksIGlucHV0U3RyZWFtLmdldFJlYWxIZWlnaHQoKSk7XG4gICAgY29uc3QgX2NhbnZhc1NpemUgPSBpbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCk7XG4gICAgY29uc3QgX3NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSk7XG4gICAgY29uc3QgdG9wUmlnaHQgPSBpbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpO1xuICAgIGNvbnN0IF9zeCA9IHRvcFJpZ2h0Lng7XG4gICAgY29uc3QgX3N5ID0gdG9wUmlnaHQueTtcbiAgICBsZXQgX2NhbnZhcztcbiAgICBsZXQgX2N0eCA9IG51bGw7XG4gICAgbGV0IF9kYXRhID0gbnVsbDtcbiAgICBjb25zdCB7IHdpbGxSZWFkRnJlcXVlbnRseSB9ID0gX3N0cmVhbUNvbmZpZztcblxuICAgIF9jYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhcy53aWR0aCA9IF9jYW52YXNTaXplLng7XG4gICAgX2NhbnZhcy5oZWlnaHQgPSBfY2FudmFzU2l6ZS55O1xuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX3N0cmVhbUNvbmZpZy5kZWJ1Zz8uc2hvd0ltYWdlRGV0YWlscykge1xuICAgICAgICBjb25zb2xlLndhcm4oJyoqKiBmcmFtZV9ncmFiYmVyX2Jyb3dzZXI6IHdpbGxSZWFkRnJlcXVlbnRseT0nLCB3aWxsUmVhZEZyZXF1ZW50bHksICdjYW52YXM9JywgX2NhbnZhcyk7XG4gICAgfVxuICAgIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoJzJkJywgeyB3aWxsUmVhZEZyZXF1ZW50bHk6ICEhd2lsbFJlYWRGcmVxdWVudGx5IH0pOyAvLyBkb3VibGUgbm90IGJlY2F1c2Ugd2UgaGF2ZSBhbiBvcHRpb25hbCBib29sIHRoYXQgbmVlZHMgdG8gcGFzcyBhcyBhIGJvb2xcbiAgICBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9zdHJlYW1Db25maWcuZGVidWc/LnNob3dJbWFnZURldGFpbHMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpemU6IF9zaXplLFxuICAgICAgICAgICAgdG9wUmlnaHQsXG4gICAgICAgICAgICB2aWRlb1NpemU6IF92aWRlb1NpemUsXG4gICAgICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzU2l6ZSxcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIGdpdmVuIGFycmF5IGFzIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhO1xuICAgIH07XG5cbiAgICAvLyBCaWxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciBncmF5c2NhbGUgZGF0YSAodG8gbWF0Y2ggTm9kZSdzIGJlaGF2aW9yKVxuICAgIGZ1bmN0aW9uIGJpbGluZWFySW50ZXJwb2xhdGUoZ3JheURhdGEsIHdpZHRoLCBoZWlnaHQsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgeDAgPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICBjb25zdCB5MCA9IE1hdGguZmxvb3IoeSk7XG4gICAgICAgIGNvbnN0IHgxID0gTWF0aC5taW4oeDAgKyAxLCB3aWR0aCAtIDEpO1xuICAgICAgICBjb25zdCB5MSA9IE1hdGgubWluKHkwICsgMSwgaGVpZ2h0IC0gMSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmeCA9IHggLSB4MDtcbiAgICAgICAgY29uc3QgZnkgPSB5IC0geTA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB2MDAgPSBncmF5RGF0YVt5MCAqIHdpZHRoICsgeDBdO1xuICAgICAgICBjb25zdCB2MTAgPSBncmF5RGF0YVt5MCAqIHdpZHRoICsgeDFdO1xuICAgICAgICBjb25zdCB2MDEgPSBncmF5RGF0YVt5MSAqIHdpZHRoICsgeDBdO1xuICAgICAgICBjb25zdCB2MTEgPSBncmF5RGF0YVt5MSAqIHdpZHRoICsgeDFdO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdjAgPSB2MDAgKiAoMSAtIGZ4KSArIHYxMCAqIGZ4O1xuICAgICAgICBjb25zdCB2MSA9IHYwMSAqICgxIC0gZngpICsgdjExICogZng7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdjAgKiAoMSAtIGZ5KSArIHYxICogZnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZyYW1lIGZyb20gdGhlIGlucHV0LXN0cmVhbSBhbmQgcHV0cyBpbnRvIHRoZSBmcmFtZS1idWZmZXIuXG4gICAgICogVGhlIGltYWdlLWRhdGEgaXMgY29udmVydGVkIHRvIGdyYXktc2NhbGUgYW5kIHRoZW4gaGFsZi1zYW1wbGVkIGlmIGNvbmZpZ3VyZWQuXG4gICAgICogXG4gICAgICogRm9yIGltcHJvdmVkIGFjY3VyYWN5IChtYXRjaGluZyBOb2RlJ3MgcHJvY2Vzc2luZyksIG5vbi1oYWxmLXNhbXBsZWQgaW1hZ2VzXG4gICAgICogdXNlIGJpbGluZWFyIGludGVycG9sYXRpb24gb24gZ3JheXNjYWxlIGRhdGEgaW5zdGVhZCBvZiBzY2FsaW5nIFJHQiB0aGVuIGNvbnZlcnRpbmcuXG4gICAgICogXG4gICAgICogSU1QT1JUQU5UOiBUaGUgaW1hZ2UgaXMgQUxXQVlTIGRyYXduIHRvIHRoZSB2aXNpYmxlIGNhbnZhcyBmb3Igb3ZlcmxheXMgYW5kIGRpc3BsYXkuXG4gICAgICovXG4gICAgX3RoYXQuZ3JhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZG9IYWxmU2FtcGxlID0gX3N0cmVhbUNvbmZpZy5oYWxmU2FtcGxlO1xuICAgICAgICBjb25zdCBmcmFtZSA9IGlucHV0U3RyZWFtLmdldEZyYW1lKCk7XG4gICAgICAgIGxldCBkcmF3YWJsZSA9IGZyYW1lO1xuICAgICAgICBsZXQgZHJhd0FuZ2xlID0gMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChkcmF3YWJsZSkge1xuICAgICAgICAgICAgYWRqdXN0Q2FudmFzU2l6ZShfY2FudmFzLCBfY2FudmFzU2l6ZSwgX3N0cmVhbUNvbmZpZy5kZWJ1Zyk7XG4gICAgICAgICAgICBpZiAoX3N0cmVhbUNvbmZpZy50eXBlID09PSAnSW1hZ2VTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgZHJhd2FibGUgPSBmcmFtZS5pbWc7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRhZ3MgJiYgZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZyYW1lLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSA5MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gLTkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQUxXQVlTIGRyYXcgdG8gdmlzaWJsZSBjYW52YXMgKGZvciBvdmVybGF5cywgZGlzcGxheSwgYW5kIHRvRGF0YVVSTClcbiAgICAgICAgICAgIGlmIChkcmF3QW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBfY3R4LnRyYW5zbGF0ZShfY2FudmFzU2l6ZS54IC8gMiwgX2NhbnZhc1NpemUueSAvIDIpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKGRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIC1fY2FudmFzU2l6ZS55IC8gMiwgLV9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55LCBfY2FudmFzU2l6ZS54KTtcbiAgICAgICAgICAgICAgICBfY3R4LnJvdGF0ZSgtZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LnRyYW5zbGF0ZSgtX2NhbnZhc1NpemUueCAvIDIsIC1fY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAwLCAwLCBfY2FudmFzU2l6ZS54LCBfY2FudmFzU2l6ZS55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRvSGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIEhhbGYtc2FtcGxlIHBhdGg6IHVzZSBleGlzdGluZyBvcHRpbWl6ZWQgYXBwcm9hY2hcbiAgICAgICAgICAgICAgICBjb25zdCBjdHhEYXRhID0gX2N0eC5nZXRJbWFnZURhdGEoX3N4LCBfc3ksIF9zaXplLngsIF9zaXplLnkpLmRhdGE7XG4gICAgICAgICAgICAgICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjdHhEYXRhLCBfc2l6ZSwgX2RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb24taGFsZi1zYW1wbGU6IHVzZSBpbXByb3ZlZCBiaWxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciBiZXR0ZXIgYWNjdXJhY3lcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGF0IG9yaWdpbmFsIHNpemUsIHRoZW4gc2NhbGUgZ3JheXNjYWxlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IF92aWRlb1NpemUueDtcbiAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IF92aWRlb1NpemUueTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChkcmF3QW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC50cmFuc2xhdGUoX3ZpZGVvU2l6ZS54IC8gMiwgX3ZpZGVvU2l6ZS55IC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHgucm90YXRlKGRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAtX3ZpZGVvU2l6ZS55IC8gMiwgLV92aWRlb1NpemUueCAvIDIsIF92aWRlb1NpemUueSwgX3ZpZGVvU2l6ZS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQ3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgMCwgMCwgX3ZpZGVvU2l6ZS54LCBfdmlkZW9TaXplLnkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlIGF0IG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEltYWdlRGF0YSA9IHRlbXBDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIF92aWRlb1NpemUueCwgX3ZpZGVvU2l6ZS55KS5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYXlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3ZpZGVvU2l6ZS54ICogX3ZpZGVvU2l6ZS55KTtcbiAgICAgICAgICAgICAgICBjb21wdXRlR3JheShvcmlnaW5hbEltYWdlRGF0YSwgZ3JheURhdGEsIF9zdHJlYW1Db25maWcpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgZ3JheXNjYWxlIGRhdGEgdXNpbmcgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlZEdyYXlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX2NhbnZhc1NpemUueCAqIF9jYW52YXNTaXplLnkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBTaXplWCA9IF92aWRlb1NpemUueCAvIF9jYW52YXNTaXplLng7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFNpemVZID0gX3ZpZGVvU2l6ZS55IC8gX2NhbnZhc1NpemUueTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IF9jYW52YXNTaXplLnk7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9jYW52YXNTaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjWCA9IHggKiBzdGVwU2l6ZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmNZID0geSAqIHN0ZXBTaXplWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlZEdyYXlEYXRhW3kgKiBfY2FudmFzU2l6ZS54ICsgeF0gPSBiaWxpbmVhckludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXlEYXRhLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlkZW9TaXplLngsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWRlb1NpemUueSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjWCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjWVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ3JvcCB0byB0YXJnZXQgcmVnaW9uXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBfc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBfc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyY0lkeCA9ICh5ICsgX3N5KSAqIF9jYW52YXNTaXplLnggKyAoeCArIF9zeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YVt5ICogX3NpemUueCArIHhdID0gc2NhbGVkR3JheURhdGFbc3JjSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfdGhhdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhhdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyYW1lR3JhYmJlcjtcbiIsIi8vIE5PVEU6IChTT01FIE9GKSBUSElTIElTIEJST1dTRVIgT05MWSBDT0RFLiAgTm9kZSBkb2VzIG5vdCBoYXZlICdhdG9iJyBidWlsdCBpbiwgbm9yIFhNTEh0dHBSZXF1ZXN0LlxuLy8gSG93IGV4YWN0bHkgaXMgdGhpcyBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgaW4gUXVhZ2dhPyBEbyB3ZSBuZWVkIHRoZSBicm93c2VyIHNwZWNpZmljIGNvZGU/IERvIHdlXG4vLyBuZWVkIHRvIHBvcnQgYW55IHBhcnQgb2YgdGhpcyB0aGF0IGRvZXNuJ3Qgd29yayBpbiBOb2RlIHRvIG5vZGU/XG5cbi8vIFRhZ3Mgc2NyYXBlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanNcbmNvbnN0IEV4aWZUYWdzID0geyAweDAxMTI6ICdvcmllbnRhdGlvbicgfTtcbmV4cG9ydCBjb25zdCBBdmFpbGFibGVUYWdzID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLm1hcCgoa2V5KSA9PiBFeGlmVGFnc1trZXldKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5PYmplY3RVUkwoc3JjLCB0YWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGlmICgvXmJsb2I6L2kudGVzdChzcmMpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RVUkxUb0Jsb2Ioc3JjKVxuICAgICAgICAgICAgLnRoZW4ocmVhZFRvQnVmZmVyKVxuICAgICAgICAgICAgLnRoZW4oKGJ1ZmZlcikgPT4gZmluZFRhZ3NJbkJ1ZmZlcihidWZmZXIsIHRhZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoZGF0YVVybCkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGRhdGFVcmwucmVwbGFjZSgvXmRhdGE6KFteO10rKTtiYXNlNjQsL2dtaSwgJycpO1xuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBsZW4gPSBiaW5hcnkubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2aWV3W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIHJlYWRUb0J1ZmZlcihibG9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvYmplY3RVUkxUb0Jsb2IodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBodHRwLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIGh0dHAucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgKGh0dHAuc3RhdHVzID09PSAyMDAgfHwgaHR0cC5zdGF0dXMgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaHR0cC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBodHRwLnNlbmQoKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5CdWZmZXIoZmlsZSwgc2VsZWN0ZWRUYWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGZpbGUpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZpbGUuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBleGlmVGFncyA9IHNlbGVjdGVkVGFncy5yZWR1Y2UoKHJlc3VsdCwgc2VsZWN0ZWRUYWcpID0+IHtcbiAgICAgICAgY29uc3QgZXhpZlRhZyA9IE9iamVjdC5rZXlzKEV4aWZUYWdzKS5maWx0ZXIoKHRhZykgPT4gRXhpZlRhZ3NbdGFnXSA9PT0gc2VsZWN0ZWRUYWcpWzBdO1xuICAgICAgICBpZiAoZXhpZlRhZykge1xuICAgICAgICAgICAgcmVzdWx0W2V4aWZUYWddID0gc2VsZWN0ZWRUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IG1hcmtlcjtcblxuICAgIGlmICgoZGF0YVZpZXcuZ2V0VWludDgoMCkgIT09IDB4RkYpIHx8IChkYXRhVmlldy5nZXRVaW50OCgxKSAhPT0gMHhEOCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICBpZiAobWFya2VyID09PSAweEUxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEVYSUZEYXRhKGRhdGFWaWV3LCBvZmZzZXQgKyA0LCBleGlmVGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkRVhJRkRhdGEoZmlsZSwgc3RhcnQsIGV4aWZUYWdzKSB7XG4gICAgaWYgKGdldFN0cmluZ0Zyb21CdWZmZXIoZmlsZSwgc3RhcnQsIDQpICE9PSAnRXhpZicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBzdGFydCArIDY7XG4gICAgbGV0IGJpZ0VuZDtcblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0OTQ5KSB7XG4gICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NEQ0RCkge1xuICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMkEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gZmlsZS5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpO1xuICAgIGlmIChmaXJzdElGRE9mZnNldCA8IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRhZ3MgPSByZWFkVGFncyhmaWxlLCB0aWZmT2Zmc2V0LCB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQsIGV4aWZUYWdzLCBiaWdFbmQpO1xuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFncyhmaWxlLCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBzdHJpbmdzLCBiaWdFbmQpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gZmlsZS5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpO1xuICAgIGNvbnN0IHRhZ3MgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gZGlyU3RhcnQgKyBpICogMTIgKyAyO1xuICAgICAgICBjb25zdCB0YWcgPSBzdHJpbmdzW2ZpbGUuZ2V0VWludDE2KGVudHJ5T2Zmc2V0LCAhYmlnRW5kKV07XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHJlYWRUYWdWYWx1ZShmaWxlLCBlbnRyeU9mZnNldCwgdGlmZlN0YXJ0LCBkaXJTdGFydCwgYmlnRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpIHtcbiAgICBjb25zdCB0eXBlID0gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyAyLCAhYmlnRW5kKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBmaWxlLmdldFVpbnQzMihlbnRyeU9mZnNldCArIDQsICFiaWdFbmQpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbUJ1ZmZlcihidWZmZXIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBsZXQgb3V0c3RyID0gJyc7XG4gICAgZm9yIChsZXQgbiA9IHN0YXJ0OyBuIDwgc3RhcnQgKyBsZW5ndGg7IG4rKykge1xuICAgICAgICBvdXRzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIuZ2V0VWludDgobikpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0c3RyO1xufVxuIiwiaW1wb3J0IHsgZmluZFRhZ3NJbk9iamVjdFVSTCB9IGZyb20gJy4vZXhpZl9oZWxwZXInO1xuXG4vLyBFeHBvcnRlZCBoZWxwZXIgZm9yIGZpbGVuYW1lIGdlbmVyYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlRmlsZW5hbWUoZGlyZWN0b3J5LCBudW0pIHtcbiAgICByZXR1cm4gYCR7ZGlyZWN0b3J5fWltYWdlLSR7bnVtLnRvU3RyaW5nKCkucGFkU3RhcnQoMywgJzAnKX0uanBnYDtcbn1cblxuY29uc3QgSW1hZ2VMb2FkZXIgPSB7fTtcbkltYWdlTG9hZGVyLmxvYWQgPSBmdW5jdGlvbiAoZGlyZWN0b3J5LCBjYWxsYmFjaywgb2Zmc2V0LCBzaXplLCBzZXF1ZW5jZSwgY29uZmlnKSB7XG4gICAgY29uc3QgaHRtbEltYWdlc1NyY0FycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGNvbnN0IGh0bWxJbWFnZXNBcnJheSA9IG5ldyBBcnJheShodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgaW1nO1xuICAgIGxldCBudW07XG5cbiAgICBpZiAoc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVswXSA9IGRpcmVjdG9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudW0gPSAob2Zmc2V0ICsgaSk7XG4gICAgICAgICAgICBodG1sSW1hZ2VzU3JjQXJyYXlbaV0gPSBnZW5lcmF0ZUltYWdlRmlsZW5hbWUoZGlyZWN0b3J5LCBudW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQgPSBbXTtcbiAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZC5wdXNoKGltYWdlKTtcbiAgICB9O1xuICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQgPSBmdW5jdGlvbiAobG9hZGVkSW1nKSB7XG4gICAgICAgIGNvbnN0IG5vdGxvYWRlZEltZ3MgPSBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5vdGxvYWRlZEltZ3MubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChub3Rsb2FkZWRJbWdzW3hdID09PSBsb2FkZWRJbWcpIHtcbiAgICAgICAgICAgICAgICBub3Rsb2FkZWRJbWdzLnNwbGljZSh4LCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZW5jb2RlVVJJIGZvciBtYXRjaGluZyBmaWxlbmFtZXMgd2l0aCBzcGFjZXMgYW5kIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdOYW1lID0gZW5jb2RlVVJJKGh0bWxJbWFnZXNTcmNBcnJheVt5XS5zdWJzdHIoaHRtbEltYWdlc1NyY0FycmF5W3ldLmxhc3RJbmRleE9mKCcvJykpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZEltZy5zcmMubGFzdEluZGV4T2YoaW1nTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7IGltZzogbG9hZGVkSW1nIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90bG9hZGVkSW1ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnPy5kZWJ1Zz8uc2hvd0ltYWdlRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJbWFnZXMgbG9hZGVkOiAke2h0bWxJbWFnZXNBcnJheS5sZW5ndGh9IGltYWdlJHtodG1sSW1hZ2VzQXJyYXkubGVuZ3RoICE9PSAxID8gJ3MnIDogJyd9IGZyb20gJHtzZXF1ZW5jZSA9PT0gZmFsc2UgPyBkaXJlY3RvcnkgOiBkaXJlY3RvcnkgKyAnIChzZXF1ZW5jZSknfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0YWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbMF0udGFncyA9IHRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UoaW1nKTtcbiAgICAgICAgYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSkge1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XG4gICAgfTtcbiAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCh0aGlzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCAoSW1hZ2VMb2FkZXIpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG5pbXBvcnQgSW1hZ2VMb2FkZXIgZnJvbSAnLi4vaW1hZ2VfbG9hZGVyJztcbmltcG9ydCB7IFhZU2l6ZSwgUG9pbnQgfSBmcm9tICcuLi8uLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCB7IElucHV0U3RyZWFtRmFjdG9yeSwgSW5wdXRTdHJlYW0sIEV2ZW50SGFuZGxlckxpc3QgfSBmcm9tICcuL2lucHV0X3N0cmVhbS5kJztcblxuY29uc3QgaW5wdXRTdHJlYW1GYWN0b3J5OiBJbnB1dFN0cmVhbUZhY3RvcnkgPSB7XG4gICAgY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGNvbnNvbGUud2FybignKioqKiBJbnB1dFN0cmVhbUJyb3dzZXIgY3JlYXRlVmlkZW9TdHJlYW0nKTtcbiAgICAgICAgbGV0IF9jb25maWc6IHsgc2l6ZTogbnVtYmVyOyB0eXBlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGxldCBfY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBfY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfdG9wUmlnaHQ6IFBvaW50ID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnUG9pbnQnIH07XG4gICAgICAgIGNvbnN0IF9jYW52YXNTaXplOiBYWVNpemUgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdYWVNpemUnIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFNpemUoKTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcblxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgX2NhbGN1bGF0ZWRIZWlnaHQgPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gTWF0aC5mbG9vcigoaGVpZ2h0IC8gd2lkdGgpICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcblxuICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IF9jYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gX2NhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJywgKHR5cGVvZiBjb25maWcuc3JjICE9PSAndW5kZWZpbmVkJykgPyBjb25maWcuc3JjIDogJycpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLmVuZGVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2NvbmZpZz8udHlwZSAhPT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjdXJyZW50VGltZScsIHRpbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYsIGJvb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBfZXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0cmlnZ2VyKGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnY2FucmVjb3JkJykge1xuICAgICAgICAgICAgICAgICAgICBpbml0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHNpemUpIHtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gc2l6ZS54O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBzaXplLnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnB1dFN0cmVhbTtcbiAgICB9LFxuICAgIGNyZWF0ZUxpdmVTdHJlYW0odmlkZW8pOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGNvbnNvbGUud2FybignKioqKiBJbnB1dFN0cmVhbUJyb3dzZXIgY3JlYXRlTGl2ZVN0cmVhbScpO1xuICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoYXQgPSBpbnB1dFN0cmVhbUZhY3RvcnkuY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pO1xuICAgICAgICB0aGF0LmVuZGVkID0gZnVuY3Rpb24gZW5kZWQoKTogZmFsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIGNyZWF0ZUltYWdlU3RyZWFtKCk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVJbWFnZVN0cmVhbScpO1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHNlcXVlbmNlOiBhbnkgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xuICAgICAgICBsZXQgZnJhbWVJZHggPSAwO1xuICAgICAgICBsZXQgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW1nQXJyYXk6IGFueVtdIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMTtcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkSW1hZ2VzKCk6IHZvaWQge1xuICAgICAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBJbWFnZUxvYWRlci5sb2FkKGJhc2VVcmwsIChpbWdzOiBBcnJheTx7IHRhZ3M6IGFueTsgaW1nOiBIVE1MSW1hZ2VFbGVtZW50fT4pID0+IHtcbiAgICAgICAgICAgICAgICBpbWdBcnJheSA9IGltZ3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChpbWdzWzBdLnRhZ3MgJiYgaW1nc1swXS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpIDogd2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IDA7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KCdjYW5yZWNvcmQnLCBbXSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9LCBvZmZzZXQsIHNpemUsIF9jb25maWc/LnNlcXVlbmNlLCBfY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hFdmVudChldmVudE5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55Pik6IHZvaWQge1xuICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MgYXMgYW55KTsgLy8gVE9ETzogdHlwZXNjcmlwdCBjb21wbGFpbnMgdGhhdCBhbnlbXSBpcyBub3QgdmFsaWQgZm9yIGEgc2Vjb25kIGFyZyBmb3IgYXBwbHk/IVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFueSBjb2RlIHNoYXJlZCB3aXRoIHRoZSBmaXJzdCBJbnB1dFN0cmVhbSBhYm92ZSBzaG91bGQgYmUgc2hhcmVkIG5vdCBjb3BpZWRcbiAgICAgICAgLy8gVE9ETzogcHVibGlzaEV2ZW50IG5lZWRzIGFjY2VzcyB0byBpbnB1dFN0cmVhbSwgYnV0IGlucHV0U3RyZWFtIG5lZWRzIGFjY2VzcyB0byBwdWJsaXNoRXZlbnRcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyB3aHkgaXQncyBhICd2YXInLCBzbyBpdCBob2lzdHMgYmFjay4gIFRoaXMgaXMgdWdseSwgYW5kIHNob3VsZCBiZSBjaGFuZ2VkLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXG4gICAgICAgIHZhciBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG5cbiAgICAgICAgICAgIHRyaWdnZXI6IHB1Ymxpc2hFdmVudCxcblxuICAgICAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKG5ld1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQobmV3SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRJbnB1dFN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBzdHJlYW0uc3JjO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9hZEltYWdlcygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZGVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKCkge30sXG5cbiAgICAgICAgICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhdXNlKCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwbGF5KCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gdGltZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50SGFuZGxlcnMpLmZvckVhY2goKGluZCkgPT4gZGVsZXRlIF9ldmVudEhhbmRsZXJzW2luZF0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYW52YXNTaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbnZhc1NpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBpbWdBcnJheT8uW2ZyYW1lSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSWR4IDwgKHNpemUgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZHgrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2VuZGVkJywgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnB1dFN0cmVhbUZhY3Rvcnk7XG4iLCIvKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgVHJhY2VyID0ge1xuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgeyBzZWFyY2hEaXJlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGxldCBwb3M7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgeDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC5jeSArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XG4gICAgICAgICAgICAgICAgcG9zID0geSAqIHdpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBpZiAoKGltYWdlRGF0YVtwb3NdID09PSBjb2xvcikgJiYgKChsYWJlbERhdGFbcG9zXSA9PT0gMCkgfHwgKGxhYmVsRGF0YVtwb3NdID09PSBsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGVkZ2VsYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyAxKSAlIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJ0ZXgyRCh4LCB5LCBkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgbGV0IEZ2ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBDdjtcbiAgICAgICAgICAgIGxldCBQO1xuICAgICAgICAgICAgbGV0IGxkaXI7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIGN4OiBzeCxcbiAgICAgICAgICAgICAgICBjeTogc3ksXG4gICAgICAgICAgICAgICAgZGlyOiAwLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSkge1xuICAgICAgICAgICAgICAgIEZ2ID0gdmVydGV4MkQoc3gsIHN5LCBjdXJyZW50LmRpcik7XG4gICAgICAgICAgICAgICAgQ3YgPSBGdjtcbiAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgQ3YgPSBQO1xuXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsUGl4ZWxDb3VudCA9IGltYWdlV3JhcHBlci5zaXplLnggKiBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgICAgICAgICAgICAgIGxldCBwaXhlbENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyA2KSAlIDg7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxkaXIgIT09IGN1cnJlbnQuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gbGRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnggPSBjdXJyZW50LmN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueSA9IGN1cnJlbnQuY3k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjdXJyZW50LmN4ICE9PSBzeCB8fCBjdXJyZW50LmN5ICE9PSBzeSkgJiYgKytwaXhlbENvdW50ZXIgPCB0b3RhbFBpeGVsQ291bnQpO1xuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKFRyYWNlcik7XG4iLCJpbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcblxuLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbmNvbnN0IFJhc3Rlcml6ZXIgPSB7XG4gICAgY3JlYXRlQ29udG91cjJEKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlyOiBudWxsLFxuICAgICAgICAgICAgaW5kZXg6IG51bGwsXG4gICAgICAgICAgICBmaXJzdFZlcnRleDogbnVsbCxcbiAgICAgICAgICAgIGluc2lkZUNvbnRvdXJzOiBudWxsLFxuICAgICAgICAgICAgbmV4dHBlZXI6IG51bGwsXG4gICAgICAgICAgICBwcmV2cGVlcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIENPTlRPVVJfRElSOiB7XG4gICAgICAgIENXX0RJUjogMCxcbiAgICAgICAgQ0NXX0RJUjogMSxcbiAgICAgICAgVU5LTk9XTl9ESVI6IDIsXG4gICAgfSxcbiAgICBESVI6IHtcbiAgICAgICAgT1VUU0lERV9FREdFOiAtMzI3NjcsXG4gICAgICAgIElOU0lERV9FREdFOiAtMzI3NjYsXG4gICAgfSxcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgICAgIGNvbnN0IHRyYWNlciA9IFRyYWNlci5jcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXN0ZXJpemUoZGVwdGhsYWJlbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2xvcjtcbiAgICAgICAgICAgICAgICBsZXQgYmM7XG4gICAgICAgICAgICAgICAgbGV0IGxjO1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgIGxldCBjeDtcbiAgICAgICAgICAgICAgICBsZXQgY3k7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JNYXAgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4O1xuICAgICAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgICAgIGxldCBjYztcbiAgICAgICAgICAgICAgICBsZXQgc2M7XG4gICAgICAgICAgICAgICAgbGV0IHBvcztcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQwMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xvck1hcFswXSA9IGltYWdlRGF0YVswXTtcbiAgICAgICAgICAgICAgICBjYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjeSA9IDE7IGN5IDwgaGVpZ2h0IC0gMTsgY3krKykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjeCA9IDE7IGN4IDwgd2lkdGggLSAxOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeSAqIHdpZHRoICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPT0gYmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY29ubmVjdGVkQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbbGNdID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgbGMsIGNvbG9yLCBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aGxhYmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBzYy5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjLmluc2lkZUNvbnRvdXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYy5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNjLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY29ubmVjdGVkQ291bnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgIGRyYXdDb250b3VyKGNhbnZhcywgZmlyc3RDb250b3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHEgPSBmaXJzdENvbnRvdXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGlxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcSA9IHBxLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocS5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHEuZmlyc3RWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocCAhPT0gcS5maXJzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUmFzdGVyaXplcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbi8qIEBwcmVzZXJ2ZSBBU00gQkVHSU4gKi9cbi8qKlxuICogTW9ycGhvbG9naWNhbCBza2VsZXRvbml6YXRpb24gdXNpbmcgaXRlcmF0aXZlIHRoaW5uaW5nIGFsZ29yaXRobS5cbiAqIFJlZHVjZXMgYmluYXJ5IGltYWdlcyB0byBzaW5nbGUtcGl4ZWwtd2lkZSBza2VsZXRvbnMgd2hpbGUgcHJlc2VydmluZyB0b3BvbG9neS5cbiAqXG4gKiBNZW1vcnkgbGF5b3V0IGluIHNoYXJlZCBBcnJheUJ1ZmZlciAoNCByZWdpb25zIG9mIHNpemXCsik6XG4gKiAtIFJlZ2lvbiAwOiBXb3JraW5nIGltYWdlIChzdWJJbWFnZVB0ciA9IDApXG4gKiAtIFJlZ2lvbiAxOiBFcm9kZWQgcmVzdWx0IChlcm9kZWRJbWFnZVB0ciA9IHNpemXCsilcbiAqIC0gUmVnaW9uIDI6IFRlbXAvc2NyYXRjaCBzcGFjZSAodGVtcEltYWdlUHRyID0gMipzaXplwrIpXG4gKiAtIFJlZ2lvbiAzOiBGaW5hbCBza2VsZXRvbiBvdXRwdXQgKHNrZWxJbWFnZVB0ciA9IDMqc2l6ZcKyKVxuICovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgICAndXNlIGFzbSc7XG5cbiAgICB2YXIgaW1hZ2VzID0gbmV3IHN0ZGxpYi5VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgdmFyIHNpemUgPSBmb3JlaWduLnNpemUgfCAwO1xuICAgIHZhciBpbXVsID0gc3RkbGliLk1hdGguaW11bDtcblxuICAgIC8qKlxuICAgICAqIE1vcnBob2xvZ2ljYWwgZXJvc2lvbiB3aXRoIDUtcGl4ZWwgY3Jvc3Mgc3RydWN0dXJpbmcgZWxlbWVudC5cbiAgICAgKiBBIHBpeGVsIHN1cnZpdmVzIG9ubHkgaWYgYWxsIDUgcGl4ZWxzIGluIHRoZSBjcm9zcyBwYXR0ZXJuIGFyZSBzZXQ6XG4gICAgICogdG9wLWxlZnQsIHRvcC1yaWdodCwgY2VudGVyLCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgPSBpbkltYWdlUHRyIHwgMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgPSBvdXRJbWFnZVB0ciB8IDA7XG5cbiAgICAgICAgdmFyIHYgPSAwO1xuICAgICAgICB2YXIgdSA9IDA7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgeVN0YXJ0MSA9IDA7XG4gICAgICAgIHZhciB5U3RhcnQyID0gMDtcbiAgICAgICAgdmFyIHhTdGFydDEgPSAwO1xuICAgICAgICB2YXIgeFN0YXJ0MiA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgLy8gUGl4ZWwgc3Vydml2ZXMgZXJvc2lvbiBvbmx5IGlmIGFsbCA1IGNyb3NzIG5laWdoYm9ycyBhcmUgc2V0XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA9PSAoNSB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGl4ZWwtd2lzZSBzdWJ0cmFjdGlvbjogb3V0ID0gYSAtIGIgKGNhcHR1cmVzIHRoZSBcInBlZWxlZFwiIGxheWVyKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgPSBhSW1hZ2VQdHIgfCAwO1xuICAgICAgICBiSW1hZ2VQdHIgPSBiSW1hZ2VQdHIgfCAwO1xuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgLSAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGl4ZWwtd2lzZSBPUjogb3V0ID0gYSB8IGIgKGFjY3VtdWxhdGVzIHNrZWxldG9uIGxheWVycylcbiAgICBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciA9IGFJbWFnZVB0ciB8IDA7XG4gICAgICAgIGJJbWFnZVB0ciA9IGJJbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSB8IChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb3VudHMgbm9uLXplcm8gcGl4ZWxzIHRvIGRldGVjdCB3aGVuIGVyb3Npb24gaXMgY29tcGxldGVcbiAgICBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgPSBpbWFnZVB0ciB8IDA7XG5cbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgc3VtID0gKChzdW0gfCAwKSArIChpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoc3VtIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmlsbHMgaW1hZ2UgcmVnaW9uIHdpdGggYSBjb25zdGFudCB2YWx1ZVxuICAgIGZ1bmN0aW9uIGluaXQoaW1hZ2VQdHIsIHZhbHVlKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHwgMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1vcnBob2xvZ2ljYWwgZGlsYXRpb24gd2l0aCA1LXBpeGVsIGNyb3NzIC0gcGl4ZWwgaXMgc2V0IGlmIGFueSBuZWlnaGJvciBpcyBzZXRcbiAgICBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciA9IGluSW1hZ2VQdHIgfCAwO1xuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgdiA9IDA7XG4gICAgICAgIHZhciB1ID0gMDtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciB5U3RhcnQxID0gMDtcbiAgICAgICAgdmFyIHlTdGFydDIgPSAwO1xuICAgICAgICB2YXIgeFN0YXJ0MSA9IDA7XG4gICAgICAgIHZhciB4U3RhcnQyID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID4gKDAgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvcGllcyBpbWFnZSBkYXRhIGZyb20gc3JjIHRvIGRzdCByZWdpb25cbiAgICBmdW5jdGlvbiBtZW1jcHkoc3JjSW1hZ2VQdHIsIGRzdEltYWdlUHRyKSB7XG4gICAgICAgIHNyY0ltYWdlUHRyID0gc3JjSW1hZ2VQdHIgfCAwO1xuICAgICAgICBkc3RJbWFnZVB0ciA9IGRzdEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soZHN0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoaW1hZ2VzWyhzcmNJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWmVyb3Mgb3V0IHRoZSBib3JkZXIgcGl4ZWxzIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBGaXJzdCBsb29wOiBoYW5kbGVzIHRvcCwgbGVmdCwgYW5kIHJpZ2h0IGVkZ2VzIHNpbXVsdGFuZW91c2x5XG4gICAgICogU2Vjb25kIGxvb3A6IGhhbmRsZXMgYm90dG9tIGVkZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6ZXJvQm9yZGVyKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSAwO1xuXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB4KSB8IDBdID0gMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoKHkgKyBzaXplKSAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKHNpemUgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWluIHNrZWxldG9uaXphdGlvbiBhbGdvcml0aG0gdXNpbmcgaXRlcmF0aXZlIHRoaW5uaW5nOlxuICAgICAqIDEuIEVyb2RlIHRoZSB3b3JraW5nIGltYWdlXG4gICAgICogMi4gRGlsYXRlIHRoZSBlcm9kZWQgdmVyc2lvblxuICAgICAqIDMuIFN1YnRyYWN0IGRpbGF0ZWQgZnJvbSBvcmlnaW5hbCAoZXh0cmFjdHMgXCJwZWVsZWRcIiBsYXllcilcbiAgICAgKiA0LiBPUiB0aGUgcGVlbGVkIGxheWVyIGludG8gc2tlbGV0b24gYWNjdW11bGF0b3JcbiAgICAgKiA1LiBDb3B5IGVyb2RlZCBpbWFnZSBiYWNrIHRvIHdvcmtpbmcgaW1hZ2VcbiAgICAgKiA2LiBSZXBlYXQgdW50aWwgd29ya2luZyBpbWFnZSBpcyBlbXB0eVxuICAgICAqXG4gICAgICogQHJldHVybnMge3ZvaWR9IE5vIHJldHVybiB2YWx1ZSAtIG9wZXJhdGVzIGRpcmVjdGx5IG9uIHNoYXJlZCBidWZmZXIuXG4gICAgICogICBJbnB1dCBpbWFnZSBpcyByZWFkIGZyb20gYnVmZmVyIG9mZnNldCAwIChzdWJJbWFnZVB0cikuXG4gICAgICogICBPdXRwdXQgc2tlbGV0b24gaXMgd3JpdHRlbiB0byBidWZmZXIgb2Zmc2V0IDMqc2l6ZcKyIChza2VsSW1hZ2VQdHIpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNrZWxldG9uaXplKCkge1xuICAgICAgICB2YXIgc3ViSW1hZ2VQdHIgPSAwOyAgICAgICAgLy8gUmVnaW9uIDA6IFdvcmtpbmcgaW1hZ2UgKGlucHV0LCBvZmZzZXQgPSAwKVxuICAgICAgICB2YXIgZXJvZGVkSW1hZ2VQdHIgPSAwOyAgICAgLy8gUmVnaW9uIDE6IEVyb2RlZCByZXN1bHQgKG9mZnNldCA9IHNpemXCsilcbiAgICAgICAgdmFyIHRlbXBJbWFnZVB0ciA9IDA7ICAgICAgIC8vIFJlZ2lvbiAyOiBTY3JhdGNoIHNwYWNlIChvZmZzZXQgPSAyKnNpemXCsilcbiAgICAgICAgdmFyIHNrZWxJbWFnZVB0ciA9IDA7ICAgICAgIC8vIFJlZ2lvbiAzOiBGaW5hbCBza2VsZXRvbiAob3V0cHV0LCBvZmZzZXQgPSAzKnNpemXCsilcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBkb25lID0gMDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgYnl0ZSBvZmZzZXRzIGZvciBlYWNoIHJlZ2lvbiBpbiB0aGUgc2hhcmVkIGJ1ZmZlclxuICAgICAgICBlcm9kZWRJbWFnZVB0ciA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwOyAgICAgICAgICAgICAgICAgIC8vIFJlZ2lvbiAxOiBzaXplwrIgYnl0ZXMgaW5cbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDsgIC8vIFJlZ2lvbiAyOiAyKnNpemXCsiBieXRlcyBpblxuICAgICAgICBza2VsSW1hZ2VQdHIgPSAodGVtcEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDsgICAgLy8gUmVnaW9uIDM6IDMqc2l6ZcKyIGJ5dGVzIGluXG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBza2VsZXRvbiBhY2N1bXVsYXRvciB0byB6ZXJvXG4gICAgICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHN1YkltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1bSA9IGNvdW50Tm9uWmVybyhzdWJJbWFnZVB0cikgfCAwO1xuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNrZWxldG9uaXplOiBza2VsZXRvbml6ZSB9O1xufVxuLyogQHByZXNlcnZlIEFTTSBFTkQgKi9cblxuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiIsImltcG9ydCB7IHZlYzIsIG1hdDIgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQge1xuICAgIGNhbGN1bGF0ZVBhdGNoU2l6ZSxcbiAgICBvdHN1VGhyZXNob2xkLFxuICAgIGhzdjJyZ2IsXG4gICAgY2x1c3RlcixcbiAgICB0b3BHZW5lcmljLFxuICAgIGltYWdlUmVmLFxuICAgIGhhbGZTYW1wbGUsXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmFzdGVyaXplciBmcm9tICcuL3Jhc3Rlcml6ZXInO1xuaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcblxuXG5cbmxldCBfY29uZmlnO1xubGV0IF9jdXJyZW50SW1hZ2VXcmFwcGVyO1xubGV0IF9za2VsSW1hZ2VXcmFwcGVyO1xubGV0IF9zdWJJbWFnZVdyYXBwZXI7XG5sZXQgX2xhYmVsSW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaEdyaWQ7XG5sZXQgX3BhdGNoTGFiZWxHcmlkO1xubGV0IF9pbWFnZVRvUGF0Y2hHcmlkO1xubGV0IF9iaW5hcnlJbWFnZVdyYXBwZXI7XG5sZXQgX3BhdGNoU2l6ZTtcbmNvbnN0IF9jYW52YXNDb250YWluZXIgPSB7XG4gICAgY3R4OiB7XG4gICAgICAgIGJpbmFyeTogbnVsbCxcbiAgICB9LFxuICAgIGRvbToge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbn07XG5jb25zdCBfbnVtUGF0Y2hlcyA9IHsgeDogMCwgeTogMCB9O1xubGV0IF9pbnB1dEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbGV0b25pemVyO1xuXG5mdW5jdGlvbiBpbml0QnVmZmVycygpIHtcbiAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHk6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnkgLyAyIHwgMCxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBfaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgfVxuXG4gICAgX3BhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShfY29uZmlnLnBhdGNoU2l6ZSwgX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XG5cbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcblxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgYnVmZmVyIHNpemUgKDQgcmVnaW9ucyBmb3IgYXNtLmpzIHNrZWxldG9uaXplcilcbiAgICBjb25zdCBza2VsZXRvbkltYWdlRGF0YVNpemUgPSBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiA0O1xuICAgIC8vIFJvdW5kIHVwIHRvIG5leHQgcG93ZXIgb2YgMiBmb3IgYXNtLmpzIGhlYXAgcmVxdWlyZW1lbnRcbiAgICAvLyBVc2UgbWluaW11bSA2NEtCIGZvciBvcHRpbWFsIGFzbS5qcyBwZXJmb3JtYW5jZSAoYXZvaWRzIFY4IHdhcm5pbmdzKVxuICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBNYXRoLm1heCg2NTUzNiwgTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nMihza2VsZXRvbkltYWdlRGF0YVNpemUpKSkpO1xuICAgIGNvbnN0IHNrZWxldG9uSW1hZ2VEYXRhID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlclNpemUpO1xuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcbiAgICBfc2tlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3NrZWxldG9uaXplciA9IHNrZWxldG9uaXplcihcbiAgICAgICAgeyBNYXRoLCBVaW50OEFycmF5IH0sXG4gICAgICAgIHsgc2l6ZTogX3BhdGNoU2l6ZS54IH0sXG4gICAgICAgIHNrZWxldG9uSW1hZ2VEYXRhLFxuICAgICk7XG5cbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB4OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLngpIHwgMCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDAsXG4gICAgfSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG4gICAgX3BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9wYXRjaExhYmVsR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCBJbnQzMkFycmF5LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICBpZiAoX2NvbmZpZy51c2VXb3JrZXIgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSAnYmluYXJ5QnVmZmVyJztcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGVidWcnKS5hcHBlbmRDaGlsZChfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsUmVhZEZyZXF1ZW50bHkgPSAhIV9jb25maWcud2lsbFJlYWRGcmVxdWVudGx5O1xuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zz8uc2hvd0NhbnZhcykge1xuICAgICAgICBjb25zb2xlLndhcm4oJyogaW5pdENhbnZhcyB3aWxsUmVhZEZyZXF1ZW50bHknLCB3aWxsUmVhZEZyZXF1ZW50bHksIF9jb25maWcpO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuZ2V0Q29udGV4dCgnMmQnLCB7IHdpbGxSZWFkRnJlcXVlbnRseSB9KTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkud2lkdGggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgICBsZXQgb3ZlckF2ZztcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IHRyYW5zTWF0O1xuICAgIGxldCBtaW54ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IG1pbnkgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgYm94O1xuICAgIGxldCBzY2FsZTtcblxuICAgIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgIG92ZXJBdmcgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XG4gICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hlcykge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAncmVkJyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XG4gICAgb3ZlckF2ZyA9IChvdmVyQXZnICogMTgwIC8gTWF0aC5QSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgIGlmIChvdmVyQXZnIDwgMCkge1xuICAgICAgICBvdmVyQXZnICs9IDE4MDtcbiAgICB9XG5cbiAgICBvdmVyQXZnID0gKDE4MCAtIG92ZXJBdmcpICogTWF0aC5QSSAvIDE4MDtcbiAgICB0cmFuc01hdCA9IG1hdDIuY29weShtYXQyLmNyZWF0ZSgpLCBbTWF0aC5jb3Mob3ZlckF2ZyksIE1hdGguc2luKG92ZXJBdmcpLCAtTWF0aC5zaW4ob3ZlckF2ZyksIE1hdGguY29zKG92ZXJBdmcpXSk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgcGF0Y2hlcyBhbmQgcm90YXRlIGJ5IGFuZ2xlXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgocGF0Y2guYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdIDwgbWlueCkge1xuICAgICAgICAgICAgICAgIG1pbnggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdID4gbWF4eCkge1xuICAgICAgICAgICAgICAgIG1heHggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdIDwgbWlueSkge1xuICAgICAgICAgICAgICAgIG1pbnkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdID4gbWF4eSkge1xuICAgICAgICAgICAgICAgIG1heHkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBib3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSwgW21pbngsIG1heHldXTtcblxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWRCb3gpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XG4gICAgLy8gcmV2ZXJzZSByb3RhdGlvbjtcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIoYm94W2pdLCBib3hbal0sIHRyYW5zTWF0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd0JCKSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIuc2NhbGUoYm94W2pdLCBib3hbal0sIHNjYWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBiaW5hcnkgaW1hZ2Ugb2YgdGhlIGN1cnJlbnQgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gYmluYXJpemVJbWFnZSgpIHtcbiAgICBvdHN1VGhyZXNob2xkKF9jdXJyZW50SW1hZ2VXcmFwcGVyLCBfYmluYXJ5SW1hZ2VXcmFwcGVyKTtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcykge1xuICAgICAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNob3coX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAyNTUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBpbWFnZVxuICogZXh0cmFjdCBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXRjaGVzKCkge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBtb21lbnRzO1xuICAgIGxldCBwYXRjaGVzRm91bmQgPSBbXTtcbiAgICBsZXQgcmFzdGVyaXplcjtcbiAgICBsZXQgcmFzdGVyUmVzdWx0O1xuICAgIGxldCBwYXRjaDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgX251bVBhdGNoZXMueDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfbnVtUGF0Y2hlcy55OyBqKyspIHtcbiAgICAgICAgICAgIHggPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCAqIGk7XG4gICAgICAgICAgICB5ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnkgKiBqO1xuXG4gICAgICAgICAgICAvLyBzZXBlcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgc2tlbGV0b25pemUoeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIFJhc3Rlcml6ZSwgZmluZCBpbmRpdmlkdWFsIGJhcnNcbiAgICAgICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xuICAgICAgICAgICAgcmFzdGVyaXplciA9IFJhc3Rlcml6ZXIuY3JlYXRlKF9za2VsSW1hZ2VXcmFwcGVyLCBfbGFiZWxJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgcmFzdGVyUmVzdWx0ID0gcmFzdGVyaXplci5yYXN0ZXJpemUoMCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgX2xhYmVsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCBNYXRoLmZsb29yKDM2MCAvIHJhc3RlclJlc3VsdC5jb3VudCksXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXG4gICAgICAgICAgICBtb21lbnRzID0gX2xhYmVsSW1hZ2VXcmFwcGVyLm1vbWVudHMocmFzdGVyUmVzdWx0LmNvdW50KTtcblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXG4gICAgICAgICAgICBwYXRjaGVzRm91bmQgPSBwYXRjaGVzRm91bmQuY29uY2F0KGRlc2NyaWJlUGF0Y2gobW9tZW50cywgW2ksIGpdLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0ZvdW5kUGF0Y2hlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xuICAgIGxldCBpO1xuICAgIGxldCBzdW07XG4gICAgbGV0IGxhYmVsSGlzdCA9IFtdO1xuICAgIGxldCB0b3BMYWJlbHMgPSBbXTtcblxuXG4gICAgZm9yIChpID0gMDsgaSA8IG1heExhYmVsOyBpKyspIHtcbiAgICAgICAgbGFiZWxIaXN0LnB1c2goMCk7XG4gICAgfVxuICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPiAwKSB7XG4gICAgICAgICAgICBsYWJlbEhpc3RbX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSAtIDFdKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYWJlbEhpc3QgPSBsYWJlbEhpc3QubWFwKCh2YWwsIGlkeCkgPT4gKHtcbiAgICAgICAgdmFsLFxuICAgICAgICBsYWJlbDogaWR4ICsgMSxcbiAgICB9KSk7XG5cbiAgICBsYWJlbEhpc3Quc29ydCgoYSwgYikgPT4gYi52YWwgLSBhLnZhbCk7XG5cbiAgICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDUgcGF0Y2hlcyBwcmVzZW50XG4gICAgdG9wTGFiZWxzID0gbGFiZWxIaXN0LmZpbHRlcigoZWwpID0+IGVsLnZhbCA+PSA1KTtcblxuICAgIHJldHVybiB0b3BMYWJlbHM7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgc3VtO1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IGJveDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcGF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID09PSB0b3BMYWJlbHNbaV0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbc3VtXTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dSZW1haW5pbmdQYXRjaExhYmVscykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaHN2WzBdID0gKHRvcExhYmVsc1tpXS5sYWJlbCAvIChtYXhMYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY29sb3I6IGByZ2IoJHtyZ2Iuam9pbignLCcpfSlgLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcztcbn1cblxuLyoqXG4gKiBGaW5kIHNpbWlsYXIgbW9tZW50cyAodmlhIGNsdXN0ZXIpXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xuICovXG5mdW5jdGlvbiBzaW1pbGFyTW9tZW50cyhtb21lbnRzKSB7XG4gICAgY29uc3QgY2x1c3RlcnMgPSBjbHVzdGVyKG1vbWVudHMsIDAuOTApO1xuICAgIGNvbnN0IHRvcENsdXN0ZXIgPSB0b3BHZW5lcmljKGNsdXN0ZXJzLCAxLCAoZSkgPT4gZS5nZXRQb2ludHMoKS5sZW5ndGgpO1xuICAgIGxldCBwb2ludHMgPSBbXTsgY29uc3RcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvaW50cyA9IHRvcENsdXN0ZXJbMF0uaXRlbS5nZXRQb2ludHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc3ViSW1hZ2VBc0NvcHkoX3N1YkltYWdlV3JhcHBlciwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcblxuICAgIC8vIFNob3cgc2tlbGV0b24gaWYgcmVxdWVzdGVkXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICAgIGxldCBrO1xuICAgIGxldCBhdmc7XG4gICAgY29uc3QgZWxpZ2libGVNb21lbnRzID0gW107XG4gICAgbGV0IG1hdGNoaW5nTW9tZW50cztcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gW107XG4gICAgY29uc3QgbWluQ29tcG9uZW50V2VpZ2h0ID0gTWF0aC5jZWlsKF9wYXRjaFNpemUueCAvIDMpO1xuXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gb25seSBjb2xsZWN0IG1vbWVudHMgd2hpY2gncyBhcmVhIGNvdmVycyBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHQgcGl4ZWxzLlxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNba10ubTAwID4gbWluQ29tcG9uZW50V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZWxpZ2libGVNb21lbnRzLnB1c2gobW9tZW50c1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXG4gICAgICAgIGlmIChlbGlnaWJsZU1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTW9tZW50cyA9IHNpbWlsYXJNb21lbnRzKGVsaWdpYmxlTW9tZW50cyk7XG4gICAgICAgICAgICBhdmcgPSAwO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzaW1pbGFyaXR5IG9mIHRoZSBtb21lbnRzXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXT8ucmFkID8/IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcGF0Y2ggdG8gdGhlIHNldFxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IG1vbWVudHMubGVuZ3RoIC8gNCkge1xuICAgICAgICAgICAgICAgIGF2ZyAvPSBtYXRjaGluZ01vbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJveDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbTWF0aC5jb3MoYXZnKSwgTWF0aC5zaW4oYXZnKV0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoZXNGb3VuZFxuICovXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcbiAgICBsZXQgbGFiZWwgPSAwO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IDAuOTU7XG4gICAgbGV0IGN1cnJJZHggPSAwO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFjZShjdXJyZW50SWR4KSB7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRjaDtcbiAgICAgICAgbGV0IGlkeDtcbiAgICAgICAgbGV0IGRpcjtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHtcbiAgICAgICAgICAgIHg6IGN1cnJlbnRJZHggJSBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54LFxuICAgICAgICAgICAgeTogKGN1cnJlbnRJZHggLyBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54KSB8IDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzaW1pbGFyaXR5O1xuXG4gICAgICAgIGlmIChjdXJyZW50SWR4IDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50UGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2N1cnJlbnRJZHhdO1xuICAgICAgICAgICAgLy8gYXNzaWduIGxhYmVsXG4gICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtjdXJyZW50SWR4XSA9IGxhYmVsO1xuICAgICAgICAgICAgZm9yIChkaXIgPSAwOyBkaXIgPCBUcmFjZXIuc2VhcmNoRGlyZWN0aW9ucy5sZW5ndGg7IGRpcisrKSB7XG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQueSArIFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zW2Rpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQueCArIFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zW2Rpcl1bMV07XG4gICAgICAgICAgICAgICAgaWR4ID0geSAqIF9wYXRjaExhYmVsR3JpZC5zaXplLnggKyB4O1xuXG4gICAgICAgICAgICAgICAgLy8gY29udGludWUgaWYgcGF0Y2ggZW1wdHlcbiAgICAgICAgICAgICAgICBpZiAoX3BhdGNoR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbaWR4XSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3QoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtpZHhdLnZlYywgY3VycmVudFBhdGNoLnZlYykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByZXBhcmUgZm9yIGZpbmRpbmcgdGhlIHJpZ2h0IHBhdGNoZXNcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaEdyaWQuZGF0YSwgMCk7XG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hMYWJlbEdyaWQuZGF0YSwgMCk7XG4gICAgQXJyYXlIZWxwZXIuaW5pdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhLCBudWxsKTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzRm91bmRbal07XG4gICAgICAgIF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gcGF0Y2g7XG4gICAgICAgIF9wYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSAxO1xuICAgIH1cblxuICAgIC8vIHJhc3Rlcml6ZSB0aGUgcGF0Y2hlcyBmb3VuZCB0byBkZXRlcm1pbmUgYXJlYVxuICAgIF9wYXRjaEdyaWQuemVyb0JvcmRlcigpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgd2hpbGUgKChjdXJySWR4ID0gbm90WWV0UHJvY2Vzc2VkKCkpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGxhYmVsKys7XG4gICAgICAgIHRyYWNlKGN1cnJJZHgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hMYWJlbHMpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPiAwICYmIF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIDw9IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2pdO1xuICAgICAgICAgICAgICAgIGhzdlswXSA9IChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSAvIChsYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAgICAgIHsgY29sb3I6IGByZ2IoJHtyZ2Iuam9pbignLCcpfSlgLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0KGlucHV0SW1hZ2VXcmFwcGVyLCBjb25maWcpIHtcbiAgICAgICAgX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgX2lucHV0SW1hZ2VXcmFwcGVyID0gaW5wdXRJbWFnZVdyYXBwZXI7XG5cbiAgICAgICAgaW5pdEJ1ZmZlcnMoKTtcbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgIH0sXG5cbiAgICBsb2NhdGUoKSB7XG4gICAgICAgIGlmIChfY29uZmlnLmhhbGZTYW1wbGUpIHtcbiAgICAgICAgICAgIGhhbGZTYW1wbGUoX2lucHV0SW1hZ2VXcmFwcGVyLCBfY3VycmVudEltYWdlV3JhcHBlcik7XG4gICAgICAgIH1cblxuICAgICAgICBiaW5hcml6ZUltYWdlKCk7XG4gICAgICAgIGNvbnN0IHBhdGNoZXNGb3VuZCA9IGZpbmRQYXRjaGVzKCk7XG4gICAgICAgIC8vIHJldHVybiB1bmxlc3MgNSUgb3IgbW9yZSBwYXRjaGVzIGFyZSBmb3VuZFxuICAgICAgICBpZiAocGF0Y2hlc0ZvdW5kLmxlbmd0aCA8IF9udW1QYXRjaGVzLnggKiBfbnVtUGF0Y2hlcy55ICogMC4wNSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByYXN0ZXJyaXplIGFyZWEgYnkgY29tcGFyaW5nIGFuZ3VsYXIgc2ltaWxhcml0eTtcbiAgICAgICAgY29uc3QgbWF4TGFiZWwgPSByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpO1xuICAgICAgICBpZiAobWF4TGFiZWwgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgYXJlYSB3aXRoIHRoZSBtb3N0IHBhdGNoZXMgKGJpZ2dlc3QgY29ubmVjdGVkIGFyZWEpXG4gICAgICAgIGNvbnN0IHRvcExhYmVscyA9IGZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMobWF4TGFiZWwpO1xuICAgICAgICBpZiAodG9wTGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBib3hlcyA9IGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKTtcbiAgICAgICAgcmV0dXJuIGJveGVzO1xuICAgIH0sXG5cbiAgICBjaGVja0ltYWdlQ29uc3RyYWludHMoaW5wdXRTdHJlYW0sIGNvbmZpZykge1xuICAgICAgICBsZXQgcGF0Y2hTaXplO1xuICAgICAgICBsZXQgd2lkdGggPSBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IHRoaXNIYWxmU2FtcGxlID0gY29uZmlnLmhhbGZTYW1wbGUgPyAwLjUgOiAxO1xuICAgICAgICBsZXQgYXJlYTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCBiYXNlZCBvbiBhcmVhXG4gICAgICAgIGlmIChpbnB1dFN0cmVhbS5nZXRDb25maWcoKS5hcmVhKSB7XG4gICAgICAgICAgICBhcmVhID0gY29tcHV0ZUltYWdlQXJlYSh3aWR0aCwgaGVpZ2h0LCBpbnB1dFN0cmVhbS5nZXRDb25maWcoKS5hcmVhKTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldFRvcFJpZ2h0KHsgeDogYXJlYS5zeCwgeTogYXJlYS5zeSB9KTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldENhbnZhc1NpemUoeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgd2lkdGggPSBhcmVhLnN3O1xuICAgICAgICAgICAgaGVpZ2h0ID0gYXJlYS5zaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKHdpZHRoICogdGhpc0hhbGZTYW1wbGUpLFxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihoZWlnaHQgKiB0aGlzSGFsZlNhbXBsZSksXG4gICAgICAgIH07XG5cbiAgICAgICAgcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKGNvbmZpZy5wYXRjaFNpemUsIHNpemUpO1xuICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zz8uc2hvd1BhdGNoU2l6ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGgubWF4KE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSwgcGF0Y2hTaXplLngpKTtcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0SGVpZ2h0KE1hdGgubWF4KE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnkgLyBwYXRjaFNpemUueSkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS55KSwgcGF0Y2hTaXplLnkpKTtcblxuICAgICAgICBpZiAoKGlucHV0U3RyZWFtLmdldFdpZHRoKCkgJSBwYXRjaFNpemUueCkgPT09IDAgJiYgKGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgZGltZW5zaW9ucyBkbyBub3QgY29tcGx5IHdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3M6IFdpZHRoICgke1xuICAgICAgICAgICAgd2lkdGh9IClhbmQgaGVpZ2h0ICgke2hlaWdodFxuICAgICAgICB9KSBtdXN0IGEgbXVsdGlwbGUgb2YgJHtwYXRjaFNpemUueH1gKTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSBcIi4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gXCJjb21tb24vaW1hZ2Vfd3JhcHBlclwiO1xuXG5leHBvcnQgY2xhc3MgUXVhZ2dhQ29udGV4dCB7XG4gICAgcHVibGljIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0O1xuXG4gICAgcHVibGljIGlucHV0U3RyZWFtOiBhbnk7XG5cbiAgICBwdWJsaWMgZnJhbWVncmFiYmVyOiBhbnk7XG5cbiAgICBwdWJsaWMgaW5wdXRJbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXI7XG5cbiAgICBwdWJsaWMgc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRmxhZyBpbmRpY2F0aW5nIHRoYXQgc3RvcCgpIHdhcyBjYWxsZWQgd2hpbGUgaW5pdCgpIHdhcyBzdGlsbCBpbiBwcm9ncmVzcy5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gaGFuZGxlIHJhY2UgY29uZGl0aW9ucyBpbiBSZWFjdCBTdHJpY3RNb2RlIHdoZXJlIGNvbXBvbmVudHNcbiAgICAgKiBhcmUgbW91bnRlZC91bm1vdW50ZWQgcmFwaWRseSwgY2F1c2luZyBpbml0KCkgdG8gYmUgY2FsbGVkLCB0aGVuIHN0b3AoKSxcbiAgICAgKiB0aGVuIGluaXQoKSBhZ2FpbiBiZWZvcmUgdGhlIGZpcnN0IGluaXQoKSBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgcHVibGljIGluaXRBYm9ydGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgYm94U2l6ZTogYW55O1xuXG4gICAgcHVibGljIHJlc3VsdENvbGxlY3RvcjogYW55O1xuXG4gICAgcHVibGljIGRlY29kZXI6IGFueTtcblxuICAgIHB1YmxpYyB3b3JrZXJQb29sOiBhbnlbXSA9IFtdO1xuXG4gICAgcHVibGljIG9uVUlUaHJlYWQgPSB0cnVlO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNhbnZhc0NvbnRhaW5lciA9IG5ldyBDYW52YXNDb250YWluZXIoKTtcbn1cblxuZXhwb3J0IGNsYXNzIENhbnZhc0luZm8ge1xuICAgIGltYWdlOiBhbnk7XG4gICAgb3ZlcmxheTogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzQ29udGFpbmVyIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgY3R4OiBDYW52YXNJbmZvO1xuICAgIHB1YmxpYyByZWFkb25seSBkb206IENhbnZhc0luZm87XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgQ2FudmFzSW5mbygpO1xuICAgICAgICB0aGlzLmRvbSA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld1BvcnQodGFyZ2V0PzogRWxlbWVudCB8IHN0cmluZyk6IEVsZW1lbnQgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYWxyZWFkeSBhIERPTSBlbGVtZW50XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5ub2RlTmFtZSAmJiB0YXJnZXQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLy8gVXNlICcjaW50ZXJhY3RpdmUudmlld3BvcnQnIGFzIGEgZmFsbGJhY2sgc2VsZWN0b3IgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgIGNvbnN0IHNlbGVjdG9yID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JztcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG4iLCJpbXBvcnQgeyB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbSB9IGZyb20gJy4uL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW0uZCc7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi4vbG9jYXRvci9iYXJjb2RlX2xvY2F0b3InO1xuXG4vLyBUT0RPOiBuZWVkIHR5cGVzY3JpcHQgZGVmIGZvciBCYXJjb2RlTG9jYXRvclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoXG4gICAgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLFxuICAgIGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyIHwgdW5kZWZpbmVkLFxuICAgIGxvY2F0b3I6IGFueSxcbikge1xuICAgIGNvbnN0IGlucHV0SW1hZ2VXcmFwcGVyID0gaW1hZ2VXcmFwcGVyIHx8IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLFxuICAgICAgICB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSxcbiAgICAgICAgdHlwZTogJ1hZU2l6ZScsXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIChsb2NhdG9yIGFzIGFueSkuY29uZmlnPy5kZWJ1Zz8uc2hvd0ltYWdlRGV0YWlscykge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgdmVjMi5jbG9uZShbMCwgMF0pLFxuICAgICAgICB2ZWMyLmNsb25lKFswLCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgdmVjMi5jbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgdmVjMi5jbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCAwXSksXG4gICAgXTtcbiAgICBCYXJjb2RlTG9jYXRvci5pbml0KGlucHV0SW1hZ2VXcmFwcGVyLCBsb2NhdG9yKTtcbiAgICByZXR1cm4geyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9O1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgZ2V0Vmlld1BvcnQgZnJvbSAnLi9nZXRWaWV3UG9ydCc7XG5pbXBvcnQgdHlwZSB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gZ2V0Q2FudmFzQW5kQ29udGV4dChzZWxlY3Rvcjogc3RyaW5nLCBjbGFzc05hbWU6IHN0cmluZywgb3B0aW9uczogeyB3aWxsUmVhZEZyZXF1ZW50bHk6IGJvb2xlYW47IGRlYnVnPzogYW55IH0pIHtcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBvcHRpb25zLmRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignKiBpbml0Q2FudmFzIGdldENhbnZhc0FuZENvbnRleHQnKTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgd2lsbFJlYWRGcmVxdWVudGx5OiBvcHRpb25zLndpbGxSZWFkRnJlcXVlbnRseSB9KTtcbiAgICByZXR1cm4geyBjYW52YXMsIGNvbnRleHQgfTtcbn1cblxuaW50ZXJmYWNlIEluaXRDYW52YXNlc09wdGlvbnMge1xuICAgIHdpbGxSZWFkRnJlcXVlbnRseTogYm9vbGVhbjtcbiAgICBjcmVhdGVPdmVybGF5OiBib29sZWFuO1xuICAgIGRlYnVnPzogYW55O1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplLCB7IHdpbGxSZWFkRnJlcXVlbnRseSwgY3JlYXRlT3ZlcmxheSwgZGVidWcgfTogSW5pdENhbnZhc2VzT3B0aW9ucyk6IENhbnZhc0NvbnRhaW5lciB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmltZ0J1ZmZlcicsICdpbWdCdWZmZXInLCB7IHdpbGxSZWFkRnJlcXVlbnRseSwgZGVidWcgfSk7XG4gICAgICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgaW1hZ2UuY2FudmFzLmhlaWdodCA9IGNhbnZhc1NpemUueTtcblxuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBvdmVybGF5IGNhbnZhcyBpZiBjcmVhdGVPdmVybGF5IGlzIHRydWUgKGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgICAgIGxldCBvdmVybGF5OiB7IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsOyBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsIH0gPSB7XG4gICAgICAgICAgICBjYW52YXM6IG51bGwsXG4gICAgICAgICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY3JlYXRlT3ZlcmxheSkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVJlc3VsdCA9IGdldENhbnZhc0FuZENvbnRleHQoJ2NhbnZhcy5kcmF3aW5nQnVmZmVyJywgJ2RyYXdpbmdCdWZmZXInLCB7IHdpbGxSZWFkRnJlcXVlbnRseSwgZGVidWcgfSk7XG4gICAgICAgICAgICBvdmVybGF5UmVzdWx0LmNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgIG92ZXJsYXlSZXN1bHQuY2FudmFzLmhlaWdodCA9IGNhbnZhc1NpemUueTtcbiAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5UmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbToge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogb3ZlcmxheS5jYW52YXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogb3ZlcmxheS5jb250ZXh0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRDYW52YXMoY29udGV4dDogUXVhZ2dhQ29udGV4dCk6IENhbnZhc0NvbnRhaW5lciB8IG51bGwge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld1BvcnQoY29udGV4dD8uY29uZmlnPy5pbnB1dFN0cmVhbT8udGFyZ2V0KTtcbiAgICBjb25zdCB0eXBlID0gY29udGV4dD8uY29uZmlnPy5pbnB1dFN0cmVhbT8udHlwZTtcbiAgICBpZiAoIXR5cGUpIHJldHVybiBudWxsO1xuXG4gICAgLy8gRGVmYXVsdCB0byB0cnVlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGNvbnN0IGNyZWF0ZU92ZXJsYXkgPSBjb250ZXh0Py5jb25maWc/LmNhbnZhcz8uY3JlYXRlT3ZlcmxheSAhPT0gZmFsc2U7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoXG4gICAgICAgIGNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEhY29udGV4dD8uY29uZmlnPy5pbnB1dFN0cmVhbT8ud2lsbFJlYWRGcmVxdWVudGx5LFxuICAgICAgICAgICAgY3JlYXRlT3ZlcmxheSxcbiAgICAgICAgICAgIGRlYnVnOiBjb250ZXh0Py5jb25maWc/LmxvY2F0b3I/LmRlYnVnXG4gICAgICAgIH1cbiAgICApO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tLm92ZXJsYXkgJiYgIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLyogV29ya2VyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHN0cmFpZ2h0IGZyb20gdGhlIG9yaWdpbmFsIHF1YWdnYS5qcyBmaWxlLlxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcbiAqIHRvIHJlZmVyIHRvIHVudGlsIGl0IGlzIHJlLWltcGxlbWVudGVkLiBXZSBtYXkgYmUgYWJsZSB0byBmaXgvdXNlIHNvbWUgb2YgdGhpcy5cbiAqL1xuXG5pbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcsIEJhcmNvZGVSZWFkZXJDb25zdHJ1Y3RvciB9IGZyb20gXCIuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuXG4vLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCBpbnRlcmZhY2UgZm9yIEZyYW1lR3JhYmJlclxuXG5pbnRlcmZhY2UgUVdvcmtlclRocmVhZCB7XG4gICAgaW1hZ2VEYXRhOiBVaW50OEFycmF5O1xuICAgIGJ1c3k6IGJvb2xlYW47XG4gICAgd29ya2VyOiBXb3JrZXI7XG59XG5cbmxldCB3b3JrZXJQb29sOiBBcnJheTxRV29ya2VyVGhyZWFkPiA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlV29ya2VycyhmcmFtZUdyYWJiZXI6IGFueSkge1xuICAgIGxldCBhdmFpbGFibGVXb3JrZXI6IFFXb3JrZXJUaHJlYWQ7XG4gICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoKSB7XG4gICAgICAgIGF2YWlsYWJsZVdvcmtlciA9IHdvcmtlclBvb2wuZmlsdGVyKCh3b3JrZXJUaHJlYWQpID0+ICF3b3JrZXJUaHJlYWQuYnVzeSlbMF07XG4gICAgICAgIGlmIChhdmFpbGFibGVXb3JrZXIpIHtcbiAgICAgICAgICAgIGZyYW1lR3JhYmJlci5hdHRhY2hEYXRhKGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKGZyYW1lR3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIuYnVzeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEsXG4gICAgICAgICAgICAgICAgfSwgW2F2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEuYnVmZmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29uZmlnRm9yV29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAuLi5jb25maWcuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlKGZhY3RvcnkpIHtcbiAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICB2YXIgUXVhZ2dhID0gZmFjdG9yeSgpLmRlZmF1bHQ7XG4gICAgICAgIGlmICghUXVhZ2dhKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgJ2V2ZW50JzogJ2Vycm9yJywgbWVzc2FnZTogJ1F1YWdnYSBjb3VsZCBub3QgYmUgY3JlYXRlZCcgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4vLyBAdHMtaWdub3JlXG4gICAgdmFyIGltYWdlV3JhcHBlcjtcblxuLy8gQHRzLWlnbm9yZVxuICAgIGZ1bmN0aW9uIG9uUHJvY2Vzc2VkKHJlc3VsdCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlUmVhZHkoKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ2luaXRpYWxpemVkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuY21kID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBlLmRhdGEuY29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIgPSBuZXcgUXVhZ2dhLkltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAgICAgeDogZS5kYXRhLnNpemUueCxcbiAgICAgICAgICAgICAgICB5OiBlLmRhdGEuc2l6ZS55LFxuICAgICAgICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgUXVhZ2dhLmluaXQoY29uZmlnLCB3b3JrZXJJbnRlcmZhY2VSZWFkeSwgaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3Byb2Nlc3MnKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgUXVhZ2dhLnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3NldFJlYWRlcnMnKSB7XG4gICAgICAgICAgICBRdWFnZ2Euc2V0UmVhZGVycyhlLmRhdGEucmVhZGVycyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3JlZ2lzdGVyUmVhZGVyJykge1xuICAgICAgICAgICAgUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyKGUuZGF0YS5uYW1lLCBlLmRhdGEucmVhZGVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlV29ya2VyQmxvYigpIHtcbiAgICB2YXIgYmxvYixcbiAgICAgICAgZmFjdG9yeVNvdXJjZTtcblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBfX2ZhY3RvcnlTb3VyY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmYWN0b3J5U291cmNlID0gX19mYWN0b3J5U291cmNlX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB9XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgIGJsb2IgPSBuZXcgQmxvYihbJygnICsgd29ya2VySW50ZXJmYWNlLnRvU3RyaW5nKCkgKyAnKSgnICsgZmFjdG9yeVNvdXJjZSArICcpOyddLFxuICAgICAgICB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbTogYW55LCBjYjogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBibG9iVVJMID0gZ2VuZXJhdGVXb3JrZXJCbG9iKCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcblxuICAgIGNvbnN0IHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCA9IHtcbiAgICAgICAgd29ya2VyLFxuICAgICAgICBpbWFnZURhdGE6IG5ldyBVaW50OEFycmF5KGlucHV0U3RyZWFtLmdldFdpZHRoKCkgKiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSksXG4gICAgICAgIGJ1c3k6IHRydWUsXG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2luaXRpYWxpemVkJykge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2Iod29ya2VyVGhyZWFkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETzogaG93IHRvIHRocmVhZCBwdWJsaXNoUmVzdWx0IGludG8gaGVyZT8gVHlwZVNjcmlwdCBzYXlzIGl0J3Mgbm90IGhlcmUuIGh0dHBzOi8vZ2l0aHViLmNvbS9lcmljYmxhZGUvcXVhZ2dhMi9pc3N1ZXMvNDY2I2lzc3VlY29tbWVudC0xNzI0MjQ4MDgwIHNheXMgaXQncyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAodHlwZW9mIHB1Ymxpc2hSZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHB1Ymxpc2hSZXN1bHQoZS5kYXRhLnJlc3VsdCwgd29ya2VyVGhyZWFkLmltYWdlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBlcnJvcjogJyArIGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgIHNpemU6IHsgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgfSxcbiAgICAgICAgaW1hZ2VEYXRhOiB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLFxuICAgICAgICBjb25maWc6IGNvbmZpZ0Zvcldvcmtlcihjb25maWcpLFxuICAgIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eTogbnVtYmVyLCBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW0/OiBhbnksIGNiPzogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBpbmNyZWFzZUJ5ID0gY2FwYWNpdHkgLSB3b3JrZXJQb29sLmxlbmd0aDtcbiAgICBpZiAoaW5jcmVhc2VCeSA9PT0gMCAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgIH0gZWxzZSBpZiAoaW5jcmVhc2VCeSA8IDApIHtcbiAgICAgICAgY29uc3Qgd29ya2Vyc1RvVGVybWluYXRlID0gd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcbiAgICAgICAgd29ya2Vyc1RvVGVybWluYXRlLmZvckVhY2goZnVuY3Rpb24gKHdvcmtlclRocmVhZCkge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIHRlcm1pbmF0ZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXJQb29sID0gd29ya2VyUG9vbC5zbGljZSgwLCBpbmNyZWFzZUJ5KTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd29ya2VySW5pdGlhbGl6ZWQgPSAod29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkKSA9PiB7XG4gICAgICAgICAgICB3b3JrZXJQb29sLnB1c2god29ya2VyVGhyZWFkKTtcbiAgICAgICAgICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCA+PSBjYXBhY2l0eSAmJiBjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0V29ya2VyKGNvbmZpZywgaW5wdXRTdHJlYW0sIHdvcmtlckluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdzZXRSZWFkZXJzJywgcmVhZGVycyB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogQmFyY29kZVJlYWRlckNvbnN0cnVjdG9yKSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdyZWdpc3RlclJlYWRlcicsIG5hbWUsIHJlYWRlciB9KSk7XG59XG4iLCJpbXBvcnQgeyBJbnB1dFN0cmVhbUZhY3RvcnkgfSBmcm9tICdpbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLmQnO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbVR5cGUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgYW4gSW5wdXRTdHJlYW0gdHlwZXNjcmlwdCBpbnRlcmZhY2UsIHNvIHdlIGRvbid0IGhhdmUgYW4gXCJhbnlcIiBpbiB0aGUgbmV4dCBsaW5lXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cElucHV0U3RyZWFtKHR5cGU6IElucHV0U3RyZWFtVHlwZSA9ICdMaXZlU3RyZWFtJywgdmlld3BvcnQ6IEVsZW1lbnQgfCBudWxsLCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdWaWRlb1N0cmVhbSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0ltYWdlU3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiB7IGlucHV0U3RyZWFtOiBpbnB1dFN0cmVhbUZhY3RvcnkuY3JlYXRlSW1hZ2VTdHJlYW0oKSB9O1xuICAgICAgICBjYXNlICdMaXZlU3RyZWFtJzoge1xuICAgICAgICAgICAgbGV0IHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB2aWRlbyA9IHZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKHZpZGVvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBpbnB1dFN0cmVhbUZhY3RvcnkuY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyBhcyBIVE1MVmlkZW9FbGVtZW50KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCogc2V0dXBJbnB1dFN0cmVhbSBpbnZhbGlkIHR5cGUgJHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmlkZW86IG51bGwsIGlucHV0U3RyZWFtOiBudWxsIH07XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB0eXBlIHsgUG9pbnQgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuZXhwb3J0IHR5cGUgQm94ID0gQXJyYXk8WyBudW1iZXIsIG51bWJlciBdPjtcblxuZXhwb3J0IHR5cGUgTGluZSA9IFsgUG9pbnQsIFBvaW50IF07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlQm94KGJveDogQm94LCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxldCBjb3JuZXIgPSBib3gubGVuZ3RoO1xuICAgIHdoaWxlIChjb3JuZXItLSkge1xuICAgICAgICBib3hbY29ybmVyXVswXSArPSB4T2Zmc2V0O1xuICAgICAgICBib3hbY29ybmVyXVsxXSArPSB5T2Zmc2V0O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVMaW5lKGxpbmU6IExpbmUsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGluZVswXS54ICs9IHhPZmZzZXQ7XG4gICAgbGluZVswXS55ICs9IHlPZmZzZXQ7XG4gICAgbGluZVsxXS54ICs9IHhPZmZzZXQ7XG4gICAgbGluZVsxXS55ICs9IHlPZmZzZXQ7XG59XG4iLCJpbXBvcnQgeyB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB7IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZywgQmFyY29kZVJlYWRlckNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uL2NvbW1vbi9ldmVudHMnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBGcmFtZUdyYWJiZXIgZnJvbSAnLi4vaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyc7XG5pbXBvcnQgSW5wdXRTdHJlYW0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbSc7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi4vbG9jYXRvci9iYXJjb2RlX2xvY2F0b3InO1xuaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCB9IGZyb20gJy4uL1F1YWdnYUNvbnRleHQnO1xuaW1wb3J0IHsgQmFyY29kZUluZm8gfSBmcm9tICcuLi9yZWFkZXIvYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IF9nZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcbmltcG9ydCBfaW5pdEJ1ZmZlcnMgZnJvbSAnLi9pbml0QnVmZmVycyc7XG5pbXBvcnQgX2luaXRDYW52YXMgZnJvbSAnLi9pbml0Q2FudmFzJztcbmltcG9ydCAqIGFzIFFXb3JrZXJzIGZyb20gJy4vcXdvcmtlcic7XG5pbXBvcnQgc2V0dXBJbnB1dFN0cmVhbSBmcm9tICcuL3NldHVwSW5wdXRTdHJlYW0nO1xuaW1wb3J0IHsgbW92ZUxpbmUsIG1vdmVCb3ggfSBmcm9tICcuL3RyYW5zZm9ybSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XG4gICAgY29udGV4dDogUXVhZ2dhQ29udGV4dCA9IG5ldyBRdWFnZ2FDb250ZXh0KCk7XG5cbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9ID0gX2luaXRCdWZmZXJzKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJveFNpemUgPSBib3hTaXplO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRCdWZmZXJzKGltYWdlV3JhcHBlcik7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIHJldHVybiBfZ2V0Vmlld1BvcnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWFkeShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGluaXRDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9pbml0Q2FudmFzKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvbS5vdmVybGF5O1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xuICAgIH1cblxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIGluaXQgd2FzIGFib3J0ZWQgKGUuZy4sIGJ5IGNhbGxpbmcgc3RvcCgpIGR1cmluZyBpbml0aWFsaXphdGlvbilcbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgY29tcG9uZW50cyBhcmUgbW91bnRlZC91bm1vdW50ZWQgcmFwaWRseVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluaXRBYm9ydGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0luaXRpYWxpemF0aW9uIHdhcyBhYm9ydGVkJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdDb25maWd1cmF0aW9uIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBpbnB1dFN0cmVhbSBpcyBwcm9wZXJseSBpbml0aWFsaXplZCBiZWZvcmUgcHJvY2VlZGluZ1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdJbnB1dCBzdHJlYW0gbm90IGluaXRpYWxpemVkJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEJhcmNvZGVMb2NhdG9yLmNoZWNrSW1hZ2VDb25zdHJhaW50cyh0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0b3IpO1xuICAgICAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlciA9IEZyYW1lR3JhYmJlci5jcmVhdGUoXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbChcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8ubnVtT2ZXb3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeShjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBpbml0SW5wdXRTdHJlYW0oY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGU6IGlucHV0VHlwZSwgY29uc3RyYWludHMgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIGNvbnN0IHsgdmlkZW8sIGlucHV0U3RyZWFtIH0gPSBzZXR1cElucHV0U3RyZWFtKGlucHV0VHlwZSwgdGhpcy5nZXRWaWV3UG9ydCgpLCBJbnB1dFN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ0xpdmVTdHJlYW0nICYmIHZpZGVvKSB7XG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgY29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gaW5wdXRTdHJlYW0udHJpZ2dlcignY2FucmVjb3JkJykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRBdHRyaWJ1dGUoJ3ByZWxvYWQnLCAnYXV0bycpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0SW5wdXRTdHJlYW0odGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdjYW5yZWNvcmQnLCB0aGlzLmNhblJlY29yZC5iaW5kKHVuZGVmaW5lZCwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSA9IGlucHV0U3RyZWFtO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nQm94ZXMoKTogQXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdGUgPyBCYXJjb2RlTG9jYXRvci5sb2NhdGUoKVxuICAgICAgICAgICAgOiBbW1xuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMV0pLFxuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMl0pLFxuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbM10pLFxuICAgICAgICAgICAgXV0gYXMgdW5rbm93biBhcyBBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0OiBhbnksIHRyYW5zZm9ybWVkQm94ZXM6IFNldDxhbnk+ID0gbmV3IFNldCgpKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSB0b3BSaWdodC54O1xuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gdG9wUmlnaHQueTtcblxuICAgICAgICBpZiAoeE9mZnNldCA9PT0gMCAmJiB5T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBCYXJjb2RlSW5mbyBtYXkgbm90IGJlIHRoZSByaWdodCB0eXBlIGhlcmUuXG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZm9yRWFjaCgoYmFyY29kZTogQmFyY29kZUluZm8pID0+IHRoaXMudHJhbnNmb3JtUmVzdWx0KGJhcmNvZGUsIHRyYW5zZm9ybWVkQm94ZXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGluZSAmJiByZXN1bHQubGluZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIG1vdmVMaW5lKHJlc3VsdC5saW5lLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYm94ICYmICF0cmFuc2Zvcm1lZEJveGVzLmhhcyhyZXN1bHQuYm94KSkge1xuICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94LCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkQm94ZXMuYWRkKHJlc3VsdC5ib3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3hlcyAmJiByZXN1bHQuYm94ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQuYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGlmIHRoaXMgYm94IGhhcyBhbHJlYWR5IGJlZW4gdHJhbnNmb3JtZWQgKGVpdGhlciBhcyByZXN1bHQuYm94IG9yIHRocm91Z2ggYmFyY29kZXMpXG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZEJveGVzLmhhcyhyZXN1bHQuYm94ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveGVzW2ldLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRCb3hlcy5hZGQocmVzdWx0LmJveGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCwgaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+KTogdm9pZCB7XG4gICAgICAgIGlmICghaW1hZ2VEYXRhIHx8ICF0aGlzLmNvbnRleHQucmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgZGF0YSBzdHJ1Y3R1cmUgaG9sZHMgYSBcImJhcmNvZGVzXCIgcmVzdWx0LCBpZiBhbnkuLi5cbiAgICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xuICAgICAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZpbHRlcigoYmFyY29kZTogUXVhZ2dhSlNSZXN1bHRPYmplY3QpID0+IGJhcmNvZGUuY29kZVJlc3VsdClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoYmFyY29kZTogUXVhZ2dhSlNSZXN1bHRPYmplY3QpID0+IHRoaXMuYWRkUmVzdWx0KGJhcmNvZGUsIGltYWdlRGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdChcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKSxcbiAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGhhc0NvZGVSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEocmVzdWx0ICYmIChyZXN1bHQuYmFyY29kZXNcbiAgICAgICAgICAgID8gcmVzdWx0LmJhcmNvZGVzLnNvbWUoKGJhcmNvZGUpID0+IGJhcmNvZGUuY29kZVJlc3VsdClcbiAgICAgICAgICAgIDogcmVzdWx0LmNvZGVSZXN1bHQpKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIHB1Ymxpc2hSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSBudWxsLCBpbWFnZURhdGE/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IHJlc3VsdFRvUHVibGlzaDogQXJyYXk8UXVhZ2dhSlNSZXN1bHRPYmplY3Q+IHwgUXVhZ2dhSlNSZXN1bHRPYmplY3QgfCBudWxsID0gcmVzdWx0O1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgdGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLmFkZFJlc3VsdChyZXN1bHQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQ/LmJhcmNvZGVzPy5sZW5ndGggPiAwID8gcmVzdWx0LmJhcmNvZGVzIDogcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnB1Ymxpc2goJ3Byb2Nlc3NlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvZGVSZXN1bHQocmVzdWx0IGFzIFF1YWdnYUpTUmVzdWx0T2JqZWN0KSkge1xuICAgICAgICAgICAgRXZlbnRzLnB1Ymxpc2goJ2RldGVjdGVkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZHJhdyBzY2FubmVyIGFyZWEgZWFjaCBmcmFtZSB3aGVuIGxvY2F0ZSBpcyBmYWxzZSB2aWEgcHVibGljIEFQSS5cbiAgICAgICAgY29uc3QgY2ZnID0gdGhpcy5jb250ZXh0LmNvbmZpZztcbiAgICAgICAgaWYgKGNmZyAmJiBjZmcubG9jYXRlID09PSBmYWxzZSAmJiBjZmcuaW5wdXRTdHJlYW0/LmFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjYW5uZXJBcmVhKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBsb2NhdGVBbmREZWNvZGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRCb3VuZGluZ0JveGVzKCk7XG4gICAgICAgIGlmIChib3hlcykge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlUmVzdWx0ID0gKGF3YWl0IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSkgfHwge307XG4gICAgICAgICAgICBkZWNvZGVSZXN1bHQuYm94ZXMgPSBib3hlcztcbiAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChkZWNvZGVSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZVJlc3VsdCA9IGF3YWl0IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21JbWFnZSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGltYWdlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGltYWdlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JrZXJzVXBkYXRlZCA9IFFXb3JrZXJzLnVwZGF0ZVdvcmtlcnModGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlcik7XG4gICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpO1xuICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzdGFydENvbnRpbnVvdXNVcGRhdGUoKTogdm9pZCB7XG4gICAgICAgIGxldCBuZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgLy8gZnJlcXVlbmN5IHNwZWNpZmllcyBhIG1heGltdW0gcmF0ZSwgbm90IGFuIGFic29sdXRlLiBJZiB0aGUgc3lzdGVtIGNhbm5vdFxuICAgICAgICAvLyBhY2hpZXZlIHRoZSByZXF1ZXN0ZWQgZnJlcXVlbmN5LCBzY2FucyB3aWxsIG9jY3VyIGFzIGZhc3QgYXMgcG9zc2libGUuXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMTAwMCAvICh0aGlzLmNvbnRleHQuY29uZmlnPy5mcmVxdWVuY3kgfHwgNjApO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCBuZXdGcmFtZSA9ICh0aW1lc3RhbXA6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3RnJhbWUocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cblxuICAgIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQgJiYgdGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBzdG9wKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIC8vIFNldCBpbml0QWJvcnRlZCBmbGFnIGlmIHN0b3AoKSBpcyBjYWxsZWQgd2hpbGUgaW5pdCgpIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAgICAgIC8vIChpLmUuLCBiZWZvcmUgZnJhbWVncmFiYmVyIGlzIGluaXRpYWxpemVkKS4gVGhpcyBwcmV2ZW50cyB0aGUgY2FuUmVjb3JkXG4gICAgICAgIC8vIGNhbGxiYWNrIGZyb20gY29udGludWluZyBhZnRlciBzdG9wKCkgd2FzIGNhbGxlZC5cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5pdEFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2woMCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbSAmJiB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgYXdhaXQgQ2FtZXJhQWNjZXNzLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbT8uY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogQmFyY29kZVJlYWRlckNvbnN0cnVjdG9yKTogdm9pZCB7XG4gICAgICAgIEJhcmNvZGVEZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gZHJhdyBhIHNjYW5uZXIgYXJlYSBvdmVybGF5IHVzaW5nIHRoZSBjdXJyZW50IFF1YWdnYSBpbnN0YW5jZSdzIG92ZXJsYXkgY2FudmFzLlxuICAgICAqIERyYXdzIGJhc2VkIG9uIHRoZSBpbnN0YW5jZSdzIGNvbmZpZ3VyZWQgaW5wdXRTdHJlYW0uYXJlYSwgdXNpbmcgdGhlIGFjdHVhbCBhZGp1c3RlZCBib3hTaXplXG4gICAgICogdG8gbWF0Y2ggdGhlIHJlYWwgc2Nhbm5pbmcgYXJlYSBhZnRlciBwYXRjaCBhbGlnbm1lbnQuXG4gICAgICogT25seSBkcmF3cyB3aGVuIGxvY2F0ZSBpcyBmYWxzZSBhbmQgYW4gYXJlYSBpcyBjb25maWd1cmVkIHdpdGggc3R5bGluZy5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9jYWNoZWRTdHlsZVZhbHVlcz86IHsgYm9yZGVyQ29sb3I/OiBzdHJpbmc7IGJvcmRlcldpZHRoPzogbnVtYmVyOyBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfTtcbiAgICBwcml2YXRlIF9yZXNvbHZlZFN0eWxlPzogeyBjb2xvcjogc3RyaW5nOyB3aWR0aDogbnVtYmVyOyBiZz86IHN0cmluZyB9O1xuICAgIGRyYXdTY2FubmVyQXJlYSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtPy5hcmVhO1xuICAgICAgICBpZiAoIWFyZWEpIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3ZlcmxheUN0eCA9IHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuY3R4Lm92ZXJsYXk7XG4gICAgICAgIGlmICghb3ZlcmxheUN0eCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIE9ubHkgZHJhdyB3aGVuIGxvY2F0ZSBpcyBmYWxzZVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRlICE9PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFF1aWNrIGNoZWNrcyBmb3IgdmlzdWFsaXphdGlvbiBwcmVzZW5jZVxuICAgICAgICBjb25zdCBoYXNBbnlTdHlsZSA9IChhcmVhLmJvcmRlckNvbG9yICE9PSB1bmRlZmluZWQgJiYgYXJlYS5ib3JkZXJDb2xvciAhPT0gJycpXG4gICAgICAgICAgICB8fCAoYXJlYS5ib3JkZXJXaWR0aCAhPT0gdW5kZWZpbmVkICYmIGFyZWEuYm9yZGVyV2lkdGggPiAwKVxuICAgICAgICAgICAgfHwgKGFyZWEuYmFja2dyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgJiYgYXJlYS5iYWNrZ3JvdW5kQ29sb3IgIT09ICcnKTtcbiAgICAgICAgaWYgKCFoYXNBbnlTdHlsZSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFdoZW4gbG9jYXRlIGlzIGZhbHNlLCB1c2UgdGhlIGFjdHVhbCBhZGp1c3RlZCBib3hTaXplIHRoYXQgbWF0Y2hlcyB0aGUgc2Nhbm5pbmcgYXJlYVxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5ib3hTaXplKSByZXR1cm47XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvZmZzZXQgZm9yIHRoZSBjb25zdHJhaW5lZCBhcmVhXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0T2Zmc2V0ID0gdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSB0b3BSaWdodE9mZnNldC54O1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gdG9wUmlnaHRPZmZzZXQueTtcblxuICAgICAgICBjb25zdCBib3ggPSB0aGlzLmNvbnRleHQuYm94U2l6ZTtcbiAgICAgICAgY29uc3QgdG9wTGVmdCA9IGJveFswXTtcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IGJveFsxXTtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBib3hbM107XG5cbiAgICAgICAgLy8gQWRkIHRoZSBvZmZzZXQgdG8gcG9zaXRpb24gY29ycmVjdGx5IG9uIGNhbnZhc1xuICAgICAgICBjb25zdCB4ID0gdG9wTGVmdFswXSArIG9mZnNldFg7XG4gICAgICAgIGNvbnN0IHkgPSB0b3BMZWZ0WzFdICsgb2Zmc2V0WTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0b3BSaWdodFswXSAtIHRvcExlZnRbMF07XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbUxlZnRbMV0gLSB0b3BMZWZ0WzFdO1xuICAgICAgICBjb25zdCBzdHlsZUNoYW5nZWQgPSAhdGhpcy5fY2FjaGVkU3R5bGVWYWx1ZXNcbiAgICAgICAgICAgIHx8IHRoaXMuX2NhY2hlZFN0eWxlVmFsdWVzLmJvcmRlckNvbG9yICE9PSBhcmVhLmJvcmRlckNvbG9yXG4gICAgICAgICAgICB8fCB0aGlzLl9jYWNoZWRTdHlsZVZhbHVlcy5ib3JkZXJXaWR0aCAhPT0gYXJlYS5ib3JkZXJXaWR0aFxuICAgICAgICAgICAgfHwgdGhpcy5fY2FjaGVkU3R5bGVWYWx1ZXMuYmFja2dyb3VuZENvbG9yICE9PSBhcmVhLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgaWYgKHN0eWxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkU3R5bGVWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGFyZWEuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGFyZWEuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhcmVhLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaG91bGREcmF3Qm9yZGVyID0gYXJlYS5ib3JkZXJDb2xvciAhPT0gdW5kZWZpbmVkIHx8IGFyZWEuYm9yZGVyV2lkdGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gYXJlYS5ib3JkZXJDb2xvciA/PyAncmdiYSgwLCAyNTUsIDAsIDAuNSknO1xuICAgICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSBzaG91bGREcmF3Qm9yZGVyID8gKGFyZWEuYm9yZGVyV2lkdGggPz8gMikgOiAwO1xuICAgICAgICAgICAgY29uc3QgYmcgPSBhcmVhLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVkU3R5bGUgPSB7IGNvbG9yLCB3aWR0aDogYm9yZGVyV2lkdGgsIGJnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3Jlc29sdmVkU3R5bGUhO1xuICAgICAgICBpZiAoc3R5bGUuYmcpIHtcbiAgICAgICAgICAgIG92ZXJsYXlDdHguZmlsbFN0eWxlID0gc3R5bGUuYmc7XG4gICAgICAgICAgICBvdmVybGF5Q3R4LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS53aWR0aCA+IDApIHtcbiAgICAgICAgICAgIG92ZXJsYXlDdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgICAgIG92ZXJsYXlDdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBvdmVybGF5Q3R4LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcbmltcG9ydCBUeXBlRGVmcyBmcm9tICcuL2NvbW1vbi90eXBlZGVmcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgKiBhcyBSZWFkZXJzIGZyb20gJy4vcmVhZGVyL2luZGV4JztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnL2NvbmZpZyc7XG5cbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcblxuY29uc3QgaW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG5cbmNvbnN0IFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY2IgPSAoZXJyKSA9PiB7IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIGluaXRBYm9ydGVkIGZsYWcgd2hlbiBzdGFydGluZyBhIG5ldyBpbml0XG4gICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuaW5pdEFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAvLyBUT0RPICMxNzk6IHBlbmRpbmcgcmVzdHJ1Y3R1cmUgaW4gSXNzdWUgIzE3OSwgd2UgYXJlIHRlbXAgZGlzYWJsaW5nIHdvcmtlcnNcbiAgICAgICAgaWYgKHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5vblVJVGhyZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5pbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRJbnB1dFN0cmVhbShjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gKGNvbmZpZywgY2IpIHtcbiAgICAgICAgLy8gSWYgY29uZmlnIGlzIHByb3ZpZGVkLCBjYWxsIGluaXQoKSB0aGVuIHN0YXJ0KClcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgICAgICBpZiAoIWNiKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2IgPSAoZXJyKSA9PiB7IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHN0YXJ0RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKHN0YXJ0RXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGluaXQoKSBoYXNuJ3QgYmVlbiBjb21wbGV0ZWQsIHRocm93IGFuIGVycm9yXG4gICAgICAgIGlmICghX2NvbnRleHQuZnJhbWVncmFiYmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0KCkgd2FzIGNhbGxlZCBiZWZvcmUgaW5pdCgpIGNvbXBsZXRlZC4gJ1xuICAgICAgICAgICAgICAgICsgJ0NhbGwgaW5pdCgpIGZpcnN0LCBvciBjYWxsIHN0YXJ0KGNvbmZpZykgdG8gY29tYmluZSBpbml0IGFuZCBzdGFydC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhcnQoKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0b3AoKTtcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25EZXRlY3RlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uUHJvY2Vzc2VkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbiAocmVhZGVycykge1xuICAgICAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyBuYW1lLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyByZWFkZXIsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiAocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuICAgIGRyYXdTY2FubmVyQXJlYTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UuZHJhd1NjYW5uZXJBcmVhKCk7XG4gICAgfSxcbiAgICBkZWNvZGVTaW5nbGU6IGZ1bmN0aW9uIChjb25maWcsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHF1YWdnYUluc3RhbmNlID0gbmV3IFF1YWdnYSgpO1xuICAgICAgICBjb25maWcgPSBtZXJnZSh7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgICAgICAgICBzcmM6IGNvbmZpZy5zcmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVtT2ZXb3JrZXJzOiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1ZykgPyAwIDogMSxcbiAgICAgICAgICAgIGxvY2F0b3I6IHtcbiAgICAgICAgICAgICAgICBoYWxmU2FtcGxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3NTogcmVzdHJ1Y3R1cmUgd29ya2VyIHN1cHBvcnQgc28gdGhhdCBpdCB3aWxsIHdvcmsgd2l0aCB0eXBlc2NyaXB0IHVzaW5nIHdvcmtlci1sb2FkZXJcbiAgICAgICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9sb2FkZXJzL3dvcmtlci1sb2FkZXIvXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd29ya2VycyByZXF1aXJlIFdvcmtlciBhbmQgQmxvYiBzdXBwb3J0IHByZXNlbnRseSwgc28gaWYgbm8gQmxvYiBvciBXb3JrZXIgdGhlbiBzZXRcbiAgICAgICAgLy8gd29ya2VycyB0byAwLlxuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDAgJiYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBubyBXb3JrZXIgYW5kL29yIEJsb2Igc3VwcG9ydCAtIGZvcmNpbmcgbnVtT2ZXb3JrZXJzIHRvIDAnKTtcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdChjb25maWcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3luYyB0aGUgZGVjb2RlU2luZ2xlIGluc3RhbmNlJ3MgY2FudmFzIHRvIHRoZSBnbG9iYWwgX2NvbnRleHQgc28gUXVhZ2dhLmNhbnZhcyB3b3Jrc1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5jYW52YXNDb250YWluZXIgPSBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcblxuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBSZWFkZXJzLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcbmV4cG9ydCB7XG4gICAgQmFyY29kZURlY29kZXIsXG4gICAgUmVhZGVycyxcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=