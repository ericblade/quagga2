(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory();
	else
		root["Quagga"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 90);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(68);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _getPrototypeOf(t) {
  return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(68);
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
var assertThisInitialized = __webpack_require__(150);
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return assertThisInitialized(t);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(38);
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && setPrototypeOf(t, e);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(146)();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports) {

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(46);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(151);
function _get() {
  return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(102),
    getValue = __webpack_require__(108);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(91),
    createAssigner = __webpack_require__(134);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(152);
var iterableToArray = __webpack_require__(153);
var unsupportedIterableToArray = __webpack_require__(66);
var nonIterableSpread = __webpack_require__(154);
function _toConsumableArray(r) {
  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    getRawTag = __webpack_require__(104),
    objectToString = __webpack_require__(105);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(60),
    baseAssignValue = __webpack_require__(29);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(61),
    baseKeysIn = __webpack_require__(132),
    isArrayLike = __webpack_require__(26);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(92),
    listCacheDelete = __webpack_require__(93),
    listCacheGet = __webpack_require__(94),
    listCacheHas = __webpack_require__(95),
    listCacheSet = __webpack_require__(96);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(23);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(117);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(28),
    isLength = __webpack_require__(56);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isObject = __webpack_require__(10);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(50);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(124);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(55);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(126),
    isObjectLike = __webpack_require__(11);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8),
    stubFalse = __webpack_require__(128);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(30)(module)))

/***/ }),
/* 36 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(46);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(30)(module)))

/***/ }),
/* 38 */
/***/ (function(module, exports) {

function _setPrototypeOf(t, e) {
  return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(61),
    baseKeys = __webpack_require__(159),
    isArrayLike = __webpack_require__(26);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(163),
    stubArray = __webpack_require__(75);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(166),
    Map = __webpack_require__(27),
    Promise = __webpack_require__(167),
    Set = __webpack_require__(168),
    WeakMap = __webpack_require__(169),
    baseGetTag = __webpack_require__(17),
    toSource = __webpack_require__(47);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(12),
    isKey = __webpack_require__(180),
    stringToPath = __webpack_require__(181),
    toString = __webpack_require__(184);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(21),
    stackClear = __webpack_require__(97),
    stackDelete = __webpack_require__(98),
    stackGet = __webpack_require__(99),
    stackHas = __webpack_require__(100),
    stackSet = __webpack_require__(101);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(103)))

/***/ }),
/* 47 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(109),
    mapCacheDelete = __webpack_require__(116),
    mapCacheGet = __webpack_require__(118),
    mapCacheHas = __webpack_require__(119),
    mapCacheSet = __webpack_require__(120);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(29),
    eq = __webpack_require__(23);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(30)(module)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(31);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 53 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(125),
    getPrototype = __webpack_require__(32),
    isPrototype = __webpack_require__(33);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 56 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    getPrototype = __webpack_require__(32),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(129),
    baseUnary = __webpack_require__(36),
    nodeUtil = __webpack_require__(37);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 59 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(29),
    eq = __webpack_require__(23);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(131),
    isArguments = __webpack_require__(34),
    isArray = __webpack_require__(12),
    isBuffer = __webpack_require__(35),
    isIndex = __webpack_require__(62),
    isTypedArray = __webpack_require__(58);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 62 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(136);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(137),
    shortOut = __webpack_require__(139);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(67);
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
  }
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
var toPrimitive = __webpack_require__(145);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 69 */
/***/ (function(module, exports) {

function _OverloadYield(e, d) {
  this.v = e, this.k = d;
}
module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var regeneratorDefine = __webpack_require__(71);
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return regeneratorDefine(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = !1,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function d(t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = !0, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), !0), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function () {
    return this;
  }), regeneratorDefine(u, "toString", function () {
    return "[object Generator]";
  }), (module.exports = _regenerator = function _regenerator() {
    return {
      w: i,
      m: f
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  module.exports = _regeneratorDefine = function regeneratorDefine(e, r, n, t) {
    function o(r, n) {
      _regeneratorDefine(e, r, function (e) {
        return this._invoke(r, n, e);
      });
    }
    r ? i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
}
module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var regenerator = __webpack_require__(70);
var regeneratorAsyncIterator = __webpack_require__(73);
function _regeneratorAsyncGen(r, e, t, o, n) {
  return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
}
module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var OverloadYield = __webpack_require__(69);
var regeneratorDefine = __webpack_require__(71);
function AsyncIterator(t, e) {
  function n(r, o, i, f) {
    try {
      var c = t[r](o),
        u = c.value;
      return u instanceof OverloadYield ? e.resolve(u.v).then(function (t) {
        n("next", t, i, f);
      }, function (t) {
        n("throw", t, i, f);
      }) : e.resolve(u).then(function (t) {
        c.value = t, i(c);
      }, function (t) {
        return n("throw", t, i, f);
      });
    } catch (t) {
      f(t);
    }
  }
  var r;
  this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function () {
    return this;
  })), regeneratorDefine(this, "_invoke", function (t, o, i) {
    function f() {
      return new e(function (e, r) {
        n(t, i, e, r);
      });
    }
    return r = r ? r.then(f, f) : f();
  }, !0);
}
module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 75 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(41),
    getPrototype = __webpack_require__(32),
    getSymbols = __webpack_require__(40),
    stubArray = __webpack_require__(75);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(41),
    isArray = __webpack_require__(12);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(77),
    getSymbolsIn = __webpack_require__(76),
    keysIn = __webpack_require__(20);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(44);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(142);
var iterableToArrayLimit = __webpack_require__(143);
var unsupportedIterableToArray = __webpack_require__(66);
var nonIterableRest = __webpack_require__(144);
function _slicedToArray(r, e) {
  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(155);
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(74),
    baseClone = __webpack_require__(156),
    baseUnset = __webpack_require__(179),
    castPath = __webpack_require__(43),
    copyObject = __webpack_require__(18),
    customOmitClone = __webpack_require__(190),
    flatRest = __webpack_require__(191),
    getAllKeysIn = __webpack_require__(78);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(1);
var setPrototypeOf = __webpack_require__(38);
var isNativeFunction = __webpack_require__(195);
var construct = __webpack_require__(196);
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return module.exports = _wrapNativeSuper = function _wrapNativeSuper(t) {
    if (null === t || !isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return construct(t, arguments, getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), setPrototypeOf(Wrapper, t);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(198);


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(45),
    assignMergeValue = __webpack_require__(49),
    baseFor = __webpack_require__(121),
    baseMergeDeep = __webpack_require__(123),
    isObject = __webpack_require__(10),
    keysIn = __webpack_require__(20),
    safeGet = __webpack_require__(59);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(22);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(21);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 99 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 100 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(21),
    Map = __webpack_require__(27),
    MapCache = __webpack_require__(48);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(28),
    isMasked = __webpack_require__(106),
    isObject = __webpack_require__(10),
    toSource = __webpack_require__(47);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 105 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(107);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(110),
    ListCache = __webpack_require__(21),
    Map = __webpack_require__(27);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(111),
    hashDelete = __webpack_require__(112),
    hashGet = __webpack_require__(113),
    hashHas = __webpack_require__(114),
    hashSet = __webpack_require__(115);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 112 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(24);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 117 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(25);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(122);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 122 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(49),
    cloneBuffer = __webpack_require__(51),
    cloneTypedArray = __webpack_require__(52),
    copyArray = __webpack_require__(53),
    initCloneObject = __webpack_require__(54),
    isArguments = __webpack_require__(34),
    isArray = __webpack_require__(12),
    isArrayLikeObject = __webpack_require__(127),
    isBuffer = __webpack_require__(35),
    isFunction = __webpack_require__(28),
    isObject = __webpack_require__(10),
    isPlainObject = __webpack_require__(57),
    isTypedArray = __webpack_require__(58),
    safeGet = __webpack_require__(59),
    toPlainObject = __webpack_require__(130);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(10);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(26),
    isObjectLike = __webpack_require__(11);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 128 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(17),
    isLength = __webpack_require__(56),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    keysIn = __webpack_require__(20);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 131 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(10),
    isPrototype = __webpack_require__(33),
    nativeKeysIn = __webpack_require__(133);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 133 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(135),
    isIterateeCall = __webpack_require__(140);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(63),
    overRest = __webpack_require__(64),
    setToString = __webpack_require__(65);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 136 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(138),
    defineProperty = __webpack_require__(50),
    identity = __webpack_require__(63);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 138 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(23),
    isArrayLike = __webpack_require__(26),
    isIndex = __webpack_require__(62),
    isObject = __webpack_require__(10);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */

if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (/* function FrameRequestCallback */callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}
if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */
}
if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2

    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }
    var to = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];
      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}

/***/ }),
/* 142 */
/***/ (function(module, exports) {

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var OverloadYield = __webpack_require__(69);
var regenerator = __webpack_require__(70);
var regeneratorAsync = __webpack_require__(147);
var regeneratorAsyncGen = __webpack_require__(72);
var regeneratorAsyncIterator = __webpack_require__(73);
var regeneratorKeys = __webpack_require__(148);
var regeneratorValues = __webpack_require__(149);
function _regeneratorRuntime() {
  "use strict";

  var r = regenerator(),
    e = r.m(_regeneratorRuntime),
    t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
  function n(r) {
    var e = "function" == typeof r && r.constructor;
    return !!e && (e === t || "GeneratorFunction" === (e.displayName || e.name));
  }
  var o = {
    "throw": 1,
    "return": 2,
    "break": 3,
    "continue": 3
  };
  function a(r) {
    var e, t;
    return function (n) {
      e || (e = {
        stop: function stop() {
          return t(n.a, 2);
        },
        "catch": function _catch() {
          return n.v;
        },
        abrupt: function abrupt(r, e) {
          return t(n.a, o[r], e);
        },
        delegateYield: function delegateYield(r, o, a) {
          return e.resultName = o, t(n.d, regeneratorValues(r), a);
        },
        finish: function finish(r) {
          return t(n.f, r);
        }
      }, t = function t(r, _t, o) {
        n.p = e.prev, n.n = e.next;
        try {
          return r(_t, o);
        } finally {
          e.next = n.n;
        }
      }), e.resultName && (e[e.resultName] = n.v, e.resultName = void 0), e.sent = n.v, e.next = n.n;
      try {
        return r.call(this, e);
      } finally {
        n.p = e.prev, n.n = e.next;
      }
    };
  }
  return (module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return {
      wrap: function wrap(e, t, n, o) {
        return r.w(a(e), t, n, o && o.reverse());
      },
      isGeneratorFunction: n,
      mark: r.m,
      awrap: function awrap(r, e) {
        return new OverloadYield(r, e);
      },
      AsyncIterator: regeneratorAsyncIterator,
      async: function async(r, e, t, o, u) {
        return (n(e) ? regeneratorAsyncGen : regeneratorAsync)(a(r), e, t, o, u);
      },
      keys: regeneratorKeys,
      values: regeneratorValues
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var regeneratorAsyncGen = __webpack_require__(72);
function _regeneratorAsync(n, e, r, t, o) {
  var a = regeneratorAsyncGen(n, e, r, t, o);
  return a.next().then(function (n) {
    return n.done ? n.value : a.next();
  });
}
module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 148 */
/***/ (function(module, exports) {

function _regeneratorKeys(e) {
  var n = Object(e),
    r = [];
  for (var t in n) r.unshift(t);
  return function e() {
    for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e;
    return e.done = !0, e;
  };
}
module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(9)["default"];
function _regeneratorValues(e) {
  if (null != e) {
    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
      r = 0;
    if (t) return t.call(e);
    if ("function" == typeof e.next) return e;
    if (!isNaN(e.length)) return {
      next: function next() {
        return e && r >= e.length && (e = void 0), {
          value: e && e[r++],
          done: !e
        };
      }
    };
  }
  throw new TypeError(_typeof(e) + " is not iterable");
}
module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(1);
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)););
  return t;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(67);
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return arrayLikeToArray(r);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 153 */
/***/ (function(module, exports) {

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 155 */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(45),
    arrayEach = __webpack_require__(157),
    assignValue = __webpack_require__(60),
    baseAssign = __webpack_require__(158),
    baseAssignIn = __webpack_require__(161),
    cloneBuffer = __webpack_require__(51),
    copyArray = __webpack_require__(53),
    copySymbols = __webpack_require__(162),
    copySymbolsIn = __webpack_require__(164),
    getAllKeys = __webpack_require__(165),
    getAllKeysIn = __webpack_require__(78),
    getTag = __webpack_require__(42),
    initCloneArray = __webpack_require__(170),
    initCloneByTag = __webpack_require__(171),
    initCloneObject = __webpack_require__(54),
    isArray = __webpack_require__(12),
    isBuffer = __webpack_require__(35),
    isMap = __webpack_require__(175),
    isObject = __webpack_require__(10),
    isSet = __webpack_require__(177),
    keys = __webpack_require__(39),
    keysIn = __webpack_require__(20);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 157 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    keys = __webpack_require__(39);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(33),
    nativeKeys = __webpack_require__(160);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(55);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    keysIn = __webpack_require__(20);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    getSymbols = __webpack_require__(40);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(18),
    getSymbolsIn = __webpack_require__(76);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(77),
    getSymbols = __webpack_require__(40),
    keys = __webpack_require__(39);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(14),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(31),
    cloneDataView = __webpack_require__(172),
    cloneRegExp = __webpack_require__(173),
    cloneSymbol = __webpack_require__(174),
    cloneTypedArray = __webpack_require__(52);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(31);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 173 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(176),
    baseUnary = __webpack_require__(36),
    nodeUtil = __webpack_require__(37);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(42),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(178),
    baseUnary = __webpack_require__(36),
    nodeUtil = __webpack_require__(37);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(42),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(43),
    last = __webpack_require__(186),
    parent = __webpack_require__(187),
    toKey = __webpack_require__(79);

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(12),
    isSymbol = __webpack_require__(44);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(182);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(183);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(48);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(185);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    arrayMap = __webpack_require__(74),
    isArray = __webpack_require__(12),
    isSymbol = __webpack_require__(44);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 186 */
/***/ (function(module, exports) {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(188),
    baseSlice = __webpack_require__(189);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(43),
    toKey = __webpack_require__(79);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 189 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var isPlainObject = __webpack_require__(57);

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(192),
    overRest = __webpack_require__(64),
    setToString = __webpack_require__(65);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(193);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(41),
    isFlattenable = __webpack_require__(194);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    isArguments = __webpack_require__(34),
    isArray = __webpack_require__(12);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 195 */
/***/ (function(module, exports) {

function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var isNativeReflectConstruct = __webpack_require__(197);
var setPrototypeOf = __webpack_require__(38);
function _construct(t, e, r) {
  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && setPrototypeOf(p, r.prototype), p;
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 197 */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "Readers", function() { return /* reexport */ reader_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/mat2.js
var mat2_namespaceObject = {};
__webpack_require__.r(mat2_namespaceObject);
__webpack_require__.d(mat2_namespaceObject, "create", function() { return mat2_create; });
__webpack_require__.d(mat2_namespaceObject, "clone", function() { return clone; });
__webpack_require__.d(mat2_namespaceObject, "copy", function() { return copy; });
__webpack_require__.d(mat2_namespaceObject, "identity", function() { return identity; });
__webpack_require__.d(mat2_namespaceObject, "fromValues", function() { return fromValues; });
__webpack_require__.d(mat2_namespaceObject, "set", function() { return set; });
__webpack_require__.d(mat2_namespaceObject, "transpose", function() { return transpose; });
__webpack_require__.d(mat2_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(mat2_namespaceObject, "adjoint", function() { return adjoint; });
__webpack_require__.d(mat2_namespaceObject, "determinant", function() { return determinant; });
__webpack_require__.d(mat2_namespaceObject, "multiply", function() { return multiply; });
__webpack_require__.d(mat2_namespaceObject, "rotate", function() { return rotate; });
__webpack_require__.d(mat2_namespaceObject, "scale", function() { return mat2_scale; });
__webpack_require__.d(mat2_namespaceObject, "fromRotation", function() { return fromRotation; });
__webpack_require__.d(mat2_namespaceObject, "fromScaling", function() { return fromScaling; });
__webpack_require__.d(mat2_namespaceObject, "str", function() { return str; });
__webpack_require__.d(mat2_namespaceObject, "frob", function() { return frob; });
__webpack_require__.d(mat2_namespaceObject, "LDU", function() { return LDU; });
__webpack_require__.d(mat2_namespaceObject, "add", function() { return add; });
__webpack_require__.d(mat2_namespaceObject, "subtract", function() { return subtract; });
__webpack_require__.d(mat2_namespaceObject, "exactEquals", function() { return exactEquals; });
__webpack_require__.d(mat2_namespaceObject, "equals", function() { return mat2_equals; });
__webpack_require__.d(mat2_namespaceObject, "multiplyScalar", function() { return multiplyScalar; });
__webpack_require__.d(mat2_namespaceObject, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
__webpack_require__.d(mat2_namespaceObject, "mul", function() { return mul; });
__webpack_require__.d(mat2_namespaceObject, "sub", function() { return sub; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec2.js
var vec2_namespaceObject = {};
__webpack_require__.r(vec2_namespaceObject);
__webpack_require__.d(vec2_namespaceObject, "create", function() { return vec2_create; });
__webpack_require__.d(vec2_namespaceObject, "clone", function() { return vec2_clone; });
__webpack_require__.d(vec2_namespaceObject, "fromValues", function() { return vec2_fromValues; });
__webpack_require__.d(vec2_namespaceObject, "copy", function() { return vec2_copy; });
__webpack_require__.d(vec2_namespaceObject, "set", function() { return vec2_set; });
__webpack_require__.d(vec2_namespaceObject, "add", function() { return vec2_add; });
__webpack_require__.d(vec2_namespaceObject, "subtract", function() { return vec2_subtract; });
__webpack_require__.d(vec2_namespaceObject, "multiply", function() { return vec2_multiply; });
__webpack_require__.d(vec2_namespaceObject, "divide", function() { return divide; });
__webpack_require__.d(vec2_namespaceObject, "ceil", function() { return ceil; });
__webpack_require__.d(vec2_namespaceObject, "floor", function() { return floor; });
__webpack_require__.d(vec2_namespaceObject, "min", function() { return min; });
__webpack_require__.d(vec2_namespaceObject, "max", function() { return vec2_max; });
__webpack_require__.d(vec2_namespaceObject, "round", function() { return vec2_round; });
__webpack_require__.d(vec2_namespaceObject, "scale", function() { return vec2_scale; });
__webpack_require__.d(vec2_namespaceObject, "scaleAndAdd", function() { return scaleAndAdd; });
__webpack_require__.d(vec2_namespaceObject, "distance", function() { return distance; });
__webpack_require__.d(vec2_namespaceObject, "squaredDistance", function() { return squaredDistance; });
__webpack_require__.d(vec2_namespaceObject, "length", function() { return vec2_length; });
__webpack_require__.d(vec2_namespaceObject, "squaredLength", function() { return squaredLength; });
__webpack_require__.d(vec2_namespaceObject, "negate", function() { return negate; });
__webpack_require__.d(vec2_namespaceObject, "inverse", function() { return inverse; });
__webpack_require__.d(vec2_namespaceObject, "normalize", function() { return normalize; });
__webpack_require__.d(vec2_namespaceObject, "dot", function() { return dot; });
__webpack_require__.d(vec2_namespaceObject, "cross", function() { return cross; });
__webpack_require__.d(vec2_namespaceObject, "lerp", function() { return lerp; });
__webpack_require__.d(vec2_namespaceObject, "random", function() { return random; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2", function() { return transformMat2; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2d", function() { return transformMat2d; });
__webpack_require__.d(vec2_namespaceObject, "transformMat3", function() { return transformMat3; });
__webpack_require__.d(vec2_namespaceObject, "transformMat4", function() { return transformMat4; });
__webpack_require__.d(vec2_namespaceObject, "rotate", function() { return vec2_rotate; });
__webpack_require__.d(vec2_namespaceObject, "angle", function() { return angle; });
__webpack_require__.d(vec2_namespaceObject, "signedAngle", function() { return signedAngle; });
__webpack_require__.d(vec2_namespaceObject, "zero", function() { return zero; });
__webpack_require__.d(vec2_namespaceObject, "str", function() { return vec2_str; });
__webpack_require__.d(vec2_namespaceObject, "exactEquals", function() { return vec2_exactEquals; });
__webpack_require__.d(vec2_namespaceObject, "equals", function() { return vec2_equals; });
__webpack_require__.d(vec2_namespaceObject, "len", function() { return len; });
__webpack_require__.d(vec2_namespaceObject, "sub", function() { return vec2_sub; });
__webpack_require__.d(vec2_namespaceObject, "mul", function() { return vec2_mul; });
__webpack_require__.d(vec2_namespaceObject, "div", function() { return div; });
__webpack_require__.d(vec2_namespaceObject, "dist", function() { return dist; });
__webpack_require__.d(vec2_namespaceObject, "sqrDist", function() { return sqrDist; });
__webpack_require__.d(vec2_namespaceObject, "sqrLen", function() { return sqrLen; });
__webpack_require__.d(vec2_namespaceObject, "forEach", function() { return forEach; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec3.js
var vec3_namespaceObject = {};
__webpack_require__.r(vec3_namespaceObject);
__webpack_require__.d(vec3_namespaceObject, "create", function() { return vec3_create; });
__webpack_require__.d(vec3_namespaceObject, "clone", function() { return vec3_clone; });
__webpack_require__.d(vec3_namespaceObject, "length", function() { return vec3_length; });
__webpack_require__.d(vec3_namespaceObject, "fromValues", function() { return vec3_fromValues; });
__webpack_require__.d(vec3_namespaceObject, "copy", function() { return vec3_copy; });
__webpack_require__.d(vec3_namespaceObject, "set", function() { return vec3_set; });
__webpack_require__.d(vec3_namespaceObject, "add", function() { return vec3_add; });
__webpack_require__.d(vec3_namespaceObject, "subtract", function() { return vec3_subtract; });
__webpack_require__.d(vec3_namespaceObject, "multiply", function() { return vec3_multiply; });
__webpack_require__.d(vec3_namespaceObject, "divide", function() { return vec3_divide; });
__webpack_require__.d(vec3_namespaceObject, "ceil", function() { return vec3_ceil; });
__webpack_require__.d(vec3_namespaceObject, "floor", function() { return vec3_floor; });
__webpack_require__.d(vec3_namespaceObject, "min", function() { return vec3_min; });
__webpack_require__.d(vec3_namespaceObject, "max", function() { return vec3_max; });
__webpack_require__.d(vec3_namespaceObject, "round", function() { return vec3_round; });
__webpack_require__.d(vec3_namespaceObject, "scale", function() { return vec3_scale; });
__webpack_require__.d(vec3_namespaceObject, "scaleAndAdd", function() { return vec3_scaleAndAdd; });
__webpack_require__.d(vec3_namespaceObject, "distance", function() { return vec3_distance; });
__webpack_require__.d(vec3_namespaceObject, "squaredDistance", function() { return vec3_squaredDistance; });
__webpack_require__.d(vec3_namespaceObject, "squaredLength", function() { return vec3_squaredLength; });
__webpack_require__.d(vec3_namespaceObject, "negate", function() { return vec3_negate; });
__webpack_require__.d(vec3_namespaceObject, "inverse", function() { return vec3_inverse; });
__webpack_require__.d(vec3_namespaceObject, "normalize", function() { return vec3_normalize; });
__webpack_require__.d(vec3_namespaceObject, "dot", function() { return vec3_dot; });
__webpack_require__.d(vec3_namespaceObject, "cross", function() { return vec3_cross; });
__webpack_require__.d(vec3_namespaceObject, "lerp", function() { return vec3_lerp; });
__webpack_require__.d(vec3_namespaceObject, "slerp", function() { return slerp; });
__webpack_require__.d(vec3_namespaceObject, "hermite", function() { return hermite; });
__webpack_require__.d(vec3_namespaceObject, "bezier", function() { return bezier; });
__webpack_require__.d(vec3_namespaceObject, "random", function() { return vec3_random; });
__webpack_require__.d(vec3_namespaceObject, "transformMat4", function() { return vec3_transformMat4; });
__webpack_require__.d(vec3_namespaceObject, "transformMat3", function() { return vec3_transformMat3; });
__webpack_require__.d(vec3_namespaceObject, "transformQuat", function() { return transformQuat; });
__webpack_require__.d(vec3_namespaceObject, "rotateX", function() { return rotateX; });
__webpack_require__.d(vec3_namespaceObject, "rotateY", function() { return rotateY; });
__webpack_require__.d(vec3_namespaceObject, "rotateZ", function() { return rotateZ; });
__webpack_require__.d(vec3_namespaceObject, "angle", function() { return vec3_angle; });
__webpack_require__.d(vec3_namespaceObject, "zero", function() { return vec3_zero; });
__webpack_require__.d(vec3_namespaceObject, "str", function() { return vec3_str; });
__webpack_require__.d(vec3_namespaceObject, "exactEquals", function() { return vec3_exactEquals; });
__webpack_require__.d(vec3_namespaceObject, "equals", function() { return vec3_equals; });
__webpack_require__.d(vec3_namespaceObject, "sub", function() { return vec3_sub; });
__webpack_require__.d(vec3_namespaceObject, "mul", function() { return vec3_mul; });
__webpack_require__.d(vec3_namespaceObject, "div", function() { return vec3_div; });
__webpack_require__.d(vec3_namespaceObject, "dist", function() { return vec3_dist; });
__webpack_require__.d(vec3_namespaceObject, "sqrDist", function() { return vec3_sqrDist; });
__webpack_require__.d(vec3_namespaceObject, "len", function() { return vec3_len; });
__webpack_require__.d(vec3_namespaceObject, "sqrLen", function() { return vec3_sqrLen; });
__webpack_require__.d(vec3_namespaceObject, "forEach", function() { return vec3_forEach; });

// NAMESPACE OBJECT: ./src/reader/index.ts
var reader_namespaceObject = {};
__webpack_require__.r(reader_namespaceObject);
__webpack_require__.d(reader_namespaceObject, "BarcodeReader", function() { return barcode_reader; });
__webpack_require__.d(reader_namespaceObject, "TwoOfFiveReader", function() { return _2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "NewCodabarReader", function() { return codabar_reader; });
__webpack_require__.d(reader_namespaceObject, "Code128Reader", function() { return code_128_reader; });
__webpack_require__.d(reader_namespaceObject, "Code32Reader", function() { return code_32_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39Reader", function() { return code_39_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39VINReader", function() { return code_39_vin_reader; });
__webpack_require__.d(reader_namespaceObject, "Code93Reader", function() { return code_93_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN2Reader", function() { return ean_2_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN5Reader", function() { return ean_5_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN8Reader", function() { return ean_8_reader; });
__webpack_require__.d(reader_namespaceObject, "EANReader", function() { return ean_reader; });
__webpack_require__.d(reader_namespaceObject, "I2of5Reader", function() { return i2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "PharmacodeReader", function() { return pharmacode_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCEReader", function() { return upc_e_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCReader", function() { return upc_reader; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(9);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(15);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(141);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(80);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(2);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(3);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var ANGLE_ORDER = "zyx";

/**
 * Symmetric round
 * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background
 *
 * @param {Number} a value to round
 */
function round(a) {
  if (a >= 0) return Math.round(a);
  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);
}

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Convert Radian To Degree
 *
 * @param {Number} a Angle in Radians
 */
function toDegree(a) {
  return a * radian;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a          The first number to test.
 * @param {Number} b          The second number to test.
 * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;
  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));
}
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat2.js


/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function mat2_create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }
  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2 | null} out, or null if source matrix is not invertible
 */
function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is necessary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function mat2_scale(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat2_equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
var sub = subtract;
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec2.js


/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function vec2_create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function vec2_clone(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function vec2_fromValues(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */
function vec2_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function vec2_set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * symmetric round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */
function vec2_round(out, a) {
  out[0] = round(a[0]);
  out[1] = round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function vec2_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec2_length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */
function vec2_rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}

/**
 * Get the smallest angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
}

/**
 * Get the signed angle in the interval [-pi,pi] between two 2D vectors (positive if `a` is to the right of `b`)
 * 
 * @param {ReadonlyVec2} a The first vector
 * @param {ReadonlyVec2} b The second vector
 * @returns {number} The signed angle in radians
 */
function signedAngle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}

/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */
function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec2_str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = vec2_length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var vec2_sub = vec2_subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var vec2_mul = vec2_multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = vec2_create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js


/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function vec3_create() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function vec3_clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec3_length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function vec3_fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */
function vec3_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function vec3_set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */
function vec3_ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */
function vec3_floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * symmetric round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */
function vec3_round(out, a) {
  out[0] = round(a[0]);
  out[1] = round(a[1]);
  out[2] = round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function vec3_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function vec3_scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */
function vec3_distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function vec3_squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function vec3_squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */
function vec3_negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */
function vec3_inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */
function vec3_normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec3_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function vec3_lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a spherical linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function slerp(out, a, b, t) {
  var angle = Math.acos(Math.min(Math.max(vec3_dot(a, b), -1), 1));
  var sinTotal = Math.sin(angle);
  var ratioA = Math.sin((1 - t) * angle) / sinTotal;
  var ratioB = Math.sin(t * angle) / sinTotal;
  out[0] = ratioA * a[0] + ratioB * b[0];
  out[1] = ratioA * a[1] + ratioB * b[1];
  out[2] = ratioA * a[2] + ratioB * b[2];
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec3} out
 */
function vec3_random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = RANDOM() * 2.0 * Math.PI;
  var z = RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */
function vec3_transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function vec3_transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q normalized quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // Fast Vector Rotation using Quaternions by Robert Eisele
  // https://raw.org/proof/vector-rotation-using-quaternions/

  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var vx = a[0],
    vy = a[1],
    vz = a[2];

  // t = q x v
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;

  // t = 2t
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;

  // v + w t + q x t
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateX(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateY(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateZ(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */
function vec3_angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)),
    cosine = mag && vec3_dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}

/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */
function vec3_zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec3_str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var vec3_sub = vec3_subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var vec3_mul = vec3_multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var vec3_div = vec3_divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var vec3_dist = vec3_distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var vec3_sqrDist = vec3_squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var vec3_len = vec3_length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var vec3_sqrLen = vec3_squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var vec3_forEach = function () {
  var vec = vec3_create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/index.js











// CONCATENATED MODULE: ./src/common/array_helper.ts
/* eslint-disable no-param-reassign */

/* harmony default export */ var array_helper = ({
  init: function init(arr, val) {
    arr.fill(val);
  },
  /**
   * IN-PLACE Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    // Durstenfeld shuffle algorithm
    // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
    for (var i = arr.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var _ref = [arr[j], arr[i]];
      arr[i] = _ref[0];
      arr[j] = _ref[1];
    }
    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },
  /**
   * returns the elements which's score is bigger than the threshold
   */
  // eslint-disable-next-line no-unused-vars
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }
      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }
    return max;
  },
  max: function max(arr) {
    var max = 0;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }
    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;
    while (length--) {
      sum += arr[length];
    }
    return sum;
  }
});
// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)



/**
 * Creates a cluster for grouping similar orientations of datapoints
 */
/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2_namespaceObject.clone([0, 0])
    };
    var pointMap = {};
    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }
    function updateCenter() {
      var i;
      var sum = 0;
      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }
      center.rad = sum / points.length;
      center.vec = vec2_namespaceObject.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }
    function init() {
      _add(point);
      updateCenter();
    }
    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);
          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2_namespaceObject.dot(otherPoint.point.vec, center.vec));
        if (similarity > threshold) {
          return true;
        }
        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */
/* eslint-disable no-bitwise */




/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */
function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return vec2_namespaceObject.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3_namespaceObject.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}

/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */
function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y;

  // sum up first column
  posB = width;
  sum = 0;
  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }
  posA = 0;
  posB = 1;
  sum = 0;
  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }
  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;
    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;

  // sum up first row
  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }
  for (var v = 1; v < height; v++) {
    sum = 0;
    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }
  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;
  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }
  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);
  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }
  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;
  for (i = 1; i < length - 1; i++) {
    right = line[i + 1];
    //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign
    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }
  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;
  function px(init, end) {
    var sum = 0;
    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }
    return sum;
  }
  function mx(init, end) {
    var sum = 0;
    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }
    return sum;
  }
  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);
    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;
      if (p12 === 0) {
        p12 = 1;
      }
      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }
    return array_helper.maxIndex(vet);
  }
  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
}

// local thresholding
function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }
  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1);

  // clear out top & bottom-border
  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  }

  // clear out left & right border
  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }
  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];
  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }
  function addToCluster(newPoint) {
    var found = false;
    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];
      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }
    return found;
  }

  // iterate over each cloud
  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);
    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }
  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;
    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;
      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }
        return false;
      }

      // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met

      var from = points[idx];
      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }
      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx];
      // eslint-disable-next-line no-cond-assign
      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }
      return found ? toIdx : null;
    }
    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length);

      // trace forward
      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]);
      // eslint-disable-next-line no-cond-assign
      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }
      if (centerPos > 0) {
        currentPos = centerPos;
        // eslint-disable-next-line no-cond-assign
        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }
      if (top.length > result.length) {
        result = top;
      }
    }
    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;
  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;
  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function cv_utils_subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }
  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;
  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }
  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;
  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;
  while (length--) {
    sum += data[length];
  }
  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;
  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }
  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);
    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;
      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }
  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;
  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }
    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;
  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;
  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width;
    // eslint-disable-next-line no-param-reassign
    canvas.height = this.height;
    console.warn('* loadImageArray getContext 2d');
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);
    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
      data = _ctx$getImageData.data;
    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };
  img.src = src;
}

/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */
function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;
  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }
    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;
  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  }
  // eslint-disable-next-line no-param-reassign
  rgb[0] = (r + m) * 255 | 0;
  // eslint-disable-next-line no-param-reassign
  rgb[1] = (g + m) * 255 | 0;
  // eslint-disable-next-line no-param-reassign
  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  // Handle edge cases
  // NaN: Not a number - no meaningful divisors
  // Infinity: Infinite values have no finite divisors
  // Non-positive: Divisors are typically defined for positive integers only
  // While negative numbers technically have divisors, returning them would complicate
  // the API (would need to return both positive and negative divisors, or make assumptions)
  if (!Number.isFinite(n) || n < 1) {
    return [];
  }
  var largeDivisors = [];
  var divisors = [];
  var sqrtN = Math.sqrt(n);
  for (var i = 1; i <= sqrtN; i++) {
    if (n % i === 0) {
      divisors.push(i);
      // Only add the complementary divisor if it's different (not a perfect square root)
      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }
  return divisors.concat(largeDivisors);
}
function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }
  return result;
}
function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);
  var divisorsY = _computeDivisors(imgSize.y);
  var wideSide = Math.max(imgSize.x, imgSize.y);
  var common = _computeIntersection(divisorsX, divisorsY);
  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;
  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];
    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }
    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }
    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }
    return null;
  }
  optimalPatchSize = findPatchSizeForDivisors(common);
  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));
    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }
  // Fallback: if no optimal patch size found, use image size (or 1x1 minimum)
  // This ensures the function always returns a valid {x, y} object
  if (!optimalPatchSize) {
    optimalPatchSize = {
      x: Math.max(1, imgSize.x),
      y: Math.max(1, imgSize.y)
    };
  }
  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    // Skip styling properties that aren't dimension converters
    if (!_dimensionsConverters[key]) {
      return result;
    }
    var value = area[key];
    var parsed = _parseCSSDimensionValues(value);
    var calculated = _dimensionsConverters[key](parsed, context);

    // eslint-disable-next-line no-param-reassign
    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}
// CONCATENATED MODULE: ./src/common/image_wrapper.ts







function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}
var image_wrapper_ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;
    classCallCheck_default()(this, ImageWrapper);
    defineProperty_default()(this, "data", void 0);
    defineProperty_default()(this, "size", void 0);
    defineProperty_default()(this, "indexMapping", void 0);
    if (!data) {
      this.data = new ArrayType(size.x * size.y);
      if (initialize) {
        array_helper.init(this.data, 0);
      }
    } else {
      this.data = data;
    }
    this.size = size;
  }

  // tests if a position is within the image, extended out by a border on each side
  return createClass_default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border);
      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    }

    // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.
  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
        sizeX = _imageWrapper$size.x,
        sizeY = _imageWrapper$size.y;
      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }
      return imageWrapper;
      // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    }

    // Retrieve a grayscale value at the given pixel position of the image
  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    }

    // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)
  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };
        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }
        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }
      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    }

    // Sets a given pixel position in the image to the given grayscale value
  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    }

    // Sets the border of the image (1 pixel) to zero
  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
        width = _this$size.x,
        height = _this$size.y;
      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }
      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }
      delete this.indexMapping;
      return this;
    }

    // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.
  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;
      if (labelCount <= 0) {
        return result;
      }
      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }
      for (y = 0; y < height; y++) {
        ysq = y * y;
        for (x = 0; x < width; x++) {
          val = data[y * width + x];
          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }
      for (i = 0; i < labelCount; i++) {
        label = labelSum[i];
        // eslint-disable-next-line no-restricted-globals
        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI;
          // eslint-disable-next-line no-mixed-operators
          label.theta = (tmp * 180 / PI + 90) % 180 - 90;
          if (label.theta < 0) {
            label.theta += 180;
          }
          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2_namespaceObject.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }
      return result;
    }

    // return a Uint8ClampedArray containing this grayscale image converted to RGBA form
  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);
      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }
      return ret;
    }

    // Display this ImageWrapper in a given Canvas element at the specified scale
  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      console.warn('* imagewrapper show getcontext 2d');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }
      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale);
      // eslint-disable-next-line no-param-reassign
      canvas.width = this.size.x;
      // eslint-disable-next-line no-param-reassign
      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    }

    // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.
  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      console.warn('* imagewrapper overlay getcontext 2d');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }
      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;
      while (length--) {
        hsv[0] = this.data[length] * adjustedScale;
        // eslint-disable-next-line no-nested-ternary
        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : hsv2rgb(hsv, rgb);
        var pos = length * 4;
        var _result = result;
        var _result2 = slicedToArray_default()(_result, 3);
        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }
      ctx.putImageData(frame, from.x, from.y);
    }
  }]);
}();
/* harmony default export */ var image_wrapper = (image_wrapper_ImageWrapper);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(7);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(6);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// CONCATENATED MODULE: ./src/common/image_debug.ts
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.

// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.

/* harmony default export */ var image_debug = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);
    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }
    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;
    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }
    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }
    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(4);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(1);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(5);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts



/* eslint-disable no-unused-vars */
/* eslint-disable class-methods-use-this */
// eslint-disable-next-line import/no-cycle



// for some reason this throws a shadow error on itself?!
// eslint-disable-next-line no-shadow
var BarcodeDirection = /*#__PURE__*/function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
  return BarcodeDirection;
}({});
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);
    defineProperty_default()(this, "_row", []);
    defineProperty_default()(this, "config", {});
    defineProperty_default()(this, "supplements", []);
    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);
    defineProperty_default()(this, "FORMAT", 'unknown');
    defineProperty_default()(this, "CONFIG_KEYS", {});
    this._row = [];
    this.config = config || {};
    if (supplements) {
      this.supplements = supplements;
    }
  }
  return createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }
      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      var maxSingleError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.SINGLE_CODE_ERROR || 1;
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }
      if (sum < modulo) {
        return Number.MAX_VALUE;
      }
      barWidth = sum / modulo;
      // eslint-disable-next-line no-param-reassign
      maxSingleError *= barWidth;
      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;
        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }
        error += singleError;
      }
      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }
      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;
      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);
        if (tmp > 1) {
          // eslint-disable-next-line no-param-reassign
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern;
      // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));
      var result = this.decode();
      // console.warn('* first result=', result);
      if (result === null) {
        this._row.reverse();
        result = this.decode();
        // console.warn('* reversed result=', result);
        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }
      if (result) {
        result.format = this.FORMAT;
      }
      // console.warn('* returning', result);
      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      // eslint-disable-next-line no-param-reassign
      start = start < 0 ? 0 : start;
      var i;
      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;
      for (var i = offset; i < end; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          // eslint-disable-next-line no-param-reassign
          isWhite = !isWhite;
        }
      }
      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper.init(counters, 0);
      for (var i = start; i < end; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          // eslint-disable-next-line no-param-reassign
          counters[counterPos]++;
        } else {
          counterPos++;
          if (counterPos === numCounters) {
            break;
          } else {
            // eslint-disable-next-line no-param-reassign
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }
      return counters;
    }

    // override/implement this in your custom readers.
  }, {
    key: "decodeImage",
    value: function decodeImage(imageWrapper) {
      // eslint-disable-next-line no-void
      void imageWrapper;
      return null;
    }
  }], [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts






function _callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var N = 1;
var W = 3;
var START_PATTERN = [W, N, W, N, N, N];
var STOP_PATTERN = [W, N, N, N, W];
var CODE_PATTERN = [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]];
var START_PATTERN_LENGTH = START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);
var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  function TwoOfFiveReader() {
    var _this;
    classCallCheck_default()(this, TwoOfFiveReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, TwoOfFiveReader, [].concat(args));
    defineProperty_default()(_this, "barSpaceRatio", [1, 1]);
    defineProperty_default()(_this, "FORMAT", '2of5');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.78);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.30);
    return _this;
  }
  inherits_default()(TwoOfFiveReader, _BarcodeReader);
  return createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }
      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;
            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }
            error = this._matchPattern(counter, pattern);
            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }
            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;
      var offset = this._nextSet(this._row);
      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;
      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true);
        if (!startInfo) {
          return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();
      var offset = this._nextSet(this._row);
      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);
      this._row.reverse();
      if (endInfo === null) {
        return null;
      }

      // reverse numbers
      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      for (var code = 0; code < CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, CODE_PATTERN[code]);
        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }
      if (bestMatch.error < epsilon) {
        return bestMatch;
      }
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;
      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }
        code = this._decodeCode(counter);
        if (!code) {
          return null;
        }
        result.push("".concat(code.code));
        decodedCodes.push(code);
      }
      return code;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      var endInfo = this._findEnd();
      if (!endInfo) {
        return null;
      }
      var counters = this._fillCounters(startInfo.end, endInfo.start, false);
      if (!this._verifyCounterLength(counters)) {
        return null;
      }
      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];
      var code = this._decodePayload(counters, result, decodedCodes);
      if (!code) {
        return null;
      }
      if (result.length < 5) {
        return null;
      }
      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts






function codabar_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, codabar_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function codabar_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (codabar_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


// const ALPHABETH_STRING = '0123456789-$:/.+ABCD';
var ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;
var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  function NewCodabarReader() {
    var _this;
    classCallCheck_default()(this, NewCodabarReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = codabar_reader_callSuper(this, NewCodabarReader, [].concat(args));
    defineProperty_default()(_this, "_counters", []);
    defineProperty_default()(_this, "FORMAT", 'codabar');
    return _this;
  }
  inherits_default()(NewCodabarReader, _BarcodeReader);
  return createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;
      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];
        if (counter > max) {
          max = counter;
        }
        if (counter < min) {
          min = counter;
        }
      }
      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;
      if (end > this._counters.length) {
        return -1;
      }
      var barThreshold = this._computeAlternatingThreshold(offset, end);
      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);
      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;
      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;
        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }
        bitmask >>= 1;
      }
      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;
      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }
      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);
      var end = start;
      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);
        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }
      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;
      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }
      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);
      for (var i = 0; i < ALPHABET.length; i++) {
        if (ALPHABET[i] === charCode) {
          return CHARACTER_ENCODINGS[i];
        }
      }
      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;
      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);
        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }
        pos += 8;
      }
      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);
      var pos = startCounter;
      var pattern;
      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);
        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];
          if (size < cat.min || size > cat.max) {
            return false;
          }
          pattern >>= 1;
        }
        pos += 8;
      }
      return true;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();
      if (!start) {
        return null;
      }
      var nextStart = start.startCounter;
      var result = [];
      var pattern;
      do {
        pattern = this._toPattern(nextStart);
        if (pattern < 0) {
          return null;
        }
        var decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        nextStart += 8;
        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length);

      // verify end
      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      }

      // verify end white space
      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }
      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }
      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;
      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);
      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts






function code_128_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_128_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_128_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_128_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code128Reader() {
    var _this;
    classCallCheck_default()(this, Code128Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_128_reader_callSuper(this, Code128Reader, [].concat(args));
    defineProperty_default()(_this, "CODE_SHIFT", 98);
    defineProperty_default()(_this, "CODE_C", 99);
    defineProperty_default()(_this, "CODE_B", 100);
    defineProperty_default()(_this, "CODE_A", 101);
    defineProperty_default()(_this, "START_CODE_A", 103);
    defineProperty_default()(_this, "START_CODE_B", 104);
    defineProperty_default()(_this, "START_CODE_C", 105);
    defineProperty_default()(_this, "STOP_CODE", 106);
    defineProperty_default()(_this, "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.64);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.30);
    defineProperty_default()(_this, "FORMAT", 'code_128');
    defineProperty_default()(_this, "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });
    return _this;
  }
  inherits_default()(Code128Reader, _BarcodeReader);
  return createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }
            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            bestMatch.end = i;
            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }
            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }
            return bestMatch;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);
      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    value:
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = this._nextSet(this._row);
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);
            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }
            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }
            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var _this2 = this;
      var startInfo = this._findStart();
      if (startInfo === null) {
        return null;
      }
      // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;

      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;
      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;
          case _this2.START_CODE_B:
            return _this2.CODE_B;
          case _this2.START_CODE_C:
            return _this2.CODE_C;
          default:
            return null;
        }
      }(code.code);
      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);
        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }
          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }
          decodedCodes.push(code);
          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;
                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;
                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
          }
        } else {
          done = true;
        }
        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }
      if (code === null) {
        return null;
      }
      code.end = this._nextUnset(this._row, code.end);
      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }
      checksum -= multiplier * rawResult[rawResult.length - 1];
      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }
      if (!result.length) {
        return null;
      }

      // remove last code from result (checksum)
      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }
      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
        trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
        sumNormalized = 0,
        sumExpected = 0;
      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }
      return sumExpected / sumNormalized;
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(13);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(16);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts







function code_39_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_39_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_39_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_39_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/* eslint-disable class-methods-use-this */


var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var code_39_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_39_reader_CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;
var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code39Reader() {
    var _this;
    classCallCheck_default()(this, Code39Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_39_reader_callSuper(this, Code39Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_39');
    return _this;
  }
  inherits_default()(Code39Reader, _BarcodeReader);
  return createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);
      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;
      for (var i = offset; i < this._row.length; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }
            patternStart += counter[0] + counter[1];
            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }
            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;
      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;
        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            // eslint-disable-next-line no-bitwise
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }
        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;
              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }
          return pattern;
        }
      }
      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;
      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }
      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_39_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_39_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_39_reader_ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper.sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;
      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }
      return false;
    }
  }, {
    key: "decode",
    value: function decode() {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      var start = this._findStart();
      if (!start) {
        return null;
      }
      var nextStart = this._nextSet(this._row, start.end);
      var decodedChar;
      var lastStart;
      do {
        counters = this._toCounters(nextStart, counters);
        var pattern = this._toPattern(counters);
        if (pattern < 0) {
          return null;
        }
        decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper.sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');
      result.pop();
      if (!result.length) {
        return null;
      }
      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }
      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts







function code_32_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_32_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_32_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_32_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }

var patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';
var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  function Code32Reader() {
    var _this;
    classCallCheck_default()(this, Code32Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_32_reader_callSuper(this, Code32Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_32_reader');
    return _this;
  }
  inherits_default()(Code32Reader, _Code39Reader);
  return createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }
      var res = 0;
      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }
      var code32 = "".concat(res);
      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }
      return 'A' + code32;
    }

    // TODO (this was todo in original repo, no text was there. sorry.)
  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "decode",
    value: function decode() {
      var result = _superPropGet(Code32Reader, "decode", this, 3)([]);
      if (!result) {
        return null;
      }
      var code = result.code;
      if (!code) {
        return null;
      }
      code = code.replace(patterns.AEIO, '');
      if (!this._checkChecksum(code)) {
        return null;
      }
      var code32 = this._decodeCode32(code);
      if (!code32) {
        return null;
      }
      result.code = code32;
      return result;
    }
  }]);
}(code_39_reader);
/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts







function code_39_vin_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_39_vin_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_39_vin_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_39_vin_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function code_39_vin_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
/* eslint-disable class-methods-use-this */


var code_39_vin_reader_patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};
var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  function Code39VINReader() {
    var _this;
    classCallCheck_default()(this, Code39VINReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_39_vin_reader_callSuper(this, Code39VINReader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_39_vin');
    return _this;
  }
  inherits_default()(Code39VINReader, _Code39Reader);
  return createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    value:
    // TODO (this was todo in original repo, no text was there. sorry.)
    function _checkChecksum(code) {
      return !!code;
    }

    // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
  }, {
    key: "decode",
    value: function decode() {
      var result = code_39_vin_reader_superPropGet(Code39VINReader, "decode", this, 3)([]);
      if (!result) {
        return null;
      }
      var code = result.code;
      if (!code) {
        return null;
      }
      code = code.replace(code_39_vin_reader_patterns.IOQ, '');
      if (!code.match(code_39_vin_reader_patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }
        return null;
      }
      if (!this._checkChecksum(code)) {
        return null;
      }
      result.code = code;
      return result;
    }
  }]);
}(code_39_reader);
/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts







function code_93_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_93_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_93_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_93_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;
var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code93Reader() {
    var _this;
    classCallCheck_default()(this, Code93Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_93_reader_callSuper(this, Code93Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_93');
    return _this;
  }
  inherits_default()(Code93Reader, _BarcodeReader);
  return createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;
      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);
        if (normalized < 1 || normalized > 4) {
          return -1;
        }
        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }
      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);
      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }
            patternStart += counter[0] + counter[1];
            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }
            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }
      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];
      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];
        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }
          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;
          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }
              break;
            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }
              break;
            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }
              break;
            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }
              break;
            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }
          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }
      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      start = this._findStart();
      if (!start) {
        return null;
      }
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];
      var nextStart = this._nextSet(this._row, start.end);
      var lastStart;
      var decodedChar;
      do {
        counters = this._toCounters(nextStart, counters);
        var pattern = this._toPattern(counters);
        if (pattern < 0) {
          return null;
        }
        decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper.sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');
      result.pop();
      if (!result.length) {
        return null;
      }
      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }
      if (!this._verifyChecksums(result)) {
        return null;
      }
      result = result.slice(0, result.length - 2);
      // yes, this is an assign inside an if.
      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }
      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/ean_reader.ts






function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function ean_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }



// const CODE_L_START = 0;
var CODE_G_START = 10;

var ean_reader_START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var ean_reader_CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
// const SINGLE_CODE_ERROR = 0.70;
var AVG_CODE_ERROR = 0.48;
var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  // TODO: does this need to be in the class?

  function EANReader(config, supplements) {
    var _this;
    classCallCheck_default()(this, EANReader);
    _this = ean_reader_callSuper(this, EANReader, [merge_default()({
      supplements: []
    }, config), supplements]);
    defineProperty_default()(_this, "FORMAT", 'ean_13');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.70);
    defineProperty_default()(_this, "STOP_PATTERN", [1, 1, 1]);
    return _this;
  }
  inherits_default()(EANReader, _BarcodeReader);
  return createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR;
      // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);
      var counterPos = 0;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      var found = false;
      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern);
            // console.warn('* matchPattern', error, counter, pattern);
            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i;
              // console.warn('* return bestMatch', JSON.stringify(bestMatch));
              return bestMatch;
            }
            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      if (found) {
        // console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {
        // console.warn('* return null');
      }
      return found ? bestMatch : null;
    }

    // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?
  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;
      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = ean_reader_CODE_PATTERN.length;
        // console.warn('* decodeCode after length');
      }
      var found = false;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, ean_reader_CODE_PATTERN[code]);
              bestMatch.end = i;
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            }
            // console.warn('* return bestMatch', JSON.stringify(bestMatch));
            return bestMatch;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);
      var startInfo = null;
      while (!startInfo) {
        startInfo = this._findPattern(ean_reader_START_PATTERN, offset, false, true);
        // console.warn('* startInfo=', JSON.stringify(startInfo));
        if (!startInfo) {
          return null;
        }
        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      // console.warn('* returning null');
      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      }
      // console.warn('* return null');
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);
      var codeFrequency = 0x0;
      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);
        // console.warn('* decodeCode=', outCode);
        if (!outCode) {
          // console.warn('* return null');
          return null;
        }
        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }
        result.push(outCode.code);
        decodedCodes.push(outCode);
      }
      var firstDigit = this._calculateFirstDigit(codeFrequency);
      // console.warn('* firstDigit=', firstDigit);
      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }
      result.unshift(firstDigit);
      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false);
      // console.warn('* findPattern=', JSON.stringify(middlePattern));

      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }
      decodedCodes.push(middlePattern);
      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START);
        // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }
        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      }

      // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);
      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      }
      // console.warn('* return null');
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;
      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }
      sum *= 3;
      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      }

      // console.warn('* end checksum', sum % 10 === 0);
      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);
      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);
      if (startInfo === null) {
        return null;
      }

      // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');
      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i].decode(this._row, startInfo.end);
          // console.warn('* decode result=', result);
          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      }

      // console.warn('* end decodeExtensions');
      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);
      if (!code) {
        return null;
      }
      code = this._findEnd(code.end, false);
      if (!code) {
        return null;
      }
      decodedCodes.push(code);

      // Checksum
      if (!this._checksum(result)) {
        return null;
      }

      // console.warn('* this.supplements=', this.supplements);
      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end);
        // console.warn('* decodeExtensions returns', supplement);
        if (!supplement) {
          return null;
        }
        if (!supplement.decodedCodes) {
          return null;
        }
        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };
        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }
        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }
      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);
}(barcode_reader);
/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts






function ean_2_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_2_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_2_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_2_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  function EAN2Reader() {
    var _this;
    classCallCheck_default()(this, EAN2Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_2_reader_callSuper(this, EAN2Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_2');
    return _this;
  }
  inherits_default()(EAN2Reader, _EANReader);
  return createClass_default()(EAN2Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (row) {
        this._row = row;
      }
      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;
      if (offset === undefined) {
        return null;
      }
      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }
        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }
      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }
      var startInfo = this._findStart();
      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);
}(ean_reader);
;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts






function ean_5_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_5_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_5_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_5_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }
  return null;
}
function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;
  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }
  sum *= 3;
  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }
  sum *= 3;
  return sum % 10;
}
var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  function EAN5Reader() {
    var _this;
    classCallCheck_default()(this, EAN5Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_5_reader_callSuper(this, EAN5Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_5');
    return _this;
  }
  inherits_default()(EAN5Reader, _EANReader);
  return createClass_default()(EAN5Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (start === undefined) {
        return null;
      }
      if (row) {
        this._row = row;
      }
      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];
      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }
        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }
      if (result.length !== 5) {
        return null;
      }
      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }
      var startInfo = this._findStart();
      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);
}(ean_reader);
;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts






function ean_8_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_8_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_8_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_8_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  function EAN8Reader() {
    var _this;
    classCallCheck_default()(this, EAN8Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_8_reader_callSuper(this, EAN8Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_8');
    return _this;
  }
  inherits_default()(EAN8Reader, _EANReader);
  return createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;
      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);
        if (!code) {
          return null;
        }
        result.push(code.code);
        decodedCodes.push(code);
      }
      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);
      if (code === null) {
        return null;
      }
      decodedCodes.push(code);
      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
      }
      return code;
    }
  }]);
}(ean_reader);
/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts







function i2of5_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, i2of5_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function i2of5_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (i2of5_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function i2of5_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that



var i2of5_reader_N = 1;
var i2of5_reader_W = 3;
var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  function I2of5Reader(opts) {
    var _this;
    classCallCheck_default()(this, I2of5Reader);
    _this = i2of5_reader_callSuper(this, I2of5Reader, [merge_default()({
      normalizeBarSpaceWidth: false
    }, opts)]);
    defineProperty_default()(_this, "barSpaceRatio", [1, 1]);
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.78);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.38);
    defineProperty_default()(_this, "START_PATTERN", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N]);
    defineProperty_default()(_this, "STOP_PATTERN", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W]);
    defineProperty_default()(_this, "CODE_PATTERN", [[i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N]]);
    defineProperty_default()(_this, "MAX_CORRECTION_FACTOR", 5);
    defineProperty_default()(_this, "FORMAT", 'i2of5');
    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }
    _this.config = opts;
    return possibleConstructorReturn_default()(_this, _this);
  }
  inherits_default()(I2of5Reader, _BarcodeReader);
  return createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;
        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }
        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;
        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }
      return i2of5_reader_superPropGet(I2of5Reader, "_matchPattern", this, 3)([counter, code]);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);
            var error = this._matchPattern(counter, pattern);
            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }
            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;
      var offset = this._nextSet(this._row);
      var startInfo = null;
      var narrowBarWidth = 1;
      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);
        if (!startInfo) {
          return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();
      var endInfo = this._findPattern(this.STOP_PATTERN);
      this._row.reverse();
      if (endInfo === null) {
        return null;
      }

      // reverse numbers
      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];
      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);
        if (!code) {
          return null;
        }
        codes.push(code);
      }
      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }
      if (bestMatch.error < epsilon) {
        return bestMatch;
      }
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;
      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }
        codes = this._decodePair(counterPair);
        if (!codes) {
          return null;
        }
        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }
      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      decodedCodes.push(startInfo);
      var endInfo = this._findEnd();
      if (!endInfo) {
        return null;
      }
      var counters = this._fillCounters(startInfo.end, endInfo.start, false);
      if (!this._verifyCounterLength(counters)) {
        return null;
      }
      var code = this._decodePayload(counters, result, decodedCodes);
      if (!code) {
        return null;
      }
      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }
      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/pharmacode_reader.ts







function pharmacode_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, pharmacode_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function pharmacode_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (pharmacode_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


/**
 * Pharmacode (Pharmaceutical Binary Code) Reader
 *
 * Pharmacode is a binary barcode used in pharmaceutical packaging.
 * It encodes numbers from 3 to 131070 using narrow and wide bars.
 *
 * Encoding rules:
 * - Reading from right to left (least significant first)
 * - Narrow bar at position i adds 2^i to the value
 * - Wide bar at position i adds 2^(i+1) to the value
 * - Bars are separated by uniform-width spaces
 * - Minimum 2 bars, maximum 16 bars
 * - Valid range: 3 to 131070
 *
 * Example: Value 755
 * Binary representation of bars (from left to right in barcode):
 * wide, narrow, wide, narrow, narrow, wide, narrow, wide, narrow
 *
 * Reference: https://en.wikipedia.org/wiki/Pharmacode
 */

// Minimum number of bars in a valid Pharmacode
var MIN_BAR_COUNT = 2;
// Maximum number of bars in a valid Pharmacode
var MAX_BAR_COUNT = 16;
// Minimum valid Pharmacode value
var MIN_VALUE = 3;
// Maximum valid Pharmacode value
var MAX_VALUE = 131070;

// Threshold ratio to distinguish narrow from wide bars
// A bar wider than this ratio of the narrow bar width is considered wide
var WIDE_BAR_THRESHOLD = 1.75;

// Maximum allowed variation in space widths (coefficient of variation)
var MAX_SPACE_VARIANCE = 0.4;

// Maximum allowed variation in narrow bar widths
var MAX_NARROW_BAR_VARIANCE = 0.4;
var pharmacode_reader_PharmacodeReader = /*#__PURE__*/function (_BarcodeReader) {
  function PharmacodeReader() {
    var _this;
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck_default()(this, PharmacodeReader);
    _this = pharmacode_reader_callSuper(this, PharmacodeReader, [config]);
    defineProperty_default()(_this, "FORMAT", 'pharmacode');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.7);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.48);
    return _this;
  }

  /**
   * Find the start of the barcode (first black bar after leading whitespace)
   */
  inherits_default()(PharmacodeReader, _BarcodeReader);
  return createClass_default()(PharmacodeReader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);
      if (offset >= this._row.length) {
        return null;
      }

      // Find the first black bar
      var barStart = offset;
      var barEnd = barStart;
      while (barEnd < this._row.length && this._row[barEnd]) {
        barEnd++;
      }
      if (barEnd === barStart) {
        return null;
      }

      // Verify there's some leading whitespace (quiet zone)
      var barWidth = barEnd - barStart;
      var quietZoneStart = Math.max(0, barStart - barWidth * 2);
      if (barStart > 0 && !this._matchRange(quietZoneStart, barStart, 0)) {
        return null;
      }
      return {
        start: barStart,
        end: barEnd
      };
    }

    /**
     * Extract all bar and space widths from the pattern
     */
  }, {
    key: "_extractBarsAndSpaces",
    value: function _extractBarsAndSpaces(startPos) {
      var bars = [];
      var spaces = [];
      var pos = startPos;
      var isBar = true;
      var currentWidth = 0;

      // Start with the first bar
      while (pos < this._row.length && this._row[pos]) {
        currentWidth++;
        pos++;
      }
      if (currentWidth === 0) {
        return null;
      }
      bars.push(currentWidth);

      // Continue extracting alternating spaces and bars
      while (pos < this._row.length && bars.length <= MAX_BAR_COUNT) {
        currentWidth = 0;
        isBar = !isBar;
        if (isBar) {
          // Counting a bar
          while (pos < this._row.length && this._row[pos]) {
            currentWidth++;
            pos++;
          }
          if (currentWidth === 0) {
            // End of barcode
            break;
          }
          bars.push(currentWidth);
        } else {
          // Counting a space
          while (pos < this._row.length && !this._row[pos]) {
            currentWidth++;
            pos++;
          }
          if (currentWidth === 0) {
            break;
          }
          // Check if this might be the trailing quiet zone
          // A very large space likely means end of barcode
          if (spaces.length > 0) {
            var avgSpace = spaces.reduce(function (a, b) {
              return a + b;
            }, 0) / spaces.length;
            if (currentWidth > avgSpace * 3) {
              // This is likely the quiet zone, not an inter-bar space
              break;
            }
          }
          spaces.push(currentWidth);
        }
      }

      // Validate bar count
      if (bars.length < MIN_BAR_COUNT || bars.length > MAX_BAR_COUNT) {
        return null;
      }

      // We should have (n-1) spaces for n bars
      if (spaces.length !== bars.length - 1) {
        return null;
      }
      return {
        bars: bars,
        spaces: spaces,
        end: pos
      };
    }

    /**
     * Check if space widths are uniform enough for a valid Pharmacode
     */
  }, {
    key: "_validateSpaces",
    value: function _validateSpaces(spaces) {
      if (spaces.length === 0) {
        return true; // Single bar (though invalid for Pharmacode)
      }
      var mean = spaces.reduce(function (a, b) {
        return a + b;
      }, 0) / spaces.length;
      if (mean === 0) {
        return false;
      }

      // Calculate coefficient of variation
      var variance = spaces.reduce(function (sum, s) {
        return sum + Math.pow(s - mean, 2);
      }, 0) / spaces.length;
      var stdDev = Math.sqrt(variance);
      var cv = stdDev / mean;
      return cv <= MAX_SPACE_VARIANCE;
    }

    /**
     * Classify bars as narrow or wide and decode the value
     */
  }, {
    key: "_decodeBars",
    value: function _decodeBars(bars) {
      // Find the minimum bar width (likely narrow bar)
      var minWidth = Math.min.apply(Math, toConsumableArray_default()(bars));

      // If all bars are similar width, it might be a valid Pharmacode with all narrow or all wide bars
      // But we need to determine the threshold
      var threshold = minWidth * WIDE_BAR_THRESHOLD;

      // Separate bars into narrow and wide for validation
      var narrowBars = [];
      bars.forEach(function (width) {
        if (width <= threshold) {
          narrowBars.push(width);
        }
      });

      // Validate narrow bar consistency
      if (narrowBars.length > 0) {
        var narrowMean = narrowBars.reduce(function (a, b) {
          return a + b;
        }, 0) / narrowBars.length;
        var narrowVariance = narrowBars.reduce(function (sum, w) {
          return sum + Math.pow(w - narrowMean, 2);
        }, 0) / narrowBars.length;
        var narrowCv = Math.sqrt(narrowVariance) / narrowMean;
        if (narrowCv > MAX_NARROW_BAR_VARIANCE) {
          return null;
        }
      }

      // Calculate the Pharmacode value using the correct algorithm
      // Reading from right to left (reverse the bars array)
      // For each bar: value = value * 2 + (1 for narrow, 2 for wide)
      var value = 0;
      for (var i = bars.length - 1; i >= 0; i--) {
        var isWide = bars[i] > threshold;
        value = value * 2 + (isWide ? 2 : 1);
      }
      return {
        value: value
      };
    }

    /**
     * Verify trailing whitespace (quiet zone)
     */
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(end, barWidth) {
      var trailingWhitespaceEnd = Math.min(end + barWidth * 2, this._row.length);
      return this._matchRange(end, trailingWhitespaceEnd, 0);
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      // Find the start of the barcode
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }

      // Extract bars and spaces
      var extracted = this._extractBarsAndSpaces(startInfo.start);
      if (!extracted) {
        return null;
      }
      var bars = extracted.bars,
        spaces = extracted.spaces,
        end = extracted.end;

      // Validate space uniformity
      if (!this._validateSpaces(spaces)) {
        return null;
      }

      // Decode the bars
      var decoded = this._decodeBars(bars);
      if (!decoded) {
        return null;
      }
      var value = decoded.value;

      // Validate value range
      if (value < MIN_VALUE || value > MAX_VALUE) {
        return null;
      }

      // Verify trailing whitespace
      var avgBarWidth = bars.reduce(function (a, b) {
        return a + b;
      }, 0) / bars.length;
      if (!this._verifyTrailingWhitespace(end, avgBarWidth)) {
        // Soft fail - allow but note it
      }

      // Build the decoded codes array for debugging/visualization
      var decodedCodes = bars.map(function (width, index) {
        return {
          code: width > Math.min.apply(Math, toConsumableArray_default()(bars)) * WIDE_BAR_THRESHOLD ? 1 : 0,
          start: 0,
          // Could calculate actual positions if needed
          end: 0,
          error: 0
        };
      });
      return {
        code: value.toString(),
        start: startInfo.start,
        end: end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var pharmacode_reader = (pharmacode_reader_PharmacodeReader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts







function upc_e_reader_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function upc_e_reader_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? upc_e_reader_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : upc_e_reader_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function upc_e_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, upc_e_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function upc_e_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (upc_e_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function upc_e_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }

var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  function UPCEReader() {
    var _this;
    classCallCheck_default()(this, UPCEReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = upc_e_reader_callSuper(this, UPCEReader, [].concat(args));
    defineProperty_default()(_this, "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);
    defineProperty_default()(_this, "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);
    defineProperty_default()(_this, "FORMAT", 'upc_e');
    return _this;
  }
  inherits_default()(UPCEReader, _EANReader);
  return createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);
      var codeFrequency = 0x0;
      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);
        if (!outCode) {
          return null;
        }
        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }
        result.push(outCode.code);
        decodedCodes.push(outCode);
      }
      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }
      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];
      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }
      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return upc_e_reader_superPropGet(UPCEReader, "_checksum", this, 3)([this._convertToUPCA(result)]);
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return upc_e_reader_superPropGet(UPCEReader, "_findEnd", this, 3)([offset, true]);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }]);
}(ean_reader);
/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts






function upc_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, upc_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function upc_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (upc_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  function UPCReader() {
    var _this;
    classCallCheck_default()(this, UPCReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = upc_reader_callSuper(this, UPCReader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'upc_a');
    return _this;
  }
  inherits_default()(UPCReader, _EANReader);
  return createClass_default()(UPCReader, [{
    key: "decode",
    value: function decode(row, start) {
      var result = ean_reader.prototype.decode.call(this);
      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }
      return null;
    }
  }]);
}(ean_reader);
/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */
Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */
  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;
  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }
  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }
  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }
  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;
  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }
    error -= deltaY;
    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }
  return {
    line: line,
    min: min,
    max: max
  };
};

/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */
Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j;

  // 1. find extrema
  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });
  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];
    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }
    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }
  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });
  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  }

  // iterate over extrema and convert to binary based on avg between minmax
  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }
    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }
  return {
    line: line,
    threshold: threshold
  };
};

/**
 * Used for development only
 */
Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d');
    // eslint-disable-next-line no-param-reassign
    canvas.width = line.length;
    // eslint-disable-next-line no-param-reassign
    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }
    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i;

    // eslint-disable-next-line no-param-reassign
    canvas.width = line.length;
    ctx.fillColor = 'black';
    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js


function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

/* eslint-disable import/no-cycle */

/**
 * Barcode Decoder Module
 *
 * This module handles the decoding of barcodes using configured readers.
 *
 * READER ORDER GUARANTEE:
 * Readers are processed in the exact order they are specified in the `readers`
 * config array. The first reader to successfully decode the barcode wins.
 *
 * Example:
 *   readers: ['ean_reader', 'upc_e_reader', 'code_128_reader']
 *
 * Decoding order:
 *   1. ean_reader attempts to decode
 *   2. If ean_reader returns null, upc_e_reader attempts to decode
 *   3. If upc_e_reader returns null, code_128_reader attempts to decode
 *   4. First non-null result is returned
 *
 * EXTERNAL READERS:
 * External readers must be registered via registerReader() before use.
 * Once registered, they follow the same ordering rules as built-in readers.
 * Their position in the `readers` array determines their priority.
 *
 * To prioritize an external reader:
 *   Quagga.registerReader('my_reader', MyReader);
 *   config.decoder.readers = ['my_reader', 'ean_reader']; // my_reader tried first
 */


















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader,
  pharmacode_reader: pharmacode_reader
};
/* harmony default export */ var barcode_decoder = ({
  /**
   * Registers an external/custom barcode reader.
   * Once registered, the reader can be used in config.readers array.
   * The reader's position in config.readers determines its decoding priority.
   *
   * @param name - The identifier to use in config.readers (e.g., 'my_custom_reader')
   * @param reader - The reader class (must extend BarcodeReader)
   *
   * @example
   * // Register a custom reader
   * BarcodeDecoder.registerReader('my_reader', MyCustomReader);
   *
   * // Use it with high priority (first in array)
   * config.decoder.readers = ['my_reader', 'ean_reader', 'code_128_reader'];
   */
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();
    function initCanvas() {
      if ( true && typeof document !== 'undefined') {
        var _config$debug;
        var $debug = document.querySelector('#debug.detection');
        _canvas.dom.frequency = document.querySelector('canvas.frequency');
        if (!_canvas.dom.frequency) {
          _canvas.dom.frequency = document.createElement('canvas');
          _canvas.dom.frequency.className = 'frequency';
          if ($debug) {
            $debug.appendChild(_canvas.dom.frequency);
          }
        }
        if ( true && (_config$debug = config.debug) !== null && _config$debug !== void 0 && _config$debug.printReaderInfo) {
          console.warn('* barcode decoder initCanvas getcontext 2d');
        }
        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');
        if (!_canvas.dom.pattern) {
          _canvas.dom.pattern = document.createElement('canvas');
          _canvas.dom.pattern.className = 'patternBuffer';
          if ($debug) {
            $debug.appendChild(_canvas.dom.pattern);
          }
        }
        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');
        if (_canvas.dom.overlay) {
          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
        }
      }
    }

    /**
     * Initializes barcode readers from config.readers array.
     * Readers are instantiated and stored in the order they appear in config,
     * which determines their decoding priority (first in array = highest priority).
     */
    function initReaders() {
      var _config$debug3;
      config.readers.forEach(function (readerConfig) {
        var _config$debug2;
        var reader;
        var configuration = {};
        var supplements = [];
        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }
        if ( true && (_config$debug2 = config.debug) !== null && _config$debug2 !== void 0 && _config$debug2.printReaderInfo) {
          console.log('Before registering reader: ', reader);
        }
        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }
        try {
          var readerObj = new READERS[reader](configuration, supplements);
          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });
      if ( true && (_config$debug3 = config.debug) !== null && _config$debug3 !== void 0 && _config$debug3.printReaderInfo) {
        console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
          return JSON.stringify({
            format: reader.FORMAT,
            config: reader.config
          });
        }).join(', ')));
      }
    }
    function initConfig() {
      if ( true && typeof document !== 'undefined') {
        var i;
        var vis = [{
          node: _canvas.dom.frequency,
          prop: config.debug.showFrequency
        }, {
          node: _canvas.dom.pattern,
          prop: config.debug.showPattern
        }];
        for (i = 0; i < vis.length; i++) {
          if (vis[i].prop === true) {
            vis[i].node.style.display = 'block';
          } else {
            vis[i].node.style.display = 'none';
          }
        }
      }
    }

    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */
    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */
        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      }

      // check if inside image
      extendLine(ext);
      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }
      return line;
    }
    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    /**
     * Attempts to decode a barcode from a scan line.
     * Readers are tried in order (as specified in config.readers).
     * The first reader to return a non-null result wins.
     * @param {Array} line The scan line to decode
     * @returns {Object|null} Decoded result or null if no reader succeeded
     */
    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);
      if ( true && config.debug.showFrequency) {
        if (_canvas.ctx.overlay) {
          image_debug.drawPath(line, {
            x: 'x',
            y: 'y'
          }, _canvas.ctx.overlay, {
            color: 'red',
            lineWidth: 3
          });
        }
        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
      }
      bresenham.toBinaryLine(barcodeLine);
      if ( true && config.debug.showPattern) {
        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
      }

      // Iterate readers in order - first successful decode wins
      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }
      if (result === null) {
        return null;
      }
      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }

    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */
    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);
      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */
        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }
      return result;
    }
    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    /**
     * Decodes from a full image using readers that support image-based decoding.
     * Readers are tried in order (as specified in config.readers).
     * @param {Object} imageWrapper The image to decode
     * @returns {Object|null} Decoded result or null
     */
    function _decodeFromImage2(_x) {
      return _decodeFromImage.apply(this, arguments);
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */
    function _decodeFromImage() {
      _decodeFromImage = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2(imageWrapper) {
        var result, _iterator, _step, reader, _t;
        return regenerator_default.a.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              result = null; // Iterate readers in order - first successful decode wins
              _iterator = _createForOfIteratorHelper(_barcodeReaders);
              _context2.prev = 1;
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context2.next = 5;
                break;
              }
              reader = _step.value;
              if (!reader.decodeImage) {
                _context2.next = 4;
                break;
              }
              _context2.next = 3;
              return reader.decodeImage(imageWrapper);
            case 3:
              result = _context2.sent;
              if (!result) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("continue", 5);
            case 4:
              _context2.next = 2;
              break;
            case 5:
              _context2.next = 7;
              break;
            case 6:
              _context2.prev = 6;
              _t = _context2["catch"](1);
              _iterator.e(_t);
            case 7:
              _context2.prev = 7;
              _iterator.f();
              return _context2.finish(7);
            case 8:
              return _context2.abrupt("return", result);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[1, 6, 7, 8]]);
      }));
      return _decodeFromImage.apply(this, arguments);
    }
    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;
      if (true) {
        if (config.debug.drawBoundingBox && ctx) {
          image_debug.drawPath(box, {
            x: 0,
            y: 1
          }, ctx, {
            color: 'blue',
            lineWidth: 2
          });
        }
      }
      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));
      if (line === null) {
        return null;
      }
      result = tryDecode(line);
      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }
      if (result === null) {
        return null;
      }
      if ( true && result && config.debug.drawScanline && ctx) {
        image_debug.drawPath(line, {
          x: 'x',
          y: 'y'
        }, ctx, {
          color: 'red',
          lineWidth: 3
        });
      }
      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }
    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;
        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;
          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }
        return {
          barcodes: barcodes
        };
      },
      decodeFromImage: function decodeFromImage(imageWrapperIn) {
        return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
          var result;
          return regenerator_default.a.wrap(function (_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 1;
                return _decodeFromImage2(imageWrapperIn);
              case 1:
                result = _context.sent;
                return _context.abrupt("return", result);
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }))();
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }
        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/reader/index.ts

















// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};
  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }
    return events[eventName];
  }
  function clearEvents() {
    events = {};
  }
  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }
  function _subscribe(event, callback, async) {
    var subscription;
    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;
      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }
    getEvent(event).subscribers.push(subscription);
  }
  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers;

      // Publish one-time subscriptions
      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });

      // remove them from the subscriber
      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      });

      // publish the rest
      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);
        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__(81);
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties);

// EXTERNAL MODULE: ./node_modules/lodash/omit.js
var omit = __webpack_require__(82);
var omit_default = /*#__PURE__*/__webpack_require__.n(omit);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var wrapNativeSuper = __webpack_require__(83);
var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper);

// CONCATENATED MODULE: ./src/quagga/Exception.ts







function Exception_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, Exception_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function Exception_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (Exception_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var Exception_Exception = /*#__PURE__*/function (_Error) {
  function Exception(m, code) {
    var _this;
    classCallCheck_default()(this, Exception);
    _this = Exception_callSuper(this, Exception, [m]);
    defineProperty_default()(_this, "code", void 0);
    _this.code = code;
    Object.setPrototypeOf(_this, Exception.prototype);
    return _this;
  }
  inherits_default()(Exception, _Error);
  return createClass_default()(Exception);
}(/*#__PURE__*/wrapNativeSuper_default()(Error));

// CONCATENATED MODULE: ./src/common/mediaDevices.ts

var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Exception_Exception("enumerateDevices is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Exception_Exception("getUserMedia is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts



var _excluded = ["deviceId"];
function camera_access_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function camera_access_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? camera_access_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : camera_access_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function camera_access_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = camera_access_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function camera_access_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return camera_access_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? camera_access_arrayLikeToArray(r, a) : void 0; } }
function camera_access_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

// TODO: when this file was written years ago, HTMLMediaElement.play() did not return a useful value
// to let us know when the video started playing.  Now, it does.  So, we shouldn't need to run this
// odd waitForVideo() function that polls to see if the video has started.



var streamRef;
function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;
    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (true) {
            console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
          }
          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Exception_Exception('Unable to play video stream. Is webcam working?', -1)); // TODO: add error code
      }
      attempts--;
    }
    checkVideo();
  });
}

/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */
function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}
function _initCamera() {
  _initCamera = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee4(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function (_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 1;
          return getUserMedia(constraints);
        case 1:
          stream = _context4.sent;
          streamRef = stream;
          if (!video) {
            _context4.next = 2;
            break;
          }
          video.setAttribute('autoplay', 'true');
          video.setAttribute('muted', 'true');
          video.setAttribute('playsinline', 'true'); // not listed on MDN...
          // eslint-disable-next-line no-param-reassign
          video.srcObject = stream;
          video.addEventListener('loadedmetadata', function () {
            video.play()["catch"](function (err) {
              console.warn('* Error while trying to play video stream:', err);
            });
          });
          return _context4.abrupt("return", waitForVideo(video));
        case 2:
          return _context4.abrupt("return", Promise.resolve());
        case 3:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _initCamera.apply(this, arguments);
}
function deprecatedConstraints(videoConstraints) {
  // Remove deprecated properties (facing, minAspectRatio, maxAspectRatio) while
  // preserving all valid MediaTrackConstraints including advanced, zoom, torch, etc.
  var normalized = omit_default()(videoConstraints, ['facing', 'minAspectRatio', 'maxAspectRatio']);
  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }
  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }
  return normalized;
}

// TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.
function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);
  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }
  return Promise.resolve({
    audio: false,
    video: video
  });
}

/**
 * Enumerates video input devices, optionally filtering by constraints.
 * @param videoConstraints Optional constraints to filter devices.
 * When provided, only devices that satisfy the given constraints will be returned.
 * This works by attempting to get a media stream for each device with the constraints
 * and returning only the devices that succeed.
 * @returns Promise resolving to an array of MediaDeviceInfo for video input devices.
 */
function enumerateVideoDevices(_x3) {
  return _enumerateVideoDevices.apply(this, arguments);
}
function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee5(videoConstraints) {
    var devices, videoDevices, constrainedDevices, processedConstraints, _, constraintsWithoutDeviceId, _iterator, _step, device, constraints, stream, _t3, _t4;
    return regenerator_default.a.wrap(function (_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 1;
          return enumerateDevices();
        case 1:
          devices = _context5.sent;
          videoDevices = devices.filter(function (device) {
            return device.kind === 'videoinput';
          }); // If no constraints are provided, return all video devices
          if (videoConstraints) {
            _context5.next = 2;
            break;
          }
          return _context5.abrupt("return", videoDevices);
        case 2:
          // Filter devices based on constraints by trying to get a media stream for each
          constrainedDevices = []; // Process constraints but exclude deviceId since we'll set it ourselves for each device
          processedConstraints = deprecatedConstraints(videoConstraints); // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _ = processedConstraints.deviceId, constraintsWithoutDeviceId = objectWithoutProperties_default()(processedConstraints, _excluded);
          _iterator = camera_access_createForOfIteratorHelper(videoDevices);
          _context5.prev = 3;
          _iterator.s();
        case 4:
          if ((_step = _iterator.n()).done) {
            _context5.next = 9;
            break;
          }
          device = _step.value;
          _context5.prev = 5;
          constraints = {
            audio: false,
            video: camera_access_objectSpread(camera_access_objectSpread({}, constraintsWithoutDeviceId), {}, {
              deviceId: {
                exact: device.deviceId
              }
            })
          };
          _context5.next = 6;
          return getUserMedia(constraints);
        case 6:
          stream = _context5.sent;
          // Stop all tracks immediately after testing
          stream.getTracks().forEach(function (track) {
            return track.stop();
          });
          constrainedDevices.push(device);
          _context5.next = 8;
          break;
        case 7:
          _context5.prev = 7;
          _t3 = _context5["catch"](5);
        case 8:
          _context5.next = 4;
          break;
        case 9:
          _context5.next = 11;
          break;
        case 10:
          _context5.prev = 10;
          _t4 = _context5["catch"](3);
          _iterator.e(_t4);
        case 11:
          _context5.prev = 11;
          _iterator.f();
          return _context5.finish(11);
        case 12:
          return _context5.abrupt("return", constrainedDevices);
        case 13:
        case "end":
          return _context5.stop();
      }
    }, _callee5, null, [[3, 10, 11, 12], [5, 7]]);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}
function getActiveTrack() {
  if (!streamRef) {
    return null;
  }
  var tracks = streamRef.getVideoTracks();
  return tracks && tracks !== null && tracks !== void 0 && tracks.length ? tracks[0] : null;
}

/**
 * Returns the active MediaStream, or null if no stream is active.
 * Use this when you need access to the full stream, for example to pass to WebRTC
 * or to clone the stream. For just the video track, use getActiveTrack() instead.
 * @returns The active MediaStream, or null if no camera is currently active.
 */
function getActiveStream() {
  var _streamRef;
  return (_streamRef = streamRef) !== null && _streamRef !== void 0 ? _streamRef : null;
}

/**
 * Used for accessing information about the active stream track and available video devices.
 */
var QuaggaJSCameraAccess = {
  requestedVideoElement: null,
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            QuaggaJSCameraAccess.requestedVideoElement = video;
            _context.next = 1;
            return pickConstraints(videoConstraints);
          case 1:
            newConstraints = _context.sent;
            return _context.abrupt("return", initCamera(video, newConstraints));
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  },
  release: function release() {
    var tracks = streamRef && streamRef.getVideoTracks();
    if (QuaggaJSCameraAccess.requestedVideoElement !== null) {
      QuaggaJSCameraAccess.requestedVideoElement.pause();
    }
    return new Promise(function (resolve) {
      setTimeout(function () {
        if (tracks && tracks.length) {
          tracks.forEach(function (track) {
            return track.stop();
          });
        }
        streamRef = null;
        QuaggaJSCameraAccess.requestedVideoElement = null;
        resolve();
      }, 0);
    });
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStream: getActiveStream,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack,
  disableTorch: function disableTorch() {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2() {
      var track, _t;
      return regenerator_default.a.wrap(function (_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
            // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?
            if (!track) {
              _context2.next = 4;
              break;
            }
            _context2.prev = 1;
            _context2.next = 2;
            return track.applyConstraints({
              advanced: [{
                torch: false
              }]
            });
          case 2:
            _context2.next = 4;
            break;
          case 3:
            _context2.prev = 3;
            _t = _context2["catch"](1);
            if (_t instanceof OverconstrainedError) {
              console.warn('quagga2/CameraAccess: Torch not supported on this device');
            }
            throw _t;
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 3]]);
    }))();
  },
  enableTorch: function enableTorch() {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee3() {
      var track, _t2;
      return regenerator_default.a.wrap(function (_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
            // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?
            if (!track) {
              _context3.next = 4;
              break;
            }
            _context3.prev = 1;
            _context3.next = 2;
            return track.applyConstraints({
              advanced: [{
                torch: true
              }]
            });
          case 2:
            _context3.next = 4;
            break;
          case 3:
            _context3.prev = 3;
            _t2 = _context3["catch"](1);
            if (_t2 instanceof OverconstrainedError) {
              console.warn('quagga2/CameraAccess: Torch not supported on this device');
            }
            throw _t2;
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 3]]);
    }))();
  }
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts

function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}
function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}
/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d', {
      willReadFrequently: !!config.willReadFrequently
    });
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;
    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }
    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|
        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;
          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug.drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }
          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"
    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
      // borderColor: 'rgba(0, 255, 0, 0.5)', // uncomment to draw area border
      // borderWidth: 2, // uncomment to draw area border
      // backgroundColor: 'rgba(0, 255, 0, 0.1)', // uncomment to tint the scan area
    },
    singleChannel: false,
    // true: only the red color-channel is read
    debug: {
      showImageDetails: false // logs frame grabber info, canvas size adjustments
    }
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false,
      printReaderInfo: false // logs reader registration and initialization
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      showPatchSize: false,
      // logs calculated patch size
      showImageDetails: false,
      // logs image wrapper size, canvas details
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large
  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"
    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large
  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts



var ExportConfig = function () {
  var QuaggaConfig;
  if (true) {
    QuaggaConfig = config_dev;
  } else {}
  return QuaggaConfig;
}();
/* harmony default export */ var config_config = (ExportConfig);
// CONCATENATED MODULE: ./src/input/frame_grabber_browser.js
// NOTE FOR ANYONE IN HERE IN THE FUTURE:
// webpack.config.js replaces the frame_grabber module with THIS module when it is building for a Browser environment.


var TO_RADIANS = Math.PI / 180;
function adjustCanvasSize(canvas, targetSize, debug) {
  if (canvas.width !== targetSize.x) {
    if ( true && debug !== null && debug !== void 0 && debug.showImageDetails) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }
    canvas.width = targetSize.x;
  }
  if (canvas.height !== targetSize.y) {
    if ( true && debug !== null && debug !== void 0 && debug.showImageDetails) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }
    canvas.height = targetSize.y;
  }
}
var FrameGrabber = {};
FrameGrabber.create = function (inputStream, canvas) {
  var _streamConfig$debug, _streamConfig$debug2;
  // console.warn('*** FrameGrabberBrowser create');
  var _that = {};
  var _streamConfig = inputStream.getConfig();
  var _videoSize = imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());
  var _canvasSize = inputStream.getCanvasSize();
  var _size = imageRef(inputStream.getWidth(), inputStream.getHeight());
  var topRight = inputStream.getTopRight();
  var _sx = topRight.x;
  var _sy = topRight.y;
  var _canvas;
  var _ctx = null;
  var _data = null;
  var willReadFrequently = _streamConfig.willReadFrequently;
  _canvas = canvas || document.createElement('canvas');
  _canvas.width = _canvasSize.x;
  _canvas.height = _canvasSize.y;
  if ( true && (_streamConfig$debug = _streamConfig.debug) !== null && _streamConfig$debug !== void 0 && _streamConfig$debug.showImageDetails) {
    console.warn('*** frame_grabber_browser: willReadFrequently=', willReadFrequently, 'canvas=', _canvas);
  }
  _ctx = _canvas.getContext('2d', {
    willReadFrequently: !!willReadFrequently
  }); // double not because we have an optional bool that needs to pass as a bool
  _data = new Uint8Array(_size.x * _size.y);
  if ( true && (_streamConfig$debug2 = _streamConfig.debug) !== null && _streamConfig$debug2 !== void 0 && _streamConfig$debug2.showImageDetails) {
    console.log('FrameGrabber', JSON.stringify({
      size: _size,
      topRight: topRight,
      videoSize: _videoSize,
      canvasSize: _canvasSize
    }));
  }

  /**
   * Uses the given array as frame-buffer
   */
  _that.attachData = function (data) {
    _data = data;
  };

  /**
   * Returns the used frame-buffer
   */
  _that.getData = function () {
    return _data;
  };

  // Bilinear interpolation for grayscale data (to match Node's behavior)
  function bilinearInterpolate(grayData, width, height, x, y) {
    var x0 = Math.floor(x);
    var y0 = Math.floor(y);
    var x1 = Math.min(x0 + 1, width - 1);
    var y1 = Math.min(y0 + 1, height - 1);
    var fx = x - x0;
    var fy = y - y0;
    var v00 = grayData[y0 * width + x0];
    var v10 = grayData[y0 * width + x1];
    var v01 = grayData[y1 * width + x0];
    var v11 = grayData[y1 * width + x1];
    var v0 = v00 * (1 - fx) + v10 * fx;
    var v1 = v01 * (1 - fx) + v11 * fx;
    return v0 * (1 - fy) + v1 * fy;
  }

  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   * 
   * For improved accuracy (matching Node's processing), non-half-sampled images
   * use bilinear interpolation on grayscale data instead of scaling RGB then converting.
   * 
   * IMPORTANT: The image is ALWAYS drawn to the visible canvas for overlays and display.
   */
  _that.grab = function () {
    var doHalfSample = _streamConfig.halfSample;
    var frame = inputStream.getFrame();
    var drawable = frame;
    var drawAngle = 0;
    if (drawable) {
      adjustCanvasSize(_canvas, _canvasSize, _streamConfig.debug);
      if (_streamConfig.type === 'ImageStream') {
        drawable = frame.img;
        if (frame.tags && frame.tags.orientation) {
          switch (frame.tags.orientation) {
            case 6:
              drawAngle = 90 * TO_RADIANS;
              break;
            case 8:
              drawAngle = -90 * TO_RADIANS;
              break;
          }
        }
      }

      // ALWAYS draw to visible canvas (for overlays, display, and toDataURL)
      if (drawAngle !== 0) {
        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);
        _ctx.rotate(drawAngle);
        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);
        _ctx.rotate(-drawAngle);
        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
      } else {
        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
      }
      if (doHalfSample) {
        // Half-sample path: use existing optimized approach
        var ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;
        grayAndHalfSampleFromCanvasData(ctxData, _size, _data);
      } else {
        // Non-half-sample: use improved bilinear interpolation for better accuracy
        // Process at original size, then scale grayscale data
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = _videoSize.x;
        tempCanvas.height = _videoSize.y;
        var tempCtx = tempCanvas.getContext('2d');
        if (drawAngle !== 0) {
          tempCtx.translate(_videoSize.x / 2, _videoSize.y / 2);
          tempCtx.rotate(drawAngle);
          tempCtx.drawImage(drawable, -_videoSize.y / 2, -_videoSize.x / 2, _videoSize.y, _videoSize.x);
        } else {
          tempCtx.drawImage(drawable, 0, 0, _videoSize.x, _videoSize.y);
        }

        // Convert to grayscale at original size
        var originalImageData = tempCtx.getImageData(0, 0, _videoSize.x, _videoSize.y).data;
        var grayData = new Uint8Array(_videoSize.x * _videoSize.y);
        computeGray(originalImageData, grayData, _streamConfig);

        // Scale grayscale data using bilinear interpolation
        var scaledGrayData = new Uint8Array(_canvasSize.x * _canvasSize.y);
        var stepSizeX = _videoSize.x / _canvasSize.x;
        var stepSizeY = _videoSize.y / _canvasSize.y;
        for (var y = 0; y < _canvasSize.y; y++) {
          for (var x = 0; x < _canvasSize.x; x++) {
            var srcX = x * stepSizeX;
            var srcY = y * stepSizeY;
            scaledGrayData[y * _canvasSize.x + x] = bilinearInterpolate(grayData, _videoSize.x, _videoSize.y, srcX, srcY) | 0;
          }
        }

        // Crop to target region
        for (var _y = 0; _y < _size.y; _y++) {
          for (var _x = 0; _x < _size.x; _x++) {
            var srcIdx = (_y + _sy) * _canvasSize.x + (_x + _sx);
            _data[_y * _size.x + _x] = scaledGrayData[srcIdx];
          }
        }
      }
      return true;
    }
    return false;
  };
  _that.getSize = function () {
    return _size;
  };
  return _that;
};
/* harmony default export */ var frame_grabber_browser = (FrameGrabber);
// CONCATENATED MODULE: ./src/input/exif_helper.js
// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
// need to port any part of this that doesn't work in Node to node?

// Tags scraped from https://github.com/exif-js/exif-js
var ExifTags = {
  0x0112: 'orientation'
};
var AvailableTags = Object.keys(ExifTags).map(function (key) {
  return ExifTags[key];
});
function findTagsInObjectURL(src) {
  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  if (/^blob:/i.test(src)) {
    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
      return findTagsInBuffer(buffer, tags);
    });
  }
  return Promise.resolve(null);
}
function base64ToArrayBuffer(dataUrl) {
  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);
  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }
  return buffer;
}
function readToBuffer(blob) {
  return new Promise(function (resolve) {
    var fileReader = new FileReader();
    fileReader.onload = function (e) {
      return resolve(e.target.result);
    };
    fileReader.readAsArrayBuffer(blob);
  });
}
function objectURLToBlob(url) {
  return new Promise(function (resolve, reject) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';
    http.onreadystatechange = function () {
      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
        resolve(this.response);
      }
    };
    http.onerror = reject;
    http.send();
  });
}
function findTagsInBuffer(file) {
  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  var dataView = new DataView(file);
  var length = file.byteLength;
  var exifTags = selectedTags.reduce(function (result, selectedTag) {
    var exifTag = Object.keys(ExifTags).filter(function (tag) {
      return ExifTags[tag] === selectedTag;
    })[0];
    if (exifTag) {
      result[exifTag] = selectedTag;
    }
    return result;
  }, {});
  var offset = 2;
  var marker;
  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false;
  }
  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false;
    }
    marker = dataView.getUint8(offset + 1);
    if (marker === 0xE1) {
      return readEXIFData(dataView, offset + 4, exifTags);
    }
    offset += 2 + dataView.getUint16(offset + 2);
  }
  return false;
}
function readEXIFData(file, start, exifTags) {
  if (getStringFromBuffer(file, start, 4) !== 'Exif') {
    return false;
  }
  var tiffOffset = start + 6;
  var bigEnd;
  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }
  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }
  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);
  if (firstIFDOffset < 0x00000008) {
    return false;
  }
  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
  return tags;
}
function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};
  for (var i = 0; i < entries; i++) {
    var entryOffset = dirStart + i * 12 + 2;
    var tag = strings[file.getUint16(entryOffset, !bigEnd)];
    if (tag) {
      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
    }
  }
  return tags;
}
function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);
  switch (type) {
    case 3:
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      }
  }
  return null;
}
function getStringFromBuffer(buffer, start, length) {
  var outstr = '';
  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }
  return outstr;
}
// CONCATENATED MODULE: ./src/input/image_loader.js


// Exported helper for filename generation
function generateImageFilename(directory, num) {
  return "".concat(directory, "image-").concat(num.toString().padStart(3, '0'), ".jpg");
}
var ImageLoader = {};
ImageLoader.load = function (directory, callback, offset, size, sequence, config) {
  var htmlImagesSrcArray = new Array(size);
  var htmlImagesArray = new Array(htmlImagesSrcArray.length);
  var i;
  var img;
  var num;
  if (sequence === false) {
    htmlImagesSrcArray[0] = directory;
  } else {
    for (i = 0; i < htmlImagesSrcArray.length; i++) {
      num = offset + i;
      htmlImagesSrcArray[i] = generateImageFilename(directory, num);
    }
  }
  htmlImagesArray.notLoaded = [];
  htmlImagesArray.addImage = function (image) {
    htmlImagesArray.notLoaded.push(image);
  };
  htmlImagesArray.loaded = function (loadedImg) {
    var notloadedImgs = htmlImagesArray.notLoaded;
    for (var x = 0; x < notloadedImgs.length; x++) {
      if (notloadedImgs[x] === loadedImg) {
        notloadedImgs.splice(x, 1);
        for (var y = 0; y < htmlImagesSrcArray.length; y++) {
          // Use encodeURI for matching filenames with spaces and special characters
          var imgName = encodeURI(htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/')));
          if (loadedImg.src.lastIndexOf(imgName) !== -1) {
            htmlImagesArray[y] = {
              img: loadedImg
            };
            break;
          }
        }
        break;
      }
    }
    if (notloadedImgs.length === 0) {
      var _config$debug;
      if ( true && config !== null && config !== void 0 && (_config$debug = config.debug) !== null && _config$debug !== void 0 && _config$debug.showImageDetails) {
        console.log("Images loaded: ".concat(htmlImagesArray.length, " image").concat(htmlImagesArray.length !== 1 ? 's' : '', " from ").concat(sequence === false ? directory : directory + ' (sequence)'));
      }
      if (sequence === false) {
        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
          htmlImagesArray[0].tags = tags;
          callback(htmlImagesArray);
        })["catch"](function (e) {
          console.log(e);
          callback(htmlImagesArray);
        });
      } else {
        callback(htmlImagesArray);
      }
    }
  };
  for (i = 0; i < htmlImagesSrcArray.length; i++) {
    img = new Image();
    htmlImagesArray.addImage(img);
    addOnloadHandler(img, htmlImagesArray);
    img.src = htmlImagesSrcArray[i];
  }
};
function addOnloadHandler(img, htmlImagesArray) {
  img.onload = function () {
    htmlImagesArray.loaded(this);
  };
  img.onerror = function () {
    htmlImagesArray.loaded(this);
  };
}
/* harmony default export */ var image_loader = (ImageLoader);
// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
/* eslint-disable @typescript-eslint/no-explicit-any */


var inputStreamFactory = {
  createVideoStream: function createVideoStream(video) {
    console.warn('**** InputStreamBrowser createVideoStream');
    var _config = null;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _calculatedWidth;
    var _calculatedHeight;
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    function initSize() {
      var _config2, _config3;
      var width = video.videoWidth;
      var height = video.videoHeight;

      // eslint-disable-next-line no-nested-ternary
      _calculatedWidth = (_config2 = _config) !== null && _config2 !== void 0 && _config2.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
      // eslint-disable-next-line no-nested-ternary
      _calculatedHeight = (_config3 = _config) !== null && _config3 !== void 0 && _config3.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
      _canvasSize.x = _calculatedWidth;
      _canvasSize.y = _calculatedHeight;
    }
    var inputStream = {
      getRealWidth: function getRealWidth() {
        return video.videoWidth;
      },
      getRealHeight: function getRealHeight() {
        return video.videoHeight;
      },
      getWidth: function getWidth() {
        return _calculatedWidth;
      },
      getHeight: function getHeight() {
        return _calculatedHeight;
      },
      setWidth: function setWidth(width) {
        _calculatedWidth = width;
      },
      setHeight: function setHeight(height) {
        _calculatedHeight = height;
      },
      setInputStream: function setInputStream(config) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = config;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
      },
      ended: function ended() {
        return video.ended;
      },
      getConfig: function getConfig() {
        return _config;
      },
      setAttribute: function setAttribute(name, value) {
        if (video) {
          video.setAttribute(name, value);
        }
      },
      pause: function pause() {
        video.pause();
      },
      play: function play() {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        video.play();
      },
      setCurrentTime: function setCurrentTime(time) {
        var _config4;
        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
          this.setAttribute('currentTime', time.toString());
        }
      },
      addEventListener: function addEventListener(event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }
          _eventHandlers[event].push(f);
        } else {
          video.addEventListener(event, f, bool);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        _eventNames.forEach(function (eventName) {
          var handlers = _eventHandlers[eventName];
          if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
              video.removeEventListener(eventName, handler);
            });
          }
        });
      },
      trigger: function trigger(eventName, args) {
        var j;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var handlers = _eventHandlers[eventName];
        if (eventName === 'canrecord') {
          initSize();
        }
        if (handlers && handlers.length > 0) {
          for (j = 0; j < handlers.length; j++) {
            handlers[j].apply(inputStream, args);
          }
        }
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        return video;
      }
    };
    return inputStream;
  },
  createLiveStream: function createLiveStream(video) {
    console.warn('**** InputStreamBrowser createLiveStream');
    if (video) {
      video.setAttribute('autoplay', 'true');
    }
    var that = inputStreamFactory.createVideoStream(video);
    that.ended = function ended() {
      return false;
    };
    return that;
  },
  createImageStream: function createImageStream() {
    // console.warn('**** InputStreamBrowser createImageStream');
    var _config = null;
    var width = 0;
    var height = 0;
    var frameIdx = 0;
    var paused = true;
    var loaded = false;
    var imgArray = null;
    var size = 0;
    var offset = 1;
    var baseUrl = null;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    function loadImages() {
      var _config7;
      loaded = false;
      image_loader.load(baseUrl, function (imgs) {
        var _config5, _config6;
        imgArray = imgs;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (imgs[0].tags && imgs[0].tags.orientation) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          switch (imgs[0].tags.orientation) {
            case 6:
            case 8:
              width = imgs[0].img.height;
              height = imgs[0].img.width;
              break;
            default:
              width = imgs[0].img.width;
              height = imgs[0].img.height;
          }
        } else {
          width = imgs[0].img.width;
          height = imgs[0].img.height;
        }
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = (_config5 = _config) !== null && _config5 !== void 0 && _config5.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
        // eslint-disable-next-line no-nested-ternary
        calculatedHeight = (_config6 = _config) !== null && _config6 !== void 0 && _config6.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        loaded = true;
        frameIdx = 0;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence, _config);
    }
    function publishEvent(eventName, args) {
      var j;
      var handlers = _eventHandlers[eventName];
      if (handlers && handlers.length > 0) {
        for (j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
        }
      }
    }

    // TODO: any code shared with the first InputStream above should be shared not copied
    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
    // eslint-disable-next-line no-var,vars-on-top
    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(newWidth) {
        calculatedWidth = newWidth;
      },
      setHeight: function setHeight(newHeight) {
        calculatedHeight = newHeight;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (stream.sequence === false) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          size = 1;
        } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          size = stream.length;
        }
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }
          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        var frame;
        if (!loaded) {
          return null;
        }
        if (!paused) {
          var _imgArray;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];
          if (frameIdx < size - 1) {
            frameIdx++;
          } else {
            setTimeout(function () {
              _ended = true;
              publishEvent('ended', []);
            }, 0);
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
// CONCATENATED MODULE: ./src/locator/tracer.js
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var tracer_Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;
    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;
      for (i = 0; i < searchDirections.length; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;
        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }
        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }
        current.dir = (current.dir + 1) % 8;
      }
      return false;
    }
    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }
    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };
      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;
        var totalPixelCount = imageWrapper.size.x * imageWrapper.size.y;
        var pixelCounter = 0;
        do {
          current.dir = (current.dir + 6) % 8;
          _trace(current, color, label, edgelabel);
          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }
          ldir = current.dir;
        } while ((current.cx !== sx || current.cy !== sy) && ++pixelCounter < totalPixelCount);
        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }
      return Fv;
    }
    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ var locator_tracer = (tracer_Tracer);
// CONCATENATED MODULE: ./src/locator/rasterizer.js


/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = locator_tracer.create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;
        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }
        colorMap[0] = imageData[0];
        cc = null;
        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];
          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;
            if (labelData[pos] === 0) {
              color = imageData[pos];
              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);
                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;
                    if (cc !== null) {
                      cc.prevpeer = p;
                    }
                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);
                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;
                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }
                    p.index = depthlabel;
                    sc = cc;
                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }
                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;
                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }
                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;
              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }
        sc = cc;
        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }
        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;
          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }
          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;
              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }
            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;
              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;
              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }
            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);
            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ var locator_rasterizer = (Rasterizer);
// CONCATENATED MODULE: ./src/locator/skeletonizer.js
/* eslint-disable no-param-reassign */
/* eslint-disable no-bitwise */
/* eslint-disable eqeqeq */
/* @preserve ASM BEGIN */
/**
 * Morphological skeletonization using iterative thinning algorithm.
 * Reduces binary images to single-pixel-wide skeletons while preserving topology.
 *
 * Memory layout in shared ArrayBuffer (4 regions of size):
 * - Region 0: Working image (subImagePtr = 0)
 * - Region 1: Eroded result (erodedImagePtr = size)
 * - Region 2: Temp/scratch space (tempImagePtr = 2*size)
 * - Region 3: Final skeleton output (skelImagePtr = 3*size)
 */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  /**
   * Morphological erosion with 5-pixel cross structuring element.
   * A pixel survives only if all 5 pixels in the cross pattern are set:
   * top-left, top-right, center, bottom-left, bottom-right.
   */
  function erode(inImagePtr, outImagePtr) {
    inImagePtr = inImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;
    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;
      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
        // Pixel survives erosion only if all 5 cross neighbors are set
        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  // Pixel-wise subtraction: out = a - b (captures the "peeled" layer)
  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr = aImagePtr | 0;
    bImagePtr = bImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  // Pixel-wise OR: out = a | b (accumulates skeleton layers)
  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr = aImagePtr | 0;
    bImagePtr = bImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  // Counts non-zero pixels to detect when erosion is complete
  function countNonZero(imagePtr) {
    imagePtr = imagePtr | 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }
    return sum | 0;
  }

  // Fills image region with a constant value
  function init(imagePtr, value) {
    imagePtr = imagePtr | 0;
    value = value | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  // Morphological dilation with 5-pixel cross - pixel is set if any neighbor is set
  function dilate(inImagePtr, outImagePtr) {
    inImagePtr = inImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;
    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;
      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  // Copies image data from src to dst region
  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr = srcImagePtr | 0;
    dstImagePtr = dstImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  /**
   * Zeros out the border pixels of the image.
   * First loop: handles top, left, and right edges simultaneously
   * Second loop: handles bottom edge
   */
  function zeroBorder(imagePtr) {
    imagePtr = imagePtr | 0;
    var x = 0;
    var y = 0;
    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  /**
   * Main skeletonization algorithm using iterative thinning:
   * 1. Erode the working image
   * 2. Dilate the eroded version
   * 3. Subtract dilated from original (extracts "peeled" layer)
   * 4. OR the peeled layer into skeleton accumulator
   * 5. Copy eroded image back to working image
   * 6. Repeat until working image is empty
   *
   * @returns {void} No return value - operates directly on shared buffer.
   *   Input image is read from buffer offset 0 (subImagePtr).
   *   Output skeleton is written to buffer offset 3*size (skelImagePtr).
   */
  function skeletonize() {
    var subImagePtr = 0; // Region 0: Working image (input, offset = 0)
    var erodedImagePtr = 0; // Region 1: Eroded result (offset = size)
    var tempImagePtr = 0; // Region 2: Scratch space (offset = 2*size)
    var skelImagePtr = 0; // Region 3: Final skeleton (output, offset = 3*size)
    var sum = 0;
    var done = 0;

    // Calculate byte offsets for each region in the shared buffer
    erodedImagePtr = imul(size, size) | 0; // Region 1: size bytes in
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0; // Region 2: 2*size bytes in
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // Region 3: 3*size bytes in

    // Initialize skeleton accumulator to zero
    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);
    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }
  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */

/* harmony default export */ var skeletonizer = (Skeletonizer);
/* eslint-enable eqeqeq */
// CONCATENATED MODULE: ./src/locator/barcode_locator.js








var barcode_locator_config;
var _currentImageWrapper;
var _skelImageWrapper;
var _subImageWrapper;
var _labelImageWrapper;
var _patchGrid;
var _patchLabelGrid;
var _imageToPatchGrid;
var _binaryImageWrapper;
var _patchSize;
var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};
var _inputImageWrapper;
var _skeletonizer;
function barcode_locator_initBuffers() {
  if (barcode_locator_config.halfSample) {
    _currentImageWrapper = new image_wrapper({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }
  _patchSize = calculatePatchSize(barcode_locator_config.patchSize, _currentImageWrapper.size);

  // eslint-disable-next-line no-bitwise
  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0;
  // eslint-disable-next-line no-bitwise
  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new image_wrapper(_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new image_wrapper(_patchSize, undefined, Array, true);

  // Calculate required buffer size (4 regions for asm.js skeletonizer)
  var skeletonImageDataSize = _patchSize.x * _patchSize.y * 4;
  // Round up to next power of 2 for asm.js heap requirement
  // Use minimum 64KB for optimal asm.js performance (avoids V8 warnings)
  var bufferSize = Math.max(65536, Math.pow(2, Math.ceil(Math.log2(skeletonImageDataSize))));
  var skeletonImageData = new ArrayBuffer(bufferSize);
  _subImageWrapper = new image_wrapper(_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new image_wrapper(_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = skeletonizer({
    Math: Math,
    Uint8Array: Uint8Array
  }, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new image_wrapper({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new image_wrapper(_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new image_wrapper(_imageToPatchGrid.size, undefined, Int32Array, true);
}
function barcode_locator_initCanvas() {
  var _config$debug;
  if (barcode_locator_config.useWorker || typeof document === 'undefined') {
    return;
  }
  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';
  if ( true && barcode_locator_config.debug.showCanvas === true) {
    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
  }
  var willReadFrequently = !!barcode_locator_config.willReadFrequently;
  if ( true && (_config$debug = barcode_locator_config.debug) !== null && _config$debug !== void 0 && _config$debug.showCanvas) {
    console.warn('* initCanvas willReadFrequently', willReadFrequently, barcode_locator_config);
  }
  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d', {
    willReadFrequently: willReadFrequently
  });
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}

/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */
function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale;

  // draw all patches which are to be taken into consideration
  overAvg = 0;
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;
    if ( true && barcode_locator_config.debug.showPatches) {
      image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: 'red'
      });
    }
  }
  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;
  if (overAvg < 0) {
    overAvg += 180;
  }
  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = mat2_namespaceObject.copy(mat2_namespaceObject.create(), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]);

  // iterate over patches and rotate by angle
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    for (j = 0; j < 4; j++) {
      vec2_namespaceObject.transformMat2(patch.box[j], patch.box[j], transMat);
    }
    if ( true && barcode_locator_config.debug.boxFromPatches.showTransformed) {
      image_debug.drawPath(patch.box, {
        x: 0,
        y: 1
      }, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }

  // find bounding box
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }
      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }
      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }
      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }
  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];
  if ( true && barcode_locator_config.debug.boxFromPatches.showTransformedBox) {
    image_debug.drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }
  scale = barcode_locator_config.halfSample ? 2 : 1;
  // reverse rotation;
  transMat = mat2_namespaceObject.invert(transMat, transMat);
  for (j = 0; j < 4; j++) {
    vec2_namespaceObject.transformMat2(box[j], box[j], transMat);
  }
  if ( true && barcode_locator_config.debug.boxFromPatches.showBB) {
    image_debug.drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }
  for (j = 0; j < 4; j++) {
    vec2_namespaceObject.scale(box[j], box[j], scale);
  }
  return box;
}

/**
 * Creates a binary image of the current image
 */
function binarizeImage() {
  otsuThreshold(_currentImageWrapper, _binaryImageWrapper);
  _binaryImageWrapper.zeroBorder();
  if ( true && barcode_locator_config.debug.showCanvas) {
    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
  }
}

/**
 * Iterate over the entire image
 * extract patches
 */
function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;
  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j;

      // seperate parts
      skeletonize(x, y);

      // Rasterize, find individual bars
      _skelImageWrapper.zeroBorder();
      array_helper.init(_labelImageWrapper.data, 0);
      rasterizer = locator_rasterizer.create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);
      if ( true && barcode_locator_config.debug.showLabels) {
        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
          x: x,
          y: y
        });
      }

      // calculate moments from the skeletonized patch
      moments = _labelImageWrapper.moments(rasterResult.count);

      // extract eligible patches
      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }
  if ( true && barcode_locator_config.debug.showFoundPatches) {
    for (i = 0; i < patchesFound.length; i++) {
      patch = patchesFound[i];
      image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }
  return patchesFound;
}

/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */
function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];
  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }
  sum = _patchLabelGrid.data.length;
  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }
  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  });

  // extract top areas with at least 5 patches present
  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}

/**
 *
 */
function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];
  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;
    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }
    box = boxFromPatches(patches);
    if (box) {
      boxes.push(box);

      // draw patch-labels if requested
      if ( true && barcode_locator_config.debug.showRemainingPatchLabels) {
        for (j = 0; j < patches.length; j++) {
          patch = patches[j];
          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
          hsv2rgb(hsv, rgb);
          image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
            color: "rgb(".concat(rgb.join(','), ")"),
            lineWidth: 2
          });
        }
      }
    }
  }
  return boxes;
}

/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */
function similarMoments(moments) {
  var clusters = cv_utils_cluster(moments, 0.90);
  var topCluster = topGeneric(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];
  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();
    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }
  return result;
}
function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, imageRef(x, y));
  _skeletonizer.skeletonize();

  // Show skeleton if requested
  if ( true && barcode_locator_config.debug.showSkeleton) {
    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, imageRef(x, y));
  }
}

/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */
function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);
  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    }

    // if at least 2 moments are found which have at least minComponentWeights covered
    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0;
      // determine the similarity of the moments
      for (k = 0; k < matchingMoments.length; k++) {
        var _matchingMoments$k$ra, _matchingMoments$k;
        avg += (_matchingMoments$k$ra = (_matchingMoments$k = matchingMoments[k]) === null || _matchingMoments$k === void 0 ? void 0 : _matchingMoments$k.rad) !== null && _matchingMoments$k$ra !== void 0 ? _matchingMoments$k$ra : 0;
      }

      // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set
      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [vec2_namespaceObject.clone([x, y]), vec2_namespaceObject.clone([x + _subImageWrapper.size.x, y]), vec2_namespaceObject.clone([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), vec2_namespaceObject.clone([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: vec2_namespaceObject.clone([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }
  return patchesFound;
}

/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */
function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];
  function notYetProcessed() {
    var i;
    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }
    return _patchLabelGrid.data.length;
  }
  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;
    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx];
      // assign label
      _patchLabelGrid.data[currentIdx] = label;
      for (dir = 0; dir < locator_tracer.searchDirections.length; dir++) {
        y = current.y + locator_tracer.searchDirections[dir][0];
        x = current.x + locator_tracer.searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x;

        // continue if patch empty
        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE;
          // eslint-disable-next-line no-continue
          continue;
        }
        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(vec2_namespaceObject.dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec));
          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  }

  // prepare for finding the right patches
  array_helper.init(_patchGrid.data, 0);
  array_helper.init(_patchLabelGrid.data, 0);
  array_helper.init(_imageToPatchGrid.data, null);
  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  }

  // rasterize the patches found to determine area
  _patchGrid.zeroBorder();

  // eslint-disable-next-line no-cond-assign
  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  }

  // draw patch-labels if requested
  if ( true && barcode_locator_config.debug.showPatchLabels) {
    for (j = 0; j < _patchLabelGrid.data.length; j++) {
      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
        patch = _imageToPatchGrid.data[j];
        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
        hsv2rgb(hsv, rgb);
        image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
          color: "rgb(".concat(rgb.join(','), ")"),
          lineWidth: 2
        });
      }
    }
  }
  return label;
}
/* harmony default export */ var barcode_locator = ({
  init: function init(inputImageWrapper, config) {
    barcode_locator_config = config;
    _inputImageWrapper = inputImageWrapper;
    barcode_locator_initBuffers();
    barcode_locator_initCanvas();
  },
  locate: function locate() {
    if (barcode_locator_config.halfSample) {
      halfSample(_inputImageWrapper, _currentImageWrapper);
    }
    binarizeImage();
    var patchesFound = findPatches();
    // return unless 5% or more patches are found
    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    }

    // rasterrize area by comparing angular similarity;
    var maxLabel = rasterizeAngularSimilarity(patchesFound);
    if (maxLabel < 1) {
      return null;
    }

    // search for area with the most patches (biggest connected area)
    var topLabels = findBiggestConnectedAreas(maxLabel);
    if (topLabels.length === 0) {
      return null;
    }
    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var _config$debug2;
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area;

    // calculate width and height based on area
    if (inputStream.getConfig().area) {
      area = computeImageArea(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }
    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = calculatePatchSize(config.patchSize, size);
    if ( true && (_config$debug2 = config.debug) !== null && _config$debug2 !== void 0 && _config$debug2.showPatchSize) {
      console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
    }
    inputStream.setWidth(Math.max(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x), patchSize.x));
    inputStream.setHeight(Math.max(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y), patchSize.y));
    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }
    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
// CONCATENATED MODULE: ./src/QuaggaContext.ts



var QuaggaContext_QuaggaContext = /*#__PURE__*/createClass_default()(function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);
  defineProperty_default()(this, "config", void 0);
  defineProperty_default()(this, "inputStream", void 0);
  defineProperty_default()(this, "framegrabber", void 0);
  defineProperty_default()(this, "inputImageWrapper", void 0);
  defineProperty_default()(this, "stopped", false);
  /**
   * Flag indicating that stop() was called while init() was still in progress.
   * This is used to handle race conditions in React StrictMode where components
   * are mounted/unmounted rapidly, causing init() to be called, then stop(),
   * then init() again before the first init() completes.
   */
  defineProperty_default()(this, "initAborted", false);
  defineProperty_default()(this, "boxSize", void 0);
  defineProperty_default()(this, "resultCollector", void 0);
  defineProperty_default()(this, "decoder", void 0);
  defineProperty_default()(this, "workerPool", []);
  defineProperty_default()(this, "onUIThread", true);
  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
});
var QuaggaContext_CanvasInfo = /*#__PURE__*/createClass_default()(function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);
  defineProperty_default()(this, "image", void 0);
  defineProperty_default()(this, "overlay", void 0);
});
var QuaggaContext_CanvasContainer = /*#__PURE__*/createClass_default()(function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);
  defineProperty_default()(this, "ctx", void 0);
  defineProperty_default()(this, "dom", void 0);
  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
});
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  }

  // Check if target is already a DOM element
  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  }
  // Use '#interactive.viewport' as a fallback selector (backwards compatibility)
  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initBuffers.ts




// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var _config, _config$debug;
  var inputImageWrapper = imageWrapper || new image_wrapper({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });
  if ( true && (_config = locator.config) !== null && _config !== void 0 && (_config$debug = _config.debug) !== null && _config$debug !== void 0 && _config$debug.showImageDetails) {
    console.log("image wrapper size ".concat(inputImageWrapper.size));
  }
  var boxSize = [vec2_namespaceObject.clone([0, 0]), vec2_namespaceObject.clone([0, inputImageWrapper.size.y]), vec2_namespaceObject.clone([inputImageWrapper.size.x, inputImageWrapper.size.y]), vec2_namespaceObject.clone([inputImageWrapper.size.x, 0])];
  barcode_locator.init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts

function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);
  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }
  return canvas;
}
function getCanvasAndContext(selector, className, options) {
  var _options$debug;
  var canvas = findOrCreateCanvas(selector, className);
  if ( true && (_options$debug = options.debug) !== null && _options$debug !== void 0 && _options$debug.showImageDetails) {
    console.warn('* initCanvas getCanvasAndContext');
  }
  var context = canvas.getContext('2d', {
    willReadFrequently: options.willReadFrequently
  });
  return {
    canvas: canvas,
    context: context
  };
}
function initCanvases(canvasSize, _ref) {
  var willReadFrequently = _ref.willReadFrequently,
    createOverlay = _ref.createOverlay,
    debug = _ref.debug;
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer', {
      willReadFrequently: willReadFrequently,
      debug: debug
    });
    image.canvas.width = canvasSize.x;
    image.canvas.height = canvasSize.y;

    // Only create overlay canvas if createOverlay is true (default behavior)
    var overlay = {
      canvas: null,
      context: null
    };
    if (createOverlay) {
      var overlayResult = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer', {
        willReadFrequently: willReadFrequently,
        debug: debug
      });
      overlayResult.canvas.width = canvasSize.x;
      overlayResult.canvas.height = canvasSize.y;
      overlay = overlayResult;
    }
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }
  return null;
}
function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu, _context$config3, _context$config3$canv, _context$config4, _context$config4$inpu, _context$config5, _context$config5$loca;
  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;

  // Default to true for backwards compatibility
  var createOverlay = (context === null || context === void 0 ? void 0 : (_context$config3 = context.config) === null || _context$config3 === void 0 ? void 0 : (_context$config3$canv = _context$config3.canvas) === null || _context$config3$canv === void 0 ? void 0 : _context$config3$canv.createOverlay) !== false;
  var container = initCanvases(context.inputStream.getCanvasSize(), {
    willReadFrequently: !!(context !== null && context !== void 0 && (_context$config4 = context.config) !== null && _context$config4 !== void 0 && (_context$config4$inpu = _context$config4.inputStream) !== null && _context$config4$inpu !== void 0 && _context$config4$inpu.willReadFrequently),
    createOverlay: createOverlay,
    debug: context === null || context === void 0 ? void 0 : (_context$config5 = context.config) === null || _context$config5 === void 0 ? void 0 : (_context$config5$loca = _context$config5.locator) === null || _context$config5$loca === void 0 ? void 0 : _context$config5$loca.debug
  });
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;
  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }
      if (dom.overlay && !viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }
  return container;
}
// CONCATENATED MODULE: ./src/quagga/qworker.ts

function qworker_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function qworker_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? qworker_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : qworker_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */

// TODO: need a typescript interface for FrameGrabber

var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;
  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];
    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);
      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }
      return true;
    } else {
      return false;
    }
  }
  return null;
}
function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
}

// @ts-ignore
function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];
    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  }
  // @ts-ignore
  var imageWrapper;

  // @ts-ignore
  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result
      // @ts-ignore
    }, [imageWrapper.data.buffer]);
  }
  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data
      // @ts-ignore
    }, [imageWrapper.data.buffer]);
  }

  // @ts-ignore
  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}
function generateWorkerBlob() {
  var blob, factorySource;

  /* jshint ignore:start */
  // @ts-ignore
  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */

  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}
function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };
  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);
      if (true) {
        console.log('Worker initialized');
      }
      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false;
      // TODO: how to thread publishResult into here? TypeScript says it's not here. https://github.com/ericblade/quagga2/issues/466#issuecomment-1724248080 says it's necessary?
      // @ts-ignore
      if (typeof publishResult !== 'undefined') {
        // @ts-ignore
        publishResult(e.data.result, workerThread.imageData);
      }
    } else if (e.data.event === 'error') {
      if (true) {
        console.log('Worker error: ' + e.data.message);
      }
    }
  };
  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;
  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();
      if (true) {
        console.log('Worker terminated!');
      }
    });
    workerPool = workerPool.slice(0, increaseBy);
    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);
      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };
    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var inputStreamFactory = arguments.length > 2 ? arguments[2] : undefined;
  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: inputStreamFactory.createVideoStream(video)
        };
      }
    case 'ImageStream':
      return {
        inputStream: inputStreamFactory.createImageStream()
      };
    case 'LiveStream':
      {
        var _video = null;
        if (viewport) {
          _video = viewport.querySelector('video');
          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }
        return {
          video: _video,
          inputStream: inputStreamFactory.createLiveStream(_video)
        };
      }
    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */

function moveBox(box, xOffset, yOffset) {
  var corner = box.length;
  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts



















var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;
    classCallCheck_default()(this, Quagga);
    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());
    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;
      // Check if init was aborted (e.g., by calling stop() during initialization)
      // This can happen in React StrictMode where components are mounted/unmounted rapidly
      if (_this.context.initAborted) {
        callback(new Error('Initialization was aborted'));
        return;
      }
      if (!_this.context.config) {
        callback(new Error('Configuration not initialized'));
        return;
      }
      // Check if inputStream is properly initialized before proceeding
      if (!_this.context.inputStream) {
        callback(new Error('Input stream not initialized'));
        return;
      }
      barcode_locator.checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);
      _this.initCanvas();
      _this.context.framegrabber = frame_grabber_browser.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);
      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }
      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;
        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }
        _this.ready(callback);
      });
    });
    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);
        if (!workersUpdated) {
          var _this$context$inputIm;
          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);
          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;
        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);
        _this.context.framegrabber.grab();
        _this.locateAndDecode();
      }
    });
    /**
     * Public method to draw a scanner area overlay using the current Quagga instance's overlay canvas.
     * Draws based on the instance's configured inputStream.area, using the actual adjusted boxSize
     * to match the real scanning area after patch alignment.
     * Only draws when locate is false and an area is configured with styling.
     */
    defineProperty_default()(this, "_cachedStyleValues", void 0);
    defineProperty_default()(this, "_resolvedStyle", void 0);
  }
  return createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }
      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
        inputImageWrapper = _initBuffers2.inputImageWrapper,
        boxSize = _initBuffers2.boxSize;
      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }
      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }
      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);
      if (!container) {
        return;
      }
      var ctx = container.ctx,
        dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }
      var _this$context$config$ = this.context.config.inputStream,
        inputType = _this$context$config$.type,
        constraints = _this$context$config$.constraints;
      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream_browser),
        video = _setupInputStream.video,
        inputStream = _setupInputStream.inputStream;
      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }
      if (inputStream) {
        inputStream.setAttribute('preload', 'auto');
        inputStream.setInputStream(this.context.config.inputStream);
        inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      }
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;
      return (_this$context$config3 = this.context.config) !== null && _this$context$config3 !== void 0 && _this$context$config3.locate ? barcode_locator.locate() : [[vec2_namespaceObject.clone(this.context.boxSize[0]), vec2_namespaceObject.clone(this.context.boxSize[1]), vec2_namespaceObject.clone(this.context.boxSize[2]), vec2_namespaceObject.clone(this.context.boxSize[3])]];
    }

    // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;
      var transformedBoxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;
      if (xOffset === 0 && yOffset === 0) {
        return;
      }
      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode, transformedBoxes);
        });
      }
      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }
      if (result.box && !transformedBoxes.has(result.box)) {
        moveBox(result.box, xOffset, yOffset);
        transformedBoxes.add(result.box);
      }
      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          // Skip if this box has already been transformed (either as result.box or through barcodes)
          if (!transformedBoxes.has(result.boxes[i])) {
            moveBox(result.boxes[i], xOffset, yOffset);
            transformedBoxes.add(result.boxes[i]);
          }
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;
      if (!imageData || !this.context.resultCollector) {
        return;
      }

      // TODO: Figure out what data structure holds a "barcodes" result, if any...
      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    }

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    }

    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  }, {
    key: "publishResult",
    value: function publishResult() {
      var _cfg$inputStream;
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;
      if (result && this.context.onUIThread) {
        var _result$barcodes;
        this.transformResult(result);
        this.addResult(result, imageData);
        // @ts-ignore
        resultToPublish = (result === null || result === void 0 ? void 0 : (_result$barcodes = result.barcodes) === null || _result$barcodes === void 0 ? void 0 : _result$barcodes.length) > 0 ? result.barcodes : result;
      }
      events.publish('processed', resultToPublish);
      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }

      // Redraw scanner area each frame when locate is false via public API.
      var cfg = this.context.config;
      if (cfg && cfg.locate === false && (_cfg$inputStream = cfg.inputStream) !== null && _cfg$inputStream !== void 0 && _cfg$inputStream.area) {
        this.drawScannerArea();
      }
    }
  }, {
    key: "locateAndDecode",
    value: function () {
      var _locateAndDecode = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
        var boxes, _this$context$inputIm3, decodeResult, imageResult, _this$context$inputIm4, _t;
        return regenerator_default.a.wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              boxes = this.getBoundingBoxes();
              if (!boxes) {
                _context.next = 3;
                break;
              }
              _context.next = 1;
              return this.context.decoder.decodeFromBoundingBoxes(boxes);
            case 1:
              _t = _context.sent;
              if (_t) {
                _context.next = 2;
                break;
              }
              _t = {};
            case 2:
              decodeResult = _t;
              decodeResult.boxes = boxes;
              this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
              _context.next = 5;
              break;
            case 3:
              _context.next = 4;
              return this.context.decoder.decodeFromImage(this.context.inputImageWrapper);
            case 4:
              imageResult = _context.sent;
              if (imageResult) {
                this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
              } else {
                this.publishResult();
              }
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function locateAndDecode() {
        return _locateAndDecode.apply(this, arguments);
      }
      return locateAndDecode;
    }()
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
        _this4 = this;
      var next = null;
      // frequency specifies a maximum rate, not an absolute. If the system cannot
      // achieve the requested frequency, scans will occur as fast as possible.
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;
      var _newFrame = function newFrame(timestamp) {
        next = next || timestamp;
        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;
            _this4.update();
          }
          window.requestAnimationFrame(_newFrame);
        }
      };
      _newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;
      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function () {
      var _stop = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2() {
        var _this$context$config7;
        var _this$context$inputSt;
        return regenerator_default.a.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.context.stopped = true;
              // Set initAborted flag if stop() is called while init() is still in progress
              // (i.e., before framegrabber is initialized). This prevents the canRecord
              // callback from continuing after stop() was called.
              if (!this.context.framegrabber) {
                this.context.initAborted = true;
              }
              adjustWorkerPool(0);
              if (!((_this$context$config7 = this.context.config) !== null && _this$context$config7 !== void 0 && _this$context$config7.inputStream && this.context.config.inputStream.type === 'LiveStream')) {
                _context2.next = 2;
                break;
              }
              _context2.next = 1;
              return camera_access.release();
            case 1:
              (_this$context$inputSt = this.context.inputStream) === null || _this$context$inputSt === void 0 ? void 0 : _this$context$inputSt.clearEventHandlers();
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function stop() {
        return _stop.apply(this, arguments);
      }
      return stop;
    }()
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }
      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);
      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }
      qworker_registerReader(name, reader);
    }
  }, {
    key: "drawScannerArea",
    value: function drawScannerArea() {
      var _this$context$config8, _this$context$config9, _this$context$config0;
      var area = (_this$context$config8 = this.context.config) === null || _this$context$config8 === void 0 ? void 0 : (_this$context$config9 = _this$context$config8.inputStream) === null || _this$context$config9 === void 0 ? void 0 : _this$context$config9.area;
      if (!area) return;
      var overlayCtx = this.context.canvasContainer.ctx.overlay;
      if (!overlayCtx) return;

      // Only draw when locate is false
      if (((_this$context$config0 = this.context.config) === null || _this$context$config0 === void 0 ? void 0 : _this$context$config0.locate) !== false) return;

      // Quick checks for visualization presence
      var hasAnyStyle = area.borderColor !== undefined && area.borderColor !== '' || area.borderWidth !== undefined && area.borderWidth > 0 || area.backgroundColor !== undefined && area.backgroundColor !== '';
      if (!hasAnyStyle) return;

      // When locate is false, use the actual adjusted boxSize that matches the scanning area
      if (!this.context.boxSize) return;

      // Get the offset for the constrained area
      var topRightOffset = this.context.inputStream.getTopRight();
      var offsetX = topRightOffset.x;
      var offsetY = topRightOffset.y;
      var box = this.context.boxSize;
      var topLeft = box[0];
      var bottomLeft = box[1];
      var topRight = box[3];

      // Add the offset to position correctly on canvas
      var x = topLeft[0] + offsetX;
      var y = topLeft[1] + offsetY;
      var width = topRight[0] - topLeft[0];
      var height = bottomLeft[1] - topLeft[1];
      var styleChanged = !this._cachedStyleValues || this._cachedStyleValues.borderColor !== area.borderColor || this._cachedStyleValues.borderWidth !== area.borderWidth || this._cachedStyleValues.backgroundColor !== area.backgroundColor;
      if (styleChanged) {
        var _area$borderColor, _area$borderWidth;
        this._cachedStyleValues = {
          borderColor: area.borderColor,
          borderWidth: area.borderWidth,
          backgroundColor: area.backgroundColor
        };
        var shouldDrawBorder = area.borderColor !== undefined || area.borderWidth !== undefined;
        var color = (_area$borderColor = area.borderColor) !== null && _area$borderColor !== void 0 ? _area$borderColor : 'rgba(0, 255, 0, 0.5)';
        var borderWidth = shouldDrawBorder ? (_area$borderWidth = area.borderWidth) !== null && _area$borderWidth !== void 0 ? _area$borderWidth : 2 : 0;
        var bg = area.backgroundColor;
        this._resolvedStyle = {
          color: color,
          width: borderWidth,
          bg: bg
        };
      }
      var style = this._resolvedStyle;
      if (style.bg) {
        overlayCtx.fillStyle = style.bg;
        overlayCtx.fillRect(x, y, width, height);
      }
      if (style.width > 0) {
        overlayCtx.strokeStyle = style.color;
        overlayCtx.lineWidth = style.width;
        overlayCtx.strokeRect(x, y, width, height);
      }
    }
  }]);
}();

// CONCATENATED MODULE: ./src/quagga.js


 // eslint-disable-line no-unused-vars









var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;
    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }
    // Reset the initAborted flag when starting a new init
    quaggaInstance.context.initAborted = false;
    quaggaInstance.context.config = merge_default()({}, config_config, config);
    // TODO #179: pending restructure in Issue #179, we are temp disabling workers
    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }
    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);
      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }
    return promise;
  },
  start: function start(config, cb) {
    // If config is provided, call init() then start()
    if (config) {
      var promise;
      if (!cb) {
        promise = new Promise(function (resolve, reject) {
          cb = function cb(err) {
            err ? reject(err) : resolve();
          };
        });
      }
      this.init(config, function (err) {
        if (err) {
          cb(err);
          return;
        }
        try {
          instance.start();
          cb();
        } catch (startErr) {
          cb(startErr);
        }
      });
      return promise;
    }
    // If init() hasn't been completed, throw an error
    if (!_context.framegrabber) {
      throw new Error('start() was called before init() completed. ' + 'Call init() first, or call start(config) to combine init and start.');
    }
    return instance.start();
  },
  stop: function stop() {
    return instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }
    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }
    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }
    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }
    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }
    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },
  get canvas() {
    return _context.canvasContainer;
  },
  drawScannerArea: function drawScannerArea() {
    return instance.drawScannerArea();
  },
  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;
    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  true && config.debug ? 0 : 1,
      locator: {
        halfSample: false
      }
    }, config);
    // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/
    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    }
    // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.
    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }
    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();
            if (resultCallback) {
              resultCallback.call(null, result);
            }
            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },
  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },
  Readers: reader_namespaceObject,
  CameraAccess: camera_access,
  ImageDebug: image_debug,
  ImageWrapper: image_wrapper,
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface);
// export BarcodeReader and other utilities for external plugins


/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvT3ZlcmxvYWRZaWVsZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckRlZmluZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckFzeW5jR2VuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9vbWl0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vdHlwZWRlZnMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckFzeW5jLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yS2V5cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVJlZ0V4cC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5zZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19wYXJlbnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3VzdG9tT21pdENsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY29uc3RydWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0Mi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jbHVzdGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vY3ZfdXRpbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2VfZGVidWcudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9iYXJjb2RlX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyLzJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV85M19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvcGhhcm1hY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9kZWNvZGVyL2JyZXNlbmhhbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvZGVjb2Rlci9iYXJjb2RlX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9pbmRleC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2V2ZW50cy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL0V4Y2VwdGlvbi50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL21lZGlhRGV2aWNlcy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcuZGV2LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLm5vZGUudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcucHJvZC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlcl9icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9leGlmX2hlbHBlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW1hZ2VfbG9hZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtX2Jyb3dzZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvUXVhZ2dhQ29udGV4dC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2dldFZpZXdQb3J0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdEJ1ZmZlcnMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9pbml0Q2FudmFzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvcXdvcmtlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3NldHVwSW5wdXRTdHJlYW0udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS90cmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9xdWFnZ2EudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJNYXRoIiwiaW11bCIsImEiLCJiIiwiYWgiLCJhbCIsImJoIiwiYmwiLCJPYmplY3QiLCJhc3NpZ24iLCJ0YXJnZXQiLCJUeXBlRXJyb3IiLCJ0byIsImluZGV4IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwibmV4dFNvdXJjZSIsIm5leHRLZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbml0IiwiYXJyIiwidmFsIiwiZmlsbCIsInNodWZmbGUiLCJpIiwiaiIsImZsb29yIiwicmFuZG9tIiwiX3JlZiIsInRvUG9pbnRMaXN0Iiwicm93cyIsInJlZHVjZSIsInAiLCJuIiwicm93IiwiY29uY2F0Iiwiam9pbiIsInB1c2giLCJ0aHJlc2hvbGQiLCJzY29yZUZ1bmMiLCJxdWV1ZSIsInByZXYiLCJuZXh0IiwiYXBwbHkiLCJtYXhJbmRleCIsIm1heCIsInN1bSIsImNyZWF0ZSIsInBvaW50IiwicG9pbnRzIiwiY2VudGVyIiwicmFkIiwidmVjIiwidmVjMiIsImNsb25lIiwicG9pbnRNYXAiLCJhZGQiLCJwb2ludFRvQWRkIiwiaWQiLCJ1cGRhdGVDZW50ZXIiLCJjb3MiLCJzaW4iLCJmaXRzIiwib3RoZXJQb2ludCIsInNpbWlsYXJpdHkiLCJhYnMiLCJkb3QiLCJnZXRQb2ludHMiLCJnZXRDZW50ZXIiLCJjcmVhdGVQb2ludCIsIm5ld1BvaW50IiwicHJvcGVydHkiLCJpbWFnZVJlZiIsIngiLCJ5IiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsInZlYzMiLCJyb3VuZCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlMiIsImltYWdlV3JhcHBlciIsImludGVncmFsV3JhcHBlciIsImltYWdlRGF0YSIsImRhdGEiLCJ3aWR0aCIsInNpemUiLCJoZWlnaHQiLCJpbnRlZ3JhbEltYWdlRGF0YSIsInBvc0EiLCJwb3NCIiwicG9zQyIsInBvc0QiLCJjb21wdXRlSW50ZWdyYWxJbWFnZSIsInYiLCJ1IiwidGhyZXNob2xkSW1hZ2UiLCJ0YXJnZXRXcmFwcGVyIiwidGFyZ2V0RGF0YSIsImNvbXB1dGVIaXN0b2dyYW0iLCJiaXRzUGVyUGl4ZWwiLCJiaXRTaGlmdCIsImJ1Y2tldENudCIsImhpc3QiLCJJbnQzMkFycmF5Iiwic2hhcnBlbkxpbmUiLCJsaW5lIiwibGVmdCIsInJpZ2h0IiwiZGV0ZXJtaW5lT3RzdVRocmVzaG9sZCIsInVuZGVmaW5lZCIsInB4IiwiZW5kIiwibXgiLCJkZXRlcm1pbmVUaHJlc2hvbGQiLCJ2ZXQiLCJwMSIsInAyIiwicDEyIiwibTEiLCJtMiIsIm0xMiIsImsiLCJBcnJheUhlbHBlciIsIm90c3VUaHJlc2hvbGQiLCJjb21wdXRlQmluYXJ5SW1hZ2UiLCJrZXJuZWwiLCJBIiwiQiIsIkMiLCJEIiwiYXZnIiwiY2x1c3RlciIsInRoaXNDbHVzdGVyIiwiY2x1c3RlcnMiLCJhZGRUb0NsdXN0ZXIiLCJmb3VuZCIsIkNsdXN0ZXIyIiwiVHJhY2VyIiwidHJhY2UiLCJpdGVyYXRpb24iLCJtYXhJdGVyYXRpb25zIiwidG9wIiwicmVzdWx0IiwiY2VudGVyUG9zIiwiY3VycmVudFBvcyIsImlkeCIsImZvcndhcmQiLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwic3VidHJhY3QiLCJhSW1hZ2VXcmFwcGVyIiwiYkltYWdlV3JhcHBlciIsInJlc3VsdEltYWdlV3JhcHBlciIsImFJbWFnZURhdGEiLCJiSW1hZ2VEYXRhIiwiY0ltYWdlRGF0YSIsImJpdHdpc2VPciIsImNvdW50Tm9uWmVybyIsInRvcEdlbmVyaWMiLCJsaXN0IiwibWluSWR4IiwibWluIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiZ3JheUFycmF5RnJvbUltYWdlIiwiaHRtbEltYWdlIiwib2Zmc2V0WCIsImN0eCIsImFycmF5IiwiZHJhd0ltYWdlIiwiY3R4RGF0YSIsImdldEltYWdlRGF0YSIsImNvbXB1dGVHcmF5IiwiZ3JheUFycmF5RnJvbUNvbnRleHQiLCJvZmZzZXQiLCJncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhIiwiY2FudmFzRGF0YSIsIm91dEFycmF5IiwidG9wUm93SWR4IiwiYm90dG9tUm93SWR4IiwiZW5kSWR4Iiwib3V0V2lkdGgiLCJvdXRJbWdJZHgiLCJpbldpZHRoIiwiY29uZmlnIiwibCIsInNpbmdsZUNoYW5uZWwiLCJsb2FkSW1hZ2VBcnJheSIsInNyYyIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiY29uc29sZSIsIndhcm4iLCJnZXRDb250ZXh0IiwiVWludDhBcnJheSIsIl9jdHgkZ2V0SW1hZ2VEYXRhIiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImhzdjJyZ2IiLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJfY29tcHV0ZURpdmlzb3JzIiwiaXNGaW5pdGUiLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0TiIsInNxcnQiLCJ1bnNoaWZ0IiwiX2NvbXB1dGVJbnRlcnNlY3Rpb24iLCJhcnIxIiwiYXJyMiIsImNhbGN1bGF0ZVBhdGNoU2l6ZSIsInBhdGNoU2l6ZSIsImltZ1NpemUiLCJkaXZpc29yc1giLCJkaXZpc29yc1kiLCJ3aWRlU2lkZSIsImNvbW1vbiIsIm5yT2ZQYXRjaGVzTGlzdCIsIm5yT2ZQYXRjaGVzTWFwIiwic21hbGwiLCJtZWRpdW0iLCJsYXJnZSIsIm5yT2ZQYXRjaGVzSWR4IiwibnJPZlBhdGNoZXMiLCJkZXNpcmVkUGF0Y2hTaXplIiwib3B0aW1hbFBhdGNoU2l6ZSIsImZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyIsIl9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyIsInZhbHVlIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJrZXkiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJhc3NlcnROdW1iZXJQb3NpdGl2ZSIsIkVycm9yIiwiSW1hZ2VXcmFwcGVyIiwiQXJyYXlUeXBlIiwiaW5pdGlhbGl6ZSIsIl9jbGFzc0NhbGxDaGVjayIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9jcmVhdGVDbGFzcyIsImluSW1hZ2VXaXRoQm9yZGVyIiwiaW1nUmVmIiwiYm9yZGVyIiwic3ViSW1hZ2VBc0NvcHkiLCJfaW1hZ2VXcmFwcGVyJHNpemUiLCJzaXplWCIsInNpemVZIiwiZ2V0IiwiZ2V0U2FmZSIsImluZGV4TWFwcGluZyIsInNldCIsInplcm9Cb3JkZXIiLCJfdGhpcyRzaXplIiwibW9tZW50cyIsImxhYmVsQ291bnQiLCJ5c3EiLCJsYWJlbFN1bSIsImxhYmVsIiwibXUxMSIsIm11MDIiLCJtdTIwIiwieF8iLCJ5XyIsInRtcCIsIlBJIiwiUElfNCIsIm0wMCIsIm0wMSIsIm0xMCIsIm0xMSIsIm0wMiIsIm0yMCIsInRoZXRhIiwiaXNOYU4iLCJhdGFuIiwiZ2V0QXNSR0JBIiwic2NhbGUiLCJyZXQiLCJVaW50OENsYW1wZWRBcnJheSIsInBpeGVsIiwiY3VycmVudCIsInNob3ciLCJmcmFtZSIsIm5ld0ZyYW1lIiwiSW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwib3ZlcmxheSIsImluU2NhbGUiLCJhZGp1c3RlZFNjYWxlIiwid2hpdGVSZ2IiLCJibGFja1JnYiIsIl9yZXN1bHQiLCJfcmVzdWx0MiIsIl9zbGljZWRUb0FycmF5IiwiZHJhd1JlY3QiLCJzdHlsZSIsInN0cm9rZVN0eWxlIiwiY29sb3IiLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJiZWdpblBhdGgiLCJzdHJva2VSZWN0IiwiZHJhd1BhdGgiLCJwYXRoIiwiZGVmIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwic3Ryb2tlIiwiY2FudmFzRGF0YVBvcyIsImltYWdlRGF0YVBvcyIsIkJhcmNvZGVEaXJlY3Rpb24iLCJCYXJjb2RlUmVhZGVyIiwic3VwcGxlbWVudHMiLCJfcm93IiwiX25leHRVbnNldCIsInN0YXJ0IiwiX21hdGNoUGF0dGVybiIsImNvdW50ZXIiLCJjb2RlIiwibWF4U2luZ2xlRXJyb3IiLCJTSU5HTEVfQ09ERV9FUlJPUiIsImVycm9yIiwic2luZ2xlRXJyb3IiLCJtb2R1bG8iLCJiYXJXaWR0aCIsImNvdW50Iiwic2NhbGVkIiwiX25leHRTZXQiLCJfY29ycmVjdEJhcnMiLCJjb3JyZWN0aW9uIiwiaW5kaWNlcyIsImRlY29kZVBhdHRlcm4iLCJwYXR0ZXJuIiwiZGVjb2RlIiwicmV2ZXJzZSIsImRpcmVjdGlvbiIsIlJldmVyc2UiLCJGb3J3YXJkIiwiZm9ybWF0IiwiRk9STUFUIiwiX21hdGNoUmFuZ2UiLCJfZmlsbENvdW50ZXJzIiwiaXNXaGl0ZSIsImNvdW50ZXJzIiwiY291bnRlclBvcyIsIl90b0NvdW50ZXJzIiwibnVtQ291bnRlcnMiLCJkZWNvZGVJbWFnZSIsIlN0YXJ0Tm90Rm91bmRFeGNlcHRpb24iLCJDb2RlTm90Rm91bmRFeGNlcHRpb24iLCJQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb24iLCJOIiwiVyIsIlNUQVJUX1BBVFRFUk4iLCJTVE9QX1BBVFRFUk4iLCJDT0RFX1BBVFRFUk4iLCJTVEFSVF9QQVRURVJOX0xFTkdUSCIsIlR3b09mRml2ZVJlYWRlciIsIl9CYXJjb2RlUmVhZGVyIiwiX3RoaXMiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsIl9jYWxsU3VwZXIiLCJfaW5oZXJpdHMiLCJfZmluZFBhdHRlcm4iLCJ0cnlIYXJkZXIiLCJiZXN0TWF0Y2giLCJlcHNpbG9uIiwiQVZHX0NPREVfRVJST1IiLCJfZmluZFN0YXJ0Iiwic3RhcnRJbmZvIiwibmFycm93QmFyV2lkdGgiLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0IiwiX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZSIsImVuZEluZm8iLCJ0cmFpbGluZ1doaXRlc3BhY2VFbmQiLCJfZmluZEVuZCIsIl92ZXJpZnlDb3VudGVyTGVuZ3RoIiwiX2RlY29kZUNvZGUiLCJfZGVjb2RlUGF5bG9hZCIsImRlY29kZWRDb2RlcyIsImNvdW50ZXJMZW5ndGgiLCJiYXJTcGFjZVJhdGlvIiwiQUxQSEFCRVQiLCJDSEFSQUNURVJfRU5DT0RJTkdTIiwiU1RBUlRfRU5EIiwiTUlOX0VOQ09ERURfQ0hBUlMiLCJNQVhfQUNDRVBUQUJMRSIsIlBBRERJTkciLCJOZXdDb2RhYmFyUmVhZGVyIiwiX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZCIsIl9jb3VudGVycyIsIl90b1BhdHRlcm4iLCJiYXJUaHJlc2hvbGQiLCJzcGFjZVRocmVzaG9sZCIsImJpdG1hc2siLCJfaXNTdGFydEVuZCIsIl9zdW1Db3VudGVycyIsInN0YXJ0Q291bnRlciIsImVuZENvdW50ZXIiLCJfcGF0dGVyblRvQ2hhciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoIiwiX3ZlcmlmeVdoaXRlc3BhY2UiLCJfY2hhclRvUGF0dGVybiIsImNoYXIiLCJjaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJfdGhyZXNob2xkUmVzdWx0UGF0dGVybiIsImNhdGVnb3JpemF0aW9uIiwic3BhY2UiLCJuYXJyb3ciLCJjb3VudHMiLCJ3aWRlIiwiYmFyIiwia2luZCIsImNhdCIsImZvckVhY2giLCJuZXdraW5kIiwiY2VpbCIsIl92YWxpZGF0ZVJlc3VsdCIsInRocmVzaG9sZHMiLCJuZXh0U3RhcnQiLCJkZWNvZGVkQ2hhciIsIkNvZGUxMjhSZWFkZXIiLCJfY29ycmVjdCIsImNhbGN1bGF0ZUNvcnJlY3Rpb24iLCJNT0RVTEVfSU5ESUNFUyIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQyIsIl90aGlzMiIsImNoZWNrc3VtIiwiY29kZXNldCIsIkNPREVfQSIsIlNUQVJUX0NPREVfQiIsIkNPREVfQiIsIkNPREVfQyIsImRvbmUiLCJzaGlmdE5leHQiLCJyZW1vdmVMYXN0Q2hhcmFjdGVyIiwibXVsdGlwbGllciIsInJhd1Jlc3VsdCIsIlNUT1BfQ09ERSIsIkNPREVfU0hJRlQiLCJzcGxpY2UiLCJzZWxmIiwiZXhwZWN0ZWQiLCJub3JtYWxpemVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwiQUxQSEFCRVRIX1NUUklORyIsIlVpbnQxNkFycmF5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwibWFwIiwiQVNURVJJU0siLCJDb2RlMzlSZWFkZXIiLCJwYXR0ZXJuU3RhcnQiLCJ3aGl0ZVNwYWNlTXVzdFN0YXJ0IiwibWF4TmFycm93V2lkdGgiLCJudW1XaWRlQmFycyIsIndpZGVCYXJXaWR0aCIsIl9maW5kTmV4dFdpZHRoIiwibWluV2lkdGgiLCJsYXN0U3RhcnQiLCJwYXR0ZXJuU2l6ZSIsInBvcCIsInBhdHRlcm5zIiwiQUVJTyIsIkFaMDkiLCJjb2RlMzJzZXQiLCJDb2RlMzJSZWFkZXIiLCJfQ29kZTM5UmVhZGVyIiwiX2RlY29kZUNvZGUzMiIsInRlc3QiLCJyZXMiLCJjb2RlMzIiLCJzbGljZSIsIl9jaGVja0NoZWNrc3VtIiwiX3N1cGVyUHJvcEdldCIsInJlcGxhY2UiLCJJT1EiLCJDb2RlMzlWSU5SZWFkZXIiLCJsb2ciLCJDb2RlOTNSZWFkZXIiLCJfdmVyaWZ5RW5kIiwiX2RlY29kZUV4dGVuZGVkIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJfbWF0Y2hDaGVja0NoYXIiLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJfdmVyaWZ5Q2hlY2tzdW1zIiwiQ09ERV9HX1NUQVJUIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwibWVyZ2UiLCJjb2RlcmFuZ2UiLCJfY2FsY3VsYXRlRmlyc3REaWdpdCIsImNvZGVGcmVxdWVuY3kiLCJpbkNvZGUiLCJvdXRDb2RlIiwiX29iamVjdFNwcmVhZCIsImZpcnN0RGlnaXQiLCJtaWRkbGVQYXR0ZXJuIiwiX2NoZWNrc3VtIiwiX2RlY29kZUV4dGVuc2lvbnMiLCJlcnIiLCJyZXN1bHRJbmZvIiwic3VwcGxlbWVudCIsImxhc3RDb2RlIiwiRUFOMlJlYWRlciIsIl9FQU5SZWFkZXIiLCJwYXJzZUludCIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsIkVBTjVSZWFkZXIiLCJFQU44UmVhZGVyIiwiSTJvZjVSZWFkZXIiLCJvcHRzIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY291bnRlclN1bSIsImNvZGVTdW0iLCJjb3JyZWN0aW9uUmF0aW8iLCJNQVhfQ09SUkVDVElPTl9GQUNUT1IiLCJjb3JyZWN0aW9uUmF0aW9JbnZlcnNlIiwiX2RlY29kZVBhaXIiLCJjb3VudGVyUGFpciIsImNvZGVzIiwiTUlOX0JBUl9DT1VOVCIsIk1BWF9CQVJfQ09VTlQiLCJNSU5fVkFMVUUiLCJXSURFX0JBUl9USFJFU0hPTEQiLCJNQVhfU1BBQ0VfVkFSSUFOQ0UiLCJNQVhfTkFSUk9XX0JBUl9WQVJJQU5DRSIsIlBoYXJtYWNvZGVSZWFkZXIiLCJiYXJTdGFydCIsImJhckVuZCIsInF1aWV0Wm9uZVN0YXJ0IiwiX2V4dHJhY3RCYXJzQW5kU3BhY2VzIiwic3RhcnRQb3MiLCJiYXJzIiwic3BhY2VzIiwiaXNCYXIiLCJjdXJyZW50V2lkdGgiLCJhdmdTcGFjZSIsIl92YWxpZGF0ZVNwYWNlcyIsIm1lYW4iLCJ2YXJpYW5jZSIsInBvdyIsInN0ZERldiIsImN2IiwiX2RlY29kZUJhcnMiLCJuYXJyb3dCYXJzIiwibmFycm93TWVhbiIsIm5hcnJvd1ZhcmlhbmNlIiwidyIsIm5hcnJvd0N2IiwiaXNXaWRlIiwiZXh0cmFjdGVkIiwiZGVjb2RlZCIsImF2Z0JhcldpZHRoIiwidG9TdHJpbmciLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwiX2NvbnZlcnRUb1VQQ0EiLCJ1cGNhIiwibGFzdERpZ2l0IiwiVVBDUmVhZGVyIiwiY2hhckF0Iiwic3Vic3RyaW5nIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJESVIiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJyZWFkIiwiZGVsdGFYIiwiZGVsdGFZIiwieVN0ZXAiLCJ0b0JpbmFyeUxpbmUiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiZGlyIiwiclRocmVzaG9sZCIsImRlYnVnIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInBoYXJtYWNvZGVfcmVhZGVyIiwicmVnaXN0ZXJSZWFkZXIiLCJuYW1lIiwicmVhZGVyIiwiaW5wdXRJbWFnZVdyYXBwZXIiLCJfY2FudmFzIiwiZnJlcXVlbmN5IiwiZG9tIiwiX2JhcmNvZGVSZWFkZXJzIiwiaW5pdENhbnZhcyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIl9jb25maWckZGVidWciLCIkZGVidWciLCJxdWVyeVNlbGVjdG9yIiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJwcmludFJlYWRlckluZm8iLCJfY29uZmlnJGRlYnVnMyIsInJlYWRlcnMiLCJyZWFkZXJDb25maWciLCJfY29uZmlnJGRlYnVnMiIsImNvbmZpZ3VyYXRpb24iLCJfdHlwZW9mIiwicmVhZGVyT2JqIiwiSlNPTiIsInN0cmluZ2lmeSIsInZpcyIsIm5vZGUiLCJwcm9wIiwic2hvd0ZyZXF1ZW5jeSIsInNob3dQYXR0ZXJuIiwiZGlzcGxheSIsImdldEV4dGVuZGVkTGluZSIsImFuZ2xlIiwiZXh0IiwiZXh0ZW5kTGluZSIsImFtb3VudCIsImV4dGVuc2lvbiIsImdldExpbmUiLCJib3giLCJ0cnlEZWNvZGUiLCJiYXJjb2RlTGluZSIsIkltYWdlRGVidWciLCJjb2RlUmVzdWx0IiwidHJ5RGVjb2RlQnJ1dGVGb3JjZSIsImxpbmVBbmdsZSIsInNpZGVMZW5ndGgiLCJzbGljZXMiLCJ4ZGlyIiwieWRpciIsImdldExpbmVMZW5ndGgiLCJkZWNvZGVGcm9tSW1hZ2UiLCJfeCIsIl9kZWNvZGVGcm9tSW1hZ2UiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJtYXJrIiwiX2NhbGxlZTIiLCJfaXRlcmF0b3IiLCJfc3RlcCIsIl90Iiwid3JhcCIsIl9jb250ZXh0MiIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwic2VudCIsImFicnVwdCIsImUiLCJmIiwiZmluaXNoIiwic3RvcCIsImRlY29kZUZyb21Cb3VuZGluZ0JveCIsImRyYXdCb3VuZGluZ0JveCIsImxpbmVMZW5ndGgiLCJhdGFuMiIsImRyYXdTY2FubGluZSIsImRlY29kZUZyb21Cb3VuZGluZ0JveGVzIiwiYm94ZXMiLCJiYXJjb2RlcyIsIm11bHRpcGxlIiwiaW1hZ2VXcmFwcGVySW4iLCJfY2FsbGVlIiwiX2NvbnRleHQiLCJzZXRSZWFkZXJzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudHMiLCJnZXRFdmVudCIsImV2ZW50TmFtZSIsInN1YnNjcmliZXJzIiwiY2xlYXJFdmVudHMiLCJwdWJsaXNoU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiYXN5bmMiLCJfc3Vic2NyaWJlIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwiZmlsdGVyIiwic3Vic2NyaWJlciIsIm9uY2UiLCJ1bnN1YnNjcmliZSIsIkV4Y2VwdGlvbiIsIl9FcnJvciIsInNldFByb3RvdHlwZU9mIiwiX3dyYXBOYXRpdmVTdXBlciIsIkVSUk9SX0RFU0MiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiUHJvbWlzZSIsInJlamVjdCIsImdldFVzZXJNZWRpYSIsImNvbnN0cmFpbnRzIiwic3RyZWFtUmVmIiwid2FpdEZvclZpZGVvIiwidmlkZW8iLCJyZXNvbHZlIiwiYXR0ZW1wdHMiLCJjaGVja1ZpZGVvIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiaW5pdENhbWVyYSIsIl94MiIsIl9pbml0Q2FtZXJhIiwiX2NhbGxlZTQiLCJzdHJlYW0iLCJfY29udGV4dDQiLCJzZXRBdHRyaWJ1dGUiLCJzcmNPYmplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwicGxheSIsImRlcHJlY2F0ZWRDb25zdHJhaW50cyIsInZpZGVvQ29uc3RyYWludHMiLCJvbWl0IiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiX3gzIiwiX2VudW1lcmF0ZVZpZGVvRGV2aWNlcyIsIl9jYWxsZWU1IiwiZGV2aWNlcyIsInZpZGVvRGV2aWNlcyIsImNvbnN0cmFpbmVkRGV2aWNlcyIsInByb2Nlc3NlZENvbnN0cmFpbnRzIiwiXyIsImNvbnN0cmFpbnRzV2l0aG91dERldmljZUlkIiwiZGV2aWNlIiwiX3QzIiwiX3Q0IiwiX2NvbnRleHQ1IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwiZXhhY3QiLCJnZXRUcmFja3MiLCJ0cmFjayIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJnZXRBY3RpdmVTdHJlYW0iLCJfc3RyZWFtUmVmIiwiUXVhZ2dhSlNDYW1lcmFBY2Nlc3MiLCJyZXF1ZXN0ZWRWaWRlb0VsZW1lbnQiLCJyZXF1ZXN0IiwibmV3Q29uc3RyYWludHMiLCJyZWxlYXNlIiwicGF1c2UiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsImRpc2FibGVUb3JjaCIsImFwcGx5Q29uc3RyYWludHMiLCJhZHZhbmNlZCIsInRvcmNoIiwiT3ZlcmNvbnN0cmFpbmVkRXJyb3IiLCJlbmFibGVUb3JjaCIsIl9jYWxsZWUzIiwiX3QyIiwiX2NvbnRleHQzIiwiY29udGFpbnMiLCJzb21lIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJfY29uZmlnJGNhcGFjaXR5Iiwid2lsbFJlYWRGcmVxdWVudGx5IiwicmVzdWx0cyIsImNhcGFjaXR5IiwiY2FwdHVyZSIsIm1hdGNoZXNDb25zdHJhaW50cyIsImJsYWNrbGlzdCIsImFkZFJlc3VsdCIsImltYWdlU2l6ZSIsInRvRGF0YVVSTCIsImdldFJlc3VsdHMiLCJEZXZDb25maWciLCJpbnB1dFN0cmVhbSIsInR5cGUiLCJzaG93SW1hZ2VEZXRhaWxzIiwibG9jYXRlIiwiY3JlYXRlT3ZlcmxheSIsImRlY29kZXIiLCJsb2NhdG9yIiwic2hvd0NhbnZhcyIsInNob3dQYXRjaGVzIiwic2hvd0ZvdW5kUGF0Y2hlcyIsInNob3dTa2VsZXRvbiIsInNob3dMYWJlbHMiLCJzaG93UGF0Y2hMYWJlbHMiLCJzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMiLCJzaG93UGF0Y2hTaXplIiwiYm94RnJvbVBhdGNoZXMiLCJzaG93VHJhbnNmb3JtZWQiLCJzaG93VHJhbnNmb3JtZWRCb3giLCJzaG93QkIiLCJOb2RlQ29uZmlnIiwic2VxdWVuY2UiLCJQcm9kQ29uZmlnIiwiRXhwb3J0Q29uZmlnIiwiUXVhZ2dhQ29uZmlnIiwiVE9fUkFESUFOUyIsImFkanVzdENhbnZhc1NpemUiLCJ0YXJnZXRTaXplIiwiRnJhbWVHcmFiYmVyIiwiX3N0cmVhbUNvbmZpZyRkZWJ1ZyIsIl9zdHJlYW1Db25maWckZGVidWcyIiwiX3RoYXQiLCJfc3RyZWFtQ29uZmlnIiwiZ2V0Q29uZmlnIiwiX3ZpZGVvU2l6ZSIsImdldFJlYWxXaWR0aCIsImdldFJlYWxIZWlnaHQiLCJfY2FudmFzU2l6ZSIsImdldENhbnZhc1NpemUiLCJfc2l6ZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwidG9wUmlnaHQiLCJnZXRUb3BSaWdodCIsIl9zeCIsIl9zeSIsIl9jdHgiLCJfZGF0YSIsInZpZGVvU2l6ZSIsImNhbnZhc1NpemUiLCJhdHRhY2hEYXRhIiwiZ2V0RGF0YSIsImJpbGluZWFySW50ZXJwb2xhdGUiLCJncmF5RGF0YSIsImZ4IiwiZnkiLCJ2MDAiLCJ2MTAiLCJ2MDEiLCJ2MTEiLCJ2MCIsInYxIiwiZ3JhYiIsImRvSGFsZlNhbXBsZSIsImdldEZyYW1lIiwiZHJhd2FibGUiLCJkcmF3QW5nbGUiLCJ0YWdzIiwib3JpZW50YXRpb24iLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJ0ZW1wQ2FudmFzIiwidGVtcEN0eCIsIm9yaWdpbmFsSW1hZ2VEYXRhIiwic2NhbGVkR3JheURhdGEiLCJzdGVwU2l6ZVgiLCJzdGVwU2l6ZVkiLCJzcmNYIiwic3JjWSIsInNyY0lkeCIsImdldFNpemUiLCJFeGlmVGFncyIsIkF2YWlsYWJsZVRhZ3MiLCJmaW5kVGFnc0luT2JqZWN0VVJMIiwib2JqZWN0VVJMVG9CbG9iIiwidGhlbiIsInJlYWRUb0J1ZmZlciIsImJ1ZmZlciIsImZpbmRUYWdzSW5CdWZmZXIiLCJiYXNlNjRUb0FycmF5QnVmZmVyIiwiZGF0YVVybCIsImJhc2U2NCIsImJpbmFyeSIsImF0b2IiLCJsZW4iLCJBcnJheUJ1ZmZlciIsInZpZXciLCJibG9iIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInVybCIsImh0dHAiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInN0YXR1cyIsInJlc3BvbnNlIiwib25lcnJvciIsInNlbmQiLCJmaWxlIiwic2VsZWN0ZWRUYWdzIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImJ5dGVMZW5ndGgiLCJleGlmVGFncyIsInNlbGVjdGVkVGFnIiwiZXhpZlRhZyIsInRhZyIsIm1hcmtlciIsImdldFVpbnQ4IiwicmVhZEVYSUZEYXRhIiwiZ2V0VWludDE2IiwiZ2V0U3RyaW5nRnJvbUJ1ZmZlciIsInRpZmZPZmZzZXQiLCJiaWdFbmQiLCJmaXJzdElGRE9mZnNldCIsImdldFVpbnQzMiIsInJlYWRUYWdzIiwidGlmZlN0YXJ0IiwiZGlyU3RhcnQiLCJzdHJpbmdzIiwiZW50cmllcyIsImVudHJ5T2Zmc2V0IiwicmVhZFRhZ1ZhbHVlIiwibnVtVmFsdWVzIiwib3V0c3RyIiwiZ2VuZXJhdGVJbWFnZUZpbGVuYW1lIiwiZGlyZWN0b3J5IiwibnVtIiwicGFkU3RhcnQiLCJJbWFnZUxvYWRlciIsImxvYWQiLCJodG1sSW1hZ2VzU3JjQXJyYXkiLCJodG1sSW1hZ2VzQXJyYXkiLCJub3RMb2FkZWQiLCJhZGRJbWFnZSIsImltYWdlIiwibG9hZGVkIiwibG9hZGVkSW1nIiwibm90bG9hZGVkSW1ncyIsImltZ05hbWUiLCJlbmNvZGVVUkkiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsImFkZE9ubG9hZEhhbmRsZXIiLCJpbnB1dFN0cmVhbUZhY3RvcnkiLCJjcmVhdGVWaWRlb1N0cmVhbSIsIl9jb25maWciLCJfZXZlbnROYW1lcyIsIl9ldmVudEhhbmRsZXJzIiwiX2NhbGN1bGF0ZWRXaWR0aCIsIl9jYWxjdWxhdGVkSGVpZ2h0IiwiX3RvcFJpZ2h0IiwiaW5pdFNpemUiLCJfY29uZmlnMiIsIl9jb25maWczIiwic2V0V2lkdGgiLCJzZXRIZWlnaHQiLCJzZXRJbnB1dFN0cmVhbSIsImVuZGVkIiwic2V0Q3VycmVudFRpbWUiLCJ0aW1lIiwiX2NvbmZpZzQiLCJib29sIiwiY2xlYXJFdmVudEhhbmRsZXJzIiwiaGFuZGxlcnMiLCJoYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRyaWdnZXIiLCJzZXRUb3BSaWdodCIsInNldENhbnZhc1NpemUiLCJjcmVhdGVMaXZlU3RyZWFtIiwiY3JlYXRlSW1hZ2VTdHJlYW0iLCJmcmFtZUlkeCIsInBhdXNlZCIsImltZ0FycmF5IiwiYmFzZVVybCIsImNhbGN1bGF0ZWRXaWR0aCIsImNhbGN1bGF0ZWRIZWlnaHQiLCJsb2FkSW1hZ2VzIiwiX2NvbmZpZzciLCJpbWdzIiwiX2NvbmZpZzUiLCJfY29uZmlnNiIsInB1Ymxpc2hFdmVudCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiaW5kIiwiX2ltZ0FycmF5Iiwic2VhcmNoRGlyZWN0aW9ucyIsImxhYmVsV3JhcHBlciIsImxhYmVsRGF0YSIsImVkZ2VsYWJlbCIsImN5IiwiY3giLCJ2ZXJ0ZXgyRCIsImNvbnRvdXJUcmFjaW5nIiwiRnYiLCJDdiIsIlAiLCJsZGlyIiwidG90YWxQaXhlbENvdW50IiwicGl4ZWxDb3VudGVyIiwiUmFzdGVyaXplciIsImNyZWF0ZUNvbnRvdXIyRCIsImZpcnN0VmVydGV4IiwiaW5zaWRlQ29udG91cnMiLCJuZXh0cGVlciIsInByZXZwZWVyIiwiQ09OVE9VUl9ESVIiLCJDV19ESVIiLCJDQ1dfRElSIiwiVU5LTk9XTl9ESVIiLCJPVVRTSURFX0VER0UiLCJJTlNJREVfRURHRSIsInRyYWNlciIsInJhc3Rlcml6ZSIsImRlcHRobGFiZWwiLCJiYyIsImxjIiwibGFiZWxpbmRleCIsImNvbG9yTWFwIiwidmVydGV4IiwiY2MiLCJzYyIsImNvbm5lY3RlZENvdW50IiwiZHJhd0NvbnRvdXIiLCJmaXJzdENvbnRvdXIiLCJwcSIsImlxIiwicSIsIlNrZWxldG9uaXplciIsInN0ZGxpYiIsImZvcmVpZ24iLCJpbWFnZXMiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJza2VsZXRvbml6ZSIsInN1YkltYWdlUHRyIiwiZXJvZGVkSW1hZ2VQdHIiLCJ0ZW1wSW1hZ2VQdHIiLCJza2VsSW1hZ2VQdHIiLCJfY3VycmVudEltYWdlV3JhcHBlciIsIl9za2VsSW1hZ2VXcmFwcGVyIiwiX3N1YkltYWdlV3JhcHBlciIsIl9sYWJlbEltYWdlV3JhcHBlciIsIl9wYXRjaEdyaWQiLCJfcGF0Y2hMYWJlbEdyaWQiLCJfaW1hZ2VUb1BhdGNoR3JpZCIsIl9iaW5hcnlJbWFnZVdyYXBwZXIiLCJfcGF0Y2hTaXplIiwiX2NhbnZhc0NvbnRhaW5lciIsIl9udW1QYXRjaGVzIiwiX2lucHV0SW1hZ2VXcmFwcGVyIiwiX3NrZWxldG9uaXplciIsImluaXRCdWZmZXJzIiwic2tlbGV0b25JbWFnZURhdGFTaXplIiwiYnVmZmVyU2l6ZSIsImxvZzIiLCJza2VsZXRvbkltYWdlRGF0YSIsInNrZWxldG9uaXplciIsInVzZVdvcmtlciIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJtYXQyIiwiY29weSIsInRyYW5zZm9ybU1hdDIiLCJpbnZlcnQiLCJiaW5hcml6ZUltYWdlIiwiZmluZFBhdGNoZXMiLCJwYXRjaGVzRm91bmQiLCJyYXN0ZXJpemVyIiwicmFzdGVyUmVzdWx0IiwiZGVzY3JpYmVQYXRjaCIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsInNvcnQiLCJlbCIsImZpbmRCb3hlcyIsInNpbWlsYXJNb21lbnRzIiwidG9wQ2x1c3RlciIsInBhdGNoUG9zIiwiZWxpZ2libGVNb21lbnRzIiwibWF0Y2hpbmdNb21lbnRzIiwibWluQ29tcG9uZW50V2VpZ2h0IiwiX21hdGNoaW5nTW9tZW50cyRrJHJhIiwiX21hdGNoaW5nTW9tZW50cyRrIiwicmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkiLCJjdXJySWR4Iiwibm90WWV0UHJvY2Vzc2VkIiwiY3VycmVudElkeCIsImN1cnJlbnRQYXRjaCIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsInRoaXNIYWxmU2FtcGxlIiwiUXVhZ2dhQ29udGV4dCIsIkNhbnZhc0NvbnRhaW5lciIsIkNhbnZhc0luZm8iLCJnZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJub2RlVHlwZSIsInNlbGVjdG9yIiwiYm94U2l6ZSIsIkJhcmNvZGVMb2NhdG9yIiwiZmluZE9yQ3JlYXRlQ2FudmFzIiwiZ2V0Q2FudmFzQW5kQ29udGV4dCIsIm9wdGlvbnMiLCJfb3B0aW9ucyRkZWJ1ZyIsImluaXRDYW52YXNlcyIsIm92ZXJsYXlSZXN1bHQiLCJfY29udGV4dCRjb25maWciLCJfY29udGV4dCRjb25maWckaW5wdXQiLCJfY29udGV4dCRjb25maWcyIiwiX2NvbnRleHQkY29uZmlnMiRpbnB1IiwiX2NvbnRleHQkY29uZmlnMyIsIl9jb250ZXh0JGNvbmZpZzMkY2FudiIsIl9jb250ZXh0JGNvbmZpZzQiLCJfY29udGV4dCRjb25maWc0JGlucHUiLCJfY29udGV4dCRjb25maWc1IiwiX2NvbnRleHQkY29uZmlnNSRsb2NhIiwidmlld3BvcnQiLCJjb250YWluZXIiLCJ3b3JrZXJQb29sIiwidXBkYXRlV29ya2VycyIsImZyYW1lR3JhYmJlciIsImF2YWlsYWJsZVdvcmtlciIsIndvcmtlclRocmVhZCIsImJ1c3kiLCJ3b3JrZXIiLCJwb3N0TWVzc2FnZSIsImNtZCIsImNvbmZpZ0ZvcldvcmtlciIsIndvcmtlckludGVyZmFjZSIsImZhY3RvcnkiLCJRdWFnZ2EiLCJtZXNzYWdlIiwib25Qcm9jZXNzZWQiLCJ3b3JrZXJJbnRlcmZhY2VSZWFkeSIsIm9ubWVzc2FnZSIsIm51bU9mV29ya2VycyIsImdlbmVyYXRlV29ya2VyQmxvYiIsImZhY3RvcnlTb3VyY2UiLCJfX2ZhY3RvcnlTb3VyY2VfXyIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJpbml0V29ya2VyIiwiY2IiLCJibG9iVVJMIiwiV29ya2VyIiwicmV2b2tlT2JqZWN0VVJMIiwicHVibGlzaFJlc3VsdCIsImFkanVzdFdvcmtlclBvb2wiLCJpbmNyZWFzZUJ5Iiwid29ya2Vyc1RvVGVybWluYXRlIiwidGVybWluYXRlIiwid29ya2VySW5pdGlhbGl6ZWQiLCJzZXR1cElucHV0U3RyZWFtIiwibW92ZUJveCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyIiwibW92ZUxpbmUiLCJfdGhpcyRjb250ZXh0JGNvbmZpZyIsImluaXRBYm9ydGVkIiwiZnJhbWVncmFiYmVyIiwiY2FudmFzQ29udGFpbmVyIiwiUVdvcmtlcnMiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzIiLCJpbml0aWFsaXplRGF0YSIsInJlYWR5Iiwib25VSVRocmVhZCIsIndvcmtlcnNVcGRhdGVkIiwiX3RoaXMkY29udGV4dCRpbnB1dEltIiwibG9jYXRlQW5kRGVjb2RlIiwiX3RoaXMkY29udGV4dCRpbnB1dEltMiIsIl9pbml0QnVmZmVyczIiLCJfaW5pdEJ1ZmZlcnMiLCJCYXJjb2RlRGVjb2RlciIsIl9nZXRWaWV3UG9ydCIsIl9pbml0Q2FudmFzIiwiaW5pdElucHV0U3RyZWFtIiwiX3RoaXMkY29udGV4dCRjb25maWckIiwiaW5wdXRUeXBlIiwiX3NldHVwSW5wdXRTdHJlYW0iLCJJbnB1dFN0cmVhbSIsIkNhbWVyYUFjY2VzcyIsImNhblJlY29yZCIsImJpbmQiLCJnZXRCb3VuZGluZ0JveGVzIiwiX3RoaXMkY29udGV4dCRjb25maWczIiwidHJhbnNmb3JtUmVzdWx0IiwidHJhbnNmb3JtZWRCb3hlcyIsIlNldCIsImJhcmNvZGUiLCJoYXMiLCJfdGhpczMiLCJyZXN1bHRDb2xsZWN0b3IiLCJoYXNDb2RlUmVzdWx0IiwiX2NmZyRpbnB1dFN0cmVhbSIsInJlc3VsdFRvUHVibGlzaCIsIl9yZXN1bHQkYmFyY29kZXMiLCJFdmVudHMiLCJjZmciLCJkcmF3U2Nhbm5lckFyZWEiLCJfbG9jYXRlQW5kRGVjb2RlIiwiX3RoaXMkY29udGV4dCRpbnB1dEltMyIsImRlY29kZVJlc3VsdCIsImltYWdlUmVzdWx0IiwiX3RoaXMkY29udGV4dCRpbnB1dEltNCIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsIl90aGlzJGNvbnRleHQkY29uZmlnNCIsIl90aGlzNCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwibm93IiwiX3RoaXMkY29udGV4dCRjb25maWc1IiwiX3RoaXMkY29udGV4dCRjb25maWc2IiwiX3N0b3AiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzciLCJfdGhpcyRjb250ZXh0JGlucHV0U3QiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzgiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzkiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzAiLCJvdmVybGF5Q3R4IiwiaGFzQW55U3R5bGUiLCJib3JkZXJDb2xvciIsImJvcmRlcldpZHRoIiwiYmFja2dyb3VuZENvbG9yIiwidG9wUmlnaHRPZmZzZXQiLCJvZmZzZXRZIiwidG9wTGVmdCIsImJvdHRvbUxlZnQiLCJzdHlsZUNoYW5nZWQiLCJfY2FjaGVkU3R5bGVWYWx1ZXMiLCJfYXJlYSRib3JkZXJDb2xvciIsIl9hcmVhJGJvcmRlcldpZHRoIiwic2hvdWxkRHJhd0JvcmRlciIsImJnIiwiX3Jlc29sdmVkU3R5bGUiLCJpbnN0YW5jZSIsIlF1YWdnYUpTU3RhdGljSW50ZXJmYWNlIiwicXVhZ2dhSW5zdGFuY2UiLCJwcm9taXNlIiwiQ29uZmlnIiwic3RhcnRFcnIiLCJvbkRldGVjdGVkIiwib2ZmRGV0ZWN0ZWQiLCJvZmZQcm9jZXNzZWQiLCJyZWdpc3RlclJlc3VsdENvbGxlY3RvciIsImRlY29kZVNpbmdsZSIsInJlc3VsdENhbGxiYWNrIiwiZGVmYXVs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QyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUN4QjtJQUFBMUgsd0JBQUEsQ0FBQTBILEtBQUEsdUJBQ2UsSUFBSTtJQUFBMUgsd0JBQUEsQ0FBQTBILEtBQUEsb0JBQ1As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TUFBTSxFQUFLO1lBQ2pDb3JDLGNBQWMsQ0FBQ3ZsQixJQUFJLENBQUMsQ0FBQztZQUNyQixJQUFJZ21CLGNBQWMsRUFBRTtjQUNoQkEsY0FBYyxDQUFDMXpDLElBQUksQ0FBQyxJQUFJLEVBQUU2SCxNQUFNLENBQUM7WUFDckM7WUFDQTJvQixPQUFPLENBQUMzb0IsTUFBTSxDQUFDO1VBQ25CLENBQUMsRUFBRSxJQUFJLENBQUM7VUFDUm9yQyxjQUFjLENBQUNsOUIsS0FBSyxDQUFDLENBQUM7UUFDMUIsQ0FBQyxFQUFFLElBQUksRUFBRWs5QixjQUFjLENBQUM7TUFDNUIsQ0FBQyxDQUFDLE9BQU8xd0IsR0FBRyxFQUFFO1FBQ1YyTixNQUFNLENBQUMzTixHQUFHLENBQUM7TUFDZjtJQUNKLENBQUMsQ0FBQztFQUNOLENBQUM7RUFDRDtFQUNBO0VBQ0EsSUFBSW94QixPQUFPQSxDQUFBLEVBQUc7SUFDVixPQUFPWCx1QkFBdUI7RUFDbEMsQ0FBQztFQUNEWSxPQUFPLEVBQVBBLHNCQUFPO0VBQ1B0RSxZQUFZLEVBQVpBLGFBQVk7RUFDWnZqQixVQUFVLEVBQVZBLFdBQVU7RUFDVmxiLFlBQVksRUFBWkEsYUFBWTtFQUNaZ2pDLGVBQWUsRUFBZkEsZ0JBQWVBO0FBQ25CLENBQUM7QUFFY2IsbUdBQXVCLEVBQUM7QUFDdkMiLCJmaWxlIjoicXVhZ2dhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlF1YWdnYVwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA5MCk7XG4iLCJ2YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoXCIuL3RvUHJvcGVydHlLZXkuanNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF9nZXRQcm90b3R5cGVPZih0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2ssIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoXCIuL3RvUHJvcGVydHlLZXkuanNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCIpO1xuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSBfdHlwZW9mKGUpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfVxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGUgJiYgc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8vIFRPRE8oQmFiZWwgOCk6IFJlbW92ZSB0aGlzIGZpbGUuXG5cbnZhciBydW50aW1lID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvcmVnZW5lcmF0b3JSdW50aW1lXCIpKCk7XG5tb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG5cbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vcGFja2FnZXMvcnVudGltZS9ydW50aW1lLmpzI0w3MzY9XG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChuLCB0LCBlLCByLCBvLCBhLCBjKSB7XG4gIHRyeSB7XG4gICAgdmFyIGkgPSBuW2FdKGMpLFxuICAgICAgdSA9IGkudmFsdWU7XG4gIH0gY2F0Y2ggKG4pIHtcbiAgICByZXR1cm4gdm9pZCBlKG4pO1xuICB9XG4gIGkuZG9uZSA/IHQodSkgOiBQcm9taXNlLnJlc29sdmUodSkudGhlbihyLCBvKTtcbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IHRoaXMsXG4gICAgICBlID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAociwgbykge1xuICAgICAgdmFyIGEgPSBuLmFwcGx5KHQsIGUpO1xuICAgICAgZnVuY3Rpb24gX25leHQobikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIG4pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3Rocm93KG4pIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgbik7XG4gICAgICB9XG4gICAgICBfbmV4dCh2b2lkIDApO1xuICAgIH0pO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xuZnVuY3Rpb24gX2dldCgpIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQgPyBSZWZsZWN0LmdldC5iaW5kKCkgOiBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgIHZhciBwID0gc3VwZXJQcm9wQmFzZShlLCB0KTtcbiAgICBpZiAocCkge1xuICAgICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIHQpO1xuICAgICAgcmV0dXJuIG4uZ2V0ID8gbi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IGUgOiByKSA6IG4udmFsdWU7XG4gICAgfVxuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF9nZXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2dldCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKHIpIHx8IGl0ZXJhYmxlVG9BcnJheShyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBhcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZShcIi4vdG9QcmltaXRpdmUuanNcIik7XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cbm1vZHVsZS5leHBvcnRzID0gdG9Qcm9wZXJ0eUtleSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9PdmVybG9hZFlpZWxkKGUsIGQpIHtcbiAgdGhpcy52ID0gZSwgdGhpcy5rID0gZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX092ZXJsb2FkWWllbGQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgcmVnZW5lcmF0b3JEZWZpbmUgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckRlZmluZS5qc1wiKTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvcigpIHtcbiAgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9ibG9iL21haW4vcGFja2FnZXMvYmFiZWwtaGVscGVycy9MSUNFTlNFICovXG4gIHZhciBlLFxuICAgIHQsXG4gICAgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sXG4gICAgbiA9IHIuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsXG4gICAgbyA9IHIudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gIGZ1bmN0aW9uIGkociwgbiwgbywgaSkge1xuICAgIHZhciBjID0gbiAmJiBuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG4gOiBHZW5lcmF0b3IsXG4gICAgICB1ID0gT2JqZWN0LmNyZWF0ZShjLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yRGVmaW5lKHUsIFwiX2ludm9rZVwiLCBmdW5jdGlvbiAociwgbiwgbykge1xuICAgICAgdmFyIGksXG4gICAgICAgIGMsXG4gICAgICAgIHUsXG4gICAgICAgIGYgPSAwLFxuICAgICAgICBwID0gbyB8fCBbXSxcbiAgICAgICAgeSA9ICExLFxuICAgICAgICBHID0ge1xuICAgICAgICAgIHA6IDAsXG4gICAgICAgICAgbjogMCxcbiAgICAgICAgICB2OiBlLFxuICAgICAgICAgIGE6IGQsXG4gICAgICAgICAgZjogZC5iaW5kKGUsIDQpLFxuICAgICAgICAgIGQ6IGZ1bmN0aW9uIGQodCwgcikge1xuICAgICAgICAgICAgcmV0dXJuIGkgPSB0LCBjID0gMCwgdSA9IGUsIEcubiA9IHIsIGE7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgZnVuY3Rpb24gZChyLCBuKSB7XG4gICAgICAgIGZvciAoYyA9IHIsIHUgPSBuLCB0ID0gMDsgIXkgJiYgZiAmJiAhbyAmJiB0IDwgcC5sZW5ndGg7IHQrKykge1xuICAgICAgICAgIHZhciBvLFxuICAgICAgICAgICAgaSA9IHBbdF0sXG4gICAgICAgICAgICBkID0gRy5wLFxuICAgICAgICAgICAgbCA9IGlbMl07XG4gICAgICAgICAgciA+IDMgPyAobyA9IGwgPT09IG4pICYmICh1ID0gaVsoYyA9IGlbNF0pID8gNSA6IChjID0gMywgMyldLCBpWzRdID0gaVs1XSA9IGUpIDogaVswXSA8PSBkICYmICgobyA9IHIgPCAyICYmIGQgPCBpWzFdKSA/IChjID0gMCwgRy52ID0gbiwgRy5uID0gaVsxXSkgOiBkIDwgbCAmJiAobyA9IHIgPCAzIHx8IGlbMF0gPiBuIHx8IG4gPiBsKSAmJiAoaVs0XSA9IHIsIGlbNV0gPSBuLCBHLm4gPSBsLCBjID0gMCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvIHx8IHIgPiAxKSByZXR1cm4gYTtcbiAgICAgICAgdGhyb3cgeSA9ICEwLCBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvLCBwLCBsKSB7XG4gICAgICAgIGlmIChmID4gMSkgdGhyb3cgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgZm9yICh5ICYmIDEgPT09IHAgJiYgZChwLCBsKSwgYyA9IHAsIHUgPSBsOyAodCA9IGMgPCAyID8gZSA6IHUpIHx8ICF5Oykge1xuICAgICAgICAgIGkgfHwgKGMgPyBjIDwgMyA/IChjID4gMSAmJiAoRy5uID0gLTEpLCBkKGMsIHUpKSA6IEcubiA9IHUgOiBHLnYgPSB1KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAyLCBpKSB7XG4gICAgICAgICAgICAgIGlmIChjIHx8IChvID0gXCJuZXh0XCIpLCB0ID0gaVtvXSkge1xuICAgICAgICAgICAgICAgIGlmICghKHQgPSB0LmNhbGwoaSwgdSkpKSB0aHJvdyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXQuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgdSA9IHQudmFsdWUsIGMgPCAyICYmIChjID0gMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSAxID09PSBjICYmICh0ID0gaVtcInJldHVyblwiXSkgJiYgdC5jYWxsKGkpLCBjIDwgMiAmJiAodSA9IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbyArIFwiJyBtZXRob2RcIiksIGMgPSAxKTtcbiAgICAgICAgICAgICAgaSA9IGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0ID0gKHkgPSBHLm4gPCAwKSA/IHUgOiByLmNhbGwobiwgRykpICE9PSBhKSBicmVhaztcbiAgICAgICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgICAgICBpID0gZSwgYyA9IDEsIHUgPSB0O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBmID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgICBkb25lOiB5XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0ociwgbywgaSksICEwKSwgdTtcbiAgfVxuICB2YXIgYSA9IHt9O1xuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cbiAgdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIGMgPSBbXVtuXSA/IHQodChbXVtuXSgpKSkgOiAocmVnZW5lcmF0b3JEZWZpbmUodCA9IHt9LCBuLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgdCksXG4gICAgdSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGMpO1xuICBmdW5jdGlvbiBmKGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChlLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCByZWdlbmVyYXRvckRlZmluZShlLCBvLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHUpLCBlO1xuICB9XG4gIHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSksIHJlZ2VuZXJhdG9yRGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIsIHJlZ2VuZXJhdG9yRGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBvLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCByZWdlbmVyYXRvckRlZmluZSh1KSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgbywgXCJHZW5lcmF0b3JcIiksIHJlZ2VuZXJhdG9yRGVmaW5lKHUsIG4sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIHJlZ2VuZXJhdG9yRGVmaW5lKHUsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgKG1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3OiBpLFxuICAgICAgbTogZlxuICAgIH07XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cykoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX3JlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIG4sIHQpIHtcbiAgdmFyIGkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHRyeSB7XG4gICAgaSh7fSwgXCJcIiwge30pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JEZWZpbmUgPSBmdW5jdGlvbiByZWdlbmVyYXRvckRlZmluZShlLCByLCBuLCB0KSB7XG4gICAgZnVuY3Rpb24gbyhyLCBuKSB7XG4gICAgICBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShyLCBuLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByID8gaSA/IGkoZSwgciwge1xuICAgICAgdmFsdWU6IG4sXG4gICAgICBlbnVtZXJhYmxlOiAhdCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIXQsXG4gICAgICB3cml0YWJsZTogIXRcbiAgICB9KSA6IGVbcl0gPSBuIDogKG8oXCJuZXh0XCIsIDApLCBvKFwidGhyb3dcIiwgMSksIG8oXCJyZXR1cm5cIiwgMikpO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBuLCB0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yRGVmaW5lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHJlZ2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3IuanNcIik7XG52YXIgcmVnZW5lcmF0b3JBc3luY0l0ZXJhdG9yID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3JBc3luY0l0ZXJhdG9yLmpzXCIpO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yQXN5bmNHZW4ociwgZSwgdCwgbywgbikge1xuICByZXR1cm4gbmV3IHJlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvcihyZWdlbmVyYXRvcigpLncociwgZSwgdCwgbyksIG4gfHwgUHJvbWlzZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvckFzeW5jR2VuLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIE92ZXJsb2FkWWllbGQgPSByZXF1aXJlKFwiLi9PdmVybG9hZFlpZWxkLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yRGVmaW5lID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3JEZWZpbmUuanNcIik7XG5mdW5jdGlvbiBBc3luY0l0ZXJhdG9yKHQsIGUpIHtcbiAgZnVuY3Rpb24gbihyLCBvLCBpLCBmKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBjID0gdFtyXShvKSxcbiAgICAgICAgdSA9IGMudmFsdWU7XG4gICAgICByZXR1cm4gdSBpbnN0YW5jZW9mIE92ZXJsb2FkWWllbGQgPyBlLnJlc29sdmUodS52KS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIG4oXCJuZXh0XCIsIHQsIGksIGYpO1xuICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgbihcInRocm93XCIsIHQsIGksIGYpO1xuICAgICAgfSkgOiBlLnJlc29sdmUodSkudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICBjLnZhbHVlID0gdCwgaShjKTtcbiAgICAgIH0sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuKFwidGhyb3dcIiwgdCwgaSwgZik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBmKHQpO1xuICAgIH1cbiAgfVxuICB2YXIgcjtcbiAgdGhpcy5uZXh0IHx8IChyZWdlbmVyYXRvckRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIHJlZ2VuZXJhdG9yRGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBhc3luY0l0ZXJhdG9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSkpLCByZWdlbmVyYXRvckRlZmluZSh0aGlzLCBcIl9pbnZva2VcIiwgZnVuY3Rpb24gKHQsIG8sIGkpIHtcbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgcmV0dXJuIG5ldyBlKGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgIG4odCwgaSwgZSwgcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHIgPSByID8gci50aGVuKGYsIGYpIDogZigpO1xuICB9LCAhMCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jSXRlcmF0b3IsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXMuanNcIik7XG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiKTtcbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiKTtcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKHIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gcmVxdWlyZShcIi4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiKTtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7XG4gIGlmIChudWxsID09IGUpIHJldHVybiB7fTtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBpID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCAtMSA9PT0gdC5pbmRleE9mKG8pICYmIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKSxcbiAgICBiYXNlVW5zZXQgPSByZXF1aXJlKCcuL19iYXNlVW5zZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjdXN0b21PbWl0Q2xvbmUgPSByZXF1aXJlKCcuL19jdXN0b21PbWl0Q2xvbmUnKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0JyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYic6ICcyJyB9XG4gKi9cbnZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgIHJldHVybiBwYXRoO1xuICB9KTtcbiAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICB9XG4gIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuIiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcbnZhciBpc05hdGl2ZUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vaXNOYXRpdmVGdW5jdGlvbi5qc1wiKTtcbnZhciBjb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3QuanNcIik7XG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKHQpIHtcbiAgdmFyIHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIE1hcCA/IG5ldyBNYXAoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIodCkge1xuICAgIGlmIChudWxsID09PSB0IHx8ICFpc05hdGl2ZUZ1bmN0aW9uKHQpKSByZXR1cm4gdDtcbiAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgaWYgKHZvaWQgMCAhPT0gcikge1xuICAgICAgaWYgKHIuaGFzKHQpKSByZXR1cm4gci5nZXQodCk7XG4gICAgICByLnNldCh0LCBXcmFwcGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3QodCwgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9XG4gICAgfSksIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIHQpO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF93cmFwTmF0aXZlU3VwZXIodCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwiLypcbiAqIHR5cGVkZWZzLmpzXG4gKiBOb3JtYWxpemVzIGJyb3dzZXItc3BlY2lmaWMgcHJlZml4ZXMgYW5kIHByb3ZpZGUgc29tZSBiYXNpYyBwb2x5ZmlsbHNcbiAqL1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uICgvKiBmdW5jdGlvbiBGcmFtZVJlcXVlc3RDYWxsYmFjayAqLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZiBNYXRoLmltdWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgTWF0aC5pbXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBhbCA9IGEgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYmwgPSBiICYgMHhmZmZmO1xuICAgICAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XG4gICAgICAgIC8vIHRoZSBmaW5hbCB8MCBjb252ZXJ0cyB0aGUgdW5zaWduZWQgdmFsdWUgaW50byBhIHNpZ25lZCB2YWx1ZVxuICAgICAgICByZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApIHwgMCk7XG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXG5cbid1c2Ugc3RyaWN0JztcblxuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0byA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICBjb25zdCBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfTtcbn1cbiIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gdG9QcmltaXRpdmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgT3ZlcmxvYWRZaWVsZCA9IHJlcXVpcmUoXCIuL092ZXJsb2FkWWllbGQuanNcIik7XG52YXIgcmVnZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvci5qc1wiKTtcbnZhciByZWdlbmVyYXRvckFzeW5jID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3JBc3luYy5qc1wiKTtcbnZhciByZWdlbmVyYXRvckFzeW5jR2VuID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3JBc3luY0dlbi5qc1wiKTtcbnZhciByZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IuanNcIik7XG52YXIgcmVnZW5lcmF0b3JLZXlzID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3JLZXlzLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yVmFsdWVzID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3JWYWx1ZXMuanNcIik7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgciA9IHJlZ2VuZXJhdG9yKCksXG4gICAgZSA9IHIubShfcmVnZW5lcmF0b3JSdW50aW1lKSxcbiAgICB0ID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSA6IGUuX19wcm90b19fKS5jb25zdHJ1Y3RvcjtcbiAgZnVuY3Rpb24gbihyKSB7XG4gICAgdmFyIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIgJiYgci5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFlICYmIChlID09PSB0IHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lKSk7XG4gIH1cbiAgdmFyIG8gPSB7XG4gICAgXCJ0aHJvd1wiOiAxLFxuICAgIFwicmV0dXJuXCI6IDIsXG4gICAgXCJicmVha1wiOiAzLFxuICAgIFwiY29udGludWVcIjogM1xuICB9O1xuICBmdW5jdGlvbiBhKHIpIHtcbiAgICB2YXIgZSwgdDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgIGUgfHwgKGUgPSB7XG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgcmV0dXJuIHQobi5hLCAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIG4udjtcbiAgICAgICAgfSxcbiAgICAgICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQociwgZSkge1xuICAgICAgICAgIHJldHVybiB0KG4uYSwgb1tyXSwgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQociwgbywgYSkge1xuICAgICAgICAgIHJldHVybiBlLnJlc3VsdE5hbWUgPSBvLCB0KG4uZCwgcmVnZW5lcmF0b3JWYWx1ZXMociksIGEpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChyKSB7XG4gICAgICAgICAgcmV0dXJuIHQobi5mLCByKTtcbiAgICAgICAgfVxuICAgICAgfSwgdCA9IGZ1bmN0aW9uIHQociwgX3QsIG8pIHtcbiAgICAgICAgbi5wID0gZS5wcmV2LCBuLm4gPSBlLm5leHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHIoX3QsIG8pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGUubmV4dCA9IG4ubjtcbiAgICAgICAgfVxuICAgICAgfSksIGUucmVzdWx0TmFtZSAmJiAoZVtlLnJlc3VsdE5hbWVdID0gbi52LCBlLnJlc3VsdE5hbWUgPSB2b2lkIDApLCBlLnNlbnQgPSBuLnYsIGUubmV4dCA9IG4ubjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByLmNhbGwodGhpcywgZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBuLnAgPSBlLnByZXYsIG4ubiA9IGUubmV4dDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JhcDogZnVuY3Rpb24gd3JhcChlLCB0LCBuLCBvKSB7XG4gICAgICAgIHJldHVybiByLncoYShlKSwgdCwgbiwgbyAmJiBvLnJldmVyc2UoKSk7XG4gICAgICB9LFxuICAgICAgaXNHZW5lcmF0b3JGdW5jdGlvbjogbixcbiAgICAgIG1hcms6IHIubSxcbiAgICAgIGF3cmFwOiBmdW5jdGlvbiBhd3JhcChyLCBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3ZlcmxvYWRZaWVsZChyLCBlKTtcbiAgICAgIH0sXG4gICAgICBBc3luY0l0ZXJhdG9yOiByZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IsXG4gICAgICBhc3luYzogZnVuY3Rpb24gYXN5bmMociwgZSwgdCwgbywgdSkge1xuICAgICAgICByZXR1cm4gKG4oZSkgPyByZWdlbmVyYXRvckFzeW5jR2VuIDogcmVnZW5lcmF0b3JBc3luYykoYShyKSwgZSwgdCwgbywgdSk7XG4gICAgICB9LFxuICAgICAga2V5czogcmVnZW5lcmF0b3JLZXlzLFxuICAgICAgdmFsdWVzOiByZWdlbmVyYXRvclZhbHVlc1xuICAgIH07XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cykoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yUnVudGltZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciByZWdlbmVyYXRvckFzeW5jR2VuID0gcmVxdWlyZShcIi4vcmVnZW5lcmF0b3JBc3luY0dlbi5qc1wiKTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvckFzeW5jKG4sIGUsIHIsIHQsIG8pIHtcbiAgdmFyIGEgPSByZWdlbmVyYXRvckFzeW5jR2VuKG4sIGUsIHIsIHQsIG8pO1xuICByZXR1cm4gYS5uZXh0KCkudGhlbihmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmRvbmUgPyBuLnZhbHVlIDogYS5uZXh0KCk7XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JBc3luYywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9yZWdlbmVyYXRvcktleXMoZSkge1xuICB2YXIgbiA9IE9iamVjdChlKSxcbiAgICByID0gW107XG4gIGZvciAodmFyIHQgaW4gbikgci51bnNoaWZ0KHQpO1xuICByZXR1cm4gZnVuY3Rpb24gZSgpIHtcbiAgICBmb3IgKDsgci5sZW5ndGg7KSBpZiAoKHQgPSByLnBvcCgpKSBpbiBuKSByZXR1cm4gZS52YWx1ZSA9IHQsIGUuZG9uZSA9ICExLCBlO1xuICAgIHJldHVybiBlLmRvbmUgPSAhMCwgZTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yS2V5cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclZhbHVlcyhlKSB7XG4gIGlmIChudWxsICE9IGUpIHtcbiAgICB2YXIgdCA9IGVbXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiXSxcbiAgICAgIHIgPSAwO1xuICAgIGlmICh0KSByZXR1cm4gdC5jYWxsKGUpO1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUubmV4dCkgcmV0dXJuIGU7XG4gICAgaWYgKCFpc05hTihlLmxlbmd0aCkpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gZSAmJiByID49IGUubGVuZ3RoICYmIChlID0gdm9pZCAwKSwge1xuICAgICAgICAgIHZhbHVlOiBlICYmIGVbcisrXSxcbiAgICAgICAgICBkb25lOiAhZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihfdHlwZW9mKGUpICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JWYWx1ZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2UodCwgbykge1xuICBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSBnZXRQcm90b3R5cGVPZih0KSk7KTtcbiAgcmV0dXJuIHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KHIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHtcbiAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7XG4gICAgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWFwO1xuIiwidmFyIGJhc2VJc1NldCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1NldCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1NldDtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNTZXQ7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNsaWNlO1xuIiwidmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21PbWl0Q2xvbmU7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwiZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24odCkge1xuICB0cnkge1xuICAgIHJldHVybiAtMSAhPT0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKTtcbiAgfSBjYXRjaCAobikge1xuICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb24sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5mdW5jdGlvbiBfY29uc3RydWN0KHQsIGUsIHIpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgdmFyIG8gPSBbbnVsbF07XG4gIG8ucHVzaC5hcHBseShvLCBlKTtcbiAgdmFyIHAgPSBuZXcgKHQuYmluZC5hcHBseSh0LCBvKSkoKTtcbiAgcmV0dXJuIHIgJiYgc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZXhwb3J0IHZhciBFUFNJTE9OID0gMC4wMDAwMDE7XG5leHBvcnQgdmFyIEFSUkFZX1RZUEUgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuZXhwb3J0IHZhciBBTkdMRV9PUkRFUiA9IFwienl4XCI7XG5cbi8qKlxuICogU3ltbWV0cmljIHJvdW5kXG4gKiBzZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvcm91bmQtaGFsZi11cC1zeW1tZXRyaWMjdXNlci1jb250ZW50LWRldGFpbGVkLWJhY2tncm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSB2YWx1ZSB0byByb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQoYSkge1xuICBpZiAoYSA+PSAwKSByZXR1cm4gTWF0aC5yb3VuZChhKTtcbiAgcmV0dXJuIGEgJSAwLjUgPT09IDAgPyBNYXRoLmZsb29yKGEpIDogTWF0aC5yb3VuZChhKTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgQVJSQVlfVFlQRSA9IHR5cGU7XG59XG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcbnZhciByYWRpYW4gPSAxODAgLyBNYXRoLlBJO1xuXG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG5cbi8qKlxuICogQ29udmVydCBSYWRpYW4gVG8gRGVncmVlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gUmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWUoYSkge1xuICByZXR1cm4gYSAqIHJhZGlhbjtcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgICAgICAgICAgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgICAgICAgICAgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b2xlcmFuY2UgIEFic29sdXRlIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSAoZGVmYXVsdCBnbE1hdHJpeC5FUFNJTE9OKVxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEVQU0lMT047XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gdG9sZXJhbmNlICogTWF0aC5tYXgoMSwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn0iLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiAyeDIgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG4gIG91dFswXSA9IDE7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZVxuICAvLyBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGExO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhWzFdO1xuICAgIG91dFszXSA9IGFbM107XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDIgfCBudWxsfSBvdXQsIG9yIG51bGwgaWYgc291cmNlIG1hdHJpeCBpcyBub3QgaW52ZXJ0aWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl0sXG4gICAgYTMgPSBhWzNdO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSBhMCAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZWNlc3NhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gYVswXTtcbiAgb3V0WzBdID0gYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl0sXG4gICAgYTMgPSBhWzNdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0gKyBhWzJdICogYVsyXSArIGFbM10gKiBhWzNdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gTERVKEwsIEQsIFUsIGEpIHtcbiAgTFsyXSA9IGFbMl0gLyBhWzBdO1xuICBVWzBdID0gYVswXTtcbiAgVVsxXSA9IGFbMV07XG4gIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07XG4gIHJldHVybiBbTCwgRCwgVV07XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl0sXG4gICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl0sXG4gICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjMlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBzeW1tZXRyaWMgcm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IGdsTWF0cml4LnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBnbE1hdHJpeC5yb3VuZChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSA9PT0gdW5kZWZpbmVkID8gMS4wIDogc2NhbGU7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAyRCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IFRoZSByZWNlaXZpbmcgdmVjMlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgYiwgcmFkKSB7XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgdmFyIHAwID0gYVswXSAtIGJbMF0sXG4gICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICBzaW5DID0gTWF0aC5zaW4ocmFkKSxcbiAgICBjb3NDID0gTWF0aC5jb3MocmFkKTtcblxuICAvL3BlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHAwICogY29zQyAtIHAxICogc2luQyArIGJbMF07XG4gIG91dFsxXSA9IHAwICogc2luQyArIHAxICogY29zQyArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzbWFsbGVzdCBhbmdsZSBiZXR3ZWVuIHR3byAyRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXSxcbiAgICBieCA9IGJbMF0sXG4gICAgYnkgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hYnMoTWF0aC5hdGFuMihheSAqIGJ4IC0gYXggKiBieSwgYXggKiBieCArIGF5ICogYnkpKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpZ25lZCBhbmdsZSBpbiB0aGUgaW50ZXJ2YWwgWy1waSxwaV0gYmV0d2VlbiB0d28gMkQgdmVjdG9ycyAocG9zaXRpdmUgaWYgYGFgIGlzIHRvIHRoZSByaWdodCBvZiBgYmApXG4gKiBcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc2lnbmVkIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZEFuZ2xlKGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV0sXG4gICAgYnggPSBiWzBdLFxuICAgIGJ5ID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYXRhbjIoYXggKiBieSAtIGF5ICogYngsIGF4ICogYnggKyBheSAqIGJ5KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHplcm9cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIilcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjM1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogc3ltbWV0cmljIHJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBnbE1hdHJpeC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gZ2xNYXRyaXgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IGdsTWF0cml4LnJvdW5kKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXSxcbiAgICBheiA9IGFbMl07XG4gIHZhciBieCA9IGJbMF0sXG4gICAgYnkgPSBiWzFdLFxuICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGRvdChhLCBiKSwgLTEpLCAxKSk7XG4gIHZhciBzaW5Ub3RhbCA9IE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIHJhdGlvQSA9IE1hdGguc2luKCgxIC0gdCkgKiBhbmdsZSkgLyBzaW5Ub3RhbDtcbiAgdmFyIHJhdGlvQiA9IE1hdGguc2luKHQgKiBhbmdsZSkgLyBzaW5Ub3RhbDtcbiAgb3V0WzBdID0gcmF0aW9BICogYVswXSArIHJhdGlvQiAqIGJbMF07XG4gIG91dFsxXSA9IHJhdGlvQSAqIGFbMV0gKyByYXRpb0IgKiBiWzFdO1xuICBvdXRbMl0gPSByYXRpb0EgKiBhWzJdICsgcmF0aW9CICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlID09PSB1bmRlZmluZWQgPyAxLjAgOiBzY2FsZTtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIHZhciB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjA7XG4gIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGU7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV0sXG4gICAgeiA9IGFbMl07XG4gIHZhciB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdLFxuICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqIENhbiBhbHNvIGJlIHVzZWQgZm9yIGR1YWwgcXVhdGVybmlvbnMuIChNdWx0aXBseSBpdCB3aXRoIHRoZSByZWFsIHBhcnQpXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBub3JtYWxpemVkIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIEZhc3QgVmVjdG9yIFJvdGF0aW9uIHVzaW5nIFF1YXRlcm5pb25zIGJ5IFJvYmVydCBFaXNlbGVcbiAgLy8gaHR0cHM6Ly9yYXcub3JnL3Byb29mL3ZlY3Rvci1yb3RhdGlvbi11c2luZy1xdWF0ZXJuaW9ucy9cblxuICB2YXIgcXggPSBxWzBdLFxuICAgIHF5ID0gcVsxXSxcbiAgICBxeiA9IHFbMl0sXG4gICAgcXcgPSBxWzNdO1xuICB2YXIgdnggPSBhWzBdLFxuICAgIHZ5ID0gYVsxXSxcbiAgICB2eiA9IGFbMl07XG5cbiAgLy8gdCA9IHEgeCB2XG4gIHZhciB0eCA9IHF5ICogdnogLSBxeiAqIHZ5O1xuICB2YXIgdHkgPSBxeiAqIHZ4IC0gcXggKiB2ejtcbiAgdmFyIHR6ID0gcXggKiB2eSAtIHF5ICogdng7XG5cbiAgLy8gdCA9IDJ0XG4gIHR4ID0gdHggKyB0eDtcbiAgdHkgPSB0eSArIHR5O1xuICB0eiA9IHR6ICsgdHo7XG5cbiAgLy8gdiArIHcgdCArIHEgeCB0XG4gIG91dFswXSA9IHZ4ICsgcXcgKiB0eCArIHF5ICogdHogLSBxeiAqIHR5O1xuICBvdXRbMV0gPSB2eSArIHF3ICogdHkgKyBxeiAqIHR4IC0gcXggKiB0ejtcbiAgb3V0WzJdID0gdnogKyBxdyAqIHR6ICsgcXggKiB0eSAtIHF5ICogdHg7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICByID0gW107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICByID0gW107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMl0gKiBNYXRoLnNpbihyYWQpICsgcFswXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMV0gPSBwWzFdO1xuICByWzJdID0gcFsyXSAqIE1hdGguY29zKHJhZCkgLSBwWzBdICogTWF0aC5zaW4ocmFkKTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICByID0gW107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXSxcbiAgICBheiA9IGFbMl0sXG4gICAgYnggPSBiWzBdLFxuICAgIGJ5ID0gYlsxXSxcbiAgICBieiA9IGJbMl0sXG4gICAgbWFnID0gTWF0aC5zcXJ0KChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopICogKGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieikpLFxuICAgIGNvc2luZSA9IG1hZyAmJiBkb3QoYSwgYikgLyBtYWc7XG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHplcm9cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIilcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV0sXG4gICAgYTIgPSBhWzJdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgICBhW2kgKyAyXSA9IHZlY1syXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQyIGZyb20gXCIuL21hdDIuanNcIjtcbmltcG9ydCAqIGFzIG1hdDJkIGZyb20gXCIuL21hdDJkLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQzIGZyb20gXCIuL21hdDMuanNcIjtcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSBcIi4vbWF0NC5qc1wiO1xuaW1wb3J0ICogYXMgcXVhdCBmcm9tIFwiLi9xdWF0LmpzXCI7XG5pbXBvcnQgKiBhcyBxdWF0MiBmcm9tIFwiLi9xdWF0Mi5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tIFwiLi92ZWMyLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gXCIuL3ZlYzMuanNcIjtcbmltcG9ydCAqIGFzIHZlYzQgZnJvbSBcIi4vdmVjNC5qc1wiO1xuZXhwb3J0IHsgZ2xNYXRyaXgsIG1hdDIsIG1hdDJkLCBtYXQzLCBtYXQ0LCBxdWF0LCBxdWF0MiwgdmVjMiwgdmVjMywgdmVjNCB9OyIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgeyBUeXBlZEFycmF5IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChhcnI6IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LCB2YWw6IG51bWJlcikge1xuICAgICAgICBhcnIuZmlsbCh2YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJTi1QTEFDRSBTaHVmZmxlcyB0aGUgY29udGVudCBvZiBhbiBhcnJheVxuICAgICAqL1xuICAgIHNodWZmbGUoYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIC8vIER1cnN0ZW5mZWxkIHNodWZmbGUgYWxnb3JpdGhtXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0NTA5NTQvaG93LXRvLXJhbmRvbWl6ZS1zaHVmZmxlLWEtamF2YXNjcmlwdC1hcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICAgIFthcnJbaV0sIGFycltqXV0gPSBbYXJyW2pdLCBhcnJbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0KGFycjogQXJyYXk8QXJyYXk8bnVtYmVyPj4pIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IGFyci5yZWR1Y2UoKHAsIG4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGBbJHtuLmpvaW4oJywnKX1dYDtcbiAgICAgICAgICAgIHAucHVzaChyb3cpO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sIFtdIGFzIEFycmF5PHN0cmluZz4pO1xuICAgICAgICByZXR1cm4gYFske3Jvd3Muam9pbignLFxcclxcbicpfV1gO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBlbGVtZW50cyB3aGljaCdzIHNjb3JlIGlzIGJpZ2dlciB0aGFuIHRoZSB0aHJlc2hvbGRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJlc2hvbGQoYXJyOiBBcnJheTxudW1iZXI+LCB0aHJlc2hvbGQ6IG51bWJlciwgc2NvcmVGdW5jOiAoKHNjb3JlOiBudW1iZXIpID0+IG51bWJlcikpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBhcnIucmVkdWNlKChwcmV2OiBBcnJheTxudW1iZXI+LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NvcmVGdW5jLmFwcGx5KGFyciwgW25leHRdKSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfSxcblxuICAgIG1heEluZGV4KGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4KGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgc3VtKGFycjogQXJyYXk8bnVtYmVyPiB8IFR5cGVkQXJyYXkpOiBudW1iZXIge1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGFycjtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW0gKz0gYXJyW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9LFxufTtcbiIsIi8vIFRPRE86IGNsdXN0ZXIuanMgYW5kIGN2X3V0aWxzLmpzIGFyZSBwcmV0dHkgdGlnaHRseSBpbnRlcnR3aW5lZCwgbWFraW5nIGZvciBhIGNvbXBsZXggY29udmVyc2lvblxuLy8gaW50byB0eXBlc2NyaXB0LiBiZSB3YXJuZWQuIDotKVxuXG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2x1c3RlciBmb3IgZ3JvdXBpbmcgc2ltaWxhciBvcmllbnRhdGlvbnMgb2YgZGF0YXBvaW50c1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHtcbiAgICAgICAgICAgIHJhZDogMCxcbiAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbMCwgMF0pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwb2ludE1hcCA9IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZChwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICBwb2ludE1hcFtwb2ludFRvQWRkLmlkXSA9IHBvaW50VG9BZGQ7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludFRvQWRkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNlbnRlcigpIHtcbiAgICAgICAgICAgIGxldCBpOyBsZXRcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBwb2ludHNbaV0ucmFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VudGVyLnJhZCA9IHN1bSAvIHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjZW50ZXIudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3MoY2VudGVyLnJhZCksIE1hdGguc2luKGNlbnRlci5yYWQpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgYWRkKHBvaW50KTtcbiAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGQocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgICAgIGlmICghcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0cyhvdGhlclBvaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY29zaW5lIHNpbWlsYXJpdHkgdG8gY2VudGVyLWFuZ2xlXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KG90aGVyUG9pbnQucG9pbnQudmVjLCBjZW50ZXIudmVjKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQb2ludHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDZW50ZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVQb2ludChuZXdQb2ludCwgaWQsIHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYWQ6IG5ld1BvaW50W3Byb3BlcnR5XSxcbiAgICAgICAgICAgIHBvaW50OiBuZXdQb2ludCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbWl4ZWQtb3BlcmF0b3JzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5pbXBvcnQgeyB2ZWMyLCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQgQ2x1c3RlcjIgZnJvbSAnLi9jbHVzdGVyJztcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgY29uc3QgdGhhdCA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9WZWMyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMygpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgcG9zQSA9IDA7IGxldCBwb3NCID0gMDsgbGV0IHBvc0MgPSAwOyBsZXQgcG9zRCA9IDA7IGxldCB4OyBsZXRcbiAgICAgICAgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cbiAgICAgICAgICAgICAgICArPSBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7IGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhOyBjb25zdFxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGxpbmU7XG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xuICAgIGxldCByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XG4gICAgbGV0IGhpc3Q7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICBjb25zdCB2ZXQgPSBbMF07XG4gICAgICAgIGxldCBwMTtcbiAgICAgICAgbGV0IHAyO1xuICAgICAgICBsZXQgcDEyO1xuICAgICAgICBsZXQgbTE7XG4gICAgICAgIGxldCBtMjtcbiAgICAgICAgbGV0IG0xMjtcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XG4gICAgICAgIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0aGlzQ2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICBsZXQgdG9wID0gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGxldCB0b0lkeDtcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxuICAgICAgICBwb3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICBjb25zdCBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIGxldCBvdXRJbWdJZHggPSAwO1xuICAgIGNvbnN0IGluV2lkdGggPSBzaXplLng7XG4gICAgbGV0IGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xuICAgIGNvbnN0IHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSkge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zb2xlLndhcm4oJyogbG9hZEltYWdlQXJyYXkgZ2V0Q29udGV4dCAyZCcpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICBjb25zdCBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcbiAgICBjb25zdCBoID0gaHN2WzBdO1xuICAgIGNvbnN0IHMgPSBoc3ZbMV07XG4gICAgY29uc3QgdiA9IGhzdlsyXTtcbiAgICBjb25zdCBjID0gdiAqIHM7XG4gICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICAvLyBIYW5kbGUgZWRnZSBjYXNlc1xuICAgIC8vIE5hTjogTm90IGEgbnVtYmVyIC0gbm8gbWVhbmluZ2Z1bCBkaXZpc29yc1xuICAgIC8vIEluZmluaXR5OiBJbmZpbml0ZSB2YWx1ZXMgaGF2ZSBubyBmaW5pdGUgZGl2aXNvcnNcbiAgICAvLyBOb24tcG9zaXRpdmU6IERpdmlzb3JzIGFyZSB0eXBpY2FsbHkgZGVmaW5lZCBmb3IgcG9zaXRpdmUgaW50ZWdlcnMgb25seVxuICAgIC8vIFdoaWxlIG5lZ2F0aXZlIG51bWJlcnMgdGVjaG5pY2FsbHkgaGF2ZSBkaXZpc29ycywgcmV0dXJuaW5nIHRoZW0gd291bGQgY29tcGxpY2F0ZVxuICAgIC8vIHRoZSBBUEkgKHdvdWxkIG5lZWQgdG8gcmV0dXJuIGJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGRpdmlzb3JzLCBvciBtYWtlIGFzc3VtcHRpb25zKVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG4pIHx8IG4gPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcbiAgICBjb25zdCBzcXJ0TiA9IE1hdGguc3FydChuKTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNxcnROOyBpKyspIHtcbiAgICAgICAgaWYgKG4gJSBpID09PSAwKSB7XG4gICAgICAgICAgICBkaXZpc29ycy5wdXNoKGkpO1xuICAgICAgICAgICAgLy8gT25seSBhZGQgdGhlIGNvbXBsZW1lbnRhcnkgZGl2aXNvciBpZiBpdCdzIGRpZmZlcmVudCAobm90IGEgcGVyZmVjdCBzcXVhcmUgcm9vdClcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIGNvbnN0IGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KTtcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gICAgY29uc3QgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpO1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgJ3gtc21hbGwnOiA1LFxuICAgICAgICBzbWFsbDogNCxcbiAgICAgICAgbWVkaXVtOiAzLFxuICAgICAgICBsYXJnZTogMixcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxuICAgIH07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XG4gICAgbGV0IG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZvdW5kLCB5OiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbGJhY2s6IGlmIG5vIG9wdGltYWwgcGF0Y2ggc2l6ZSBmb3VuZCwgdXNlIGltYWdlIHNpemUgKG9yIDF4MSBtaW5pbXVtKVxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgZnVuY3Rpb24gYWx3YXlzIHJldHVybnMgYSB2YWxpZCB7eCwgeX0gb2JqZWN0XG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XG4gICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLm1heCgxLCBpbWdTaXplLngpLFxuICAgICAgICAgICAgeTogTWF0aC5tYXgoMSwgaW1nU2l6ZS55KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XG4gICAgfSxcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XG5cbiAgICBjb25zdCBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICAvLyBTa2lwIHN0eWxpbmcgcHJvcGVydGllcyB0aGF0IGFyZW4ndCBkaW1lbnNpb24gY29udmVydGVyc1xuICAgICAgICBpZiAoIV9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJlYVtrZXldO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkID0gX2RpbWVuc2lvbnNDb252ZXJ0ZXJzW2tleV0ocGFyc2VkLCBjb250ZXh0KTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxjdWxhdGVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHN4OiBwYXJzZWRBcmVhLmxlZnQsXG4gICAgICAgIHN5OiBwYXJzZWRBcmVhLnRvcCxcbiAgICAgICAgc3c6IHBhcnNlZEFyZWEucmlnaHQgLSBwYXJzZWRBcmVhLmxlZnQsXG4gICAgICAgIHNoOiBwYXJzZWRBcmVhLmJvdHRvbSAtIHBhcnNlZEFyZWEudG9wLFxuICAgIH07XG59XG4iLCJpbXBvcnQgeyB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB7XG4gICAgWFlTaXplLFxuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiAgICBUeXBlZEFycmF5LFxuICAgIFdyYXBwZXJJbmRleE1hcHBpbmcsXG4gICAgTW9tZW50LFxuICAgIFNwYXJzZUltYWdlV3JhcHBlcixcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IHsgaHN2MnJnYiB9IGZyb20gJy4vY3ZfdXRpbHMnO1xuXG50eXBlIFBvc2l0aXZlTnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIHJlY2VpdmVkICR7dmFsfWApO1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcblxuICAgIHNpemU6IFhZU2l6ZTtcblxuICAgIGluZGV4TWFwcGluZz86IFdyYXBwZXJJbmRleE1hcHBpbmc7XG5cbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxuICAgIC8vIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbi5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2l6ZTogWFlTaXplLFxuICAgICAgICBkYXRhPzogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlLCBleHRlbmRlZCBvdXQgYnkgYSBib3JkZXIgb24gZWFjaCBzaWRlXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICAgIHJldHVybiAoaW1nUmVmLnggPj0gMClcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi54IDwgKHRoaXMuc2l6ZS54ICsgKGJvcmRlciAqIDIpKSlcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA8ICh0aGlzLnNpemUueSArIChib3JkZXIgKiAyKSkpO1xuICAgIH1cblxuICAgIC8vIENvcHkgZnJvbSBUSElTIEltYWdlV3JhcHBlciB0byB0aGUgbmV3IGltYWdlV3JhcHBlciBwYXJhbWV0ZXIsIHN0YXJ0aW5nIGF0IGZyb20sIHN0b3BwaW5nIGF0XG4gICAgLy8gZW5kIG9mIG5ldyBpbWFnZVdyYXBwZXIgc2l6ZS5cbiAgICBzdWJJbWFnZUFzQ29weShpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlciwgZnJvbTogWFlTaXplKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS54KTtcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS55KTtcbiAgICAgICAgY29uc3QgeyB4OiBzaXplWCwgeTogc2l6ZVkgfSA9IGltYWdlV3JhcHBlci5zaXplO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemVYOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZVk7IHkrKykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhW3kgKiBzaXplWCArIHhdID0gdGhpcy5kYXRhWyhmcm9tLnkgKyB5KSAqIHRoaXMuc2l6ZS54ICsgZnJvbS54ICsgeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlV3JhcHBlcjtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiByZWFsbHkgcHJvYmFibHkgc2hvdWxkIGNhbGwgaW50byBJbWFnZVdyYXBwZXIgc29tZXdoZXJlIHRvIG1ha2VcbiAgICAgICAgLy8gc3VyZSB0aGF0IGFsbCBvZiBpdCdzIHBhcmFtZXRlcnMgYXJlIHNldCBwcm9wZXJseSwgc29tZXRoaW5nIGxpa2VcbiAgICAgICAgLy8gSW1hZ2VXcmFwcGVyLlVwZGF0ZUZyb20oKVxuICAgICAgICAvLyB0aGF0IG1pZ2h0IHRha2UgYSBwcm92aWRlZCBkYXRhIGFuZCBzaXplLCBhbmQgbWFrZSBzdXJlIHRoZXJlJ3Mgbm8gaW52YWxpZCBpbmRleE1hcHBpbmdcbiAgICAgICAgLy8gaGFuZ2luZyBhcm91bmQsIGFuZCBzdWNoLlxuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2VcbiAgICBnZXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UgKHNhZmUsIHdoYXRldmVyIHRoYXRcbiAgICAvLyBtZWFucylcbiAgICBnZXRTYWZlKHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgLy8gY2FjaGUgaW5kZXhNYXBwaW5nIGJlY2F1c2UgaWYgd2UncmUgdXNpbmcgaXQgb25jZSwgd2UnbGwgcHJvYmFibHkgbmVlZCBpdCBhIGJ1bmNoIG1vcmVcbiAgICAgICAgLy8gdG9vXG4gICAgICAgIGlmICghdGhpcy5pbmRleE1hcHBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLng7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaSArIHRoaXMuc2l6ZS54XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZS55OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2ldID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2kgKyB0aGlzLnNpemUueV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbKHRoaXMuaW5kZXhNYXBwaW5nLnlbeSArIHRoaXMuc2l6ZS55XSkgKiB0aGlzLnNpemUueCArIHRoaXMuaW5kZXhNYXBwaW5nLnhbeCArIHRoaXMuc2l6ZS54XV07XG4gICAgfVxuXG4gICAgLy8gU2V0cyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBpbWFnZSB0byB0aGUgZ2l2ZW4gZ3JheXNjYWxlIHZhbHVlXG4gICAgc2V0KHg6IG51bWJlciwgeTogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdID0gdmFsdWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgYm9yZGVyIG9mIHRoZSBpbWFnZSAoMSBwaXhlbCkgdG8gemVyb1xuICAgIHplcm9Cb3JkZXIoKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgY29uc3QgeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0gPSB0aGlzLnNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gdGhpcy5kYXRhWyhoZWlnaHQgLSAxKSAqIHdpZHRoICsgaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaSAqIHdpZHRoXSA9IHRoaXMuZGF0YVtpICogd2lkdGggKyAod2lkdGggLSAxKV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiBpcyBlbnRpcmVseSB0b28gbGFyZ2UgZm9yIG1lIHRvIHJlYXNvbiBvdXQgcmlnaHQgYXQgdGhpcyBtb21lbnQgdGhhdCBpJ20gaGFuZGxpbmdcbiAgICAvLyBhbGwgdGhlIHJlc3Qgb2YgaXQsIHNvIHRoaXMgaXMgYSB2ZXJiYXRpbSBjb3B5IG9mIHRoZSBqYXZhc2NyaXB0IHNvdXJjZSwgd2l0aCBvbmx5IHR3ZWFrc1xuICAgIC8vIG5lY2Vzc2FyeSB0byBnZXQgaXQgdG8gcnVuLCBubyB0aG91Z2h0IHB1dCBpbnRvIGl0IHlldC5cbiAgICBtb21lbnRzKGxhYmVsQ291bnQ6IG51bWJlcik6IEFycmF5PE1vbWVudD4ge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXM7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5zaXplLng7XG4gICAgICAgIGxldCB2YWw7XG4gICAgICAgIGxldCB5c3E7XG4gICAgICAgIGNvbnN0IGxhYmVsU3VtOiBBcnJheTxNb21lbnQ+ID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgIGxldCBtdTExO1xuICAgICAgICBsZXQgbXUwMjtcbiAgICAgICAgbGV0IG11MjA7XG4gICAgICAgIGxldCB4XztcbiAgICAgICAgbGV0IHlfO1xuICAgICAgICBsZXQgdG1wO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgY29uc3QgeyBQSSB9ID0gTWF0aDtcbiAgICAgICAgY29uc3QgUElfNCA9IFBJIC8gNDtcblxuICAgICAgICBpZiAobGFiZWxDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGFiZWxTdW1baV0gPSB7XG4gICAgICAgICAgICAgICAgbTAwOiAwLFxuICAgICAgICAgICAgICAgIG0wMTogMCxcbiAgICAgICAgICAgICAgICBtMTA6IDAsXG4gICAgICAgICAgICAgICAgbTExOiAwLFxuICAgICAgICAgICAgICAgIG0wMjogMCxcbiAgICAgICAgICAgICAgICBtMjA6IDAsXG4gICAgICAgICAgICAgICAgdGhldGE6IDAsXG4gICAgICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgeXNxID0geSAqIHk7XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVt2YWwgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAwICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMSArPSB5O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTAgKz0geDtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTExICs9IHggKiB5O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDIgKz0geXNxO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMjAgKz0geCAqIHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVtpXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgICAgIGlmICghaXNOYU4obGFiZWwubTAwKSAmJiBsYWJlbC5tMDAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB4XyA9IGxhYmVsLm0xMCAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgICAgICB5XyA9IGxhYmVsLm0wMSAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgICAgICBtdTExID0gbGFiZWwubTExIC8gbGFiZWwubTAwIC0geF8gKiB5XztcbiAgICAgICAgICAgICAgICBtdTAyID0gbGFiZWwubTAyIC8gbGFiZWwubTAwIC0geV8gKiB5XztcbiAgICAgICAgICAgICAgICBtdTIwID0gbGFiZWwubTIwIC8gbGFiZWwubTAwIC0geF8gKiB4XztcbiAgICAgICAgICAgICAgICB0bXAgPSAobXUwMiAtIG11MjApIC8gKDIgKiBtdTExKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAwLjUgKiBNYXRoLmF0YW4odG1wKSArIChtdTExID49IDAgPyBQSV80IDogLVBJXzQpICsgUEk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhID0gKHRtcCAqIDE4MCAvIFBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsLnRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSArPSAxODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhYmVsLnJhZCA9IHRtcCA+IFBJID8gdG1wIC0gUEkgOiB0bXA7XG4gICAgICAgICAgICAgICAgbGFiZWwudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3ModG1wKSwgTWF0aC5zaW4odG1wKV0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIHJldHVybiBhIFVpbnQ4Q2xhbXBlZEFycmF5IGNvbnRhaW5pbmcgdGhpcyBncmF5c2NhbGUgaW1hZ2UgY29udmVydGVkIHRvIFJHQkEgZm9ybVxuICAgIGdldEFzUkdCQShzY2FsZSA9IDEuMCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQgKiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55KTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IHkgKiB0aGlzLnNpemUueCArIHg7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0KHgsIHkpICogc2NhbGU7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDBdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMV0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAyXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDNdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheSB0aGlzIEltYWdlV3JhcHBlciBpbiBhIGdpdmVuIENhbnZhcyBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgc2NhbGVcbiAgICBzaG93KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlID0gMS4wKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUud2FybignKiBpbWFnZXdyYXBwZXIgc2hvdyBnZXRjb250ZXh0IDJkJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldEFzUkdCQShzY2FsZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSBuZXcgSW1hZ2VEYXRhKGRhdGEgYXMgVWludDhDbGFtcGVkQXJyYXk8QXJyYXlCdWZmZXI+LCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShuZXdGcmFtZSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheXMgYSBzcGVjaWZpZWQgU3ViSW1hZ2UgYXJlYSBpbiBhIGdpdmVuIGNhbnZhcy4gVGhpcyBkaWZmZXJzIGRyYXN0aWNhbGx5IGZyb21cbiAgICAvLyBjcmVhdGluZyBhIG5ldyBTdWJJbWFnZSBhbmQgdXNpbmcgaXQncyBzaG93KCkgbWV0aG9kLiBXaHk/IEkgZG9uJ3QgaGF2ZSB0aGUgYW5zd2VyIHRvIHRoYXRcbiAgICAvLyB5ZXQuICBJIHN1c3BlY3QgdGhlIEhTVi9SR0Igb3BlcmF0aW9ucyBpbnZvbHZlZCBoZXJlIGFyZSBtYWtpbmcgaXQgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQsXG4gICAgLy8gYnV0IHVudGlsIEkgY2FuIHZpc3VhbGl6ZSB0aGVzZSBmdW5jdGlvbnMgc2lkZSBieSBzaWRlLCBJJ20ganVzdCBnb2luZyB0byBjb3B5IHRoZSBleGlzdGluZ1xuICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgIG92ZXJsYXkoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgaW5TY2FsZTogbnVtYmVyLCBmcm9tOiBYWVNpemUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRTY2FsZSA9IChpblNjYWxlIDwgMCB8fCBpblNjYWxlID4gMzYwKSA/IDM2MCA6IGluU2NhbGU7XG4gICAgICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICAgICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBjb25zdCB3aGl0ZVJnYiA9IFsyNTUsIDI1NSwgMjU1XTtcbiAgICAgICAgY29uc3QgYmxhY2tSZ2IgPSBbMCwgMCwgMF07XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc29sZS53YXJuKCcqIGltYWdld3JhcHBlciBvdmVybGF5IGdldGNvbnRleHQgMmQnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoZnJvbS54LCBmcm9tLnksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gZnJhbWU7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gdGhpcy5kYXRhO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGhzdlswXSA9IHRoaXMuZGF0YVtsZW5ndGhdICogYWRqdXN0ZWRTY2FsZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgcmVzdWx0ID0gaHN2WzBdIDw9IDAgPyB3aGl0ZVJnYiA6IGhzdlswXSA+PSAzNjAgPyBibGFja1JnYiA6IGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gbGVuZ3RoICogNDtcbiAgICAgICAgICAgIFtkYXRhW3Bvc10sIGRhdGFbcG9zICsgMV0sIGRhdGFbcG9zICsgMl1dID0gcmVzdWx0O1xuICAgICAgICAgICAgZGF0YVtwb3MgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGZyYW1lLCBmcm9tLngsIGZyb20ueSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVdyYXBwZXI7XG4iLCJpbXBvcnQgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuLy8gVE9ETzogWFlQb3NpdGlvbiBzaG91bGQgYmUgYW4gWFlPYmplY3QsIGJ1dCB0aGF0IGJyZWFrcyBYWURlZmluaXRpb24sIHdoaWNoIGJyZWFrcyBkcmF3UGF0aCgpIGJlbG93LlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlQb3NpdGlvbiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbn1cblxuZGVjbGFyZSBpbnRlcmZhY2UgQ2FudmFzU3R5bGUge1xuICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgbGluZVdpZHRoOiBudW1iZXI7XG59XG5cbi8vIFhZRGVmaW5pdGlvbiB0ZWxscyB1cyB3aGljaCBjb21wb25lbnQgb2YgYSBnaXZlbiBhcnJheSBvciBvYmplY3QgaXMgdGhlIFwiWFwiIGFuZCB3aGljaCBpcyB0aGUgXCJZXCIuXG4vLyBVc3VhbGx5IHRoaXMgaXMgMCBmb3IgWCBhbmQgMSBmb3IgWSwgYnV0IG1pZ2h0IGJlIHVzZWQgYXMgJ3gnIGZvciB4IGFuZCAneScgZm9yIFkuXG5kZWNsYXJlIGludGVyZmFjZSBYWURlZmluaXRpb24ge1xuICAgIHg6IGtleW9mIFhZUG9zaXRpb247XG4gICAgeToga2V5b2YgWFlQb3NpdGlvbjtcbn1cblxuZGVjbGFyZSB0eXBlIFBhdGggPSBBcnJheTxYWVBvc2l0aW9uPjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGRyYXdSZWN0KHBvczogWFlQb3NpdGlvbiwgc2l6ZTogWFlTaXplLCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgc3R5bGU6IENhbnZhc1N0eWxlKTogdm9pZCB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGggfHwgMTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChwb3MueCwgcG9zLnksIHNpemUueCwgc2l6ZS55KTtcbiAgICB9LFxuICAgIGRyYXdQYXRoKHBhdGg6IFBhdGgsIGRlZjogWFlEZWZpbml0aW9uLCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgc3R5bGU6IENhbnZhc1N0eWxlKTogdm9pZCB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwYXRoWzBdW2RlZi54XSwgcGF0aFswXVtkZWYueV0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHBhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocGF0aFtqXVtkZWYueF0sIHBhdGhbal1bZGVmLnldKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIGRyYXdJbWFnZShpbWFnZURhdGE6IEFycmF5PG51bWJlcj4sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgY2FudmFzRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZS54LCBzaXplLnkpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGNhbnZhc0RhdGE7XG4gICAgICAgIGxldCBjYW52YXNEYXRhUG9zID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGxldCBpbWFnZURhdGFQb3MgPSBpbWFnZURhdGEubGVuZ3RoO1xuXG4gICAgICAgIGlmIChjYW52YXNEYXRhUG9zIC8gaW1hZ2VEYXRhUG9zICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGltYWdlRGF0YVBvcy0tKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGltYWdlRGF0YVtpbWFnZURhdGFQb3NdO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gMjU1O1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2FudmFzRGF0YSwgMCwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcbmltcG9ydCB7IEltYWdlV3JhcHBlciB9IGZyb20gJ3F1YWdnYSc7XG5pbXBvcnQgeyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuLy8gZm9yIHNvbWUgcmVhc29uIHRoaXMgdGhyb3dzIGEgc2hhZG93IGVycm9yIG9uIGl0c2VsZj8hXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5leHBvcnQgZW51bSBCYXJjb2RlRGlyZWN0aW9uIHtcbiAgICBGb3J3YXJkID0gMSxcbiAgICBSZXZlcnNlID0gLTFcbn1cblxuZXhwb3J0IHR5cGUgQmFyY29kZVJlYWRlclR5cGUgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBCYXJjb2RlRm9ybWF0ID0gc3RyaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVSZWFkZXJDb25maWcge1xuICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg/OiBib29sZWFuLFxuICAgIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlclR5cGU+LFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVDb3JyZWN0aW9uIHtcbiAgICBiYXI6IG51bWJlcixcbiAgICBzcGFjZTogbnVtYmVyLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kQ291bnRlcj86IG51bWJlcixcbiAgICBlcnJvcj86IG51bWJlcixcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0Q291bnRlcj86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVJbmZvIGV4dGVuZHMgQmFyY29kZVBvc2l0aW9uIHtcbiAgICBjb2RlOiBudW1iZXIsXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGUge1xuICAgIGNvZGU6IHN0cmluZyxcbiAgICBjb2Rlc2V0PzogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbiAgICBkZWNvZGVkQ29kZXM/OiBBcnJheTxzdHJpbmcgfCBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4sXG4gICAgZGlyZWN0aW9uPzogQmFyY29kZURpcmVjdGlvbixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBlbmRJbmZvPzogQmFyY29kZVBvc2l0aW9uLFxuICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLFxuICAgIHN1cHBsZW1lbnQ/OiBCYXJjb2RlLFxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFyY29kZVJlYWRlciB7XG4gICAgX3JvdzogQXJyYXk8bnVtYmVyPiA9IFtdO1xuXG4gICAgY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG5cbiAgICBzdXBwbGVtZW50czogQXJyYXk8QmFyY29kZVJlYWRlcj4gPSBbXTtcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMDtcblxuICAgIEZPUk1BVDogQmFyY29kZUZvcm1hdCA9ICd1bmtub3duJztcblxuICAgIENPTkZJR19LRVlTOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG4gICAgLy8gVE9ETzogc2hvdWxkIGFkZCBBTFBIQUJFVEhfU1RSSU5HLCBBTFBIQUJFVCwgQ0hBUkFDVEVSX0VOQ09ESU5HUyB0byBiYXNlIGNsYXNzLCBpZiB0aGV5XG4gICAgLy8gYXJlIHVzZWZ1bCBpbiBtb3N0IHJlYWRlcnMuXG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGw7XG5cbiAgICBzdGF0aWMgZ2V0IEV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFN0YXJ0Tm90Rm91bmRFeGNlcHRpb246ICdTdGFydC1JbmZvIHdhcyBub3QgZm91bmQhJyxcbiAgICAgICAgICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogJ0NvZGUgY291bGQgbm90IGJlIGZvdW5kIScsXG4gICAgICAgICAgICBQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb246ICdQYXR0ZXJuIGNvdWxkIG5vdCBiZSBmb3VuZCEnLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICB0aGlzLl9yb3cgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIGlmIChzdXBwbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5zdXBwbGVtZW50cyA9IHN1cHBsZW1lbnRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9uZXh0VW5zZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBzdGFydCA9IDApOiBudW1iZXIge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmVbaV0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoUGF0dGVybihjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbWF4U2luZ2xlRXJyb3IgPSB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SIHx8IDEpOiBudW1iZXIge1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBsZXQgc2luZ2xlRXJyb3IgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IG1vZHVsbyA9IDA7XG4gICAgICAgIGxldCBiYXJXaWR0aCA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBzY2FsZWQgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBtb2R1bG8gKz0gY29kZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhcldpZHRoID0gc3VtIC8gbW9kdWxvO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xuICAgICAgICAgICAgc2luZ2xlRXJyb3IgPSBNYXRoLmFicyhjb3VudCAtIHNjYWxlZCkgLyBzY2FsZWQ7XG4gICAgICAgICAgICBpZiAoc2luZ2xlRXJyb3IgPiBtYXhTaW5nbGVFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgKz0gc2luZ2xlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yIC8gbW9kdWxvO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfbmV4dFNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldCA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jb3JyZWN0QmFycyhjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBudW1iZXIsIGluZGljZXM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSBpbmRpY2VzO1xuICAgICAgICBsZXQgdG1wID0gMDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgoMSAtIGNvcnJlY3Rpb24pIC8gMikpO1xuICAgICAgICAgICAgaWYgKHRtcCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlUGF0dGVybihwYXR0ZXJuOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XG4gICAgICAgIHRoaXMuX3JvdyA9IHBhdHRlcm47XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuIGNhbGxpbmcgZGVjb2RlJywgdHlwZW9mIHRoaXMsIHRoaXMuY29uc3RydWN0b3IsIHRoaXMuRk9STUFULCBKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3QgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldmVyc2VkIHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLlJldmVyc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5zdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5Gb3J3YXJkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSB0aGlzLkZPUk1BVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoUmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPCAwID8gMCA6IHN0YXJ0O1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maWxsQ291bnRlcnMob2Zmc2V0OiBudW1iZXIgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KSwgZW5kOiBudW1iZXIgPSB0aGlzLl9yb3cubGVuZ3RoLCBpc1doaXRlID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdG9Db3VudGVycyhzdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkgfCBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbc3RhcnRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChjb3VudGVycywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBudW1Db3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZS9pbXBsZW1lbnQgdGhpcyBpbiB5b3VyIGN1c3RvbSByZWFkZXJzLlxuICAgIHByb3RlY3RlZCBkZWNvZGVJbWFnZShpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcik6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12b2lkXG4gICAgICAgIHZvaWQgaW1hZ2VXcmFwcGVyO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhcmNvZGVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5jb25zdCBTVEFSVF9QQVRURVJOID0gW1csIE4sIFcsIE4sIE4sIE5dO1xuY29uc3QgU1RPUF9QQVRURVJOID0gW1csIE4sIE4sIE4sIFddO1xuY29uc3QgQ09ERV9QQVRURVJOID0gW1xuICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgW04sIFcsIE4sIE4sIFddLFxuICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgW1csIE4sIFcsIE4sIE5dLFxuICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgW1csIE4sIE4sIFcsIE5dLFxuICAgIFtOLCBXLCBOLCBXLCBOXSxcbl07XG5jb25zdCBTVEFSVF9QQVRURVJOX0xFTkdUSCA9IFNUQVJUX1BBVFRFUk4ucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcblxuY2xhc3MgVHdvT2ZGaXZlUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcblxuICAgIEZPUk1BVCA9ICcyb2Y1JztcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcblxuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcblxuICAgIHByb3RlY3RlZCBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZSA9IGZhbHNlLCB0cnlIYXJkZXIgPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyW2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIFNUQVJUX1BBVFRFUk5fTEVOR1RIKTtcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDU7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBUT0RPOiByZXZlcnNlLCBmb2xsb3dlZCBieSBzb21lIGNhbGNzLCBmb2xsb3dlZCBieSBhbm90aGVyIHJldmVyc2U/IHJlYWxseT9cbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBDT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChgJHtjb2RlLmNvZGV9YCk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgICBpZiAoIWVuZEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUd29PZkZpdmVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuLy8gY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5LSQ6Ly4rQUJDRCc7XG5jb25zdCBBTFBIQUJFVCA9IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9XG4gICAgWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBTVEFSVF9FTkQgPSBbMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgTUlOX0VOQ09ERURfQ0hBUlMgPSA0O1xuY29uc3QgTUFYX0FDQ0VQVEFCTEUgPSAyLjA7XG5jb25zdCBQQURESU5HID0gMS41O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkU2l6ZSB7XG4gICAgc2l6ZTogbnVtYmVyLFxuICAgIGNvdW50czogbnVtYmVyLFxuICAgIG1pbjogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxufTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZCB7XG4gICAgc3BhY2U6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG4gICAgYmFyOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxufTtcblxuY2xhc3MgTmV3Q29kYWJhclJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9jb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIEZPUk1BVCA9ICdjb2RhYmFyJztcblxuICAgIHByb3RlY3RlZCBfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgICAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKG1pbiArIG1heCkgLyAyLjApIHwgMDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF90b1BhdHRlcm4ob2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSA3O1xuICAgICAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycztcblxuICAgICAgICBpZiAoZW5kID4gdGhpcy5fY291bnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXJUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0LCBlbmQpO1xuICAgICAgICBjb25zdCBzcGFjZVRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQgKyAxLCBlbmQpO1xuXG4gICAgICAgIGxldCBiaXRtYXNrID0gMSA8PCAobnVtQ291bnRlcnMgLSAxKTtcbiAgICAgICAgbGV0IHRocmVzaG9sZCA9IDA7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChpICYgMSkgPT09IDAgPyBiYXJUaHJlc2hvbGQgOiBzcGFjZVRocmVzaG9sZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyc1tvZmZzZXQgKyBpXSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gYml0bWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdG1hc2sgPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9pc1N0YXJ0RW5kKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNUQVJUX0VORC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9zdW1Db3VudGVycyhzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oaSk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiAhPT0gLTEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcbiAgICAgICAgICAgICAgICBzdGFydCArPSB0aGlzLl9zdW1Db3VudGVycygwLCBpKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKGksIGkgKyA4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXG4gICAgICAgICAgICAgICAgICAgIGVuZENvdW50ZXI6IGkgKyA4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgob2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDc7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0Q291bnRlcjogbnVtYmVyLCBlbmRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKChzdGFydENvdW50ZXIgLSAxIDw9IDApXG4gICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tzdGFydENvdW50ZXIgLSAxXSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgaWYgKChlbmRDb3VudGVyICsgOCA+PSB0aGlzLl9jb3VudGVycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbZW5kQ291bnRlciArIDddID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKGVuZENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jaGFyVG9QYXR0ZXJuKGNoYXI6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQUxQSEFCRVRbaV0gPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENIQVJBQ1RFUl9FTkNPRElOR1NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDB4MDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCBjYXRlZ29yaXphdGlvbjogVGhyZXNob2xkID0ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpZGU6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpZGU6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zID0gc3RhcnRDb3VudGVyO1xuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IChqICYgMSkgPT09IDIgPyBjYXRlZ29yaXphdGlvbi5iYXIgOiBjYXRlZ29yaXphdGlvbi5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY2F0LnNpemUgKz0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICAgICAgY2F0LmNvdW50cysrO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIChbJ3NwYWNlJywgJ2JhciddIGFzIGNvbnN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld2tpbmQgPSBjYXRlZ29yaXphdGlvbltrZXldO1xuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1pbiA9XG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigobmV3a2luZC5uYXJyb3cuc2l6ZSAvIG5ld2tpbmQubmFycm93LmNvdW50cyArIG5ld2tpbmQud2lkZS5zaXplIC8gbmV3a2luZC53aWRlLmNvdW50cykgLyAyKTtcbiAgICAgICAgICAgIG5ld2tpbmQubmFycm93Lm1heCA9IE1hdGguY2VpbChuZXdraW5kLndpZGUubWluKTtcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5tYXggPSBNYXRoLmNlaWwoKG5ld2tpbmQud2lkZS5zaXplICogTUFYX0FDQ0VQVEFCTEUgKyBQQURESU5HKSAvIG5ld2tpbmQud2lkZS5jb3VudHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2F0ZWdvcml6YXRpb247XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmFsaWRhdGVSZXN1bHQocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAwID8gdGhyZXNob2xkcy5iYXIgOiB0aHJlc2hvbGRzLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPCBjYXQubWluIHx8IHNpemUgPiBjYXQubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcblxuICAgICAgICB0aGlzLl9jb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycygpO1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcjtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihuZXh0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSA4O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgdGhpcy5fY291bnRlcnMubGVuZ3RoKTtcblxuICAgICAgICAvLyB2ZXJpZnkgZW5kXG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAtIDIpIDwgTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZCB3aGl0ZSBzcGFjZVxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRTdGFydCA9IG5leHRTdGFydCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA/IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA6IG5leHRTdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQuc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULCAvLyBUT0RPOiBpIHRoaW5rIGl0IHNob3VsZCBub3QgYmUgcmVxdWlyZWQgdG8gcmV0dXJuIGZvcm1hdCBmcm9tIHRoaXMsIGFzIGJhcmNvZGVfcmVhZGVyIGZvcmNlIHNldHMgdGhlIGZvcm1hdCBhbnl3YXlcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBOZXdDb2RhYmFyUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZUNvcnJlY3Rpb24sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgQ29kZTEyOFJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIENPREVfU0hJRlQgPSA5ODtcbiAgICBDT0RFX0MgPSA5OTtcbiAgICBDT0RFX0IgPSAxMDA7XG4gICAgQ09ERV9BID0gMTAxO1xuICAgIFNUQVJUX0NPREVfQSA9IDEwMztcbiAgICBTVEFSVF9DT0RFX0IgPSAxMDQ7XG4gICAgU1RBUlRfQ09ERV9DID0gMTA1O1xuICAgIFNUT1BfQ09ERSA9IDEwNjtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMywgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMywgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMywgMV0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMywgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMywgMV0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMywgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMywgMSwgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMywgMywgMSwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMywgMSwgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMywgMywgMiwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMywgMSwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgNCwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbNCwgMSwgMywgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMSwgNCwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMywgMywgMSwgMSwgMSwgMl0sXG4gICAgICAgIF07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjY0O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcbiAgICBGT1JNQVQgPSAnY29kZV8xMjgnO1xuICAgIE1PRFVMRV9JTkRJQ0VTID0geyBiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XSB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3QoY291bnRlciwgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmNvZGUgPT09IC0xIHx8IGJlc3RNYXRjaC5lcnJvciA+IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY29ycmVjdChjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBCYXJjb2RlQ29ycmVjdGlvbikge1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLnNwYWNlLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogX2ZpbmRTdGFydCBhbmQgZGVjb2RlQ29kZSBzaGFyZSBzaW1pbGFyIGNvZGUsIGNhbiB3ZSByZS11c2Ugc29tZT9cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSB0aGlzLlNUQVJUX0NPREVfQTsgY29kZSA8PSB0aGlzLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIC8vICAgICBkb25lID0gZmFsc2UsXG4gICAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIG11bHRpcGxpZXIgPSAwLFxuICAgICAgICAvLyAgICAgY2hlY2tzdW0gPSAwLFxuICAgICAgICAvLyAgICAgY29kZXNldCxcbiAgICAgICAgLy8gICAgIHJhd1Jlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHVuc2hpZnQsXG4gICAgICAgIC8vICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLmJhcixcbiAgICAgICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLnNwYWNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICBsZXQgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgICAgIGxldCBjb2Rlc2V0ID0gKChjOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShjb2RlLmNvZGUpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGxldCB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICBsZXQgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMDtcbiAgICAgICAgbGV0IHJhd1Jlc3VsdDogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0gW107IC8vIFRPRE86IGkgdGhpbmsgdGhpcyBzaG91bGQgYmUgc3RyaW5nIG9ubHksIGJ1dCBpdCBjcmVhdGVzIHByb2JsZW1zIGlmIGl0IGlzXG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlIS5lbmQsIGNvZGUhLmNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByYXdSZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyKys7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IG11bHRpcGxpZXIgKiBjb2RlLmNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rlc2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgPCAxMCA/ICcwJyArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gY29kZXNldCA9PT0gdGhpcy5DT0RFX0EgPyB0aGlzLkNPREVfQiA6IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZS5lbmQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGNvZGUpKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjaGVja3N1bSAlIDEwMyAhPT0gcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXG4gICAgICAgIGlmIChyZW1vdmVMYXN0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgY29kZXNldDogY29kZXNldCBhcyBudW1iZXIsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kSW5mbzogY29kZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZUluZm8gfCBudWxsIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgcHVibGljIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkICs9IG5vcm1hbGl6ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTEyOFJlYWRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IHR5cGUgQmFyY29kZVBvc2l0aW9uLCB0eXBlIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKChjaGFyKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LCAweDEwOSwgMHgwNDksXG4gICAgMHgxNDgsIDB4MDE5LCAweDExOCwgMHgwNTgsIDB4MDBELCAweDEwQywgMHgwNEMsIDB4MDFDLCAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsXG4gICAgMHgwNDYsIDB4MDE2LCAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDA5NCwgMHgwQTgsIDB4MEEyLCAweDA4QSwgMHgwMkEsXG5dKTtcbmNvbnN0IEFTVEVSSVNLID0gMHgwOTQ7XG5cbmNsYXNzIENvZGUzOVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5JztcblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1heE5hcnJvd1dpZHRoID0gMDtcbiAgICAgICAgbGV0IG51bVdpZGVCYXJzID0gbnVtQ291bnRlcnM7XG4gICAgICAgIGxldCB3aWRlQmFyV2lkdGggPSAwO1xuXG4gICAgICAgIHdoaWxlIChudW1XaWRlQmFycyA+IDMpIHtcbiAgICAgICAgICAgIG1heE5hcnJvd1dpZHRoID0gdGhpcy5fZmluZE5leHRXaWR0aChjb3VudGVycywgbWF4TmFycm93V2lkdGgpO1xuICAgICAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiBudW1XaWRlQmFycyA+IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlcnNbaV0gKiAyKSA+PSB3aWRlQmFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZE5leHRXaWR0aChjb3VudGVyczogVWludDE2QXJyYXksIGN1cnJlbnQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBtaW5XaWR0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldIDwgbWluV2lkdGggJiYgY291bnRlcnNbaV0gPiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW5XaWR0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcGF0dGVyblNpemUgPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xuICAgICAgICBpZiAoKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCAqIDMpID49IHBhdHRlcm5TaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZSgpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0OiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTxBcnJheUJ1ZmZlcj47XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBBRUlPOiAvW0FFSU9dL2csXG4gICAgQVowOTogL1tBLVowLTldLyxcbn07XG5cbmNvbnN0IGNvZGUzMnNldCA9ICcwMTIzNDU2Nzg5QkNERkdISktMTU5QUVJTVFVWV1hZWic7XG5cbmNsYXNzIENvZGUzMlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzJfcmVhZGVyJztcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZTMyKGNvZGU6IHN0cmluZykge1xuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcyAqIDMyICsgY29kZTMyc2V0LmluZGV4T2YoY29kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGUzMiA9IGAke3Jlc31gO1xuICAgICAgICBpZiAoY29kZTMyLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnQScgKyBjb2RlMzI7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIHByb3RlY3RlZCBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhY29kZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGUgPSByZXN1bHQuY29kZTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUzMiA9IHRoaXMuX2RlY29kZUNvZGUzMihjb2RlKTtcblxuICAgICAgICBpZiAoIWNvZGUzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGUzMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzMlJlYWRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCB7IEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIElPUTogL1tJT1FdL2csXG4gICAgQVowOTogL1tBLVowLTldezE3fS8sXG59O1xuXG5jbGFzcyBDb2RlMzlWSU5SZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5X3Zpbic7XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgcHJvdGVjdGVkIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIC8vIENyaWJiZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuICAgIHB1YmxpYyBkZWNvZGUoKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHsgY29kZSB9ID0gcmVzdWx0O1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLklPUSwgJycpO1xuXG4gICAgICAgIGlmICghY29kZS5tYXRjaChwYXR0ZXJucy5BWjA5KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgQVowOSBwYXR0ZXJuIGNvZGU6JywgY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXG4gICAgMHgxQTgsIDB4MUE0LCAweDFBMiwgMHgxOTQsIDB4MTkyLCAweDE4QSwgMHgxNjgsIDB4MTY0LCAweDE2MiwgMHgxMzQsXG4gICAgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXG4gICAgMHgxNkUsIDB4MTc2LCAweDFBRSwgMHgxMjYsIDB4MURBLCAweDFENiwgMHgxMzIsIDB4MTVFLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xuXG5jbGFzcyBDb2RlOTNSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XG4gICAgcHJvdGVjdGVkIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VtID0gY291bnRlcnMucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkID0gTWF0aC5yb3VuZChjb3VudGVyc1tpXSAqIDkgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gKHBhdHRlcm4gPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA8PD0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5RW5kKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KTogc3RyaW5nW10gfCBudWxsIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2hhckFycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBjaGFyQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAnZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBuZXh0Q2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnRicgJiYgbmV4dENoYXIgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgNDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnVCcgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIGNvZGVfOTNfcmVhZGVyIF9kZWNvZGVFeHRlbmRlZCBoaXQgZGVmYXVsdCBjYXNlLCB0aGlzIG1heSBiZSBhbiBlcnJvcicsIGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+LCBpbmRleDogbnVtYmVyLCBtYXhXZWlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBhcnJheVRvQ2hlY2sgPSBjaGFyQXJyYXkuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xuICAgICAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9ICgoKGkgKiAtMSkgKyAobGVuZ3RoIC0gMSkpICUgbWF4V2VpZ2h0KSArIDE7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEFMUEhBQkVULmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyAod2VpZ2h0ICogdmFsdWUpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBjb25zdCBjaGVja0NoYXIgPSBBTFBIQUJFVFsod2VpZ2h0ZWRTdW1zICUgNDcpXTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNoZWNrc3VtcyhjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDIsIDIwKVxuICAgICAgICAgICAgJiYgdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMSwgMTUpO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiB8IG51bGwgPSBbXTtcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0O1xuICAgICAgICBsZXQgZGVjb2RlZENoYXI6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTxBcnJheUJ1ZmZlcj47XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUVuZChsYXN0U3RhcnQsIG5leHRTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgICAgICAvLyB5ZXMsIHRoaXMgaXMgYW4gYXNzaWduIGluc2lkZSBhbiBpZi5cbiAgICAgICAgaWYgKChyZXN1bHQgPSB0aGlzLl9kZWNvZGVFeHRlbmRlZChyZXN1bHQpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlOTNSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcbmNvbnN0IENPREVfR19TVEFSVCA9IDEwO1xuZXhwb3J0IHsgQ09ERV9HX1NUQVJUIH07XG5jb25zdCBTVEFSVF9QQVRURVJOID0gWzEsIDEsIDFdO1xuY29uc3QgTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XG5leHBvcnQgeyBNSURETEVfUEFUVEVSTiB9O1xuY29uc3QgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMl07XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgWzMsIDIsIDEsIDFdLFxuICAgIFsyLCAyLCAyLCAxXSxcbiAgICBbMiwgMSwgMiwgMl0sXG4gICAgWzEsIDQsIDEsIDFdLFxuICAgIFsxLCAxLCAzLCAyXSxcbiAgICBbMSwgMiwgMywgMV0sXG4gICAgWzEsIDEsIDEsIDRdLFxuICAgIFsxLCAzLCAxLCAyXSxcbiAgICBbMSwgMiwgMSwgM10sXG4gICAgWzMsIDEsIDEsIDJdLFxuICAgIFsxLCAxLCAyLCAzXSxcbiAgICBbMSwgMiwgMiwgMl0sXG4gICAgWzIsIDIsIDEsIDJdLFxuICAgIFsxLCAxLCA0LCAxXSxcbiAgICBbMiwgMywgMSwgMV0sXG4gICAgWzEsIDMsIDIsIDFdLFxuICAgIFs0LCAxLCAxLCAxXSxcbiAgICBbMiwgMSwgMywgMV0sXG4gICAgWzMsIDEsIDIsIDFdLFxuICAgIFsyLCAxLCAxLCAzXSxcbl07XG5jb25zdCBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbmNvbnN0IEFWR19DT0RFX0VSUk9SID0gMC40ODtcblxuY2xhc3MgRUFOUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8xMyc7XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxLCAxLCAxXTsgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICBzdXBlcihtZXJnZSh7IHN1cHBsZW1lbnRzOiBbXSB9LCBjb25maWcpLCBzdXBwbGVtZW50cyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm4nLCBwYXR0ZXJuLCBvZmZzZXQsIGlzV2hpdGUsIHRyeUhhcmRlciwgZXBzaWxvbik7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uICYmIGJlc3RNYXRjaC5lcnJvciAmJiBlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gY291bnRlci5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBmaW5kUGF0dGVybiBhbmQgZGVjb2RlQ29kZSBhcHBlYXIgdG8gc2hhcmUgcXVpdGUgc2ltaWxhciBjb2RlLCBjYW4gaXQgYmUgcmVkdWNlZD9cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29kZXJhbmdlPzogbnVtYmVyKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUnLCBzdGFydCwgY29kZXJhbmdlKTtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZUluZm8gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgaWYgKCFjb2RlcmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGJlZm9yZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIGNvZGVyYW5nZSA9IENPREVfUEFUVEVSTi5sZW5ndGg7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBhZnRlciBsZW5ndGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBjb2RlcmFuZ2U7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFN0YXJ0Jyk7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBzdGFydEluZm89JywgSlNPTi5zdHJpbmdpZnkoc3RhcnRJbmZvKSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpO1xuXG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIHN0YXJ0SW5mbycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBjYWxjdWxhdGVGaXJzdERpZ2l0JywgY29kZUZyZXF1ZW5jeSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDT0RFX0ZSRVFVRU5DWVtpXSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXlsb2FkJywgaW5Db2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9Jywgb3V0Q29kZSk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtPSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMCA8PCAoNSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaXJzdERpZ2l0ID0gdGhpcy5fY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0RGlnaXQ9JywgZmlyc3REaWdpdCk7XG4gICAgICAgIGlmIChmaXJzdERpZ2l0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoZmlyc3REaWdpdCk7XG5cbiAgICAgICAgbGV0IG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgb3V0Q29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcblxuICAgICAgICBpZiAobWlkZGxlUGF0dGVybiA9PT0gbnVsbCB8fCAhbWlkZGxlUGF0dGVybi5lbmQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2RlY29kZUNvZGUobWlkZGxlUGF0dGVybiEuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgICAgICBpZiAoIW1pZGRsZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgobWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIHJlc3VsdD0nLCBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVkQ29kZXM9JywgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgcmV0dXJuIG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm87XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB2ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCk7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kRW5kJywgb2Zmc2V0LCBpc1doaXRlKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGlzV2hpdGUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIF9jaGVja3N1bScsIHJlc3VsdCk7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gKj0gMztcblxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjaGVja3N1bScsIHN1bSAlIDEwID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RlY29kZUV4dGVuc2lvbnMob2Zmc2V0OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBzdGFydCwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zJywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGVyZSBhcmUgJywgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGgsICcgc3VwcGxlbWVudHMnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZXh0ZW5zaW9ucyBsb29wJywgaSwgdGhpcy5zdXBwbGVtZW50c1tpXSwgdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3VwcGxlbWVudHNbaV0uZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZSByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnN1cHBsZW1lbnRzW2ldLkZPUk1BVCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIGRlY29kZUV4dGVuc2lvbnMgZXJyb3IgaW4gJywgdGhpcy5zdXBwbGVtZW50c1tpXSwgJzogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgcm93KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPigpO1xuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XG4gICAgICAgIGxldCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZVBvc2l0aW9uIHwgQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxuICAgICAgICB9O1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIC8vIENoZWNrc3VtXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhpcy5zdXBwbGVtZW50cz0nLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcGxlbWVudCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMgcmV0dXJucycsIHN1cHBsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdENvZGUgPSBzdXBwbGVtZW50LmRlY29kZWRDb2Rlc1tzdXBwbGVtZW50LmRlY29kZWRDb2Rlcy5sZW5ndGggLSAxXSBhcyBCYXJjb2RlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSArIHN1cHBsZW1lbnQuY29kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5cbmNsYXNzIEVBTjJSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fMic7XG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbignJykpICUgNCkgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjJSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IENIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsyNCwgMjAsIDE4LCAxNywgMTIsIDYsIDMsIDEwLCA5LCA1XTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENIRUNLX0RJR0lUX0VOQ09ESU5HU1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIHJldHVybiBzdW0gJSAxMDtcbn1cblxuY2xhc3MgRUFONVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl81JztcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDQgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkgIT09IGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjVSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCwgTUlERExFX1BBVFRFUk4gfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzgnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gaW5Db2RlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcbiIsIi8vIFRPRE86IGkyb2Y1X3JlYWRlciBhbmQgMm9mNV9yZWFkZXIgc2hhcmUgdmVyeSBzaW1pbGFyIGNvZGUsIG1ha2UgdXNlIG9mIHRoYXRcblxuaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5cbmNsYXNzIEkyb2Y1UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgcHJpdmF0ZSBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzg7XG5cbiAgICBTVEFSVF9QQVRURVJOID0gW04sIE4sIE4sIE5dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFtOLCBOLCBXXTtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICAgICAgW1csIE4sIE4sIE4sIFddLFxuICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIFcsIE4sIFddLFxuICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIE4sIFcsIFddLFxuICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgIFtOLCBXLCBOLCBXLCBOXSxcbiAgICBdO1xuICAgIE1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiA9IDU7XG4gICAgRk9STUFUID0gJ2kyb2Y1JztcblxuICAgIGNvbnN0cnVjdG9yKG9wdHM6IEJhcmNvZGVSZWFkZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiBmYWxzZSB9LCBvcHRzKSk7XG4gICAgICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuU0lOR0xFX0NPREVfRVJST1IgPSAwLjM4O1xuICAgICAgICAgICAgdGhpcy5BVkdfQ09ERV9FUlJPUiA9IDAuMDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoUGF0dGVybihjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlclN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvID0gdGhpcy5NQVhfQ09SUkVDVElPTl9GQUNUT1I7XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlID0gMSAvIGNvcnJlY3Rpb25SYXRpbztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclN1bVtpICUgMl0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xuXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblsxXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIGNvZGUpO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuID0gZmFsc2UsIHRyeUhhcmRlcjogYm9vbGVhbiA9IGZhbHNlKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgQXJyYXk8bnVtYmVyPihwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaXNXaGl0ZSA9IGlzV2hpdGUgfHwgZmFsc2U7XG4gICAgICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIDQpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZEVuZCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyOiBBcnJheTxBcnJheTxudW1iZXI+Pik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xuICAgICAgICBjb25zdCBjb2RlczogQXJyYXk8QmFyY29kZUluZm8+ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKGNvdW50ZXI6IEFycmF5PG51bWJlcj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVJbmZvID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlclBhaXIgPSBbWzAsIDAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMCwgMF1dO1xuICAgICAgICBsZXQgY29kZXM6IEJhcmNvZGVJbmZvW10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMV1baV0gPSBjb3VudGVyc1twb3MgKyAxXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1sxXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzID0gdGhpcy5fZGVjb2RlUGFpcihjb3VudGVyUGFpcik7XG4gICAgICAgICAgICBpZiAoIWNvZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZXNbaV0uY29kZSArICcnKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4oKTtcblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHxcbiAgICAgICAgICAgICAgICByZXN1bHQubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbi8qKlxuICogUGhhcm1hY29kZSAoUGhhcm1hY2V1dGljYWwgQmluYXJ5IENvZGUpIFJlYWRlclxuICpcbiAqIFBoYXJtYWNvZGUgaXMgYSBiaW5hcnkgYmFyY29kZSB1c2VkIGluIHBoYXJtYWNldXRpY2FsIHBhY2thZ2luZy5cbiAqIEl0IGVuY29kZXMgbnVtYmVycyBmcm9tIDMgdG8gMTMxMDcwIHVzaW5nIG5hcnJvdyBhbmQgd2lkZSBiYXJzLlxuICpcbiAqIEVuY29kaW5nIHJ1bGVzOlxuICogLSBSZWFkaW5nIGZyb20gcmlnaHQgdG8gbGVmdCAobGVhc3Qgc2lnbmlmaWNhbnQgZmlyc3QpXG4gKiAtIE5hcnJvdyBiYXIgYXQgcG9zaXRpb24gaSBhZGRzIDJeaSB0byB0aGUgdmFsdWVcbiAqIC0gV2lkZSBiYXIgYXQgcG9zaXRpb24gaSBhZGRzIDJeKGkrMSkgdG8gdGhlIHZhbHVlXG4gKiAtIEJhcnMgYXJlIHNlcGFyYXRlZCBieSB1bmlmb3JtLXdpZHRoIHNwYWNlc1xuICogLSBNaW5pbXVtIDIgYmFycywgbWF4aW11bSAxNiBiYXJzXG4gKiAtIFZhbGlkIHJhbmdlOiAzIHRvIDEzMTA3MFxuICpcbiAqIEV4YW1wbGU6IFZhbHVlIDc1NVxuICogQmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIGJhcnMgKGZyb20gbGVmdCB0byByaWdodCBpbiBiYXJjb2RlKTpcbiAqIHdpZGUsIG5hcnJvdywgd2lkZSwgbmFycm93LCBuYXJyb3csIHdpZGUsIG5hcnJvdywgd2lkZSwgbmFycm93XG4gKlxuICogUmVmZXJlbmNlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaGFybWFjb2RlXG4gKi9cblxuLy8gTWluaW11bSBudW1iZXIgb2YgYmFycyBpbiBhIHZhbGlkIFBoYXJtYWNvZGVcbmNvbnN0IE1JTl9CQVJfQ09VTlQgPSAyO1xuLy8gTWF4aW11bSBudW1iZXIgb2YgYmFycyBpbiBhIHZhbGlkIFBoYXJtYWNvZGVcbmNvbnN0IE1BWF9CQVJfQ09VTlQgPSAxNjtcbi8vIE1pbmltdW0gdmFsaWQgUGhhcm1hY29kZSB2YWx1ZVxuY29uc3QgTUlOX1ZBTFVFID0gMztcbi8vIE1heGltdW0gdmFsaWQgUGhhcm1hY29kZSB2YWx1ZVxuY29uc3QgTUFYX1ZBTFVFID0gMTMxMDcwO1xuXG4vLyBUaHJlc2hvbGQgcmF0aW8gdG8gZGlzdGluZ3Vpc2ggbmFycm93IGZyb20gd2lkZSBiYXJzXG4vLyBBIGJhciB3aWRlciB0aGFuIHRoaXMgcmF0aW8gb2YgdGhlIG5hcnJvdyBiYXIgd2lkdGggaXMgY29uc2lkZXJlZCB3aWRlXG5jb25zdCBXSURFX0JBUl9USFJFU0hPTEQgPSAxLjc1O1xuXG4vLyBNYXhpbXVtIGFsbG93ZWQgdmFyaWF0aW9uIGluIHNwYWNlIHdpZHRocyAoY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uKVxuY29uc3QgTUFYX1NQQUNFX1ZBUklBTkNFID0gMC40O1xuXG4vLyBNYXhpbXVtIGFsbG93ZWQgdmFyaWF0aW9uIGluIG5hcnJvdyBiYXIgd2lkdGhzXG5jb25zdCBNQVhfTkFSUk9XX0JBUl9WQVJJQU5DRSA9IDAuNDtcblxuY2xhc3MgUGhhcm1hY29kZVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdwaGFybWFjb2RlJztcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43O1xuXG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjQ4O1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBzdGFydCBvZiB0aGUgYmFyY29kZSAoZmlyc3QgYmxhY2sgYmFyIGFmdGVyIGxlYWRpbmcgd2hpdGVzcGFjZSlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBpZiAob2Zmc2V0ID49IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYmxhY2sgYmFyXG4gICAgICAgIGNvbnN0IGJhclN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBsZXQgYmFyRW5kID0gYmFyU3RhcnQ7XG4gICAgICAgIHdoaWxlIChiYXJFbmQgPCB0aGlzLl9yb3cubGVuZ3RoICYmIHRoaXMuX3Jvd1tiYXJFbmRdKSB7XG4gICAgICAgICAgICBiYXJFbmQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXJFbmQgPT09IGJhclN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGVyZSdzIHNvbWUgbGVhZGluZyB3aGl0ZXNwYWNlIChxdWlldCB6b25lKVxuICAgICAgICBjb25zdCBiYXJXaWR0aCA9IGJhckVuZCAtIGJhclN0YXJ0O1xuICAgICAgICBjb25zdCBxdWlldFpvbmVTdGFydCA9IE1hdGgubWF4KDAsIGJhclN0YXJ0IC0gYmFyV2lkdGggKiAyKTtcbiAgICAgICAgaWYgKGJhclN0YXJ0ID4gMCAmJiAhdGhpcy5fbWF0Y2hSYW5nZShxdWlldFpvbmVTdGFydCwgYmFyU3RhcnQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogYmFyU3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGJhckVuZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGFsbCBiYXIgYW5kIHNwYWNlIHdpZHRocyBmcm9tIHRoZSBwYXR0ZXJuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9leHRyYWN0QmFyc0FuZFNwYWNlcyhzdGFydFBvczogbnVtYmVyKTogeyBiYXJzOiBudW1iZXJbXSwgc3BhY2VzOiBudW1iZXJbXSwgZW5kOiBudW1iZXIgfSB8IG51bGwge1xuICAgICAgICBjb25zdCBiYXJzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBjb25zdCBzcGFjZXM6IG51bWJlcltdID0gW107XG5cbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0UG9zO1xuICAgICAgICBsZXQgaXNCYXIgPSB0cnVlO1xuICAgICAgICBsZXQgY3VycmVudFdpZHRoID0gMDtcblxuICAgICAgICAvLyBTdGFydCB3aXRoIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMuX3Jvdy5sZW5ndGggJiYgdGhpcy5fcm93W3Bvc10pIHtcbiAgICAgICAgICAgIGN1cnJlbnRXaWR0aCsrO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmFycy5wdXNoKGN1cnJlbnRXaWR0aCk7XG5cbiAgICAgICAgLy8gQ29udGludWUgZXh0cmFjdGluZyBhbHRlcm5hdGluZyBzcGFjZXMgYW5kIGJhcnNcbiAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMuX3Jvdy5sZW5ndGggJiYgYmFycy5sZW5ndGggPD0gTUFYX0JBUl9DT1VOVCkge1xuICAgICAgICAgICAgY3VycmVudFdpZHRoID0gMDtcbiAgICAgICAgICAgIGlzQmFyID0gIWlzQmFyO1xuXG4gICAgICAgICAgICBpZiAoaXNCYXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VudGluZyBhIGJhclxuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLl9yb3cubGVuZ3RoICYmIHRoaXMuX3Jvd1twb3NdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCsrO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmQgb2YgYmFyY29kZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmFycy5wdXNoKGN1cnJlbnRXaWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvdW50aW5nIGEgc3BhY2VcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5fcm93Lmxlbmd0aCAmJiAhdGhpcy5fcm93W3Bvc10pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFdpZHRoKys7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIG1pZ2h0IGJlIHRoZSB0cmFpbGluZyBxdWlldCB6b25lXG4gICAgICAgICAgICAgICAgLy8gQSB2ZXJ5IGxhcmdlIHNwYWNlIGxpa2VseSBtZWFucyBlbmQgb2YgYmFyY29kZVxuICAgICAgICAgICAgICAgIGlmIChzcGFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmdTcGFjZSA9IHNwYWNlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggPiBhdmdTcGFjZSAqIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IHRoZSBxdWlldCB6b25lLCBub3QgYW4gaW50ZXItYmFyIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFjZXMucHVzaChjdXJyZW50V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgYmFyIGNvdW50XG4gICAgICAgIGlmIChiYXJzLmxlbmd0aCA8IE1JTl9CQVJfQ09VTlQgfHwgYmFycy5sZW5ndGggPiBNQVhfQkFSX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIChuLTEpIHNwYWNlcyBmb3IgbiBiYXJzXG4gICAgICAgIGlmIChzcGFjZXMubGVuZ3RoICE9PSBiYXJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgYmFycywgc3BhY2VzLCBlbmQ6IHBvcyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHNwYWNlIHdpZHRocyBhcmUgdW5pZm9ybSBlbm91Z2ggZm9yIGEgdmFsaWQgUGhhcm1hY29kZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfdmFsaWRhdGVTcGFjZXMoc3BhY2VzOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoc3BhY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNpbmdsZSBiYXIgKHRob3VnaCBpbnZhbGlkIGZvciBQaGFybWFjb2RlKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVhbiA9IHNwYWNlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNwYWNlcy5sZW5ndGg7XG4gICAgICAgIGlmIChtZWFuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uXG4gICAgICAgIGNvbnN0IHZhcmlhbmNlID0gc3BhY2VzLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0gKyBNYXRoLnBvdyhzIC0gbWVhbiwgMiksIDApIC8gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICAgICAgY29uc3QgY3YgPSBzdGREZXYgLyBtZWFuO1xuXG4gICAgICAgIHJldHVybiBjdiA8PSBNQVhfU1BBQ0VfVkFSSUFOQ0U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhc3NpZnkgYmFycyBhcyBuYXJyb3cgb3Igd2lkZSBhbmQgZGVjb2RlIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVjb2RlQmFycyhiYXJzOiBudW1iZXJbXSk6IHsgdmFsdWU6IG51bWJlciB9IHwgbnVsbCB7XG4gICAgICAgIC8vIEZpbmQgdGhlIG1pbmltdW0gYmFyIHdpZHRoIChsaWtlbHkgbmFycm93IGJhcilcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBNYXRoLm1pbiguLi5iYXJzKTtcblxuICAgICAgICAvLyBJZiBhbGwgYmFycyBhcmUgc2ltaWxhciB3aWR0aCwgaXQgbWlnaHQgYmUgYSB2YWxpZCBQaGFybWFjb2RlIHdpdGggYWxsIG5hcnJvdyBvciBhbGwgd2lkZSBiYXJzXG4gICAgICAgIC8vIEJ1dCB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGUgdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG1pbldpZHRoICogV0lERV9CQVJfVEhSRVNIT0xEO1xuXG4gICAgICAgIC8vIFNlcGFyYXRlIGJhcnMgaW50byBuYXJyb3cgYW5kIHdpZGUgZm9yIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgbmFycm93QmFyczogbnVtYmVyW10gPSBbXTtcblxuICAgICAgICBiYXJzLmZvckVhY2god2lkdGggPT4ge1xuICAgICAgICAgICAgaWYgKHdpZHRoIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIG5hcnJvd0JhcnMucHVzaCh3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIG5hcnJvdyBiYXIgY29uc2lzdGVuY3lcbiAgICAgICAgaWYgKG5hcnJvd0JhcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmFycm93TWVhbiA9IG5hcnJvd0JhcnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBuYXJyb3dCYXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG5hcnJvd1ZhcmlhbmNlID0gbmFycm93QmFycy5yZWR1Y2UoKHN1bSwgdykgPT4gc3VtICsgTWF0aC5wb3codyAtIG5hcnJvd01lYW4sIDIpLCAwKSAvIG5hcnJvd0JhcnMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbmFycm93Q3YgPSBNYXRoLnNxcnQobmFycm93VmFyaWFuY2UpIC8gbmFycm93TWVhbjtcbiAgICAgICAgICAgIGlmIChuYXJyb3dDdiA+IE1BWF9OQVJST1dfQkFSX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIFBoYXJtYWNvZGUgdmFsdWUgdXNpbmcgdGhlIGNvcnJlY3QgYWxnb3JpdGhtXG4gICAgICAgIC8vIFJlYWRpbmcgZnJvbSByaWdodCB0byBsZWZ0IChyZXZlcnNlIHRoZSBiYXJzIGFycmF5KVxuICAgICAgICAvLyBGb3IgZWFjaCBiYXI6IHZhbHVlID0gdmFsdWUgKiAyICsgKDEgZm9yIG5hcnJvdywgMiBmb3Igd2lkZSlcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gYmFycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgaXNXaWRlID0gYmFyc1tpXSA+IHRocmVzaG9sZDtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAyICsgKGlzV2lkZSA/IDIgOiAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRyYWlsaW5nIHdoaXRlc3BhY2UgKHF1aWV0IHpvbmUpXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kOiBudW1iZXIsIGJhcldpZHRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gTWF0aC5taW4oZW5kICsgYmFyV2lkdGggKiAyLCB0aGlzLl9yb3cubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoUmFuZ2UoZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoZSBiYXJjb2RlXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRyYWN0IGJhcnMgYW5kIHNwYWNlc1xuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB0aGlzLl9leHRyYWN0QmFyc0FuZFNwYWNlcyhzdGFydEluZm8uc3RhcnQpO1xuICAgICAgICBpZiAoIWV4dHJhY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGJhcnMsIHNwYWNlcywgZW5kIH0gPSBleHRyYWN0ZWQ7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgc3BhY2UgdW5pZm9ybWl0eVxuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlU3BhY2VzKHNwYWNlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjb2RlIHRoZSBiYXJzXG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB0aGlzLl9kZWNvZGVCYXJzKGJhcnMpO1xuICAgICAgICBpZiAoIWRlY29kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gZGVjb2RlZDtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB2YWx1ZSByYW5nZVxuICAgICAgICBpZiAodmFsdWUgPCBNSU5fVkFMVUUgfHwgdmFsdWUgPiBNQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgY29uc3QgYXZnQmFyV2lkdGggPSBiYXJzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gYmFycy5sZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZCwgYXZnQmFyV2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBTb2Z0IGZhaWwgLSBhbGxvdyBidXQgbm90ZSBpdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIGRlY29kZWQgY29kZXMgYXJyYXkgZm9yIGRlYnVnZ2luZy92aXN1YWxpemF0aW9uXG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8+ID0gYmFycy5tYXAoKHdpZHRoLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgIGNvZGU6IHdpZHRoID4gKE1hdGgubWluKC4uLmJhcnMpICogV0lERV9CQVJfVEhSRVNIT0xEKSA/IDEgOiAwLFxuICAgICAgICAgICAgc3RhcnQ6IDAsIC8vIENvdWxkIGNhbGN1bGF0ZSBhY3R1YWwgcG9zaXRpb25zIGlmIG5lZWRlZFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgZXJyb3I6IDAsXG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogdmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGhhcm1hY29kZVJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDRVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgQ09ERV9GUkVRVUVOQ1kgPSBbXG4gICAgICAgIFsgNTYsIDUyLCA1MCwgNDksIDQ0LCAzOCwgMzUsIDQyLCA0MSwgMzcgXSxcbiAgICAgICAgWzcsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdXTtcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogN107XG4gICAgRk9STUFUID0gJ3VwY19lJztcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA9IChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gKDEgPDwgKDUgLSBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0Q29kZSBhcyBCYXJjb2RlSW5mbztcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeTogbnVtYmVyLCByZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgZm9yIChsZXQgbnJTeXN0ZW0gPSAwOyBuclN5c3RlbSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBuclN5c3RlbSsrKXtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV1baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQobnJTeXN0ZW0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jb252ZXJ0VG9VUENBKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgdXBjYSA9IFtyZXN1bHRbMF1dO1xuICAgICAgICBjb25zdCBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xuXG4gICAgICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCAzKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtsYXN0RGlnaXQsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDMsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDMpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNCkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoNCwgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA1KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwLCByZXN1bHRbNV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNikpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgbGFzdERpZ2l0XSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGNhLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiB1cGNhO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2NoZWNrc3VtKHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBzdXBlci5fZmluZEVuZChvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBVUENFUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIFVQQ1JlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ3VwY19hJztcbiAgICBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEVBTlJlYWRlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY29kZSAmJiByZXN1bHQuY29kZS5sZW5ndGggPT09IDEzICYmIHJlc3VsdC5jb2RlLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XG4iLCJjb25zdCBCcmVzZW5oYW0gPSB7fTtcblxuY29uc3QgU2xvcGUgPSB7XG4gICAgRElSOiB7XG4gICAgICAgIFVQOiAxLFxuICAgICAgICBET1dOOiAtMSxcbiAgICB9LFxufTtcbi8qKlxuICogU2NhbnMgYSBsaW5lIG9mIHRoZSBnaXZlbiBpbWFnZSBmcm9tIHBvaW50IHAxIHRvIHAyIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nXG4gKiBncmF5LXNjYWxlIHZhbHVlcyAoMC0yNTUpIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVscyBpbiBhZGRpdGlvbiB0byB0aGUgbWluXG4gKiBhbmQgbWF4IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSBUaGUgc3RhcnQgcG9pbnQge3gseX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiBUaGUgZW5kIHBvaW50IHt4LHl9XG4gKiBAcmV0dXJucyB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZSA9IGZ1bmN0aW9uIChpbWFnZVdyYXBwZXIsIHAxLCBwMikge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBsZXQgeDAgPSBwMS54IHwgMDtcbiAgICBsZXQgeTAgPSBwMS55IHwgMDtcbiAgICBsZXQgeDEgPSBwMi54IHwgMDtcbiAgICBsZXQgeTEgPSBwMi55IHwgMDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3Qgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApO1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgeTtcbiAgICBsZXQgdG1wO1xuICAgIGxldCB4O1xuICAgIGNvbnN0IGxpbmUgPSBbXTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHZhbDtcbiAgICBsZXQgbWluID0gMjU1O1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVhZChhLCBiKSB7XG4gICAgICAgIHZhbCA9IGltYWdlRGF0YVtiICogd2lkdGggKyBhXTtcbiAgICAgICAgbWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuICAgICAgICBtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG4gICAgICAgIGxpbmUucHVzaCh2YWwpO1xuICAgIH1cblxuICAgIGlmIChzdGVlcCkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB5MDtcbiAgICAgICAgeTAgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geDE7XG4gICAgICAgIHgxID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBpZiAoeDAgPiB4MSkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgeDEgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geTA7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKHkxIC0geTApO1xuICAgIGVycm9yID0gKGRlbHRhWCAvIDIpIHwgMDtcbiAgICB5ID0geTA7XG4gICAgY29uc3QgeVN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xO1xuICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgICAgIHJlYWQoeSwgeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yIC09IGRlbHRhWTtcbiAgICAgICAgaWYgKGVycm9yIDwgMCkge1xuICAgICAgICAgICAgeSArPSB5U3RlcDtcbiAgICAgICAgICAgIGVycm9yICs9IGRlbHRhWDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4LFxuICAgIH07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSByZXN1bHQgZnJvbSBnZXRCYXJjb2RlTGluZSBpbnRvIGEgYmluYXJ5IHJlcHJlc2VudGF0aW9uXG4gKiBhbHNvIGNvbnNpZGVyaW5nIHRoZSBmcmVxdWVuY3kgYW5kIHNsb3BlIG9mIHRoZSBzaWduYWwgZm9yIG1vcmUgcm9idXN0IHJlc3VsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQge2xpbmUsIG1pbiwgbWF4fVxuICovXG5CcmVzZW5oYW0udG9CaW5hcnlMaW5lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGNvbnN0IHsgbWluIH0gPSByZXN1bHQ7XG4gICAgY29uc3QgeyBtYXggfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IGxpbmUgfSA9IHJlc3VsdDtcbiAgICBsZXQgc2xvcGU7XG4gICAgbGV0IHNsb3BlMjtcbiAgICBjb25zdCBjZW50ZXIgPSBtaW4gKyAobWF4IC0gbWluKSAvIDI7XG4gICAgY29uc3QgZXh0cmVtYSA9IFtdO1xuICAgIGxldCBjdXJyZW50RGlyO1xuICAgIGxldCBkaXI7XG4gICAgbGV0IHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTI7XG4gICAgY29uc3QgclRocmVzaG9sZCA9IC10aHJlc2hvbGQ7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG5cbiAgICAvLyAxLiBmaW5kIGV4dHJlbWFcbiAgICBjdXJyZW50RGlyID0gbGluZVswXSA+IGNlbnRlciA/IFNsb3BlLkRJUi5VUCA6IFNsb3BlLkRJUi5ET1dOO1xuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogMCxcbiAgICAgICAgdmFsOiBsaW5lWzBdLFxuICAgIH0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICBzbG9wZSA9IChsaW5lW2kgKyAxXSAtIGxpbmVbaV0pO1xuICAgICAgICBzbG9wZTIgPSAobGluZVtpICsgMl0gLSBsaW5lW2kgKyAxXSk7XG4gICAgICAgIGlmICgoc2xvcGUgKyBzbG9wZTIpIDwgclRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA8IChjZW50ZXIgKiAxLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuRE9XTjtcbiAgICAgICAgfSBlbHNlIGlmICgoc2xvcGUgKyBzbG9wZTIpID4gdGhyZXNob2xkICYmIGxpbmVbaSArIDFdID4gKGNlbnRlciAqIDAuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5VUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpciA9IGN1cnJlbnREaXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudERpciAhPT0gZGlyKSB7XG4gICAgICAgICAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICB2YWw6IGxpbmVbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSBkaXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiBsaW5lLmxlbmd0aCxcbiAgICAgICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGogPSBleHRyZW1hWzBdLnBvczsgaiA8IGV4dHJlbWFbMV0ucG9zOyBqKyspIHtcbiAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiBjZW50ZXIgPyAwIDogMTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XG4gICAgZm9yIChpID0gMTsgaSA8IGV4dHJlbWEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChleHRyZW1hW2kgKyAxXS52YWwgPiBleHRyZW1hW2ldLnZhbCkge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaV0udmFsICsgKChleHRyZW1hW2kgKyAxXS52YWwgLSBleHRyZW1hW2ldLnZhbCkgLyAzKSAqIDIpIHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2kgKyAxXS52YWwgKyAoKGV4dHJlbWFbaV0udmFsIC0gZXh0cmVtYVtpICsgMV0udmFsKSAvIDMpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSBleHRyZW1hW2ldLnBvczsgaiA8IGV4dHJlbWFbaSArIDFdLnBvczsgaisrKSB7XG4gICAgICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IHRocmVzaG9sZCA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgIH07XG59O1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldmVsb3BtZW50IG9ubHlcbiAqL1xuQnJlc2VuaGFtLmRlYnVnID0ge1xuICAgIHByaW50RnJlcXVlbmN5KGxpbmUsIGNhbnZhcykge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyNTY7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGksIDI1NSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGksIDI1NSAtIGxpbmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBwcmludFBhdHRlcm4obGluZSwgY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyBsZXRcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICBjdHguZmlsbENvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGksIDAsIDEsIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnJlc2VuaGFtO1xuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWN5Y2xlICovXG5cbi8qKlxuICogQmFyY29kZSBEZWNvZGVyIE1vZHVsZVxuICpcbiAqIFRoaXMgbW9kdWxlIGhhbmRsZXMgdGhlIGRlY29kaW5nIG9mIGJhcmNvZGVzIHVzaW5nIGNvbmZpZ3VyZWQgcmVhZGVycy5cbiAqXG4gKiBSRUFERVIgT1JERVIgR1VBUkFOVEVFOlxuICogUmVhZGVycyBhcmUgcHJvY2Vzc2VkIGluIHRoZSBleGFjdCBvcmRlciB0aGV5IGFyZSBzcGVjaWZpZWQgaW4gdGhlIGByZWFkZXJzYFxuICogY29uZmlnIGFycmF5LiBUaGUgZmlyc3QgcmVhZGVyIHRvIHN1Y2Nlc3NmdWxseSBkZWNvZGUgdGhlIGJhcmNvZGUgd2lucy5cbiAqXG4gKiBFeGFtcGxlOlxuICogICByZWFkZXJzOiBbJ2Vhbl9yZWFkZXInLCAndXBjX2VfcmVhZGVyJywgJ2NvZGVfMTI4X3JlYWRlciddXG4gKlxuICogRGVjb2Rpbmcgb3JkZXI6XG4gKiAgIDEuIGVhbl9yZWFkZXIgYXR0ZW1wdHMgdG8gZGVjb2RlXG4gKiAgIDIuIElmIGVhbl9yZWFkZXIgcmV0dXJucyBudWxsLCB1cGNfZV9yZWFkZXIgYXR0ZW1wdHMgdG8gZGVjb2RlXG4gKiAgIDMuIElmIHVwY19lX3JlYWRlciByZXR1cm5zIG51bGwsIGNvZGVfMTI4X3JlYWRlciBhdHRlbXB0cyB0byBkZWNvZGVcbiAqICAgNC4gRmlyc3Qgbm9uLW51bGwgcmVzdWx0IGlzIHJldHVybmVkXG4gKlxuICogRVhURVJOQUwgUkVBREVSUzpcbiAqIEV4dGVybmFsIHJlYWRlcnMgbXVzdCBiZSByZWdpc3RlcmVkIHZpYSByZWdpc3RlclJlYWRlcigpIGJlZm9yZSB1c2UuXG4gKiBPbmNlIHJlZ2lzdGVyZWQsIHRoZXkgZm9sbG93IHRoZSBzYW1lIG9yZGVyaW5nIHJ1bGVzIGFzIGJ1aWx0LWluIHJlYWRlcnMuXG4gKiBUaGVpciBwb3NpdGlvbiBpbiB0aGUgYHJlYWRlcnNgIGFycmF5IGRldGVybWluZXMgdGhlaXIgcHJpb3JpdHkuXG4gKlxuICogVG8gcHJpb3JpdGl6ZSBhbiBleHRlcm5hbCByZWFkZXI6XG4gKiAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcignbXlfcmVhZGVyJywgTXlSZWFkZXIpO1xuICogICBjb25maWcuZGVjb2Rlci5yZWFkZXJzID0gWydteV9yZWFkZXInLCAnZWFuX3JlYWRlciddOyAvLyBteV9yZWFkZXIgdHJpZWQgZmlyc3RcbiAqL1xuXG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFR3b09mRml2ZVJlYWRlciBmcm9tICcuLi9yZWFkZXIvMm9mNV9yZWFkZXInO1xuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IENvZGUzMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zMl9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVZJTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyJztcbmltcG9ydCBDb2RlOTNSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfOTNfcmVhZGVyJztcbmltcG9ydCBFQU4yUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fMl9yZWFkZXInO1xuaW1wb3J0IEVBTjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl81X3JlYWRlcic7XG5pbXBvcnQgRUFOOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzhfcmVhZGVyJztcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl9yZWFkZXInO1xuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4uL3JlYWRlci9pMm9mNV9yZWFkZXInO1xuaW1wb3J0IFBoYXJtYWNvZGVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3BoYXJtYWNvZGVfcmVhZGVyJztcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfZV9yZWFkZXInO1xuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX3JlYWRlcic7XG5pbXBvcnQgQnJlc2VuaGFtIGZyb20gJy4vYnJlc2VuaGFtJztcblxuY29uc3QgUkVBREVSUyA9IHtcbiAgICBjb2RlXzEyOF9yZWFkZXI6IENvZGUxMjhSZWFkZXIsXG4gICAgZWFuX3JlYWRlcjogRUFOUmVhZGVyLFxuICAgIGVhbl81X3JlYWRlcjogRUFONVJlYWRlcixcbiAgICBlYW5fMl9yZWFkZXI6IEVBTjJSZWFkZXIsXG4gICAgZWFuXzhfcmVhZGVyOiBFQU44UmVhZGVyLFxuICAgIGNvZGVfMzlfcmVhZGVyOiBDb2RlMzlSZWFkZXIsXG4gICAgY29kZV8zOV92aW5fcmVhZGVyOiBDb2RlMzlWSU5SZWFkZXIsXG4gICAgY29kYWJhcl9yZWFkZXI6IENvZGFiYXJSZWFkZXIsXG4gICAgdXBjX3JlYWRlcjogVVBDUmVhZGVyLFxuICAgIHVwY19lX3JlYWRlcjogVVBDRVJlYWRlcixcbiAgICBpMm9mNV9yZWFkZXI6IEkyb2Y1UmVhZGVyLFxuICAgICcyb2Y1X3JlYWRlcic6IFR3b09mRml2ZVJlYWRlcixcbiAgICBjb2RlXzkzX3JlYWRlcjogQ29kZTkzUmVhZGVyLFxuICAgIGNvZGVfMzJfcmVhZGVyOiBDb2RlMzJSZWFkZXIsXG4gICAgcGhhcm1hY29kZV9yZWFkZXI6IFBoYXJtYWNvZGVSZWFkZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGV4dGVybmFsL2N1c3RvbSBiYXJjb2RlIHJlYWRlci5cbiAgICAgKiBPbmNlIHJlZ2lzdGVyZWQsIHRoZSByZWFkZXIgY2FuIGJlIHVzZWQgaW4gY29uZmlnLnJlYWRlcnMgYXJyYXkuXG4gICAgICogVGhlIHJlYWRlcidzIHBvc2l0aW9uIGluIGNvbmZpZy5yZWFkZXJzIGRldGVybWluZXMgaXRzIGRlY29kaW5nIHByaW9yaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgaWRlbnRpZmllciB0byB1c2UgaW4gY29uZmlnLnJlYWRlcnMgKGUuZy4sICdteV9jdXN0b21fcmVhZGVyJylcbiAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciBjbGFzcyAobXVzdCBleHRlbmQgQmFyY29kZVJlYWRlcilcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gUmVnaXN0ZXIgYSBjdXN0b20gcmVhZGVyXG4gICAgICogQmFyY29kZURlY29kZXIucmVnaXN0ZXJSZWFkZXIoJ215X3JlYWRlcicsIE15Q3VzdG9tUmVhZGVyKTtcbiAgICAgKlxuICAgICAqIC8vIFVzZSBpdCB3aXRoIGhpZ2ggcHJpb3JpdHkgKGZpcnN0IGluIGFycmF5KVxuICAgICAqIGNvbmZpZy5kZWNvZGVyLnJlYWRlcnMgPSBbJ215X3JlYWRlcicsICdlYW5fcmVhZGVyJywgJ2NvZGVfMTI4X3JlYWRlciddO1xuICAgICAqL1xuICAgIHJlZ2lzdGVyUmVhZGVyOiAobmFtZSwgcmVhZGVyKSA9PiB7XG4gICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgfSxcbiAgICBjcmVhdGUoY29uZmlnLCBpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICBjb25zdCBfY2FudmFzID0ge1xuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX2JhcmNvZGVSZWFkZXJzID0gW107XG5cbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICBpbml0Q29uZmlnKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRkZWJ1ZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1Zy5kZXRlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZnJlcXVlbmN5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5jbGFzc05hbWUgPSAnZnJlcXVlbmN5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWc/LnByaW50UmVhZGVySW5mbykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogYmFyY29kZSBkZWNvZGVyIGluaXRDYW52YXMgZ2V0Y29udGV4dCAyZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5mcmVxdWVuY3kgPSBfY2FudmFzLmRvbS5mcmVxdWVuY3kuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMucGF0dGVybkJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20ucGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4uY2xhc3NOYW1lID0gJ3BhdHRlcm5CdWZmZXInO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgucGF0dGVybiA9IF9jYW52YXMuZG9tLnBhdHRlcm4uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZHJhd2luZ0J1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmIChfY2FudmFzLmRvbS5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4Lm92ZXJsYXkgPSBfY2FudmFzLmRvbS5vdmVybGF5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIGJhcmNvZGUgcmVhZGVycyBmcm9tIGNvbmZpZy5yZWFkZXJzIGFycmF5LlxuICAgICAgICAgKiBSZWFkZXJzIGFyZSBpbnN0YW50aWF0ZWQgYW5kIHN0b3JlZCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIgaW4gY29uZmlnLFxuICAgICAgICAgKiB3aGljaCBkZXRlcm1pbmVzIHRoZWlyIGRlY29kaW5nIHByaW9yaXR5IChmaXJzdCBpbiBhcnJheSA9IGhpZ2hlc3QgcHJpb3JpdHkpLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaW5pdFJlYWRlcnMoKSB7XG4gICAgICAgICAgICBjb25maWcucmVhZGVycy5mb3JFYWNoKChyZWFkZXJDb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyO1xuICAgICAgICAgICAgICAgIGxldCBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgICAgICAgICAgbGV0IHN1cHBsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnPy5wcmludFJlYWRlckluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JlZm9yZSByZWdpc3RlcmluZyByZWFkZXI6ICcsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLnN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsZW1lbnRzID0gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMucHVzaChyZWFkZXJPYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIEVycm9yIGNvbnN0cnVjdGluZyByZWFkZXIgJywgcmVhZGVyLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zz8ucHJpbnRSZWFkZXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlZ2lzdGVyZWQgUmVhZGVyczogJHtfYmFyY29kZVJlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7IGZvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnIH0pKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDb25maWcoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzW2ldLnByb3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZExpbmUobGluZSwgYW5nbGUsIGV4dCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kTGluZShhbW91bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGFtb3VudCAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgeDogYW1vdW50ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcbiAgICAgICAgICAgIGV4dGVuZExpbmUoZXh0KTtcbiAgICAgICAgICAgIHdoaWxlIChleHQgPiAxICYmICghaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVswXSlcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGV4dCAtPSBNYXRoLmNlaWwoZXh0IC8gMik7XG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZShib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIHg6IChib3hbMV1bMF0gLSBib3hbMF1bMF0pIC8gMiArIGJveFswXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzFdWzFdIC0gYm94WzBdWzFdKSAvIDIgKyBib3hbMF1bMV0sXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogKGJveFszXVswXSAtIGJveFsyXVswXSkgLyAyICsgYm94WzJdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbM11bMV0gLSBib3hbMl1bMV0pIC8gMiArIGJveFsyXVsxXSxcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGVtcHRzIHRvIGRlY29kZSBhIGJhcmNvZGUgZnJvbSBhIHNjYW4gbGluZS5cbiAgICAgICAgICogUmVhZGVycyBhcmUgdHJpZWQgaW4gb3JkZXIgKGFzIHNwZWNpZmllZCBpbiBjb25maWcucmVhZGVycykuXG4gICAgICAgICAqIFRoZSBmaXJzdCByZWFkZXIgdG8gcmV0dXJuIGEgbm9uLW51bGwgcmVzdWx0IHdpbnMuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmUgVGhlIHNjYW4gbGluZSB0byBkZWNvZGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdHxudWxsfSBEZWNvZGVkIHJlc3VsdCBvciBudWxsIGlmIG5vIHJlYWRlciBzdWNjZWVkZWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZShsaW5lKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgYmFyY29kZUxpbmUgPSBCcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUoaW5wdXRJbWFnZVdyYXBwZXIsIGxpbmVbMF0sIGxpbmVbMV0pO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jYW52YXMuY3R4Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIF9jYW52YXMuY3R4Lm92ZXJsYXksIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludEZyZXF1ZW5jeShiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBCcmVzZW5oYW0udG9CaW5hcnlMaW5lKGJhcmNvZGVMaW5lKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHJlYWRlcnMgaW4gb3JkZXIgLSBmaXJzdCBzdWNjZXNzZnVsIGRlY29kZSB3aW5zXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgYmFyY29kZUxpbmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNsaWNlcyB0aGUgZ2l2ZW4gYXJlYSBhcGFydCBhbmQgdHJpZXMgdG8gZGV0ZWN0IGEgYmFyY29kZS1wYXR0ZXJuXG4gICAgICAgICAqIGZvciBlYWNoIHNsaWNlLiBJdCByZXR1cm5zIHRoZSBkZWNvZGVkIGJhcmNvZGUsIG9yIG51bGwgaWYgbm90aGluZyB3YXMgZm91bmRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYm94XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSkge1xuICAgICAgICAgICAgY29uc3Qgc2lkZUxlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyhib3hbMV1bMF0gLSBib3hbMF1bMF0sIDIpICsgTWF0aC5wb3coKGJveFsxXVsxXSAtIGJveFswXVsxXSksIDIpKTtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3Qgc2xpY2VzID0gMTY7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkaXI7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uO1xuICAgICAgICAgICAgY29uc3QgeGRpciA9IE1hdGguc2luKGxpbmVBbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHNsaWNlcyAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgbGluZSBwZXJwZW5kaWN1bGFyIHRvIGFuZ2xlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIGRpciA9IHNpZGVMZW5ndGggLyBzbGljZXMgKiBpICogKGkgJSAyID09PSAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGRpciAqIHhkaXIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGRpciAqIHlkaXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSksIDIpXG4gICAgICAgICAgICAgICAgKyBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnggLSBsaW5lWzBdLngpLCAyKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBmcm9tIGEgZnVsbCBpbWFnZSB1c2luZyByZWFkZXJzIHRoYXQgc3VwcG9ydCBpbWFnZS1iYXNlZCBkZWNvZGluZy5cbiAgICAgICAgICogUmVhZGVycyBhcmUgdHJpZWQgaW4gb3JkZXIgKGFzIHNwZWNpZmllZCBpbiBjb25maWcucmVhZGVycykuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXIgVGhlIGltYWdlIHRvIGRlY29kZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IERlY29kZWQgcmVzdWx0IG9yIG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSByZWFkZXJzIGluIG9yZGVyIC0gZmlyc3Qgc3VjY2Vzc2Z1bCBkZWNvZGUgd2luc1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgX2JhcmNvZGVSZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRlci5kZWNvZGVJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCByZWFkZXIuZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIHRoZSBoZWxwIG9mIHRoZSBjb25maWd1cmVkIHJlYWRlcnMgKENvZGUxMjggb3IgRUFOKSB0aGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGRldGVjdCBhXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3ggVGhlIGFyZWEgdG8gc2VhcmNoIGluXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXN1bHQge2NvZGVSZXN1bHQsIGxpbmUsIGFuZ2xlLCBwYXR0ZXJuLCB0aHJlc2hvbGR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICBsZXQgbGluZTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IF9jYW52YXMuY3R4Lm92ZXJsYXk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWJ1Zy5kcmF3Qm91bmRpbmdCb3ggJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgY3R4LCB7IGNvbG9yOiAnYmx1ZScsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gZ2V0TGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmdsZSA9IE1hdGguYXRhbjIobGluZVsxXS55IC0gbGluZVswXS55LCBsaW5lWzFdLnggLSBsaW5lWzBdLngpO1xuICAgICAgICAgICAgbGluZSA9IGdldEV4dGVuZGVkTGluZShsaW5lLCBsaW5lQW5nbGUsIE1hdGguZmxvb3IobGluZUxlbmd0aCAqIDAuMSkpO1xuICAgICAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgcmVzdWx0ICYmIGNvbmZpZy5kZWJ1Zy5kcmF3U2NhbmxpbmUgJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIGN0eCwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcmVzdWx0LmJhcmNvZGVMaW5lLmxpbmUsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiByZXN1bHQuYmFyY29kZUxpbmUudGhyZXNob2xkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7IGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFyY29kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG11bHRpcGxlIH0gPSBjb25maWc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94ID0gYm94ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm94ID0gYm94O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBkZWNvZGVGcm9tSW1hZ2UoaW1hZ2VXcmFwcGVySW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWNvZGVGcm9tSW1hZ2UoaW1hZ2VXcmFwcGVySW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJFQURFUlNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVnaXN0ZXIgZXhpc3RpbmcgcmVhZGVyJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UmVhZGVycyhyZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMgPSByZWFkZXJzO1xuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4vMm9mNV9yZWFkZXInO1xuaW1wb3J0IE5ld0NvZGFiYXJSZWFkZXIgZnJvbSAnLi9jb2RhYmFyX3JlYWRlcic7XG5pbXBvcnQgQ29kZTEyOFJlYWRlciBmcm9tICcuL2NvZGVfMTI4X3JlYWRlcic7XG5pbXBvcnQgQ29kZTMyUmVhZGVyIGZyb20gJy4vY29kZV8zMl9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGU5M1JlYWRlciBmcm9tICcuL2NvZGVfOTNfcmVhZGVyJztcbmltcG9ydCBFQU4yUmVhZGVyIGZyb20gJy4vZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4vZWFuXzVfcmVhZGVyJztcbmltcG9ydCBFQU44UmVhZGVyIGZyb20gJy4vZWFuXzhfcmVhZGVyJztcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCBJMm9mNVJlYWRlciBmcm9tICcuL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgUGhhcm1hY29kZVJlYWRlciBmcm9tICcuL3BoYXJtYWNvZGVfcmVhZGVyJztcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4vdXBjX2VfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi91cGNfcmVhZGVyJztcblxuZXhwb3J0IHtcbiAgICBCYXJjb2RlUmVhZGVyLFxuICAgIFR3b09mRml2ZVJlYWRlcixcbiAgICBOZXdDb2RhYmFyUmVhZGVyLFxuICAgIENvZGUxMjhSZWFkZXIsXG4gICAgQ29kZTMyUmVhZGVyLFxuICAgIENvZGUzOVJlYWRlcixcbiAgICBDb2RlMzlWSU5SZWFkZXIsXG4gICAgQ29kZTkzUmVhZGVyLFxuICAgIEVBTjJSZWFkZXIsXG4gICAgRUFONVJlYWRlcixcbiAgICBFQU44UmVhZGVyLFxuICAgIEVBTlJlYWRlcixcbiAgICBJMm9mNVJlYWRlcixcbiAgICBQaGFybWFjb2RlUmVhZGVyLFxuICAgIFVQQ0VSZWFkZXIsXG4gICAgVVBDUmVhZGVyLCAgICBcbn1cbiIsInR5cGUgRXZlbnROYW1lID0gc3RyaW5nO1xuXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcbiAgICBhc3luYz86IGJvb2xlYW47XG4gICAgY2FsbGJhY2s6IEZ1bmN0aW9uO1xuICAgIG9uY2U/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgRXZlbnREYXRhIHtcbiAgICBzdWJzY3JpYmVyczogQXJyYXk8U3Vic2NyaXB0aW9uPjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50cyB7XG4gICAgW2tleTogc3RyaW5nXTogRXZlbnREYXRhO1xufVxuXG5pbnRlcmZhY2UgRXZlbnRJbnRlcmZhY2Uge1xuICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZDtcbiAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZDtcbiAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoKTogRXZlbnRJbnRlcmZhY2Uge1xuICAgIGxldCBldmVudHM6IEV2ZW50cyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lOiBFdmVudE5hbWUpOiBFdmVudERhdGEge1xuICAgICAgICBpZiAoIWV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiwgZGF0YTogbmV2ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5hc3luYykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfSwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHdhcyBub3Qgc3BlY2lmaWVkIG9uIG9wdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEV2ZW50KGV2ZW50KS5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgICAgICByZXR1cm4gX3N1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnNjcmliZXJzIH0gPSBldmVudDtcblxuICAgICAgICAgICAgLy8gUHVibGlzaCBvbmUtdGltZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICEhc3Vic2NyaWJlci5vbmNlKS5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gIXN1YnNjcmliZXIub25jZSk7XG5cbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEgYXMgbmV2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBhc3luYyA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgICAgICBfc3Vic2NyaWJlKGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmMsXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gZXZlbnQuc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyLmNhbGxiYWNrICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn0oKSk7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZT86IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKG06IHN0cmluZywgY29kZT86IG51bWJlcikge1xuICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEV4Y2VwdGlvbi5wcm90b3R5cGUpO1xuICAgIH1cbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vcXVhZ2dhL0V4Y2VwdGlvbic7XG5cbmNvbnN0IEVSUk9SX0RFU0MgPSAnVGhpcyBtYXkgbWVhbiB0aGF0IHRoZSB1c2VyIGhhcyBkZWNsaW5lZCBjYW1lcmEgYWNjZXNzLCBvciB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1lZGlhIEFQSXMuIElmIHlvdSBhcmUgcnVubmluZyBpbiBpT1MsIHlvdSBtdXN0IHVzZSBTYWZhcmkuJztcblxuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXhjZXB0aW9uKGBlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCwgLTEpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXhjZXB0aW9uKGBnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gLCAtMSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxufVxuIiwiLy8gVE9ETzogd2hlbiB0aGlzIGZpbGUgd2FzIHdyaXR0ZW4geWVhcnMgYWdvLCBIVE1MTWVkaWFFbGVtZW50LnBsYXkoKSBkaWQgbm90IHJldHVybiBhIHVzZWZ1bCB2YWx1ZVxuLy8gdG8gbGV0IHVzIGtub3cgd2hlbiB0aGUgdmlkZW8gc3RhcnRlZCBwbGF5aW5nLiAgTm93LCBpdCBkb2VzLiAgU28sIHdlIHNob3VsZG4ndCBuZWVkIHRvIHJ1biB0aGlzXG4vLyBvZGQgd2FpdEZvclZpZGVvKCkgZnVuY3Rpb24gdGhhdCBwb2xscyB0byBzZWUgaWYgdGhlIHZpZGVvIGhhcyBzdGFydGVkLlxuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoL29taXQnO1xuaW1wb3J0IHsgZ2V0VXNlck1lZGlhLCBlbnVtZXJhdGVEZXZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL21lZGlhRGV2aWNlcyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL3F1YWdnYS9FeGNlcHRpb24nO1xuaW1wb3J0IHR5cGUge1xuICAgIE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkLFxuICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzIGFzIENhbWVyYUFjY2Vzc1R5cGUsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5sZXQgc3RyZWFtUmVmOiBNZWRpYVN0cmVhbSB8IG51bGw7XG5cbmZ1bmN0aW9uIHdhaXRGb3JWaWRlbyh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDEwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVmlkZW8oKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvLnZpZGVvV2lkdGggPiAxMCAmJiB2aWRlby52aWRlb0hlaWdodCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAqIGRldjogY2hlY2tWaWRlbyBmb3VuZCAke3ZpZGVvLnZpZGVvV2lkdGh9cHggeCAke3ZpZGVvLnZpZGVvSGVpZ2h0fXB4YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVmlkZW8sIDUwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEV4Y2VwdGlvbignVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nLCAtMSkpOyAvLyBUT0RPOiBhZGQgZXJyb3IgY29kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0ZW1wdHMtLTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZpZGVvKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxuICogYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBjb250ZW50IGlzIHJlYWR5XG4gKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xuICovXG5hc3luYyBmdW5jdGlvbiBpbml0Q2FtZXJhKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCwgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIHN0cmVhbVJlZiA9IHN0cmVhbTtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJ3RydWUnKTsgLy8gbm90IGxpc3RlZCBvbiBNRE4uLi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlby5wbGF5KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBFcnJvciB3aGlsZSB0cnlpbmcgdG8gcGxheSB2aWRlbyBzdHJlYW06JywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdhaXRGb3JWaWRlbyh2aWRlbyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHtcbiAgICAvLyBSZW1vdmUgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIChmYWNpbmcsIG1pbkFzcGVjdFJhdGlvLCBtYXhBc3BlY3RSYXRpbykgd2hpbGVcbiAgICAvLyBwcmVzZXJ2aW5nIGFsbCB2YWxpZCBNZWRpYVRyYWNrQ29uc3RyYWludHMgaW5jbHVkaW5nIGFkdmFuY2VkLCB6b29tLCB0b3JjaCwgZXRjLlxuICAgIGNvbnN0IG5vcm1hbGl6ZWQ6IE1lZGlhVHJhY2tDb25zdHJhaW50cyA9IG9taXQodmlkZW9Db25zdHJhaW50cywgWydmYWNpbmcnLCAnbWluQXNwZWN0UmF0aW8nLCAnbWF4QXNwZWN0UmF0aW8nXSk7XG5cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xuICAgICAgICBub3JtYWxpemVkLmFzcGVjdFJhdGlvID0gdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnbWluQXNwZWN0UmF0aW9cXCcgaXMgZGVwcmVjYXRlZDsgVXNlIFxcJ2FzcGVjdFJhdGlvXFwnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbm9ybWFsaXplZC5mYWNpbmdNb2RlID0gdmlkZW9Db25zdHJhaW50cy5mYWNpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxuLy8gVGhhdCdzIG5vdCBuZWNlc3Nhcnkgd2l0aCBhc3luYyBmdW5jdGlvbnMgYmVpbmcgYSB0aGluZywgc28gdGhhdCBzaG91bGQgYmUgZml4ZWQuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkID0ge30pOiBQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+IHtcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5kZXZpY2VJZCAmJiB2aWRlby5mYWNpbmdNb2RlKSB7XG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXVkaW86IGZhbHNlLCB2aWRlbyB9KTtcbn1cblxuLyoqXG4gKiBFbnVtZXJhdGVzIHZpZGVvIGlucHV0IGRldmljZXMsIG9wdGlvbmFsbHkgZmlsdGVyaW5nIGJ5IGNvbnN0cmFpbnRzLlxuICogQHBhcmFtIHZpZGVvQ29uc3RyYWludHMgT3B0aW9uYWwgY29uc3RyYWludHMgdG8gZmlsdGVyIGRldmljZXMuXG4gKiBXaGVuIHByb3ZpZGVkLCBvbmx5IGRldmljZXMgdGhhdCBzYXRpc2Z5IHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aWxsIGJlIHJldHVybmVkLlxuICogVGhpcyB3b3JrcyBieSBhdHRlbXB0aW5nIHRvIGdldCBhIG1lZGlhIHN0cmVhbSBmb3IgZWFjaCBkZXZpY2Ugd2l0aCB0aGUgY29uc3RyYWludHNcbiAqIGFuZCByZXR1cm5pbmcgb25seSB0aGUgZGV2aWNlcyB0aGF0IHN1Y2NlZWQuXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhbiBhcnJheSBvZiBNZWRpYURldmljZUluZm8gZm9yIHZpZGVvIGlucHV0IGRldmljZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVudW1lcmF0ZVZpZGVvRGV2aWNlcyhcbiAgICB2aWRlb0NvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQsXG4pOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcbiAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIGNvbnN0IHZpZGVvRGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKChkZXZpY2U6IE1lZGlhRGV2aWNlSW5mbykgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG5cbiAgICAvLyBJZiBubyBjb25zdHJhaW50cyBhcmUgcHJvdmlkZWQsIHJldHVybiBhbGwgdmlkZW8gZGV2aWNlc1xuICAgIGlmICghdmlkZW9Db25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gdmlkZW9EZXZpY2VzO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBkZXZpY2VzIGJhc2VkIG9uIGNvbnN0cmFpbnRzIGJ5IHRyeWluZyB0byBnZXQgYSBtZWRpYSBzdHJlYW0gZm9yIGVhY2hcbiAgICBjb25zdCBjb25zdHJhaW5lZERldmljZXM6IEFycmF5PE1lZGlhRGV2aWNlSW5mbz4gPSBbXTtcblxuICAgIC8vIFByb2Nlc3MgY29uc3RyYWludHMgYnV0IGV4Y2x1ZGUgZGV2aWNlSWQgc2luY2Ugd2UnbGwgc2V0IGl0IG91cnNlbHZlcyBmb3IgZWFjaCBkZXZpY2VcbiAgICBjb25zdCBwcm9jZXNzZWRDb25zdHJhaW50cyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3QgeyBkZXZpY2VJZDogXywgLi4uY29uc3RyYWludHNXaXRob3V0RGV2aWNlSWQgfSA9IHByb2Nlc3NlZENvbnN0cmFpbnRzO1xuXG4gICAgZm9yIChjb25zdCBkZXZpY2Ugb2YgdmlkZW9EZXZpY2VzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uc3RyYWludHNXaXRob3V0RGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIGRldmljZUlkOiB7IGV4YWN0OiBkZXZpY2UuZGV2aWNlSWQgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAvLyBTdG9wIGFsbCB0cmFja3MgaW1tZWRpYXRlbHkgYWZ0ZXIgdGVzdGluZ1xuICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgICAgICAgY29uc3RyYWluZWREZXZpY2VzLnB1c2goZGV2aWNlKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAvLyBEZXZpY2UgZG9lc24ndCBzdXBwb3J0IHRoZSBjb25zdHJhaW50cywgc2tpcCBpdC5cbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2ggaXMgaW50ZW50aW9uYWxseSBlbXB0eSBhcyB3ZSdyZSB1c2luZyBnZXRVc2VyTWVkaWEgdG8gdGVzdCBpZlxuICAgICAgICAgICAgLy8gZWFjaCBkZXZpY2Ugc3VwcG9ydHMgdGhlIGNvbnN0cmFpbnRzLiBFcnJvcnMgaGVyZSBpbmRpY2F0ZSB0aGUgZGV2aWNlXG4gICAgICAgICAgICAvLyBkb2Vzbid0IG1lZXQgdGhlIHJlcXVpcmVtZW50cyAoT3ZlcmNvbnN0cmFpbmVkRXJyb3IpIG9yIG90aGVyIGlzc3Vlc1xuICAgICAgICAgICAgLy8gdGhhdCBtZWFuIHdlIHNob3VsZCBleGNsdWRlIHRoaXMgZGV2aWNlIGZyb20gdGhlIHJlc3VsdHMuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29uc3RyYWluZWREZXZpY2VzO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVUcmFjaygpOiBNZWRpYVN0cmVhbVRyYWNrIHwgbnVsbCB7XG4gICAgaWYgKCFzdHJlYW1SZWYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgIHJldHVybiB0cmFja3MgJiYgdHJhY2tzPy5sZW5ndGggPyB0cmFja3NbMF0gOiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGl2ZSBNZWRpYVN0cmVhbSwgb3IgbnVsbCBpZiBubyBzdHJlYW0gaXMgYWN0aXZlLlxuICogVXNlIHRoaXMgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8gdGhlIGZ1bGwgc3RyZWFtLCBmb3IgZXhhbXBsZSB0byBwYXNzIHRvIFdlYlJUQ1xuICogb3IgdG8gY2xvbmUgdGhlIHN0cmVhbS4gRm9yIGp1c3QgdGhlIHZpZGVvIHRyYWNrLCB1c2UgZ2V0QWN0aXZlVHJhY2soKSBpbnN0ZWFkLlxuICogQHJldHVybnMgVGhlIGFjdGl2ZSBNZWRpYVN0cmVhbSwgb3IgbnVsbCBpZiBubyBjYW1lcmEgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHwgbnVsbCB7XG4gICAgcmV0dXJuIHN0cmVhbVJlZiA/PyBudWxsO1xufVxuXG4vKipcbiAqIFVzZWQgZm9yIGFjY2Vzc2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWN0aXZlIHN0cmVhbSB0cmFjayBhbmQgYXZhaWxhYmxlIHZpZGVvIGRldmljZXMuXG4gKi9cbmNvbnN0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzOiBDYW1lcmFBY2Nlc3NUeXBlID0ge1xuICAgIHJlcXVlc3RlZFZpZGVvRWxlbWVudDogbnVsbCxcbiAgICBhc3luYyByZXF1ZXN0KHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCwgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gdmlkZW87XG4gICAgICAgIGNvbnN0IG5ld0NvbnN0cmFpbnRzID0gYXdhaXQgcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpO1xuICAgICAgICByZXR1cm4gaW5pdENhbWVyYSh2aWRlbywgbmV3Q29uc3RyYWludHMpO1xuICAgIH0sXG4gICAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmICYmIHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICBpZiAoUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmVhbVJlZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhdGVWaWRlb0RldmljZXMsXG4gICAgZ2V0QWN0aXZlU3RyZWFtLFxuICAgIGdldEFjdGl2ZVN0cmVhbUxhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrID8gdHJhY2subGFiZWwgOiAnJztcbiAgICB9LFxuICAgIGdldEFjdGl2ZVRyYWNrLFxuICAgIGFzeW5jIGRpc2FibGVUb3JjaCgpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgYWNxdWlyZSBjYW1lcmEgYWNjZXNzIGV2ZW4gaWYgdGhlcmUncyBubyBjdXJyZW50IGNhbWVyYSBvcGVuP1xuICAgICAgICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgb24gaU9TIG9yIGFub3RoZXIgZGV2aWNlIHdoZXJlIHRvcmNoIGlzbid0IHN1cHBvcnRlZCBhdCBhbGw/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRyYWNrLmFwcGx5Q29uc3RyYWludHMoeyBhZHZhbmNlZDogW3sgdG9yY2g6IGZhbHNlIH1dIH0gYXMgTWVkaWFUcmFja0NvbnN0cmFpbnRTZXQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIE92ZXJjb25zdHJhaW5lZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncXVhZ2dhMi9DYW1lcmFBY2Nlc3M6IFRvcmNoIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBlbmFibGVUb3JjaCgpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgYWNxdWlyZSBjYW1lcmEgYWNjZXNzIGV2ZW4gaWYgdGhlcmUncyBubyBjdXJyZW50IGNhbWVyYSBvcGVuP1xuICAgICAgICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgb24gaU9TIG9yIGFub3RoZXIgZGV2aWNlIHdoZXJlIHRvcmNoIGlzbid0IHN1cHBvcnRlZCBhdCBhbGw/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRyYWNrLmFwcGx5Q29uc3RyYWludHMoeyBhZHZhbmNlZDogW3sgdG9yY2g6IHRydWUgfV0gfSBhcyBNZWRpYVRyYWNrQ29uc3RyYWludFNldCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgT3ZlcmNvbnN0cmFpbmVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdxdWFnZ2EyL0NhbWVyYUFjY2VzczogVG9yY2ggbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUXVhZ2dhSlNDYW1lcmFBY2Nlc3M7XG4iLCJpbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IHR5cGUge1xuICAgIFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvcixcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uLFxuICAgIFhZU2l6ZSxcbiAgICBRdWFnZ2FJbWFnZURhdGEsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5mdW5jdGlvbiBjb250YWlucyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsIGxpc3Q6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gbGlzdCAmJiBsaXN0LnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pIGFzIEFycmF5PGtleW9mIFF1YWdnYUpTQ29kZVJlc3VsdD47XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IGl0ZW1ba2V5XSA9PT0gY29kZVJlc3VsdFtrZXldKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKFxuICAgIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBmaWx0ZXI6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24gfCB1bmRlZmluZWQsXG4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZpbHRlcihjb2RlUmVzdWx0KSA6IHRydWU7XG59XG5cbmludGVyZmFjZSBSZXN1bHRDb2xsZWN0b3Ige1xuICAgIGFkZFJlc3VsdDogKGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCkgPT4gdm9pZDtcbiAgICBnZXRSZXN1bHRzOiAoKSA9PiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlKGNvbmZpZzogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IpOiBSZXN1bHRDb2xsZWN0b3Ige1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywgeyB3aWxsUmVhZEZyZXF1ZW50bHk6ICEhY29uZmlnLndpbGxSZWFkRnJlcXVlbnRseSB9KSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4gPSBbXTtcbiAgICAgICAgbGV0IGNhcGFjaXR5ID0gY29uZmlnLmNhcGFjaXR5ID8/IDIwO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gY29uZmlnLmNhcHR1cmUgPT09IHRydWU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IGJvb2xlYW4ge1xuICAgICAgICAgICAgcmV0dXJuICEhY2FwYWNpdHlcbiAgICAgICAgICAgICAgICAmJiBjb2RlUmVzdWx0XG4gICAgICAgICAgICAgICAgJiYgIWNvbnRhaW5zKGNvZGVSZXN1bHQsIGNvbmZpZy5ibGFja2xpc3QgYXMgQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PilcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNGaWx0ZXIoY29kZVJlc3VsdCwgY29uZmlnLmZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkUmVzdWx0KGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IHZvaWQge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0geyB9OyAvLyB0aGlzIGlzICdhbnknIHRvIGF2b2lkIGhhdmluZyB0byBjb25zdHJ1Y3QgYSB3aG9sZSBRdWFnZ2FKU0NvZGVSZXN1bHQgOnxcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5LS07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0ID0gY29kZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlU2l6ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlU2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3SW1hZ2UoZGF0YSwgaW1hZ2VTaXplLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZyYW1lID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSZXN1bHRzKCk6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IERldkNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgICAgIC8vIGJvcmRlckNvbG9yOiAncmdiYSgwLCAyNTUsIDAsIDAuNSknLCAvLyB1bmNvbW1lbnQgdG8gZHJhdyBhcmVhIGJvcmRlclxuICAgICAgICAgICAgLy8gYm9yZGVyV2lkdGg6IDIsIC8vIHVuY29tbWVudCB0byBkcmF3IGFyZWEgYm9yZGVyXG4gICAgICAgICAgICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDI1NSwgMCwgMC4xKScsIC8vIHVuY29tbWVudCB0byB0aW50IHRoZSBzY2FuIGFyZWFcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIHNob3dJbWFnZURldGFpbHM6IGZhbHNlLCAvLyBsb2dzIGZyYW1lIGdyYWJiZXIgaW5mbywgY2FudmFzIHNpemUgYWRqdXN0bWVudHNcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBjYW52YXM6IHtcbiAgICAgICAgY3JlYXRlT3ZlcmxheTogdHJ1ZSwgLy8gc2V0IHRvIGZhbHNlIHRvIHNraXAgY3JlYXRpbmcgb3ZlcmxheSBjYW52YXMgKGRyYXdpbmdCdWZmZXIpXG4gICAgfSxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGcmVxdWVuY3k6IGZhbHNlLFxuICAgICAgICAgICAgZHJhd1NjYW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZSxcbiAgICAgICAgICAgIHByaW50UmVhZGVySW5mbzogZmFsc2UsIC8vIGxvZ3MgcmVhZGVyIHJlZ2lzdHJhdGlvbiBhbmQgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIHNob3dDYW52YXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZvdW5kUGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93U2tlbGV0b246IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0xhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaFNpemU6IGZhbHNlLCAvLyBsb2dzIGNhbGN1bGF0ZWQgcGF0Y2ggc2l6ZVxuICAgICAgICAgICAgc2hvd0ltYWdlRGV0YWlsczogZmFsc2UsIC8vIGxvZ3MgaW1hZ2Ugd3JhcHBlciBzaXplLCBjYW52YXMgZGV0YWlsc1xuICAgICAgICAgICAgYm94RnJvbVBhdGNoZXM6IHtcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZEJveDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0JCOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERldkNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IE5vZGVDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXG4gICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgY2FudmFzOiB7XG4gICAgICAgIGNyZWF0ZU92ZXJsYXk6IHRydWUsIC8vIHNldCB0byBmYWxzZSB0byBza2lwIGNyZWF0aW5nIG92ZXJsYXkgY2FudmFzIChkcmF3aW5nQnVmZmVyKVxuICAgIH0sXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9kZUNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IFByb2RDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgLy8gb3IgdXNlclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgICAgICB9LFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgY2FudmFzOiB7XG4gICAgICAgIGNyZWF0ZU92ZXJsYXk6IHRydWUsIC8vIHNldCB0byBmYWxzZSB0byBza2lwIGNyZWF0aW5nIG92ZXJsYXkgY2FudmFzIChkcmF3aW5nQnVmZmVyKVxuICAgIH0sXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvZENvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgRGV2Q29uZmlnIGZyb20gJy4vY29uZmlnLmRldic7XG5pbXBvcnQgTm9kZUNvbmZpZyBmcm9tICcuL2NvbmZpZy5ub2RlJztcbmltcG9ydCBQcm9kQ29uZmlnIGZyb20gJy4vY29uZmlnLnByb2QnO1xuXG5jb25zdCBFeHBvcnRDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0gKCgpID0+IHtcbiAgICBsZXQgUXVhZ2dhQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdDtcbiAgICBpZiAodHlwZW9mIEVOViA9PT0gJ3VuZGVmaW5lZCcgfHwgRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIFF1YWdnYUNvbmZpZyA9IERldkNvbmZpZztcbiAgICB9IGVsc2UgaWYgKEVOVi5ub2RlKSB7XG4gICAgICAgIFF1YWdnYUNvbmZpZyA9IE5vZGVDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUXVhZ2dhQ29uZmlnID0gUHJvZENvbmZpZztcbiAgICB9XG4gICAgcmV0dXJuIFF1YWdnYUNvbmZpZztcbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4cG9ydENvbmZpZztcbiIsIi8vIE5PVEUgRk9SIEFOWU9ORSBJTiBIRVJFIElOIFRIRSBGVVRVUkU6XG4vLyB3ZWJwYWNrLmNvbmZpZy5qcyByZXBsYWNlcyB0aGUgZnJhbWVfZ3JhYmJlciBtb2R1bGUgd2l0aCBUSElTIG1vZHVsZSB3aGVuIGl0IGlzIGJ1aWxkaW5nIGZvciBhIEJyb3dzZXIgZW52aXJvbm1lbnQuXG5cbmltcG9ydCB7XG4gICAgaW1hZ2VSZWYsXG4gICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YSxcbiAgICBjb21wdXRlR3JheSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcblxuY29uc3QgVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG5cbmZ1bmN0aW9uIGFkanVzdENhbnZhc1NpemUoY2FudmFzLCB0YXJnZXRTaXplLCBkZWJ1Zykge1xuICAgIGlmIChjYW52YXMud2lkdGggIT09IHRhcmdldFNpemUueCkge1xuICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRTaXplLng7XG4gICAgfVxuICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9PSB0YXJnZXRTaXplLnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBkZWJ1Zz8uc2hvd0ltYWdlRGV0YWlscykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFNpemUueTtcbiAgICB9XG59XG5cbmNvbnN0IEZyYW1lR3JhYmJlciA9IHt9O1xuXG5GcmFtZUdyYWJiZXIuY3JlYXRlID0gZnVuY3Rpb24gKGlucHV0U3RyZWFtLCBjYW52YXMpIHtcbiAgICAvLyBjb25zb2xlLndhcm4oJyoqKiBGcmFtZUdyYWJiZXJCcm93c2VyIGNyZWF0ZScpO1xuICAgIGNvbnN0IF90aGF0ID0ge307XG4gICAgY29uc3QgX3N0cmVhbUNvbmZpZyA9IGlucHV0U3RyZWFtLmdldENvbmZpZygpO1xuICAgIGNvbnN0IF92aWRlb1NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRSZWFsV2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0UmVhbEhlaWdodCgpKTtcbiAgICBjb25zdCBfY2FudmFzU2l6ZSA9IGlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKTtcbiAgICBjb25zdCBfc2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgY29uc3QgX3N4ID0gdG9wUmlnaHQueDtcbiAgICBjb25zdCBfc3kgPSB0b3BSaWdodC55O1xuICAgIGxldCBfY2FudmFzO1xuICAgIGxldCBfY3R4ID0gbnVsbDtcbiAgICBsZXQgX2RhdGEgPSBudWxsO1xuICAgIGNvbnN0IHsgd2lsbFJlYWRGcmVxdWVudGx5IH0gPSBfc3RyZWFtQ29uZmlnO1xuXG4gICAgX2NhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBfY2FudmFzLndpZHRoID0gX2NhbnZhc1NpemUueDtcbiAgICBfY2FudmFzLmhlaWdodCA9IF9jYW52YXNTaXplLnk7XG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfc3RyZWFtQ29uZmlnLmRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignKioqIGZyYW1lX2dyYWJiZXJfYnJvd3Nlcjogd2lsbFJlYWRGcmVxdWVudGx5PScsIHdpbGxSZWFkRnJlcXVlbnRseSwgJ2NhbnZhcz0nLCBfY2FudmFzKTtcbiAgICB9XG4gICAgX2N0eCA9IF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IHdpbGxSZWFkRnJlcXVlbnRseTogISF3aWxsUmVhZEZyZXF1ZW50bHkgfSk7IC8vIGRvdWJsZSBub3QgYmVjYXVzZSB3ZSBoYXZlIGFuIG9wdGlvbmFsIGJvb2wgdGhhdCBuZWVkcyB0byBwYXNzIGFzIGEgYm9vbFxuICAgIF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3NpemUueCAqIF9zaXplLnkpO1xuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX3N0cmVhbUNvbmZpZy5kZWJ1Zz8uc2hvd0ltYWdlRGV0YWlscykge1xuICAgICAgICBjb25zb2xlLmxvZygnRnJhbWVHcmFiYmVyJywgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc2l6ZTogX3NpemUsXG4gICAgICAgICAgICB0b3BSaWdodCxcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX3ZpZGVvU2l6ZSxcbiAgICAgICAgICAgIGNhbnZhc1NpemU6IF9jYW52YXNTaXplLFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlZCBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8vIEJpbGluZWFyIGludGVycG9sYXRpb24gZm9yIGdyYXlzY2FsZSBkYXRhICh0byBtYXRjaCBOb2RlJ3MgYmVoYXZpb3IpXG4gICAgZnVuY3Rpb24gYmlsaW5lYXJJbnRlcnBvbGF0ZShncmF5RGF0YSwgd2lkdGgsIGhlaWdodCwgeCwgeSkge1xuICAgICAgICBjb25zdCB4MCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIGNvbnN0IHkwID0gTWF0aC5mbG9vcih5KTtcbiAgICAgICAgY29uc3QgeDEgPSBNYXRoLm1pbih4MCArIDEsIHdpZHRoIC0gMSk7XG4gICAgICAgIGNvbnN0IHkxID0gTWF0aC5taW4oeTAgKyAxLCBoZWlnaHQgLSAxKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZ4ID0geCAtIHgwO1xuICAgICAgICBjb25zdCBmeSA9IHkgLSB5MDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHYwMCA9IGdyYXlEYXRhW3kwICogd2lkdGggKyB4MF07XG4gICAgICAgIGNvbnN0IHYxMCA9IGdyYXlEYXRhW3kwICogd2lkdGggKyB4MV07XG4gICAgICAgIGNvbnN0IHYwMSA9IGdyYXlEYXRhW3kxICogd2lkdGggKyB4MF07XG4gICAgICAgIGNvbnN0IHYxMSA9IGdyYXlEYXRhW3kxICogd2lkdGggKyB4MV07XG4gICAgICAgIFxuICAgICAgICBjb25zdCB2MCA9IHYwMCAqICgxIC0gZngpICsgdjEwICogZng7XG4gICAgICAgIGNvbnN0IHYxID0gdjAxICogKDEgLSBmeCkgKyB2MTEgKiBmeDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB2MCAqICgxIC0gZnkpICsgdjEgKiBmeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cbiAgICAgKiBUaGUgaW1hZ2UtZGF0YSBpcyBjb252ZXJ0ZWQgdG8gZ3JheS1zY2FsZSBhbmQgdGhlbiBoYWxmLXNhbXBsZWQgaWYgY29uZmlndXJlZC5cbiAgICAgKiBcbiAgICAgKiBGb3IgaW1wcm92ZWQgYWNjdXJhY3kgKG1hdGNoaW5nIE5vZGUncyBwcm9jZXNzaW5nKSwgbm9uLWhhbGYtc2FtcGxlZCBpbWFnZXNcbiAgICAgKiB1c2UgYmlsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiBncmF5c2NhbGUgZGF0YSBpbnN0ZWFkIG9mIHNjYWxpbmcgUkdCIHRoZW4gY29udmVydGluZy5cbiAgICAgKiBcbiAgICAgKiBJTVBPUlRBTlQ6IFRoZSBpbWFnZSBpcyBBTFdBWVMgZHJhd24gdG8gdGhlIHZpc2libGUgY2FudmFzIGZvciBvdmVybGF5cyBhbmQgZGlzcGxheS5cbiAgICAgKi9cbiAgICBfdGhhdC5ncmFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkb0hhbGZTYW1wbGUgPSBfc3RyZWFtQ29uZmlnLmhhbGZTYW1wbGU7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcbiAgICAgICAgbGV0IGRyYXdhYmxlID0gZnJhbWU7XG4gICAgICAgIGxldCBkcmF3QW5nbGUgPSAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRyYXdhYmxlKSB7XG4gICAgICAgICAgICBhZGp1c3RDYW52YXNTaXplKF9jYW52YXMsIF9jYW52YXNTaXplLCBfc3RyZWFtQ29uZmlnLmRlYnVnKTtcbiAgICAgICAgICAgIGlmIChfc3RyZWFtQ29uZmlnLnR5cGUgPT09ICdJbWFnZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZSA9IGZyYW1lLmltZztcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUudGFncyAmJiBmcmFtZS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdBbmdsZSA9IDkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSAtOTAgKiBUT19SQURJQU5TO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBTFdBWVMgZHJhdyB0byB2aXNpYmxlIGNhbnZhcyAoZm9yIG92ZXJsYXlzLCBkaXNwbGF5LCBhbmQgdG9EYXRhVVJMKVxuICAgICAgICAgICAgaWYgKGRyYXdBbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKF9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgLV9jYW52YXNTaXplLnkgLyAyLCAtX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnksIF9jYW52YXNTaXplLngpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKC1kcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKC1fY2FudmFzU2l6ZS54IC8gMiwgLV9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIDAsIDAsIF9jYW52YXNTaXplLngsIF9jYW52YXNTaXplLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZG9IYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFsZi1zYW1wbGUgcGF0aDogdXNlIGV4aXN0aW5nIG9wdGltaXplZCBhcHByb2FjaFxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eERhdGEgPSBfY3R4LmdldEltYWdlRGF0YShfc3gsIF9zeSwgX3NpemUueCwgX3NpemUueSkuZGF0YTtcbiAgICAgICAgICAgICAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGN0eERhdGEsIF9zaXplLCBfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vbi1oYWxmLXNhbXBsZTogdXNlIGltcHJvdmVkIGJpbGluZWFyIGludGVycG9sYXRpb24gZm9yIGJldHRlciBhY2N1cmFjeVxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgYXQgb3JpZ2luYWwgc2l6ZSwgdGhlbiBzY2FsZSBncmF5c2NhbGUgZGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gX3ZpZGVvU2l6ZS54O1xuICAgICAgICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gX3ZpZGVvU2l6ZS55O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBDdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdBbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQ3R4LnRyYW5zbGF0ZShfdmlkZW9TaXplLnggLyAyLCBfdmlkZW9TaXplLnkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC5yb3RhdGUoZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIC1fdmlkZW9TaXplLnkgLyAyLCAtX3ZpZGVvU2l6ZS54IC8gMiwgX3ZpZGVvU2l6ZS55LCBfdmlkZW9TaXplLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAwLCAwLCBfdmlkZW9TaXplLngsIF92aWRlb1NpemUueSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBncmF5c2NhbGUgYXQgb3JpZ2luYWwgc2l6ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2VEYXRhID0gdGVtcEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgX3ZpZGVvU2l6ZS54LCBfdmlkZW9TaXplLnkpLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JheURhdGEgPSBuZXcgVWludDhBcnJheShfdmlkZW9TaXplLnggKiBfdmlkZW9TaXplLnkpO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVHcmF5KG9yaWdpbmFsSW1hZ2VEYXRhLCBncmF5RGF0YSwgX3N0cmVhbUNvbmZpZyk7XG5cbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBncmF5c2NhbGUgZGF0YSB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkR3JheURhdGEgPSBuZXcgVWludDhBcnJheShfY2FudmFzU2l6ZS54ICogX2NhbnZhc1NpemUueSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFNpemVYID0gX3ZpZGVvU2l6ZS54IC8gX2NhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwU2l6ZVkgPSBfdmlkZW9TaXplLnkgLyBfY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX2NhbnZhc1NpemUueTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgX2NhbnZhc1NpemUueDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmNYID0geCAqIHN0ZXBTaXplWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyY1kgPSB5ICogc3RlcFNpemVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkR3JheURhdGFbeSAqIF9jYW52YXNTaXplLnggKyB4XSA9IGJpbGluZWFySW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JheURhdGEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWRlb1NpemUueCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZGVvU2l6ZS55LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNYLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNZXG4gICAgICAgICAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDcm9wIHRvIHRhcmdldCByZWdpb25cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IF9zaXplLnk7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjSWR4ID0gKHkgKyBfc3kpICogX2NhbnZhc1NpemUueCArICh4ICsgX3N4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhW3kgKiBfc2l6ZS54ICsgeF0gPSBzY2FsZWRHcmF5RGF0YVtzcmNJZHhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF90aGF0LmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGF0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVHcmFiYmVyO1xuIiwiLy8gTk9URTogKFNPTUUgT0YpIFRISVMgSVMgQlJPV1NFUiBPTkxZIENPREUuICBOb2RlIGRvZXMgbm90IGhhdmUgJ2F0b2InIGJ1aWx0IGluLCBub3IgWE1MSHR0cFJlcXVlc3QuXG4vLyBIb3cgZXhhY3RseSBpcyB0aGlzIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBpbiBRdWFnZ2E/IERvIHdlIG5lZWQgdGhlIGJyb3dzZXIgc3BlY2lmaWMgY29kZT8gRG8gd2Vcbi8vIG5lZWQgdG8gcG9ydCBhbnkgcGFydCBvZiB0aGlzIHRoYXQgZG9lc24ndCB3b3JrIGluIE5vZGUgdG8gbm9kZT9cblxuLy8gVGFncyBzY3JhcGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xuY29uc3QgRXhpZlRhZ3MgPSB7IDB4MDExMjogJ29yaWVudGF0aW9uJyB9O1xuZXhwb3J0IGNvbnN0IEF2YWlsYWJsZVRhZ3MgPSBPYmplY3Qua2V5cyhFeGlmVGFncykubWFwKChrZXkpID0+IEV4aWZUYWdzW2tleV0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbk9iamVjdFVSTChzcmMsIHRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgaWYgKC9eYmxvYjovaS50ZXN0KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFVSTFRvQmxvYihzcmMpXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiBmaW5kVGFnc0luQnVmZmVyKGJ1ZmZlciwgdGFncykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJsKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YVVybC5yZXBsYWNlKC9eZGF0YTooW147XSspO2Jhc2U2NCwvZ21pLCAnJyk7XG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeS5sZW5ndGg7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gcmVhZFRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgaHR0cC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiAoaHR0cC5zdGF0dXMgPT09IDIwMCB8fCBodHRwLnN0YXR1cyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGh0dHAuc2VuZCgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbkJ1ZmZlcihmaWxlLCBzZWxlY3RlZFRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gZmlsZS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGV4aWZUYWdzID0gc2VsZWN0ZWRUYWdzLnJlZHVjZSgocmVzdWx0LCBzZWxlY3RlZFRhZykgPT4ge1xuICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcigodGFnKSA9PiBFeGlmVGFnc1t0YWddID09PSBzZWxlY3RlZFRhZylbMF07XG4gICAgICAgIGlmIChleGlmVGFnKSB7XG4gICAgICAgICAgICByZXN1bHRbZXhpZlRhZ10gPSBzZWxlY3RlZFRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgbWFya2VyO1xuXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGV4aWZUYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRFWElGRGF0YShmaWxlLCBzdGFydCwgZXhpZlRhZ3MpIHtcbiAgICBpZiAoZ2V0U3RyaW5nRnJvbUJ1ZmZlcihmaWxlLCBzdGFydCwgNCkgIT09ICdFeGlmJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcbiAgICBsZXQgYmlnRW5kO1xuXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0RDREKSB7XG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgZXhpZlRhZ3MsIGJpZ0VuZCk7XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7XG4gICAgY29uc3QgdGFncyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW50cnlPZmZzZXQgPSBkaXJTdGFydCArIGkgKiAxMiArIDI7XG4gICAgICAgIGNvbnN0IHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCkge1xuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBvdXRzdHIgPSAnJztcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRzdHI7XG59XG4iLCJpbXBvcnQgeyBmaW5kVGFnc0luT2JqZWN0VVJMIH0gZnJvbSAnLi9leGlmX2hlbHBlcic7XG5cbi8vIEV4cG9ydGVkIGhlbHBlciBmb3IgZmlsZW5hbWUgZ2VuZXJhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VGaWxlbmFtZShkaXJlY3RvcnksIG51bSkge1xuICAgIHJldHVybiBgJHtkaXJlY3Rvcnl9aW1hZ2UtJHtudW0udG9TdHJpbmcoKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xufVxuXG5jb25zdCBJbWFnZUxvYWRlciA9IHt9O1xuSW1hZ2VMb2FkZXIubG9hZCA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGNhbGxiYWNrLCBvZmZzZXQsIHNpemUsIHNlcXVlbmNlLCBjb25maWcpIHtcbiAgICBjb25zdCBodG1sSW1hZ2VzU3JjQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgaHRtbEltYWdlc0FycmF5ID0gbmV3IEFycmF5KGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBpbWc7XG4gICAgbGV0IG51bTtcblxuICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5WzBdID0gZGlyZWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcbiAgICAgICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVtpXSA9IGdlbmVyYXRlSW1hZ2VGaWxlbmFtZShkaXJlY3RvcnksIG51bSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZCA9IFtdO1xuICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xuICAgIH07XG4gICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCA9IGZ1bmN0aW9uIChsb2FkZWRJbWcpIHtcbiAgICAgICAgY29uc3Qgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbm90bG9hZGVkSW1ncy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3NbeF0gPT09IGxvYWRlZEltZykge1xuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBlbmNvZGVVUkkgZm9yIG1hdGNoaW5nIGZpbGVuYW1lcyB3aXRoIHNwYWNlcyBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ05hbWUgPSBlbmNvZGVVUkkoaHRtbEltYWdlc1NyY0FycmF5W3ldLnN1YnN0cihodG1sSW1hZ2VzU3JjQXJyYXlbeV0ubGFzdEluZGV4T2YoJy8nKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVkSW1nLnNyYy5sYXN0SW5kZXhPZihpbWdOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxJbWFnZXNBcnJheVt5XSA9IHsgaW1nOiBsb2FkZWRJbWcgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3Rsb2FkZWRJbWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWc/LmRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEltYWdlcyBsb2FkZWQ6ICR7aHRtbEltYWdlc0FycmF5Lmxlbmd0aH0gaW1hZ2Uke2h0bWxJbWFnZXNBcnJheS5sZW5ndGggIT09IDEgPyAncycgOiAnJ30gZnJvbSAke3NlcXVlbmNlID09PSBmYWxzZSA/IGRpcmVjdG9yeSA6IGRpcmVjdG9yeSArICcgKHNlcXVlbmNlKSd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZmluZFRhZ3NJbk9iamVjdFVSTChkaXJlY3RvcnksIFsnb3JpZW50YXRpb24nXSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHRhZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxJbWFnZXNBcnJheVswXS50YWdzID0gdGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZShpbWcpO1xuICAgICAgICBhZGRPbmxvYWRIYW5kbGVyKGltZywgaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgaW1nLnNyYyA9IGh0bWxJbWFnZXNTcmNBcnJheVtpXTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBhZGRPbmxvYWRIYW5kbGVyKGltZywgaHRtbEltYWdlc0FycmF5KSB7XG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCh0aGlzKTtcbiAgICB9O1xuICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubG9hZGVkKHRoaXMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IChJbWFnZUxvYWRlcik7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuLi9pbWFnZV9sb2FkZXInO1xuaW1wb3J0IHsgWFlTaXplLCBQb2ludCB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVWaWRlb1N0cmVhbScpO1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHR5cGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0U2l6ZSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuXG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SW5wdXRTdHJlYW0oY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCAodHlwZW9mIGNvbmZpZy5zcmMgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5zcmMgOiAnJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGxheSgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnPy50eXBlICE9PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRUaW1lJywgdGltZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgICAgIF9ldmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyaWdnZXIoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjYW5yZWNvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoc2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHNpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVMaXZlU3RyZWFtJyk7XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhhdCA9IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk7XG4gICAgICAgIHRoYXQuZW5kZWQgPSBmdW5jdGlvbiBlbmRlZCgpOiBmYWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2VTdHJlYW0oKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyoqKiogSW5wdXRTdHJlYW1Ccm93c2VyIGNyZWF0ZUltYWdlU3RyZWFtJyk7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgc2VxdWVuY2U6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIGxldCBwYXVzZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpbWdBcnJheTogYW55W10gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAxO1xuICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgKGltZ3M6IEFycmF5PHsgdGFnczogYW55OyBpbWc6IEhUTUxJbWFnZUVsZW1lbnR9PikgPT4ge1xuICAgICAgICAgICAgICAgIGltZ0FycmF5ID0gaW1ncztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sIG9mZnNldCwgc2l6ZSwgX2NvbmZpZz8uc2VxdWVuY2UsIF9jb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpOyAvLyBUT0RPOiB0eXBlc2NyaXB0IGNvbXBsYWlucyB0aGF0IGFueVtdIGlzIG5vdCB2YWxpZCBmb3IgYSBzZWNvbmQgYXJnIGZvciBhcHBseT8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYW55IGNvZGUgc2hhcmVkIHdpdGggdGhlIGZpcnN0IElucHV0U3RyZWFtIGFib3ZlIHNob3VsZCBiZSBzaGFyZWQgbm90IGNvcGllZFxuICAgICAgICAvLyBUT0RPOiBwdWJsaXNoRXZlbnQgbmVlZHMgYWNjZXNzIHRvIGlucHV0U3RyZWFtLCBidXQgaW5wdXRTdHJlYW0gbmVlZHMgYWNjZXNzIHRvIHB1Ymxpc2hFdmVudFxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHdoeSBpdCdzIGEgJ3ZhcicsIHNvIGl0IGhvaXN0cyBiYWNrLiAgVGhpcyBpcyB1Z2x5LCBhbmQgc2hvdWxkIGJlIGNoYW5nZWQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcblxuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgobmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShjYW52YXNTaXplKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5Py5bZnJhbWVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJZHggPCAoc2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUlkeCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnZW5kZWQnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsIi8qKlxuICogaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vVGlwcy80MDcxNzIvQ29ubmVjdGVkLUNvbXBvbmVudC1MYWJlbGluZy1hbmQtVmVjdG9yaXphdGlvblxuICovXG5jb25zdCBUcmFjZXIgPSB7XG4gICAgc2VhcmNoRGlyZWN0aW9uczogW1swLCAxXSwgWzEsIDFdLCBbMSwgMF0sIFsxLCAtMV0sIFswLCAtMV0sIFstMSwgLTFdLCBbLTEsIDBdLCBbLTEsIDFdXSxcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCB7IHNlYXJjaERpcmVjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICAgICAgbGV0IHBvcztcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGxldCB4O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VhcmNoRGlyZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LmN5ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQuY3ggKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xuICAgICAgICAgICAgICAgIGlmICgoaW1hZ2VEYXRhW3Bvc10gPT09IGNvbG9yKSAmJiAoKGxhYmVsRGF0YVtwb3NdID09PSAwKSB8fCAobGFiZWxEYXRhW3Bvc10gPT09IGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDEpICUgODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgRnYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IEN2O1xuICAgICAgICAgICAgbGV0IFA7XG4gICAgICAgICAgICBsZXQgbGRpcjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY3g6IHN4LFxuICAgICAgICAgICAgICAgIGN5OiBzeSxcbiAgICAgICAgICAgICAgICBkaXI6IDAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgRnYgPSB2ZXJ0ZXgyRChzeCwgc3ksIGN1cnJlbnQuZGlyKTtcbiAgICAgICAgICAgICAgICBDdiA9IEZ2O1xuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBDdiA9IFA7XG5cbiAgICAgICAgICAgICAgICBsZXQgdG90YWxQaXhlbENvdW50ID0gaW1hZ2VXcmFwcGVyLnNpemUueCAqIGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgICAgICAgICAgICAgbGV0IHBpeGVsQ291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDYpICUgODtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi55ID0gY3VycmVudC5jeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKGN1cnJlbnQuY3ggIT09IHN4IHx8IGN1cnJlbnQuY3kgIT09IHN5KSAmJiArK3BpeGVsQ291bnRlciA8IHRvdGFsUGl4ZWxDb3VudCk7XG4gICAgICAgICAgICAgICAgRnYucHJldiA9IEN2LnByZXY7XG4gICAgICAgICAgICAgICAgQ3YucHJldi5uZXh0ID0gRnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRnY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCAoVHJhY2VyKTtcbiIsImltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuXG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgUmFzdGVyaXplciA9IHtcbiAgICBjcmVhdGVDb250b3VyMkQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXI6IG51bGwsXG4gICAgICAgICAgICBpbmRleDogbnVsbCxcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgaW5zaWRlQ29udG91cnM6IG51bGwsXG4gICAgICAgICAgICBuZXh0cGVlcjogbnVsbCxcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgQ09OVE9VUl9ESVI6IHtcbiAgICAgICAgQ1dfRElSOiAwLFxuICAgICAgICBDQ1dfRElSOiAxLFxuICAgICAgICBVTktOT1dOX0RJUjogMixcbiAgICB9LFxuICAgIERJUjoge1xuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NixcbiAgICB9LFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gVHJhY2VyLmNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhc3Rlcml6ZShkZXB0aGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBiYztcbiAgICAgICAgICAgICAgICBsZXQgbGM7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IGN4O1xuICAgICAgICAgICAgICAgIGxldCBjeTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvck1hcCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgbGV0IGNjO1xuICAgICAgICAgICAgICAgIGxldCBzYztcbiAgICAgICAgICAgICAgICBsZXQgcG9zO1xuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGN4ID0gMTsgY3ggPCB3aWR0aCAtIDE7IGN4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGN5ICogd2lkdGggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9PSBiYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtsY10gPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29udG91clRyYWNpbmcoY3ksIGN4LCBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSwgY29sb3IsIGxhYmVsaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRobGFiZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHNjICE9PSBudWxsKSAmJiBzYy5pbmRleCAhPT0gbGFiZWxpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IHNjLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MuaW5zaWRlQ29udG91cnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3VycyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYWJlbERhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwW2xhYmVsaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2MsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb25uZWN0ZWRDb3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcSA9IGZpcnN0Q29udG91cjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBpcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuVU5LTk9XTl9ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuLyogQHByZXNlcnZlIEFTTSBCRUdJTiAqL1xuLyoqXG4gKiBNb3JwaG9sb2dpY2FsIHNrZWxldG9uaXphdGlvbiB1c2luZyBpdGVyYXRpdmUgdGhpbm5pbmcgYWxnb3JpdGhtLlxuICogUmVkdWNlcyBiaW5hcnkgaW1hZ2VzIHRvIHNpbmdsZS1waXhlbC13aWRlIHNrZWxldG9ucyB3aGlsZSBwcmVzZXJ2aW5nIHRvcG9sb2d5LlxuICpcbiAqIE1lbW9yeSBsYXlvdXQgaW4gc2hhcmVkIEFycmF5QnVmZmVyICg0IHJlZ2lvbnMgb2Ygc2l6ZcKyKTpcbiAqIC0gUmVnaW9uIDA6IFdvcmtpbmcgaW1hZ2UgKHN1YkltYWdlUHRyID0gMClcbiAqIC0gUmVnaW9uIDE6IEVyb2RlZCByZXN1bHQgKGVyb2RlZEltYWdlUHRyID0gc2l6ZcKyKVxuICogLSBSZWdpb24gMjogVGVtcC9zY3JhdGNoIHNwYWNlICh0ZW1wSW1hZ2VQdHIgPSAyKnNpemXCsilcbiAqIC0gUmVnaW9uIDM6IEZpbmFsIHNrZWxldG9uIG91dHB1dCAoc2tlbEltYWdlUHRyID0gMypzaXplwrIpXG4gKi9cbmZ1bmN0aW9uIFNrZWxldG9uaXplcihzdGRsaWIsIGZvcmVpZ24sIGJ1ZmZlcikge1xuICAgICd1c2UgYXNtJztcblxuICAgIHZhciBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB2YXIgc2l6ZSA9IGZvcmVpZ24uc2l6ZSB8IDA7XG4gICAgdmFyIGltdWwgPSBzdGRsaWIuTWF0aC5pbXVsO1xuXG4gICAgLyoqXG4gICAgICogTW9ycGhvbG9naWNhbCBlcm9zaW9uIHdpdGggNS1waXhlbCBjcm9zcyBzdHJ1Y3R1cmluZyBlbGVtZW50LlxuICAgICAqIEEgcGl4ZWwgc3Vydml2ZXMgb25seSBpZiBhbGwgNSBwaXhlbHMgaW4gdGhlIGNyb3NzIHBhdHRlcm4gYXJlIHNldDpcbiAgICAgKiB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBjZW50ZXIsIGJvdHRvbS1sZWZ0LCBib3R0b20tcmlnaHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciA9IGluSW1hZ2VQdHIgfCAwO1xuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgdiA9IDA7XG4gICAgICAgIHZhciB1ID0gMDtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciB5U3RhcnQxID0gMDtcbiAgICAgICAgdmFyIHlTdGFydDIgPSAwO1xuICAgICAgICB2YXIgeFN0YXJ0MSA9IDA7XG4gICAgICAgIHZhciB4U3RhcnQyID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICAvLyBQaXhlbCBzdXJ2aXZlcyBlcm9zaW9uIG9ubHkgaWYgYWxsIDUgY3Jvc3MgbmVpZ2hib3JzIGFyZSBzZXRcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQaXhlbC13aXNlIHN1YnRyYWN0aW9uOiBvdXQgPSBhIC0gYiAoY2FwdHVyZXMgdGhlIFwicGVlbGVkXCIgbGF5ZXIpXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciA9IGFJbWFnZVB0ciB8IDA7XG4gICAgICAgIGJJbWFnZVB0ciA9IGJJbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSAtIChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQaXhlbC13aXNlIE9SOiBvdXQgPSBhIHwgYiAoYWNjdW11bGF0ZXMgc2tlbGV0b24gbGF5ZXJzKVxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyID0gYUltYWdlUHRyIHwgMDtcbiAgICAgICAgYkltYWdlUHRyID0gYkltYWdlUHRyIHwgMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgPSBvdXRJbWFnZVB0ciB8IDA7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIHwgKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvdW50cyBub24temVybyBwaXhlbHMgdG8gZGV0ZWN0IHdoZW4gZXJvc2lvbiBpcyBjb21wbGV0ZVxuICAgIGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciA9IGltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBzdW0gPSAoKHN1bSB8IDApICsgKGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChzdW0gfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGaWxscyBpbWFnZSByZWdpb24gd2l0aCBhIGNvbnN0YW50IHZhbHVlXG4gICAgZnVuY3Rpb24gaW5pdChpbWFnZVB0ciwgdmFsdWUpIHtcbiAgICAgICAgaW1hZ2VQdHIgPSBpbWFnZVB0ciB8IDA7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTW9ycGhvbG9naWNhbCBkaWxhdGlvbiB3aXRoIDUtcGl4ZWwgY3Jvc3MgLSBwaXhlbCBpcyBzZXQgaWYgYW55IG5laWdoYm9yIGlzIHNldFxuICAgIGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyID0gaW5JbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgdmFyIHUgPSAwO1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIHlTdGFydDEgPSAwO1xuICAgICAgICB2YXIgeVN0YXJ0MiA9IDA7XG4gICAgICAgIHZhciB4U3RhcnQxID0gMDtcbiAgICAgICAgdmFyIHhTdGFydDIgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPiAoMCB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29waWVzIGltYWdlIGRhdGEgZnJvbSBzcmMgdG8gZHN0IHJlZ2lvblxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICAgICAgc3JjSW1hZ2VQdHIgPSBzcmNJbWFnZVB0ciB8IDA7XG4gICAgICAgIGRzdEltYWdlUHRyID0gZHN0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhkc3RJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IChpbWFnZXNbKHNyY0ltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBaZXJvcyBvdXQgdGhlIGJvcmRlciBwaXhlbHMgb2YgdGhlIGltYWdlLlxuICAgICAqIEZpcnN0IGxvb3A6IGhhbmRsZXMgdG9wLCBsZWZ0LCBhbmQgcmlnaHQgZWRnZXMgc2ltdWx0YW5lb3VzbHlcbiAgICAgKiBTZWNvbmQgbG9vcDogaGFuZGxlcyBib3R0b20gZWRnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm9Cb3JkZXIoaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgPSBpbWFnZVB0ciB8IDA7XG5cbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IDA7XG5cbiAgICAgICAgZm9yICh4ID0gMDsgKHggfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHggPSAoeCArIDEpIHwgMCkge1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHgpIHwgMF0gPSAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICgoeSArIHNpemUpIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gc2tlbGV0b25pemF0aW9uIGFsZ29yaXRobSB1c2luZyBpdGVyYXRpdmUgdGhpbm5pbmc6XG4gICAgICogMS4gRXJvZGUgdGhlIHdvcmtpbmcgaW1hZ2VcbiAgICAgKiAyLiBEaWxhdGUgdGhlIGVyb2RlZCB2ZXJzaW9uXG4gICAgICogMy4gU3VidHJhY3QgZGlsYXRlZCBmcm9tIG9yaWdpbmFsIChleHRyYWN0cyBcInBlZWxlZFwiIGxheWVyKVxuICAgICAqIDQuIE9SIHRoZSBwZWVsZWQgbGF5ZXIgaW50byBza2VsZXRvbiBhY2N1bXVsYXRvclxuICAgICAqIDUuIENvcHkgZXJvZGVkIGltYWdlIGJhY2sgdG8gd29ya2luZyBpbWFnZVxuICAgICAqIDYuIFJlcGVhdCB1bnRpbCB3b3JraW5nIGltYWdlIGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gTm8gcmV0dXJuIHZhbHVlIC0gb3BlcmF0ZXMgZGlyZWN0bHkgb24gc2hhcmVkIGJ1ZmZlci5cbiAgICAgKiAgIElucHV0IGltYWdlIGlzIHJlYWQgZnJvbSBidWZmZXIgb2Zmc2V0IDAgKHN1YkltYWdlUHRyKS5cbiAgICAgKiAgIE91dHB1dCBza2VsZXRvbiBpcyB3cml0dGVuIHRvIGJ1ZmZlciBvZmZzZXQgMypzaXplwrIgKHNrZWxJbWFnZVB0cikuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2tlbGV0b25pemUoKSB7XG4gICAgICAgIHZhciBzdWJJbWFnZVB0ciA9IDA7ICAgICAgICAvLyBSZWdpb24gMDogV29ya2luZyBpbWFnZSAoaW5wdXQsIG9mZnNldCA9IDApXG4gICAgICAgIHZhciBlcm9kZWRJbWFnZVB0ciA9IDA7ICAgICAvLyBSZWdpb24gMTogRXJvZGVkIHJlc3VsdCAob2Zmc2V0ID0gc2l6ZcKyKVxuICAgICAgICB2YXIgdGVtcEltYWdlUHRyID0gMDsgICAgICAgLy8gUmVnaW9uIDI6IFNjcmF0Y2ggc3BhY2UgKG9mZnNldCA9IDIqc2l6ZcKyKVxuICAgICAgICB2YXIgc2tlbEltYWdlUHRyID0gMDsgICAgICAgLy8gUmVnaW9uIDM6IEZpbmFsIHNrZWxldG9uIChvdXRwdXQsIG9mZnNldCA9IDMqc2l6ZcKyKVxuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIGRvbmUgPSAwO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBieXRlIG9mZnNldHMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBzaGFyZWQgYnVmZmVyXG4gICAgICAgIGVyb2RlZEltYWdlUHRyID0gaW11bChzaXplLCBzaXplKSB8IDA7ICAgICAgICAgICAgICAgICAgLy8gUmVnaW9uIDE6IHNpemXCsiBieXRlcyBpblxuICAgICAgICB0ZW1wSW1hZ2VQdHIgPSAoZXJvZGVkSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwOyAgLy8gUmVnaW9uIDI6IDIqc2l6ZcKyIGJ5dGVzIGluXG4gICAgICAgIHNrZWxJbWFnZVB0ciA9ICh0ZW1wSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwOyAgICAvLyBSZWdpb24gMzogMypzaXplwrIgYnl0ZXMgaW5cblxuICAgICAgICAvLyBJbml0aWFsaXplIHNrZWxldG9uIGFjY3VtdWxhdG9yIHRvIHplcm9cbiAgICAgICAgaW5pdChza2VsSW1hZ2VQdHIsIDApO1xuICAgICAgICB6ZXJvQm9yZGVyKHN1YkltYWdlUHRyKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlcm9kZShzdWJJbWFnZVB0ciwgZXJvZGVkSW1hZ2VQdHIpO1xuICAgICAgICAgICAgZGlsYXRlKGVyb2RlZEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgICAgICAgc3VidHJhY3Qoc3ViSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIGJpdHdpc2VPcihza2VsSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgc2tlbEltYWdlUHRyKTtcbiAgICAgICAgICAgIG1lbWNweShlcm9kZWRJbWFnZVB0ciwgc3ViSW1hZ2VQdHIpO1xuICAgICAgICAgICAgc3VtID0gY291bnROb25aZXJvKHN1YkltYWdlUHRyKSB8IDA7XG4gICAgICAgICAgICBkb25lID0gKChzdW0gfCAwKSA9PSAwIHwgMCk7XG4gICAgICAgIH0gd2hpbGUgKCFkb25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2tlbGV0b25pemU6IHNrZWxldG9uaXplIH07XG59XG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xuXG5leHBvcnQgZGVmYXVsdCBTa2VsZXRvbml6ZXI7XG4vKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuIiwiaW1wb3J0IHsgdmVjMiwgbWF0MiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxuICAgIG90c3VUaHJlc2hvbGQsXG4gICAgaHN2MnJnYixcbiAgICBjbHVzdGVyLFxuICAgIHRvcEdlbmVyaWMsXG4gICAgaW1hZ2VSZWYsXG4gICAgaGFsZlNhbXBsZSxcbiAgICBjb21wdXRlSW1hZ2VBcmVhLFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XG5pbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcbmltcG9ydCBza2VsZXRvbml6ZXIgZnJvbSAnLi9za2VsZXRvbml6ZXInO1xuXG5cblxubGV0IF9jb25maWc7XG5sZXQgX2N1cnJlbnRJbWFnZVdyYXBwZXI7XG5sZXQgX3NrZWxJbWFnZVdyYXBwZXI7XG5sZXQgX3N1YkltYWdlV3JhcHBlcjtcbmxldCBfbGFiZWxJbWFnZVdyYXBwZXI7XG5sZXQgX3BhdGNoR3JpZDtcbmxldCBfcGF0Y2hMYWJlbEdyaWQ7XG5sZXQgX2ltYWdlVG9QYXRjaEdyaWQ7XG5sZXQgX2JpbmFyeUltYWdlV3JhcHBlcjtcbmxldCBfcGF0Y2hTaXplO1xuY29uc3QgX2NhbnZhc0NvbnRhaW5lciA9IHtcbiAgICBjdHg6IHtcbiAgICAgICAgYmluYXJ5OiBudWxsLFxuICAgIH0sXG4gICAgZG9tOiB7XG4gICAgICAgIGJpbmFyeTogbnVsbCxcbiAgICB9LFxufTtcbmNvbnN0IF9udW1QYXRjaGVzID0geyB4OiAwLCB5OiAwIH07XG5sZXQgX2lucHV0SW1hZ2VXcmFwcGVyO1xubGV0IF9za2VsZXRvbml6ZXI7XG5cbmZ1bmN0aW9uIGluaXRCdWZmZXJzKCkge1xuICAgIGlmIChfY29uZmlnLmhhbGZTYW1wbGUpIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB4OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gMiB8IDAsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgeTogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueSAvIDIgfCAwLFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IF9pbnB1dEltYWdlV3JhcHBlcjtcbiAgICB9XG5cbiAgICBfcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKF9jb25maWcucGF0Y2hTaXplLCBfY3VycmVudEltYWdlV3JhcHBlci5zaXplKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgX251bVBhdGNoZXMueCA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueCAvIF9wYXRjaFNpemUueCB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBfbnVtUGF0Y2hlcy55ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3BhdGNoU2l6ZS55IHwgMDtcblxuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUsIHVuZGVmaW5lZCwgVWludDhBcnJheSwgZmFsc2UpO1xuXG4gICAgX2xhYmVsSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcblxuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBidWZmZXIgc2l6ZSAoNCByZWdpb25zIGZvciBhc20uanMgc2tlbGV0b25pemVyKVxuICAgIGNvbnN0IHNrZWxldG9uSW1hZ2VEYXRhU2l6ZSA9IF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDQ7XG4gICAgLy8gUm91bmQgdXAgdG8gbmV4dCBwb3dlciBvZiAyIGZvciBhc20uanMgaGVhcCByZXF1aXJlbWVudFxuICAgIC8vIFVzZSBtaW5pbXVtIDY0S0IgZm9yIG9wdGltYWwgYXNtLmpzIHBlcmZvcm1hbmNlIChhdm9pZHMgVjggd2FybmluZ3MpXG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IE1hdGgubWF4KDY1NTM2LCBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHNrZWxldG9uSW1hZ2VEYXRhU2l6ZSkpKSk7XG4gICAgY29uc3Qgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyU2l6ZSk7XG4gICAgX3N1YkltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIDAsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSkpO1xuICAgIF9za2VsSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxuICAgICAgICBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55ICogMywgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSxcbiAgICAgICAgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBfc2tlbGV0b25pemVyID0gc2tlbGV0b25pemVyKFxuICAgICAgICB7IE1hdGgsIFVpbnQ4QXJyYXkgfSxcbiAgICAgICAgeyBzaXplOiBfcGF0Y2hTaXplLnggfSxcbiAgICAgICAgc2tlbGV0b25JbWFnZURhdGEsXG4gICAgKTtcblxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMCxcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcbiAgICBfcGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIEludDMyQXJyYXksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmNsYXNzTmFtZSA9ICdiaW5hcnlCdWZmZXInO1xuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1ZycpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxSZWFkRnJlcXVlbnRseSA9ICEhX2NvbmZpZy53aWxsUmVhZEZyZXF1ZW50bHk7XG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnPy5zaG93Q2FudmFzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignKiBpbml0Q2FudmFzIHdpbGxSZWFkRnJlcXVlbnRseScsIHdpbGxSZWFkRnJlcXVlbnRseSwgX2NvbmZpZyk7XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KCcyZCcsIHsgd2lsbFJlYWRGcmVxdWVudGx5IH0pO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS53aWR0aCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5oZWlnaHQgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IHdoaWNoIGVuY2xvc2VzIGFsbCB0aGUgZ2l2ZW4gcGF0Y2hlc1xuICogQHJldHVybnMge0FycmF5fSBUaGUgbWluaW1hbCBib3VuZGluZyBib3hcbiAqL1xuZnVuY3Rpb24gYm94RnJvbVBhdGNoZXMocGF0Y2hlcykge1xuICAgIGxldCBvdmVyQXZnO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBsZXQgdHJhbnNNYXQ7XG4gICAgbGV0IG1pbnggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWlueSA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBtYXh4ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBtYXh5ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBib3g7XG4gICAgbGV0IHNjYWxlO1xuXG4gICAgLy8gZHJhdyBhbGwgcGF0Y2hlcyB3aGljaCBhcmUgdG8gYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uXG4gICAgb3ZlckF2ZyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBvdmVyQXZnICs9IHBhdGNoLnJhZDtcbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICdyZWQnIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3ZlckF2ZyAvPSBwYXRjaGVzLmxlbmd0aDtcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgaWYgKG92ZXJBdmcgPCAwKSB7XG4gICAgICAgIG92ZXJBdmcgKz0gMTgwO1xuICAgIH1cblxuICAgIG92ZXJBdmcgPSAoMTgwIC0gb3ZlckF2ZykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXRjaGVzIGFuZCByb3RhdGUgYnkgYW5nbGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZCkge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChwYXRjaC5ib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBib3VuZGluZyBib3hcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XG4gICAgICAgICAgICAgICAgbWlueCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XG4gICAgICAgICAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XG4gICAgICAgICAgICAgICAgbWlueSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XG4gICAgICAgICAgICAgICAgbWF4eSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xuXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZEJveCkge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBfY29uZmlnLmhhbGZTYW1wbGUgPyAyIDogMTtcbiAgICAvLyByZXZlcnNlIHJvdGF0aW9uO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5pbnZlcnQodHJhbnNNYXQsIHRyYW5zTWF0KTtcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIudHJhbnNmb3JtTWF0Mihib3hbal0sIGJveFtqXSwgdHJhbnNNYXQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93QkIpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJpbmFyeSBpbWFnZSBvZiB0aGUgY3VycmVudCBpbWFnZVxuICovXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xuICAgIG90c3VUaHJlc2hvbGQoX2N1cnJlbnRJbWFnZVdyYXBwZXIsIF9iaW5hcnlJbWFnZVdyYXBwZXIpO1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2hvdyhfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDI1NSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXG4gKiBleHRyYWN0IHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IG1vbWVudHM7XG4gICAgbGV0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGxldCByYXN0ZXJpemVyO1xuICAgIGxldCByYXN0ZXJSZXN1bHQ7XG4gICAgbGV0IHBhdGNoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9udW1QYXRjaGVzLnk7IGorKykge1xuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcbiAgICAgICAgICAgIHkgPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSAqIGo7XG5cbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXG4gICAgICAgICAgICBza2VsZXRvbml6ZSh4LCB5KTtcblxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xuICAgICAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChfbGFiZWxJbWFnZVdyYXBwZXIuZGF0YSwgMCk7XG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICByYXN0ZXJSZXN1bHQgPSByYXN0ZXJpemVyLnJhc3Rlcml6ZSgwKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBfbGFiZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIE1hdGguZmxvb3IoMzYwIC8gcmFzdGVyUmVzdWx0LmNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgbW9tZW50cyBmcm9tIHRoZSBza2VsZXRvbml6ZWQgcGF0Y2hcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGVsaWdpYmxlIHBhdGNoZXNcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2ldO1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aG9zZSBjb25uZWN0ZWQgYXJlYXMgd2hpY2ggY29udGFpbiBhdCBsZWFzdCA2IHBhdGNoZXNcbiAqIGFuZCByZXR1cm5zIHRoZW0gb3JkZXJlZCBERVNDIGJ5IHRoZSBudW1iZXIgb2YgY29udGFpbmVkIHBhdGNoZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYWJlbFxuICovXG5mdW5jdGlvbiBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgbGFiZWxIaXN0ID0gW107XG4gICAgbGV0IHRvcExhYmVscyA9IFtdO1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF4TGFiZWw7IGkrKykge1xuICAgICAgICBsYWJlbEhpc3QucHVzaCgwKTtcbiAgICB9XG4gICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA+IDApIHtcbiAgICAgICAgICAgIGxhYmVsSGlzdFtfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dIC0gMV0rKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxhYmVsSGlzdCA9IGxhYmVsSGlzdC5tYXAoKHZhbCwgaWR4KSA9PiAoe1xuICAgICAgICB2YWwsXG4gICAgICAgIGxhYmVsOiBpZHggKyAxLFxuICAgIH0pKTtcblxuICAgIGxhYmVsSGlzdC5zb3J0KChhLCBiKSA9PiBiLnZhbCAtIGEudmFsKTtcblxuICAgIC8vIGV4dHJhY3QgdG9wIGFyZWFzIHdpdGggYXQgbGVhc3QgNSBwYXRjaGVzIHByZXNlbnRcbiAgICB0b3BMYWJlbHMgPSBsYWJlbEhpc3QuZmlsdGVyKChlbCkgPT4gZWwudmFsID49IDUpO1xuXG4gICAgcmV0dXJuIHRvcExhYmVscztcbn1cblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCkge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBzdW07XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdO1xuICAgIGxldCBwYXRjaDtcbiAgICBsZXQgYm94O1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b3BMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgICAgICBwYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPT09IHRvcExhYmVsc1tpXS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtzdW1dO1xuICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm94ID0gYm94RnJvbVBhdGNoZXMocGF0Y2hlcyk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICAgIGJveGVzLnB1c2goYm94KTtcblxuICAgICAgICAgICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBoc3ZbMF0gPSAodG9wTGFiZWxzW2ldLmxhYmVsIC8gKG1heExhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgICAgICBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzO1xufVxuXG4vKipcbiAqIEZpbmQgc2ltaWxhciBtb21lbnRzICh2aWEgY2x1c3RlcilcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb21lbnRzXG4gKi9cbmZ1bmN0aW9uIHNpbWlsYXJNb21lbnRzKG1vbWVudHMpIHtcbiAgICBjb25zdCBjbHVzdGVycyA9IGNsdXN0ZXIobW9tZW50cywgMC45MCk7XG4gICAgY29uc3QgdG9wQ2x1c3RlciA9IHRvcEdlbmVyaWMoY2x1c3RlcnMsIDEsIChlKSA9PiBlLmdldFBvaW50cygpLmxlbmd0aCk7XG4gICAgbGV0IHBvaW50cyA9IFtdOyBjb25zdFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICBpZiAodG9wQ2x1c3Rlci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcG9pbnRzID0gdG9wQ2x1c3RlclswXS5pdGVtLmdldFBvaW50cygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzW2ldLnBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBza2VsZXRvbml6ZSh4LCB5KSB7XG4gICAgX2JpbmFyeUltYWdlV3JhcHBlci5zdWJJbWFnZUFzQ29weShfc3ViSW1hZ2VXcmFwcGVyLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgX3NrZWxldG9uaXplci5za2VsZXRvbml6ZSgpO1xuXG4gICAgLy8gU2hvdyBza2VsZXRvbiBpZiByZXF1ZXN0ZWRcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1NrZWxldG9uKSB7XG4gICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAzNjAsIGltYWdlUmVmKHgsIHkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgYW5kIGRlc2NyaWJlcyB0aG9zZSBwYXRjaGVzIHdoaWNoIHNlZW0gdG8gY29udGFpbiBhIGJhcmNvZGUgcGF0dGVyblxuICogQHBhcmFtIHtBcnJheX0gbW9tZW50c1xuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoUG9zLFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2YgcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBkZXNjcmliZVBhdGNoKG1vbWVudHMsIHBhdGNoUG9zLCB4LCB5KSB7XG4gICAgbGV0IGs7XG4gICAgbGV0IGF2ZztcbiAgICBjb25zdCBlbGlnaWJsZU1vbWVudHMgPSBbXTtcbiAgICBsZXQgbWF0Y2hpbmdNb21lbnRzO1xuICAgIGxldCBwYXRjaDtcbiAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBbXTtcbiAgICBjb25zdCBtaW5Db21wb25lbnRXZWlnaHQgPSBNYXRoLmNlaWwoX3BhdGNoU2l6ZS54IC8gMyk7XG5cbiAgICBpZiAobW9tZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAvLyBvbmx5IGNvbGxlY3QgbW9tZW50cyB3aGljaCdzIGFyZWEgY292ZXJzIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodCBwaXhlbHMuXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBtb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAobW9tZW50c1trXS5tMDAgPiBtaW5Db21wb25lbnRXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBlbGlnaWJsZU1vbWVudHMucHVzaChtb21lbnRzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGF0IGxlYXN0IDIgbW9tZW50cyBhcmUgZm91bmQgd2hpY2ggaGF2ZSBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHRzIGNvdmVyZWRcbiAgICAgICAgaWYgKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgbWF0Y2hpbmdNb21lbnRzID0gc2ltaWxhck1vbWVudHMoZWxpZ2libGVNb21lbnRzKTtcbiAgICAgICAgICAgIGF2ZyA9IDA7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgb2YgdGhlIG1vbWVudHNcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaGluZ01vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBhdmcgKz0gbWF0Y2hpbmdNb21lbnRzW2tdPy5yYWQgPz8gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSB0d28gb2YgdGhlIG1vbWVudHMgYXJlIGFsbG93ZWQgbm90IHRvIGZpdCBpbnRvIHRoZSBlcXVhdGlvblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBwYXRjaCB0byB0aGUgc2V0XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+PSAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCAvIDQpICogM1xuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gbW9tZW50cy5sZW5ndGggLyA0KSB7XG4gICAgICAgICAgICAgICAgYXZnIC89IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXRjaFBvc1sxXSAqIF9udW1QYXRjaGVzLnggKyBwYXRjaFBvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm94OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50czogbWF0Y2hpbmdNb21lbnRzLFxuICAgICAgICAgICAgICAgICAgICByYWQ6IGF2ZyxcbiAgICAgICAgICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFtNYXRoLmNvcyhhdmcpLCBNYXRoLnNpbihhdmcpXSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzRm91bmQucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBmaW5kcyBwYXRjaGVzIHdoaWNoIGFyZSBjb25uZWN0ZWQgYW5kIHNoYXJlIHRoZSBzYW1lIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hlc0ZvdW5kXG4gKi9cbmZ1bmN0aW9uIHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCkge1xuICAgIGxldCBsYWJlbCA9IDA7XG4gICAgY29uc3QgdGhyZXNob2xkID0gMC45NTtcbiAgICBsZXQgY3VycklkeCA9IDA7XG4gICAgbGV0IGo7XG4gICAgbGV0IHBhdGNoO1xuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmdW5jdGlvbiBub3RZZXRQcm9jZXNzZWQoKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpXSA9PT0gMCAmJiBfcGF0Y2hHcmlkLmRhdGFbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnRJZHgpIHtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgY3VycmVudFBhdGNoO1xuICAgICAgICBsZXQgaWR4O1xuICAgICAgICBsZXQgZGlyO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgeDogY3VycmVudElkeCAlIF9wYXRjaExhYmVsR3JpZC5zaXplLngsXG4gICAgICAgICAgICB5OiAoY3VycmVudElkeCAvIF9wYXRjaExhYmVsR3JpZC5zaXplLngpIHwgMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNpbWlsYXJpdHk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJZHggPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbY3VycmVudElkeF07XG4gICAgICAgICAgICAvLyBhc3NpZ24gbGFiZWxcbiAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2N1cnJlbnRJZHhdID0gbGFiZWw7XG4gICAgICAgICAgICBmb3IgKGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2lkeF0udmVjLCBjdXJyZW50UGF0Y2gudmVjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBmb3IgZmluZGluZyB0aGUgcmlnaHQgcGF0Y2hlc1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaExhYmVsR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGEsIG51bGwpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICB3aGlsZSAoKGN1cnJJZHggPSBub3RZZXRQcm9jZXNzZWQoKSkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbGFiZWwrKztcbiAgICAgICAgdHJhY2UoY3VycklkeCk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaExhYmVscykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA+IDAgJiYgX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPD0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbal07XG4gICAgICAgICAgICAgICAgaHN2WzBdID0gKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIC8gKGxhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcblxuICAgICAgICBpbml0QnVmZmVycygpO1xuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIGxvY2F0ZSgpIHtcbiAgICAgICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgaGFsZlNhbXBsZShfaW5wdXRJbWFnZVdyYXBwZXIsIF9jdXJyZW50SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyaXplSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gZmluZFBhdGNoZXMoKTtcbiAgICAgICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXG4gICAgICAgIGlmIChwYXRjaGVzRm91bmQubGVuZ3RoIDwgX251bVBhdGNoZXMueCAqIF9udW1QYXRjaGVzLnkgKiAwLjA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xuICAgICAgICBjb25zdCBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICAgICAgY29uc3QgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfSxcblxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50cyhpbnB1dFN0cmVhbSwgY29uZmlnKSB7XG4gICAgICAgIGxldCBwYXRjaFNpemU7XG4gICAgICAgIGxldCB3aWR0aCA9IGlucHV0U3RyZWFtLmdldFdpZHRoKCk7XG4gICAgICAgIGxldCBoZWlnaHQgPSBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKTtcbiAgICAgICAgY29uc3QgdGhpc0hhbGZTYW1wbGUgPSBjb25maWcuaGFsZlNhbXBsZSA/IDAuNSA6IDE7XG4gICAgICAgIGxldCBhcmVhO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIGFyZWFcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcbiAgICAgICAgICAgIGFyZWEgPSBjb21wdXRlSW1hZ2VBcmVhKHdpZHRoLCBoZWlnaHQsIGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0VG9wUmlnaHQoeyB4OiBhcmVhLnN4LCB5OiBhcmVhLnN5IH0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB3aWR0aCA9IGFyZWEuc3c7XG4gICAgICAgICAgICBoZWlnaHQgPSBhcmVhLnNoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3Iod2lkdGggKiB0aGlzSGFsZlNhbXBsZSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgfTtcblxuICAgICAgICBwYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoY29uZmlnLnBhdGNoU2l6ZSwgc2l6ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnPy5zaG93UGF0Y2hTaXplKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUGF0Y2gtU2l6ZTogJHtKU09OLnN0cmluZ2lmeShwYXRjaFNpemUpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0V2lkdGgoTWF0aC5tYXgoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueCAvIHBhdGNoU2l6ZS54KSAqICgxIC8gdGhpc0hhbGZTYW1wbGUpICogcGF0Y2hTaXplLngpLCBwYXRjaFNpemUueCkpO1xuICAgICAgICBpbnB1dFN0cmVhbS5zZXRIZWlnaHQoTWF0aC5tYXgoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueSAvIHBhdGNoU2l6ZS55KSAqICgxIC8gdGhpc0hhbGZTYW1wbGUpICogcGF0Y2hTaXplLnkpLCBwYXRjaFNpemUueSkpO1xuXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XG4gICAgICAgICAgICB3aWR0aH0gKWFuZCBoZWlnaHQgKCR7aGVpZ2h0XG4gICAgICAgIH0pIG11c3QgYSBtdWx0aXBsZSBvZiAke3BhdGNoU2l6ZS54fWApO1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tIFwiLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSBcImNvbW1vbi9pbWFnZV93cmFwcGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBRdWFnZ2FDb250ZXh0IHtcbiAgICBwdWJsaWMgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3Q7XG5cbiAgICBwdWJsaWMgaW5wdXRTdHJlYW06IGFueTtcblxuICAgIHB1YmxpYyBmcmFtZWdyYWJiZXI6IGFueTtcblxuICAgIHB1YmxpYyBpbnB1dEltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcjtcblxuICAgIHB1YmxpYyBzdG9wcGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGluZGljYXRpbmcgdGhhdCBzdG9wKCkgd2FzIGNhbGxlZCB3aGlsZSBpbml0KCkgd2FzIHN0aWxsIGluIHByb2dyZXNzLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBoYW5kbGUgcmFjZSBjb25kaXRpb25zIGluIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgY29tcG9uZW50c1xuICAgICAqIGFyZSBtb3VudGVkL3VubW91bnRlZCByYXBpZGx5LCBjYXVzaW5nIGluaXQoKSB0byBiZSBjYWxsZWQsIHRoZW4gc3RvcCgpLFxuICAgICAqIHRoZW4gaW5pdCgpIGFnYWluIGJlZm9yZSB0aGUgZmlyc3QgaW5pdCgpIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgaW5pdEFib3J0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBib3hTaXplOiBhbnk7XG5cbiAgICBwdWJsaWMgcmVzdWx0Q29sbGVjdG9yOiBhbnk7XG5cbiAgICBwdWJsaWMgZGVjb2RlcjogYW55O1xuXG4gICAgcHVibGljIHdvcmtlclBvb2w6IGFueVtdID0gW107XG5cbiAgICBwdWJsaWMgb25VSVRocmVhZCA9IHRydWU7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FudmFzQ29udGFpbmVyID0gbmV3IENhbnZhc0NvbnRhaW5lcigpO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzSW5mbyB7XG4gICAgaW1hZ2U6IGFueTtcbiAgICBvdmVybGF5OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNDb250YWluZXIge1xuICAgIHB1YmxpYyByZWFkb25seSBjdHg6IENhbnZhc0luZm87XG4gICAgcHVibGljIHJlYWRvbmx5IGRvbTogQ2FudmFzSW5mbztcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN0eCA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgICAgIHRoaXMuZG9tID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3UG9ydCh0YXJnZXQ/OiBFbGVtZW50IHwgc3RyaW5nKTogRWxlbWVudCB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbHJlYWR5IGEgRE9NIGVsZW1lbnRcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0Lm5vZGVOYW1lICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyBVc2UgJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCcgYXMgYSBmYWxsYmFjayBzZWxlY3RvciAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gICAgY29uc3Qgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICcjaW50ZXJhY3RpdmUudmlld3BvcnQnO1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cbiIsImltcG9ydCB7IHZlYzIgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XG5cbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXG4gICAgbG9jYXRvcjogYW55LFxuKSB7XG4gICAgY29uc3QgaW5wdXRJbWFnZVdyYXBwZXIgPSBpbWFnZVdyYXBwZXIgfHwgbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksXG4gICAgICAgIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpLFxuICAgICAgICB0eXBlOiAnWFlTaXplJyxcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgKGxvY2F0b3IgYXMgYW55KS5jb25maWc/LmRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBpbWFnZSB3cmFwcGVyIHNpemUgJHtpbnB1dEltYWdlV3JhcHBlci5zaXplfWApO1xuICAgIH1cbiAgICBjb25zdCBib3hTaXplID0gW1xuICAgICAgICB2ZWMyLmNsb25lKFswLCAwXSksXG4gICAgICAgIHZlYzIuY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICB2ZWMyLmNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICB2ZWMyLmNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIDBdKSxcbiAgICBdO1xuICAgIEJhcmNvZGVMb2NhdG9yLmluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGxvY2F0b3IpO1xuICAgIHJldHVybiB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH07XG59XG4iLCJpbXBvcnQgeyBRdWFnZ2FDb250ZXh0LCBDYW52YXNDb250YWluZXIgfSBmcm9tICdRdWFnZ2FDb250ZXh0JztcbmltcG9ydCBnZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcbmltcG9ydCB0eXBlIHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmZ1bmN0aW9uIGZpbmRPckNyZWF0ZUNhbnZhcyhzZWxlY3Rvcjogc3RyaW5nLCBjbGFzc05hbWU6IHN0cmluZykge1xuICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBnZXRDYW52YXNBbmRDb250ZXh0KHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nLCBvcHRpb25zOiB7IHdpbGxSZWFkRnJlcXVlbnRseTogYm9vbGVhbjsgZGVidWc/OiBhbnkgfSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGZpbmRPckNyZWF0ZUNhbnZhcyhzZWxlY3RvciwgY2xhc3NOYW1lKTtcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIG9wdGlvbnMuZGVidWc/LnNob3dJbWFnZURldGFpbHMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCcqIGluaXRDYW52YXMgZ2V0Q2FudmFzQW5kQ29udGV4dCcpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywgeyB3aWxsUmVhZEZyZXF1ZW50bHk6IG9wdGlvbnMud2lsbFJlYWRGcmVxdWVudGx5IH0pO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xufVxuXG5pbnRlcmZhY2UgSW5pdENhbnZhc2VzT3B0aW9ucyB7XG4gICAgd2lsbFJlYWRGcmVxdWVudGx5OiBib29sZWFuO1xuICAgIGNyZWF0ZU92ZXJsYXk6IGJvb2xlYW47XG4gICAgZGVidWc/OiBhbnk7XG59XG5cbmZ1bmN0aW9uIGluaXRDYW52YXNlcyhjYW52YXNTaXplOiBYWVNpemUsIHsgd2lsbFJlYWRGcmVxdWVudGx5LCBjcmVhdGVPdmVybGF5LCBkZWJ1ZyB9OiBJbml0Q2FudmFzZXNPcHRpb25zKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicsIHsgd2lsbFJlYWRGcmVxdWVudGx5LCBkZWJ1ZyB9KTtcbiAgICAgICAgaW1hZ2UuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIG92ZXJsYXkgY2FudmFzIGlmIGNyZWF0ZU92ZXJsYXkgaXMgdHJ1ZSAoZGVmYXVsdCBiZWhhdmlvcilcbiAgICAgICAgbGV0IG92ZXJsYXk6IHsgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGw7IGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwgfSA9IHtcbiAgICAgICAgICAgIGNhbnZhczogbnVsbCxcbiAgICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjcmVhdGVPdmVybGF5KSB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5UmVzdWx0ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicsIHsgd2lsbFJlYWRGcmVxdWVudGx5LCBkZWJ1ZyB9KTtcbiAgICAgICAgICAgIG92ZXJsYXlSZXN1bHQuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgICAgICAgICAgb3ZlcmxheVJlc3VsdC5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgb3ZlcmxheSA9IG92ZXJsYXlSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LmNhbnZhcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY29udGV4dCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LmNvbnRleHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdENhbnZhcyhjb250ZXh0OiBRdWFnZ2FDb250ZXh0KTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3UG9ydChjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy50YXJnZXQpO1xuICAgIGNvbnN0IHR5cGUgPSBjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy50eXBlO1xuICAgIGlmICghdHlwZSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBEZWZhdWx0IHRvIHRydWUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgY29uc3QgY3JlYXRlT3ZlcmxheSA9IGNvbnRleHQ/LmNvbmZpZz8uY2FudmFzPy5jcmVhdGVPdmVybGF5ICE9PSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGluaXRDYW52YXNlcyhcbiAgICAgICAgY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogISFjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy53aWxsUmVhZEZyZXF1ZW50bHksXG4gICAgICAgICAgICBjcmVhdGVPdmVybGF5LFxuICAgICAgICAgICAgZGVidWc6IGNvbnRleHQ/LmNvbmZpZz8ubG9jYXRvcj8uZGVidWdcbiAgICAgICAgfVxuICAgICk7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybiB7IGRvbTogeyBpbWFnZTogbnVsbCwgb3ZlcmxheTogbnVsbCB9LCBjdHg6IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSB9O1xuXG4gICAgY29uc3QgeyBkb20gfSA9IGNvbnRhaW5lcjtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnSW1hZ2VTdHJlYW0nICYmICF2aWV3cG9ydC5jb250YWlucyhkb20uaW1hZ2UpKSB7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoZG9tLmltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb20ub3ZlcmxheSAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLm92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoZG9tLm92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG59XG4iLCIvKiBXb3JrZXIgZnVuY3Rpb25zLiBUaGVzZSBhcmUgc3RyYWlnaHQgZnJvbSB0aGUgb3JpZ2luYWwgcXVhZ2dhLmpzIGZpbGUuXG4gKiBOb3QgcHJlc2VudGx5IHVzZWQsIGFzIHdvcmtlciBzdXBwb3J0IGlzIG5vbi1mdW5jdGlvbmFsLiAgS2VlcGluZyB0aGVtIGFyb3VuZCB0ZW1wb3JhcmlseVxuICogdG8gcmVmZXIgdG8gdW50aWwgaXQgaXMgcmUtaW1wbGVtZW50ZWQuIFdlIG1heSBiZSBhYmxlIHRvIGZpeC91c2Ugc29tZSBvZiB0aGlzLlxuICovXG5cbmltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZywgQmFyY29kZVJlYWRlckNvbnN0cnVjdG9yIH0gZnJvbSBcIi4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5cbi8vIFRPRE86IG5lZWQgYSB0eXBlc2NyaXB0IGludGVyZmFjZSBmb3IgRnJhbWVHcmFiYmVyXG5cbmludGVyZmFjZSBRV29ya2VyVGhyZWFkIHtcbiAgICBpbWFnZURhdGE6IFVpbnQ4QXJyYXk7XG4gICAgYnVzeTogYm9vbGVhbjtcbiAgICB3b3JrZXI6IFdvcmtlcjtcbn1cblxubGV0IHdvcmtlclBvb2w6IEFycmF5PFFXb3JrZXJUaHJlYWQ+ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVXb3JrZXJzKGZyYW1lR3JhYmJlcjogYW55KSB7XG4gICAgbGV0IGF2YWlsYWJsZVdvcmtlcjogUVdvcmtlclRocmVhZDtcbiAgICBpZiAod29ya2VyUG9vbC5sZW5ndGgpIHtcbiAgICAgICAgYXZhaWxhYmxlV29ya2VyID0gd29ya2VyUG9vbC5maWx0ZXIoKHdvcmtlclRocmVhZCkgPT4gIXdvcmtlclRocmVhZC5idXN5KVswXTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZVdvcmtlcikge1xuICAgICAgICAgICAgZnJhbWVHcmFiYmVyLmF0dGFjaERhdGEoYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBpZiAoZnJhbWVHcmFiYmVyLmdyYWIoKSkge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci5idXN5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YTogYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB9LCBbYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YS5idWZmZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgICAgIC4uLmNvbmZpZy5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2UoZmFjdG9yeSkge1xuICAgIGlmIChmYWN0b3J5KSB7XG4gICAgICAgIHZhciBRdWFnZ2EgPSBmYWN0b3J5KCkuZGVmYXVsdDtcbiAgICAgICAgaWYgKCFRdWFnZ2EpIHtcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyAnZXZlbnQnOiAnZXJyb3InLCBtZXNzYWdlOiAnUXVhZ2dhIGNvdWxkIG5vdCBiZSBjcmVhdGVkJyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbi8vIEB0cy1pZ25vcmVcbiAgICB2YXIgaW1hZ2VXcmFwcGVyO1xuXG4vLyBAdHMtaWdub3JlXG4gICAgZnVuY3Rpb24gb25Qcm9jZXNzZWQocmVzdWx0KSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ3Byb2Nlc3NlZCcsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2VSZWFkeSgpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAnZXZlbnQnOiAnaW5pdGlhbGl6ZWQnLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuLy8gQHRzLWlnbm9yZVxuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGUuZGF0YS5jb25maWc7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgICAgICB4OiBlLmRhdGEuc2l6ZS54LFxuICAgICAgICAgICAgICAgIHk6IGUuZGF0YS5zaXplLnksXG4gICAgICAgICAgICB9LCBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBRdWFnZ2EuaW5pdChjb25maWcsIHdvcmtlckludGVyZmFjZVJlYWR5LCBpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgUXVhZ2dhLm9uUHJvY2Vzc2VkKG9uUHJvY2Vzc2VkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncHJvY2VzcycpIHtcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBRdWFnZ2Euc3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAnc2V0UmVhZGVycycpIHtcbiAgICAgICAgICAgIFF1YWdnYS5zZXRSZWFkZXJzKGUuZGF0YS5yZWFkZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncmVnaXN0ZXJSZWFkZXInKSB7XG4gICAgICAgICAgICBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIoZS5kYXRhLm5hbWUsIGUuZGF0YS5yZWFkZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVXb3JrZXJCbG9iKCkge1xuICAgIHZhciBibG9iLFxuICAgICAgICBmYWN0b3J5U291cmNlO1xuXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIF9fZmFjdG9yeVNvdXJjZV9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGZhY3RvcnlTb3VyY2UgPSBfX2ZhY3RvcnlTb3VyY2VfXzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgYmxvYiA9IG5ldyBCbG9iKFsnKCcgKyB3b3JrZXJJbnRlcmZhY2UudG9TdHJpbmcoKSArICcpKCcgKyBmYWN0b3J5U291cmNlICsgJyk7J10sXG4gICAgICAgIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG5cbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0V29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtOiBhbnksIGNiOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IGJsb2JVUkwgPSBnZW5lcmF0ZVdvcmtlckJsb2IoKTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVUkwpO1xuXG4gICAgY29uc3Qgd29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkID0ge1xuICAgICAgICB3b3JrZXIsXG4gICAgICAgIGltYWdlRGF0YTogbmV3IFVpbnQ4QXJyYXkoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAqIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcbiAgICAgICAgYnVzeTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmV2ZW50ID09PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYih3b3JrZXJUaHJlYWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBob3cgdG8gdGhyZWFkIHB1Ymxpc2hSZXN1bHQgaW50byBoZXJlPyBUeXBlU2NyaXB0IHNheXMgaXQncyBub3QgaGVyZS4gaHR0cHM6Ly9naXRodWIuY29tL2VyaWNibGFkZS9xdWFnZ2EyL2lzc3Vlcy80NjYjaXNzdWVjb21tZW50LTE3MjQyNDgwODAgc2F5cyBpdCdzIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHVibGlzaFJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcHVibGlzaFJlc3VsdChlLmRhdGEucmVzdWx0LCB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGVycm9yOiAnICsgZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgc2l6ZTogeyB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSB9LFxuICAgICAgICBpbWFnZURhdGE6IHdvcmtlclRocmVhZC5pbWFnZURhdGEsXG4gICAgICAgIGNvbmZpZzogY29uZmlnRm9yV29ya2VyKGNvbmZpZyksXG4gICAgfSwgW3dvcmtlclRocmVhZC5pbWFnZURhdGEuYnVmZmVyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RXb3JrZXJQb29sKGNhcGFjaXR5OiBudW1iZXIsIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbT86IGFueSwgY2I/OiBGdW5jdGlvbikge1xuICAgIGNvbnN0IGluY3JlYXNlQnkgPSBjYXBhY2l0eSAtIHdvcmtlclBvb2wubGVuZ3RoO1xuICAgIGlmIChpbmNyZWFzZUJ5ID09PSAwICYmIGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgfSBlbHNlIGlmIChpbmNyZWFzZUJ5IDwgMCkge1xuICAgICAgICBjb25zdCB3b3JrZXJzVG9UZXJtaW5hdGUgPSB3b3JrZXJQb29sLnNsaWNlKGluY3JlYXNlQnkpO1xuICAgICAgICB3b3JrZXJzVG9UZXJtaW5hdGUuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgdGVybWluYXRlZCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtlclBvb2wgPSB3b3JrZXJQb29sLnNsaWNlKDAsIGluY3JlYXNlQnkpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3b3JrZXJJbml0aWFsaXplZCA9ICh3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQpID0+IHtcbiAgICAgICAgICAgIHdvcmtlclBvb2wucHVzaCh3b3JrZXJUaHJlYWQpO1xuICAgICAgICAgICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoID49IGNhcGFjaXR5ICYmIGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluY3JlYXNlQnk7IGkrKykge1xuICAgICAgICAgICAgICAgIGluaXRXb3JrZXIoY29uZmlnLCBpbnB1dFN0cmVhbSwgd29ya2VySW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZGVycyhyZWFkZXJzOiBBcnJheTxRdWFnZ2FKU1JlYWRlckNvbmZpZz4pIHtcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3NldFJlYWRlcnMnLCByZWFkZXJzIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBCYXJjb2RlUmVhZGVyQ29uc3RydWN0b3IpIHtcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3JlZ2lzdGVyUmVhZGVyJywgbmFtZSwgcmVhZGVyIH0pKTtcbn1cbiIsImltcG9ydCB7IElucHV0U3RyZWFtRmFjdG9yeSB9IGZyb20gJ2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW0uZCc7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtVHlwZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG4vLyBUT0RPOiBuZWVkIHRvIGNyZWF0ZSBhbiBJbnB1dFN0cmVhbSB0eXBlc2NyaXB0IGludGVyZmFjZSwgc28gd2UgZG9uJ3QgaGF2ZSBhbiBcImFueVwiIGluIHRoZSBuZXh0IGxpbmVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwSW5wdXRTdHJlYW0odHlwZTogSW5wdXRTdHJlYW1UeXBlID0gJ0xpdmVTdHJlYW0nLCB2aWV3cG9ydDogRWxlbWVudCB8IG51bGwsIGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ1ZpZGVvU3RyZWFtJzoge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSW1hZ2VTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVJbWFnZVN0cmVhbSgpIH07XG4gICAgICAgIGNhc2UgJ0xpdmVTdHJlYW0nOiB7XG4gICAgICAgICAgICBsZXQgdmlkZW86IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHZpZGVvID0gdmlld3BvcnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQodmlkZW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvIGFzIEhUTUxWaWRlb0VsZW1lbnQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgKiBzZXR1cElucHV0U3RyZWFtIGludmFsaWQgdHlwZSAke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm4geyB2aWRlbzogbnVsbCwgaW5wdXRTdHJlYW06IG51bGwgfTtcbiAgICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuaW1wb3J0IHR5cGUgeyBQb2ludCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5leHBvcnQgdHlwZSBCb3ggPSBBcnJheTxbIG51bWJlciwgbnVtYmVyIF0+O1xuXG5leHBvcnQgdHlwZSBMaW5lID0gWyBQb2ludCwgUG9pbnQgXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVCb3goYm94OiBCb3gsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IGNvcm5lciA9IGJveC5sZW5ndGg7XG4gICAgd2hpbGUgKGNvcm5lci0tKSB7XG4gICAgICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XG4gICAgICAgIGJveFtjb3JuZXJdWzFdICs9IHlPZmZzZXQ7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUxpbmUobGluZTogTGluZSwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsaW5lWzBdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzBdLnkgKz0geU9mZnNldDtcbiAgICBsaW5lWzFdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzFdLnkgKz0geU9mZnNldDtcbn1cbiIsImltcG9ydCB7IHZlYzIgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IHsgUXVhZ2dhSlNSZXN1bHRPYmplY3QsIFF1YWdnYUpTUmVhZGVyQ29uZmlnLCBCYXJjb2RlUmVhZGVyQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4uL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IEZyYW1lR3JhYmJlciBmcm9tICcuLi9pbnB1dC9mcmFtZV9ncmFiYmVyLmpzJztcbmltcG9ydCBJbnB1dFN0cmVhbSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtJztcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XG5pbXBvcnQgeyBRdWFnZ2FDb250ZXh0IH0gZnJvbSAnLi4vUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgX2dldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xuaW1wb3J0IF9pbml0QnVmZmVycyBmcm9tICcuL2luaXRCdWZmZXJzJztcbmltcG9ydCBfaW5pdENhbnZhcyBmcm9tICcuL2luaXRDYW52YXMnO1xuaW1wb3J0ICogYXMgUVdvcmtlcnMgZnJvbSAnLi9xd29ya2VyJztcbmltcG9ydCBzZXR1cElucHV0U3RyZWFtIGZyb20gJy4vc2V0dXBJbnB1dFN0cmVhbSc7XG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhZ2dhIHtcbiAgICBjb250ZXh0OiBRdWFnZ2FDb250ZXh0ID0gbmV3IFF1YWdnYUNvbnRleHQoKTtcblxuICAgIGluaXRCdWZmZXJzKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH0gPSBfaW5pdEJ1ZmZlcnMoXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLmxvY2F0b3IsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuYm94U2l6ZSA9IGJveFNpemU7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIgPSBCYXJjb2RlRGVjb2Rlci5jcmVhdGUodGhpcy5jb250ZXh0LmNvbmZpZy5kZWNvZGVyLCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgIH1cblxuICAgIGdldFZpZXdQb3J0KCk6IEVsZW1lbnQgfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcbiAgICAgICAgcmV0dXJuIF9nZXRWaWV3UG9ydCh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJlYWR5KGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5wbGF5KCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgaW5pdENhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gX2luaXRDYW52YXModGhpcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGN0eCwgZG9tIH0gPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlID0gZG9tLmltYWdlO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5ID0gZG9tLm92ZXJsYXk7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuY3R4LmltYWdlID0gY3R4LmltYWdlO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5vdmVybGF5ID0gY3R4Lm92ZXJsYXk7XG4gICAgfVxuXG4gICAgY2FuUmVjb3JkID0gKGNhbGxiYWNrOiAoZXJyPzogRXJyb3IpID0+IHZvaWQpOiB2b2lkID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaW5pdCB3YXMgYWJvcnRlZCAoZS5nLiwgYnkgY2FsbGluZyBzdG9wKCkgZHVyaW5nIGluaXRpYWxpemF0aW9uKVxuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gUmVhY3QgU3RyaWN0TW9kZSB3aGVyZSBjb21wb25lbnRzIGFyZSBtb3VudGVkL3VubW91bnRlZCByYXBpZGx5XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5pdEFib3J0ZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignSW5pdGlhbGl6YXRpb24gd2FzIGFib3J0ZWQnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0NvbmZpZ3VyYXRpb24gbm90IGluaXRpYWxpemVkJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGlucHV0U3RyZWFtIGlzIHByb3Blcmx5IGluaXRpYWxpemVkIGJlZm9yZSBwcm9jZWVkaW5nXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0lucHV0IHN0cmVhbSBub3QgaW5pdGlhbGl6ZWQnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQmFyY29kZUxvY2F0b3IuY2hlY2tJbWFnZUNvbnN0cmFpbnRzKHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSwgdGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRvcik7XG4gICAgICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyID0gRnJhbWVHcmFiYmVyLmNyZWF0ZShcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBRV29ya2Vycy5hZGp1c3RXb3JrZXJQb29sKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5udW1PZldvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGluaXRJbnB1dFN0cmVhbShjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHlwZTogaW5wdXRUeXBlLCBjb25zdHJhaW50cyB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcbiAgICAgICAgY29uc3QgeyB2aWRlbywgaW5wdXRTdHJlYW0gfSA9IHNldHVwSW5wdXRTdHJlYW0oaW5wdXRUeXBlLCB0aGlzLmdldFZpZXdQb3J0KCksIElucHV0U3RyZWFtKTtcblxuICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAnTGl2ZVN0cmVhbScgJiYgdmlkZW8pIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZXF1ZXN0KHZpZGVvLCBjb25zdHJhaW50cylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBpbnB1dFN0cmVhbS50cmlnZ2VyKCdjYW5yZWNvcmQnKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldEF0dHJpYnV0ZSgncHJlbG9hZCcsICdhdXRvJyk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRJbnB1dFN0cmVhbSh0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtID0gaW5wdXRTdHJlYW07XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdCb3hlcygpOiBBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0ZSA/IEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpXG4gICAgICAgICAgICA6IFtbXG4gICAgICAgICAgICAgICAgdmVjMi5jbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVswXSksXG4gICAgICAgICAgICAgICAgdmVjMi5jbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsxXSksXG4gICAgICAgICAgICAgICAgdmVjMi5jbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXG4gICAgICAgICAgICAgICAgdmVjMi5jbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVszXSksXG4gICAgICAgICAgICBdXSBhcyB1bmtub3duIGFzIEFycmF5PEFycmF5PEFycmF5PG51bWJlcj4+PjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCB0eXBlIGZvciByZXN1bHQgaGVyZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQ6IGFueSwgdHJhbnNmb3JtZWRCb3hlczogU2V0PGFueT4gPSBuZXcgU2V0KCkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSB0b3BSaWdodC55O1xuXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSwgdHJhbnNmb3JtZWRCb3hlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3ggJiYgIXRyYW5zZm9ybWVkQm94ZXMuaGFzKHJlc3VsdC5ib3gpKSB7XG4gICAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3gsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRCb3hlcy5hZGQocmVzdWx0LmJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgaWYgdGhpcyBib3ggaGFzIGFscmVhZHkgYmVlbiB0cmFuc2Zvcm1lZCAoZWl0aGVyIGFzIHJlc3VsdC5ib3ggb3IgdGhyb3VnaCBiYXJjb2RlcylcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkQm94ZXMuaGFzKHJlc3VsdC5ib3hlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94ZXNbaV0sIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZEJveGVzLmFkZChyZXN1bHQuYm94ZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdD8uYmFyY29kZXM/Lmxlbmd0aCA+IDAgPyByZXN1bHQuYmFyY29kZXMgOiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XG4gICAgICAgICAgICBFdmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVkcmF3IHNjYW5uZXIgYXJlYSBlYWNoIGZyYW1lIHdoZW4gbG9jYXRlIGlzIGZhbHNlIHZpYSBwdWJsaWMgQVBJLlxuICAgICAgICBjb25zdCBjZmcgPSB0aGlzLmNvbnRleHQuY29uZmlnO1xuICAgICAgICBpZiAoY2ZnICYmIGNmZy5sb2NhdGUgPT09IGZhbHNlICYmIGNmZy5pbnB1dFN0cmVhbT8uYXJlYSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3U2Nhbm5lckFyZWEoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxvY2F0ZUFuZERlY29kZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldEJvdW5kaW5nQm94ZXMoKTtcbiAgICAgICAgaWYgKGJveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVSZXN1bHQgPSAoYXdhaXQgdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpKSB8fCB7fTtcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5ib3hlcyA9IGJveGVzO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGRlY29kZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0gYXdhaXQgdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUltYWdlKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoaW1hZ2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoaW1hZ2VSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlcnNVcGRhdGVkID0gUVdvcmtlcnMudXBkYXRlV29ya2Vycyh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKTtcbiAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCk7XG4gICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgbGV0IG5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAvLyBmcmVxdWVuY3kgc3BlY2lmaWVzIGEgbWF4aW11bSByYXRlLCBub3QgYW4gYWJzb2x1dGUuIElmIHRoZSBzeXN0ZW0gY2Fubm90XG4gICAgICAgIC8vIGFjaGlldmUgdGhlIHJlcXVlc3RlZCBmcmVxdWVuY3ksIHNjYW5zIHdpbGwgb2NjdXIgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAgICAgICAgY29uc3QgZGVsYXkgPSAxMDAwIC8gKHRoaXMuY29udGV4dC5jb25maWc/LmZyZXF1ZW5jeSB8fCA2MCk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCB8fCB0aW1lc3RhbXA7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IGRlbGF5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5ld0ZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBuZXdGcmFtZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgfVxuXG4gICAgc3RhcnQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCAmJiB0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbT8udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29udGludW91c1VwZGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHN0b3AoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gU2V0IGluaXRBYm9ydGVkIGZsYWcgaWYgc3RvcCgpIGlzIGNhbGxlZCB3aGlsZSBpbml0KCkgaXMgc3RpbGwgaW4gcHJvZ3Jlc3NcbiAgICAgICAgLy8gKGkuZS4sIGJlZm9yZSBmcmFtZWdyYWJiZXIgaXMgaW5pdGlhbGl6ZWQpLiBUaGlzIHByZXZlbnRzIHRoZSBjYW5SZWNvcmRcbiAgICAgICAgLy8gY2FsbGJhY2sgZnJvbSBjb250aW51aW5nIGFmdGVyIHN0b3AoKSB3YXMgY2FsbGVkLlxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbml0QWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbCgwKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtICYmIHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICBhd2FpdCBDYW1lcmFBY2Nlc3MucmVsZWFzZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtPy5jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBCYXJjb2RlUmVhZGVyQ29uc3RydWN0b3IpOiB2b2lkIHtcbiAgICAgICAgQmFyY29kZURlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIFFXb3JrZXJzLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0byBkcmF3IGEgc2Nhbm5lciBhcmVhIG92ZXJsYXkgdXNpbmcgdGhlIGN1cnJlbnQgUXVhZ2dhIGluc3RhbmNlJ3Mgb3ZlcmxheSBjYW52YXMuXG4gICAgICogRHJhd3MgYmFzZWQgb24gdGhlIGluc3RhbmNlJ3MgY29uZmlndXJlZCBpbnB1dFN0cmVhbS5hcmVhLCB1c2luZyB0aGUgYWN0dWFsIGFkanVzdGVkIGJveFNpemVcbiAgICAgKiB0byBtYXRjaCB0aGUgcmVhbCBzY2FubmluZyBhcmVhIGFmdGVyIHBhdGNoIGFsaWdubWVudC5cbiAgICAgKiBPbmx5IGRyYXdzIHdoZW4gbG9jYXRlIGlzIGZhbHNlIGFuZCBhbiBhcmVhIGlzIGNvbmZpZ3VyZWQgd2l0aCBzdHlsaW5nLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2NhY2hlZFN0eWxlVmFsdWVzPzogeyBib3JkZXJDb2xvcj86IHN0cmluZzsgYm9yZGVyV2lkdGg/OiBudW1iZXI7IGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB9O1xuICAgIHByaXZhdGUgX3Jlc29sdmVkU3R5bGU/OiB7IGNvbG9yOiBzdHJpbmc7IHdpZHRoOiBudW1iZXI7IGJnPzogc3RyaW5nIH07XG4gICAgZHJhd1NjYW5uZXJBcmVhKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0/LmFyZWE7XG4gICAgICAgIGlmICghYXJlYSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBvdmVybGF5Q3R4ID0gdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheTtcbiAgICAgICAgaWYgKCFvdmVybGF5Q3R4KSByZXR1cm47XG5cbiAgICAgICAgLy8gT25seSBkcmF3IHdoZW4gbG9jYXRlIGlzIGZhbHNlXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdGUgIT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgLy8gUXVpY2sgY2hlY2tzIGZvciB2aXN1YWxpemF0aW9uIHByZXNlbmNlXG4gICAgICAgIGNvbnN0IGhhc0FueVN0eWxlID0gKGFyZWEuYm9yZGVyQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBhcmVhLmJvcmRlckNvbG9yICE9PSAnJylcbiAgICAgICAgICAgIHx8IChhcmVhLmJvcmRlcldpZHRoICE9PSB1bmRlZmluZWQgJiYgYXJlYS5ib3JkZXJXaWR0aCA+IDApXG4gICAgICAgICAgICB8fCAoYXJlYS5iYWNrZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBhcmVhLmJhY2tncm91bmRDb2xvciAhPT0gJycpO1xuICAgICAgICBpZiAoIWhhc0FueVN0eWxlKSByZXR1cm47XG5cbiAgICAgICAgLy8gV2hlbiBsb2NhdGUgaXMgZmFsc2UsIHVzZSB0aGUgYWN0dWFsIGFkanVzdGVkIGJveFNpemUgdGhhdCBtYXRjaGVzIHRoZSBzY2FubmluZyBhcmVhXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmJveFNpemUpIHJldHVybjtcblxuICAgICAgICAvLyBHZXQgdGhlIG9mZnNldCBmb3IgdGhlIGNvbnN0cmFpbmVkIGFyZWFcbiAgICAgICAgY29uc3QgdG9wUmlnaHRPZmZzZXQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHRvcFJpZ2h0T2Zmc2V0Lng7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSB0b3BSaWdodE9mZnNldC55O1xuXG4gICAgICAgIGNvbnN0IGJveCA9IHRoaXMuY29udGV4dC5ib3hTaXplO1xuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gYm94WzBdO1xuICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gYm94WzFdO1xuICAgICAgICBjb25zdCB0b3BSaWdodCA9IGJveFszXTtcblxuICAgICAgICAvLyBBZGQgdGhlIG9mZnNldCB0byBwb3NpdGlvbiBjb3JyZWN0bHkgb24gY2FudmFzXG4gICAgICAgIGNvbnN0IHggPSB0b3BMZWZ0WzBdICsgb2Zmc2V0WDtcbiAgICAgICAgY29uc3QgeSA9IHRvcExlZnRbMV0gKyBvZmZzZXRZO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRvcFJpZ2h0WzBdIC0gdG9wTGVmdFswXTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tTGVmdFsxXSAtIHRvcExlZnRbMV07XG4gICAgICAgIGNvbnN0IHN0eWxlQ2hhbmdlZCA9ICF0aGlzLl9jYWNoZWRTdHlsZVZhbHVlc1xuICAgICAgICAgICAgfHwgdGhpcy5fY2FjaGVkU3R5bGVWYWx1ZXMuYm9yZGVyQ29sb3IgIT09IGFyZWEuYm9yZGVyQ29sb3JcbiAgICAgICAgICAgIHx8IHRoaXMuX2NhY2hlZFN0eWxlVmFsdWVzLmJvcmRlcldpZHRoICE9PSBhcmVhLmJvcmRlcldpZHRoXG4gICAgICAgICAgICB8fCB0aGlzLl9jYWNoZWRTdHlsZVZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgIT09IGFyZWEuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZiAoc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRTdHlsZVZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYXJlYS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogYXJlYS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGFyZWEuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZERyYXdCb3JkZXIgPSBhcmVhLmJvcmRlckNvbG9yICE9PSB1bmRlZmluZWQgfHwgYXJlYS5ib3JkZXJXaWR0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBhcmVhLmJvcmRlckNvbG9yID8/ICdyZ2JhKDAsIDI1NSwgMCwgMC41KSc7XG4gICAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHNob3VsZERyYXdCb3JkZXIgPyAoYXJlYS5ib3JkZXJXaWR0aCA/PyAyKSA6IDA7XG4gICAgICAgICAgICBjb25zdCBiZyA9IGFyZWEuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRTdHlsZSA9IHsgY29sb3IsIHdpZHRoOiBib3JkZXJXaWR0aCwgYmcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fcmVzb2x2ZWRTdHlsZSE7XG4gICAgICAgIGlmIChzdHlsZS5iZykge1xuICAgICAgICAgICAgb3ZlcmxheUN0eC5maWxsU3R5bGUgPSBzdHlsZS5iZztcbiAgICAgICAgICAgIG92ZXJsYXlDdHguZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLndpZHRoID4gMCkge1xuICAgICAgICAgICAgb3ZlcmxheUN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICAgICAgb3ZlcmxheUN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgIG92ZXJsYXlDdHguc3Ryb2tlUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuaW1wb3J0IFR5cGVEZWZzIGZyb20gJy4vY29tbW9uL3R5cGVkZWZzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCAqIGFzIFJlYWRlcnMgZnJvbSAnLi9yZWFkZXIvaW5kZXgnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2NvbW1vbi9ldmVudHMnO1xuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFJlc3VsdENvbGxlY3RvciBmcm9tICcuL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcvY29uZmlnJztcblxuaW1wb3J0IFF1YWdnYSBmcm9tICcuL3F1YWdnYS9xdWFnZ2EnO1xuXG5jb25zdCBpbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcbmNvbnN0IF9jb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcblxuY29uc3QgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbmZpZywgY2IsIGltYWdlV3JhcHBlciwgcXVhZ2dhSW5zdGFuY2UgPSBpbnN0YW5jZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgaW5pdEFib3J0ZWQgZmxhZyB3aGVuIHN0YXJ0aW5nIGEgbmV3IGluaXRcbiAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5pbml0QWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3OTogcGVuZGluZyByZXN0cnVjdHVyZSBpbiBJc3N1ZSAjMTc5LCB3ZSBhcmUgdGVtcCBkaXNhYmxpbmcgd29ya2Vyc1xuICAgICAgICBpZiAocXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0Lm9uVUlUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdElucHV0U3RyZWFtKGNiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoY29uZmlnLCBjYikge1xuICAgICAgICAvLyBJZiBjb25maWcgaXMgcHJvdmlkZWQsIGNhbGwgaW5pdCgpIHRoZW4gc3RhcnQoKVxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXQoY29uZmlnLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoc3RhcnRFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2Ioc3RhcnRFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaW5pdCgpIGhhc24ndCBiZWVuIGNvbXBsZXRlZCwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgaWYgKCFfY29udGV4dC5mcmFtZWdyYWJiZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQoKSB3YXMgY2FsbGVkIGJlZm9yZSBpbml0KCkgY29tcGxldGVkLiAnXG4gICAgICAgICAgICAgICAgKyAnQ2FsbCBpbml0KCkgZmlyc3QsIG9yIGNhbGwgc3RhcnQoY29uZmlnKSB0byBjb21iaW5lIGluaXQgYW5kIHN0YXJ0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5zdGFydCgpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RvcCgpO1xuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2NvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgfSxcbiAgICBvbkRldGVjdGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdvYmplY3QnIHx8ICFjYWxsYmFjay5jYWxsYmFjaykpKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vbkRldGVjdGVkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZEZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvblByb2Nlc3NlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25Qcm9jZXNzZWQgY2FsbGVkIHdpdGggaW52YWxpZCBjYWxsYmFjaywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZQcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uIChyZWFkZXJzKSB7XG4gICAgICAgIGlmICghcmVhZGVycykge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Euc2V0UmVhZGVycyBjYWxsZWQgd2l0aCBubyByZWFkZXJzLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfSxcbiAgICByZWdpc3RlclJlYWRlcjogZnVuY3Rpb24gKG5hbWUsIHJlYWRlcikge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIG5hbWUsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIHJlYWRlciwgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3I6IGZ1bmN0aW9uIChyZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKHJlc3VsdENvbGxlY3RvciAmJiB0eXBlb2YgcmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX2NvbnRleHQucmVzdWx0Q29sbGVjdG9yID0gcmVzdWx0Q29sbGVjdG9yO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgY2FudmFzKCkge1xuICAgICAgICByZXR1cm4gX2NvbnRleHQuY2FudmFzQ29udGFpbmVyO1xuICAgIH0sXG4gICAgZHJhd1NjYW5uZXJBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5kcmF3U2Nhbm5lckFyZWEoKTtcbiAgICB9LFxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcXVhZ2dhSW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlKHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6ICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgLy8gVE9ETyAjMTc1OiByZXN0cnVjdHVyZSB3b3JrZXIgc3VwcG9ydCBzbyB0aGF0IGl0IHdpbGwgd29yayB3aXRoIHR5cGVzY3JpcHQgdXNpbmcgd29ya2VyLWxvYWRlclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3b3JrZXJzIHJlcXVpcmUgV29ya2VyIGFuZCBCbG9iIHN1cHBvcnQgcHJlc2VudGx5LCBzbyBpZiBubyBCbG9iIG9yIFdvcmtlciB0aGVuIHNldFxuICAgICAgICAvLyB3b3JrZXJzIHRvIDAuXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIG5vIFdvcmtlciBhbmQvb3IgQmxvYiBzdXBwb3J0IC0gZm9yY2luZyBudW1PZldvcmtlcnMgdG8gMCcpO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBSZWFkZXJzLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcbmV4cG9ydCB7XG4gICAgQmFyY29kZURlY29kZXIsXG4gICAgUmVhZGVycyxcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=