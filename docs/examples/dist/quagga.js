(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory();
	else
		root["Quagga"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 68);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(52);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _getPrototypeOf(t) {
  return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(52);
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(8)["default"];
var assertThisInitialized = __webpack_require__(141);
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return assertThisInitialized(t);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(32);
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && setPrototypeOf(t, e);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(137)();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports) {

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(142);
function _get() {
  return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(69),
    createAssigner = __webpack_require__(125);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(36);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    getRawTag = __webpack_require__(83),
    objectToString = __webpack_require__(84);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(71),
    listCacheDelete = __webpack_require__(72),
    listCacheGet = __webpack_require__(73),
    listCacheHas = __webpack_require__(74),
    listCacheSet = __webpack_require__(75);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(18);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(13);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(97);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(112),
    isObjectLike = __webpack_require__(14);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(11),
    isKey = __webpack_require__(150),
    stringToPath = __webpack_require__(151),
    toString = __webpack_require__(154);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(143);
var iterableToArray = __webpack_require__(144);
var unsupportedIterableToArray = __webpack_require__(50);
var nonIterableSpread = __webpack_require__(145);
function _toConsumableArray(r) {
  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(81),
    getValue = __webpack_require__(88);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(15),
    isObject = __webpack_require__(9);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(39);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(27),
    isLength = __webpack_require__(31);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

function _setPrototypeOf(t, e) {
  return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(15),
    isObjectLike = __webpack_require__(14);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26),
    root = __webpack_require__(13);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(82)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(89),
    mapCacheDelete = __webpack_require__(96),
    mapCacheGet = __webpack_require__(98),
    mapCacheHas = __webpack_require__(99),
    mapCacheSet = __webpack_require__(100);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(28),
    eq = __webpack_require__(18);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(111);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(13),
    stubFalse = __webpack_require__(114);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(29)(module)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(116),
    baseUnary = __webpack_require__(117),
    nodeUtil = __webpack_require__(118);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(28),
    eq = __webpack_require__(18);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(121),
    baseKeysIn = __webpack_require__(123),
    isArrayLike = __webpack_require__(30);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 47 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(127);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(128),
    shortOut = __webpack_require__(130);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(51);
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
  }
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 51 */
/***/ (function(module, exports) {

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(8)["default"];
var toPrimitive = __webpack_require__(136);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

function _OverloadYield(e, d) {
  this.v = e, this.k = d;
}
module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var regeneratorDefine = __webpack_require__(55);
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return regeneratorDefine(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = !1,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function d(t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = !0, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), !0), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function () {
    return this;
  }), regeneratorDefine(u, "toString", function () {
    return "[object Generator]";
  }), (module.exports = _regenerator = function _regenerator() {
    return {
      w: i,
      m: f
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  module.exports = _regeneratorDefine = function regeneratorDefine(e, r, n, t) {
    function o(r, n) {
      _regeneratorDefine(e, r, function (e) {
        return this._invoke(r, n, e);
      });
    }
    r ? i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
}
module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var regenerator = __webpack_require__(54);
var regeneratorAsyncIterator = __webpack_require__(57);
function _regeneratorAsyncGen(r, e, t, o, n) {
  return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
}
module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var OverloadYield = __webpack_require__(53);
var regeneratorDefine = __webpack_require__(55);
function AsyncIterator(t, e) {
  function n(r, o, i, f) {
    try {
      var c = t[r](o),
        u = c.value;
      return u instanceof OverloadYield ? e.resolve(u.v).then(function (t) {
        n("next", t, i, f);
      }, function (t) {
        n("throw", t, i, f);
      }) : e.resolve(u).then(function (t) {
        c.value = t, i(c);
      }, function (t) {
        return n("throw", t, i, f);
      });
    } catch (t) {
      f(t);
    }
  }
  var r;
  this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function () {
    return this;
  })), regeneratorDefine(this, "_invoke", function (t, o, i) {
    function f() {
      return new e(function (e, r) {
        n(t, i, e, r);
      });
    }
    return r = r ? r.then(f, f) : f();
  }, !0);
}
module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(133);
var iterableToArrayLimit = __webpack_require__(134);
var unsupportedIterableToArray = __webpack_require__(50);
var nonIterableRest = __webpack_require__(135);
function _slicedToArray(r, e) {
  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(146);
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(147),
    flatRest = __webpack_require__(161);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(1);
var setPrototypeOf = __webpack_require__(32);
var isNativeFunction = __webpack_require__(166);
var construct = __webpack_require__(167);
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return module.exports = _wrapNativeSuper = function _wrapNativeSuper(t) {
    if (null === t || !isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return construct(t, arguments, getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), setPrototypeOf(Wrapper, t);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(169);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(70),
    assignMergeValue = __webpack_require__(38),
    baseFor = __webpack_require__(101),
    baseMergeDeep = __webpack_require__(103),
    isObject = __webpack_require__(9),
    keysIn = __webpack_require__(46),
    safeGet = __webpack_require__(44);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(16),
    stackClear = __webpack_require__(76),
    stackDelete = __webpack_require__(77),
    stackGet = __webpack_require__(78),
    stackHas = __webpack_require__(79),
    stackSet = __webpack_require__(80);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 71 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(16);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 77 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 78 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 79 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(16),
    Map = __webpack_require__(35),
    MapCache = __webpack_require__(37);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(27),
    isMasked = __webpack_require__(85),
    isObject = __webpack_require__(9),
    toSource = __webpack_require__(87);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 82 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 84 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(86);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(13);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 87 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(90),
    ListCache = __webpack_require__(16),
    Map = __webpack_require__(35);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(91),
    hashDelete = __webpack_require__(92),
    hashGet = __webpack_require__(93),
    hashHas = __webpack_require__(94),
    hashSet = __webpack_require__(95);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(20);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(20);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(20);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(20);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(21);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(21);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(21);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(21);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(102);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(38),
    cloneBuffer = __webpack_require__(104),
    cloneTypedArray = __webpack_require__(105),
    copyArray = __webpack_require__(108),
    initCloneObject = __webpack_require__(109),
    isArguments = __webpack_require__(22),
    isArray = __webpack_require__(11),
    isArrayLikeObject = __webpack_require__(113),
    isBuffer = __webpack_require__(42),
    isFunction = __webpack_require__(27),
    isObject = __webpack_require__(9),
    isPlainObject = __webpack_require__(115),
    isTypedArray = __webpack_require__(43),
    safeGet = __webpack_require__(44),
    toPlainObject = __webpack_require__(119);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(13);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(29)(module)))

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(106);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(107);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(13);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(110),
    getPrototype = __webpack_require__(40),
    isPrototype = __webpack_require__(41);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(15),
    isObjectLike = __webpack_require__(14);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(30),
    isObjectLike = __webpack_require__(14);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(15),
    getPrototype = __webpack_require__(40),
    isObjectLike = __webpack_require__(14);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(15),
    isLength = __webpack_require__(31),
    isObjectLike = __webpack_require__(14);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 117 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(36);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(29)(module)))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(120),
    keysIn = __webpack_require__(46);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(45),
    baseAssignValue = __webpack_require__(28);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(122),
    isArguments = __webpack_require__(22),
    isArray = __webpack_require__(11),
    isBuffer = __webpack_require__(42),
    isIndex = __webpack_require__(23),
    isTypedArray = __webpack_require__(43);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 122 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9),
    isPrototype = __webpack_require__(41),
    nativeKeysIn = __webpack_require__(124);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 124 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(126),
    isIterateeCall = __webpack_require__(131);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(47),
    overRest = __webpack_require__(48),
    setToString = __webpack_require__(49);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 127 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(129),
    defineProperty = __webpack_require__(39),
    identity = __webpack_require__(47);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 129 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 130 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(18),
    isArrayLike = __webpack_require__(30),
    isIndex = __webpack_require__(23),
    isObject = __webpack_require__(9);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */

if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (/* function FrameRequestCallback */callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}
if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */
}
if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2

    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }
    var to = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];
      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}

/***/ }),
/* 133 */
/***/ (function(module, exports) {

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 135 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(8)["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var OverloadYield = __webpack_require__(53);
var regenerator = __webpack_require__(54);
var regeneratorAsync = __webpack_require__(138);
var regeneratorAsyncGen = __webpack_require__(56);
var regeneratorAsyncIterator = __webpack_require__(57);
var regeneratorKeys = __webpack_require__(139);
var regeneratorValues = __webpack_require__(140);
function _regeneratorRuntime() {
  "use strict";

  var r = regenerator(),
    e = r.m(_regeneratorRuntime),
    t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
  function n(r) {
    var e = "function" == typeof r && r.constructor;
    return !!e && (e === t || "GeneratorFunction" === (e.displayName || e.name));
  }
  var o = {
    "throw": 1,
    "return": 2,
    "break": 3,
    "continue": 3
  };
  function a(r) {
    var e, t;
    return function (n) {
      e || (e = {
        stop: function stop() {
          return t(n.a, 2);
        },
        "catch": function _catch() {
          return n.v;
        },
        abrupt: function abrupt(r, e) {
          return t(n.a, o[r], e);
        },
        delegateYield: function delegateYield(r, o, a) {
          return e.resultName = o, t(n.d, regeneratorValues(r), a);
        },
        finish: function finish(r) {
          return t(n.f, r);
        }
      }, t = function t(r, _t, o) {
        n.p = e.prev, n.n = e.next;
        try {
          return r(_t, o);
        } finally {
          e.next = n.n;
        }
      }), e.resultName && (e[e.resultName] = n.v, e.resultName = void 0), e.sent = n.v, e.next = n.n;
      try {
        return r.call(this, e);
      } finally {
        n.p = e.prev, n.n = e.next;
      }
    };
  }
  return (module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return {
      wrap: function wrap(e, t, n, o) {
        return r.w(a(e), t, n, o && o.reverse());
      },
      isGeneratorFunction: n,
      mark: r.m,
      awrap: function awrap(r, e) {
        return new OverloadYield(r, e);
      },
      AsyncIterator: regeneratorAsyncIterator,
      async: function async(r, e, t, o, u) {
        return (n(e) ? regeneratorAsyncGen : regeneratorAsync)(a(r), e, t, o, u);
      },
      keys: regeneratorKeys,
      values: regeneratorValues
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var regeneratorAsyncGen = __webpack_require__(56);
function _regeneratorAsync(n, e, r, t, o) {
  var a = regeneratorAsyncGen(n, e, r, t, o);
  return a.next().then(function (n) {
    return n.done ? n.value : a.next();
  });
}
module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 139 */
/***/ (function(module, exports) {

function _regeneratorKeys(e) {
  var n = Object(e),
    r = [];
  for (var t in n) r.unshift(t);
  return function e() {
    for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e;
    return e.done = !0, e;
  };
}
module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(8)["default"];
function _regeneratorValues(e) {
  if (null != e) {
    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
      r = 0;
    if (t) return t.call(e);
    if ("function" == typeof e.next) return e;
    if (!isNaN(e.length)) return {
      next: function next() {
        return e && r >= e.length && (e = void 0), {
          value: e && e[r++],
          done: !e
        };
      }
    };
  }
  throw new TypeError(_typeof(e) + " is not iterable");
}
module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 141 */
/***/ (function(module, exports) {

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(1);
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)););
  return t;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(51);
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return arrayLikeToArray(r);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 146 */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(148),
    hasIn = __webpack_require__(158);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(149),
    baseSet = __webpack_require__(157),
    castPath = __webpack_require__(24);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(24),
    toKey = __webpack_require__(34);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(11),
    isSymbol = __webpack_require__(33);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(152);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(153);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(37);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(155);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    arrayMap = __webpack_require__(156),
    isArray = __webpack_require__(11),
    isSymbol = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(45),
    castPath = __webpack_require__(24),
    isIndex = __webpack_require__(23),
    isObject = __webpack_require__(9),
    toKey = __webpack_require__(34);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(159),
    hasPath = __webpack_require__(160);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(24),
    isArguments = __webpack_require__(22),
    isArray = __webpack_require__(11),
    isIndex = __webpack_require__(23),
    isLength = __webpack_require__(31),
    toKey = __webpack_require__(34);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(162),
    overRest = __webpack_require__(48),
    setToString = __webpack_require__(49);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(163);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(164),
    isFlattenable = __webpack_require__(165);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 164 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    isArguments = __webpack_require__(22),
    isArray = __webpack_require__(11);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var isNativeReflectConstruct = __webpack_require__(168);
var setPrototypeOf = __webpack_require__(32);
function _construct(t, e, r) {
  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && setPrototypeOf(p, r.prototype), p;
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 168 */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "Readers", function() { return /* reexport */ reader_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/mat2.js
var mat2_namespaceObject = {};
__webpack_require__.r(mat2_namespaceObject);
__webpack_require__.d(mat2_namespaceObject, "create", function() { return mat2_create; });
__webpack_require__.d(mat2_namespaceObject, "clone", function() { return clone; });
__webpack_require__.d(mat2_namespaceObject, "copy", function() { return copy; });
__webpack_require__.d(mat2_namespaceObject, "identity", function() { return identity; });
__webpack_require__.d(mat2_namespaceObject, "fromValues", function() { return fromValues; });
__webpack_require__.d(mat2_namespaceObject, "set", function() { return set; });
__webpack_require__.d(mat2_namespaceObject, "transpose", function() { return transpose; });
__webpack_require__.d(mat2_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(mat2_namespaceObject, "adjoint", function() { return adjoint; });
__webpack_require__.d(mat2_namespaceObject, "determinant", function() { return determinant; });
__webpack_require__.d(mat2_namespaceObject, "multiply", function() { return multiply; });
__webpack_require__.d(mat2_namespaceObject, "rotate", function() { return rotate; });
__webpack_require__.d(mat2_namespaceObject, "scale", function() { return mat2_scale; });
__webpack_require__.d(mat2_namespaceObject, "fromRotation", function() { return fromRotation; });
__webpack_require__.d(mat2_namespaceObject, "fromScaling", function() { return fromScaling; });
__webpack_require__.d(mat2_namespaceObject, "str", function() { return str; });
__webpack_require__.d(mat2_namespaceObject, "frob", function() { return frob; });
__webpack_require__.d(mat2_namespaceObject, "LDU", function() { return LDU; });
__webpack_require__.d(mat2_namespaceObject, "add", function() { return add; });
__webpack_require__.d(mat2_namespaceObject, "subtract", function() { return subtract; });
__webpack_require__.d(mat2_namespaceObject, "exactEquals", function() { return exactEquals; });
__webpack_require__.d(mat2_namespaceObject, "equals", function() { return mat2_equals; });
__webpack_require__.d(mat2_namespaceObject, "multiplyScalar", function() { return multiplyScalar; });
__webpack_require__.d(mat2_namespaceObject, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
__webpack_require__.d(mat2_namespaceObject, "mul", function() { return mul; });
__webpack_require__.d(mat2_namespaceObject, "sub", function() { return sub; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec2.js
var vec2_namespaceObject = {};
__webpack_require__.r(vec2_namespaceObject);
__webpack_require__.d(vec2_namespaceObject, "create", function() { return vec2_create; });
__webpack_require__.d(vec2_namespaceObject, "clone", function() { return vec2_clone; });
__webpack_require__.d(vec2_namespaceObject, "fromValues", function() { return vec2_fromValues; });
__webpack_require__.d(vec2_namespaceObject, "copy", function() { return vec2_copy; });
__webpack_require__.d(vec2_namespaceObject, "set", function() { return vec2_set; });
__webpack_require__.d(vec2_namespaceObject, "add", function() { return vec2_add; });
__webpack_require__.d(vec2_namespaceObject, "subtract", function() { return vec2_subtract; });
__webpack_require__.d(vec2_namespaceObject, "multiply", function() { return vec2_multiply; });
__webpack_require__.d(vec2_namespaceObject, "divide", function() { return divide; });
__webpack_require__.d(vec2_namespaceObject, "ceil", function() { return ceil; });
__webpack_require__.d(vec2_namespaceObject, "floor", function() { return floor; });
__webpack_require__.d(vec2_namespaceObject, "min", function() { return min; });
__webpack_require__.d(vec2_namespaceObject, "max", function() { return vec2_max; });
__webpack_require__.d(vec2_namespaceObject, "round", function() { return vec2_round; });
__webpack_require__.d(vec2_namespaceObject, "scale", function() { return vec2_scale; });
__webpack_require__.d(vec2_namespaceObject, "scaleAndAdd", function() { return scaleAndAdd; });
__webpack_require__.d(vec2_namespaceObject, "distance", function() { return distance; });
__webpack_require__.d(vec2_namespaceObject, "squaredDistance", function() { return squaredDistance; });
__webpack_require__.d(vec2_namespaceObject, "length", function() { return vec2_length; });
__webpack_require__.d(vec2_namespaceObject, "squaredLength", function() { return squaredLength; });
__webpack_require__.d(vec2_namespaceObject, "negate", function() { return negate; });
__webpack_require__.d(vec2_namespaceObject, "inverse", function() { return inverse; });
__webpack_require__.d(vec2_namespaceObject, "normalize", function() { return normalize; });
__webpack_require__.d(vec2_namespaceObject, "dot", function() { return dot; });
__webpack_require__.d(vec2_namespaceObject, "cross", function() { return cross; });
__webpack_require__.d(vec2_namespaceObject, "lerp", function() { return lerp; });
__webpack_require__.d(vec2_namespaceObject, "random", function() { return random; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2", function() { return transformMat2; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2d", function() { return transformMat2d; });
__webpack_require__.d(vec2_namespaceObject, "transformMat3", function() { return transformMat3; });
__webpack_require__.d(vec2_namespaceObject, "transformMat4", function() { return transformMat4; });
__webpack_require__.d(vec2_namespaceObject, "rotate", function() { return vec2_rotate; });
__webpack_require__.d(vec2_namespaceObject, "angle", function() { return angle; });
__webpack_require__.d(vec2_namespaceObject, "signedAngle", function() { return signedAngle; });
__webpack_require__.d(vec2_namespaceObject, "zero", function() { return zero; });
__webpack_require__.d(vec2_namespaceObject, "str", function() { return vec2_str; });
__webpack_require__.d(vec2_namespaceObject, "exactEquals", function() { return vec2_exactEquals; });
__webpack_require__.d(vec2_namespaceObject, "equals", function() { return vec2_equals; });
__webpack_require__.d(vec2_namespaceObject, "len", function() { return len; });
__webpack_require__.d(vec2_namespaceObject, "sub", function() { return vec2_sub; });
__webpack_require__.d(vec2_namespaceObject, "mul", function() { return vec2_mul; });
__webpack_require__.d(vec2_namespaceObject, "div", function() { return div; });
__webpack_require__.d(vec2_namespaceObject, "dist", function() { return dist; });
__webpack_require__.d(vec2_namespaceObject, "sqrDist", function() { return sqrDist; });
__webpack_require__.d(vec2_namespaceObject, "sqrLen", function() { return sqrLen; });
__webpack_require__.d(vec2_namespaceObject, "forEach", function() { return forEach; });

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec3.js
var vec3_namespaceObject = {};
__webpack_require__.r(vec3_namespaceObject);
__webpack_require__.d(vec3_namespaceObject, "create", function() { return vec3_create; });
__webpack_require__.d(vec3_namespaceObject, "clone", function() { return vec3_clone; });
__webpack_require__.d(vec3_namespaceObject, "length", function() { return vec3_length; });
__webpack_require__.d(vec3_namespaceObject, "fromValues", function() { return vec3_fromValues; });
__webpack_require__.d(vec3_namespaceObject, "copy", function() { return vec3_copy; });
__webpack_require__.d(vec3_namespaceObject, "set", function() { return vec3_set; });
__webpack_require__.d(vec3_namespaceObject, "add", function() { return vec3_add; });
__webpack_require__.d(vec3_namespaceObject, "subtract", function() { return vec3_subtract; });
__webpack_require__.d(vec3_namespaceObject, "multiply", function() { return vec3_multiply; });
__webpack_require__.d(vec3_namespaceObject, "divide", function() { return vec3_divide; });
__webpack_require__.d(vec3_namespaceObject, "ceil", function() { return vec3_ceil; });
__webpack_require__.d(vec3_namespaceObject, "floor", function() { return vec3_floor; });
__webpack_require__.d(vec3_namespaceObject, "min", function() { return vec3_min; });
__webpack_require__.d(vec3_namespaceObject, "max", function() { return vec3_max; });
__webpack_require__.d(vec3_namespaceObject, "round", function() { return vec3_round; });
__webpack_require__.d(vec3_namespaceObject, "scale", function() { return vec3_scale; });
__webpack_require__.d(vec3_namespaceObject, "scaleAndAdd", function() { return vec3_scaleAndAdd; });
__webpack_require__.d(vec3_namespaceObject, "distance", function() { return vec3_distance; });
__webpack_require__.d(vec3_namespaceObject, "squaredDistance", function() { return vec3_squaredDistance; });
__webpack_require__.d(vec3_namespaceObject, "squaredLength", function() { return vec3_squaredLength; });
__webpack_require__.d(vec3_namespaceObject, "negate", function() { return vec3_negate; });
__webpack_require__.d(vec3_namespaceObject, "inverse", function() { return vec3_inverse; });
__webpack_require__.d(vec3_namespaceObject, "normalize", function() { return vec3_normalize; });
__webpack_require__.d(vec3_namespaceObject, "dot", function() { return vec3_dot; });
__webpack_require__.d(vec3_namespaceObject, "cross", function() { return vec3_cross; });
__webpack_require__.d(vec3_namespaceObject, "lerp", function() { return vec3_lerp; });
__webpack_require__.d(vec3_namespaceObject, "slerp", function() { return slerp; });
__webpack_require__.d(vec3_namespaceObject, "hermite", function() { return hermite; });
__webpack_require__.d(vec3_namespaceObject, "bezier", function() { return bezier; });
__webpack_require__.d(vec3_namespaceObject, "random", function() { return vec3_random; });
__webpack_require__.d(vec3_namespaceObject, "transformMat4", function() { return vec3_transformMat4; });
__webpack_require__.d(vec3_namespaceObject, "transformMat3", function() { return vec3_transformMat3; });
__webpack_require__.d(vec3_namespaceObject, "transformQuat", function() { return transformQuat; });
__webpack_require__.d(vec3_namespaceObject, "rotateX", function() { return rotateX; });
__webpack_require__.d(vec3_namespaceObject, "rotateY", function() { return rotateY; });
__webpack_require__.d(vec3_namespaceObject, "rotateZ", function() { return rotateZ; });
__webpack_require__.d(vec3_namespaceObject, "angle", function() { return vec3_angle; });
__webpack_require__.d(vec3_namespaceObject, "zero", function() { return vec3_zero; });
__webpack_require__.d(vec3_namespaceObject, "str", function() { return vec3_str; });
__webpack_require__.d(vec3_namespaceObject, "exactEquals", function() { return vec3_exactEquals; });
__webpack_require__.d(vec3_namespaceObject, "equals", function() { return vec3_equals; });
__webpack_require__.d(vec3_namespaceObject, "sub", function() { return vec3_sub; });
__webpack_require__.d(vec3_namespaceObject, "mul", function() { return vec3_mul; });
__webpack_require__.d(vec3_namespaceObject, "div", function() { return vec3_div; });
__webpack_require__.d(vec3_namespaceObject, "dist", function() { return vec3_dist; });
__webpack_require__.d(vec3_namespaceObject, "sqrDist", function() { return vec3_sqrDist; });
__webpack_require__.d(vec3_namespaceObject, "len", function() { return vec3_len; });
__webpack_require__.d(vec3_namespaceObject, "sqrLen", function() { return vec3_sqrLen; });
__webpack_require__.d(vec3_namespaceObject, "forEach", function() { return vec3_forEach; });

// NAMESPACE OBJECT: ./src/reader/index.ts
var reader_namespaceObject = {};
__webpack_require__.r(reader_namespaceObject);
__webpack_require__.d(reader_namespaceObject, "BarcodeReader", function() { return barcode_reader; });
__webpack_require__.d(reader_namespaceObject, "TwoOfFiveReader", function() { return _2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "NewCodabarReader", function() { return codabar_reader; });
__webpack_require__.d(reader_namespaceObject, "Code128Reader", function() { return code_128_reader; });
__webpack_require__.d(reader_namespaceObject, "Code32Reader", function() { return code_32_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39Reader", function() { return code_39_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39VINReader", function() { return code_39_vin_reader; });
__webpack_require__.d(reader_namespaceObject, "Code93Reader", function() { return code_93_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN2Reader", function() { return ean_2_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN5Reader", function() { return ean_5_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN8Reader", function() { return ean_8_reader; });
__webpack_require__.d(reader_namespaceObject, "EANReader", function() { return ean_reader; });
__webpack_require__.d(reader_namespaceObject, "I2of5Reader", function() { return i2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCEReader", function() { return upc_e_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCReader", function() { return upc_reader; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(8);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(12);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(132);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(58);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(2);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(3);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var ANGLE_ORDER = "zyx";

/**
 * Symmetric round
 * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background
 *
 * @param {Number} a value to round
 */
function round(a) {
  if (a >= 0) return Math.round(a);
  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);
}

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Convert Radian To Degree
 *
 * @param {Number} a Angle in Radians
 */
function toDegree(a) {
  return a * radian;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a          The first number to test.
 * @param {Number} b          The second number to test.
 * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;
  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));
}
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat2.js


/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function mat2_create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }
  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2 | null} out, or null if source matrix is not invertible
 */
function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is necessary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function mat2_scale(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat2_equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
var sub = subtract;
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec2.js


/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function vec2_create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function vec2_clone(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function vec2_fromValues(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */
function vec2_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function vec2_set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function vec2_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * symmetric round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */
function vec2_round(out, a) {
  out[0] = round(a[0]);
  out[1] = round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function vec2_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec2_length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */
function vec2_rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}

/**
 * Get the smallest angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
}

/**
 * Get the signed angle in the interval [-pi,pi] between two 2D vectors (positive if `a` is to the right of `b`)
 * 
 * @param {ReadonlyVec2} a The first vector
 * @param {ReadonlyVec2} b The second vector
 * @returns {number} The signed angle in radians
 */
function signedAngle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}

/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */
function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec2_str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = vec2_length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var vec2_sub = vec2_subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var vec2_mul = vec2_multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = vec2_create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js


/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function vec3_create() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function vec3_clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec3_length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function vec3_fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */
function vec3_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function vec3_set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */
function vec3_ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */
function vec3_floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * symmetric round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */
function vec3_round(out, a) {
  out[0] = round(a[0]);
  out[1] = round(a[1]);
  out[2] = round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function vec3_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function vec3_scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */
function vec3_distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function vec3_squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function vec3_squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */
function vec3_negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */
function vec3_inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */
function vec3_normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec3_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function vec3_cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function vec3_lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a spherical linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function slerp(out, a, b, t) {
  var angle = Math.acos(Math.min(Math.max(vec3_dot(a, b), -1), 1));
  var sinTotal = Math.sin(angle);
  var ratioA = Math.sin((1 - t) * angle) / sinTotal;
  var ratioB = Math.sin(t * angle) / sinTotal;
  out[0] = ratioA * a[0] + ratioB * b[0];
  out[1] = ratioA * a[1] + ratioB * b[1];
  out[2] = ratioA * a[2] + ratioB * b[2];
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec3} out
 */
function vec3_random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = RANDOM() * 2.0 * Math.PI;
  var z = RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */
function vec3_transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function vec3_transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q normalized quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // Fast Vector Rotation using Quaternions by Robert Eisele
  // https://raw.org/proof/vector-rotation-using-quaternions/

  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var vx = a[0],
    vy = a[1],
    vz = a[2];

  // t = q x v
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;

  // t = 2t
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;

  // v + w t + q x t
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateX(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateY(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateZ(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */
function vec3_angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)),
    cosine = mag && vec3_dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}

/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */
function vec3_zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec3_str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var vec3_sub = vec3_subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var vec3_mul = vec3_multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var vec3_div = vec3_divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var vec3_dist = vec3_distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var vec3_sqrDist = vec3_squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var vec3_len = vec3_length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var vec3_sqrLen = vec3_squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var vec3_forEach = function () {
  var vec = vec3_create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/index.js











// CONCATENATED MODULE: ./src/common/array_helper.ts
/* eslint-disable no-param-reassign */

/* harmony default export */ var array_helper = ({
  init: function init(arr, val) {
    arr.fill(val);
  },
  /**
   * IN-PLACE Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    // Durstenfeld shuffle algorithm
    // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
    for (var i = arr.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var _ref = [arr[j], arr[i]];
      arr[i] = _ref[0];
      arr[j] = _ref[1];
    }
    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },
  /**
   * returns the elements which's score is bigger than the threshold
   */
  // eslint-disable-next-line no-unused-vars
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }
      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }
    return max;
  },
  max: function max(arr) {
    var max = 0;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }
    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;
    while (length--) {
      sum += arr[length];
    }
    return sum;
  }
});
// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)



/**
 * Creates a cluster for grouping similar orientations of datapoints
 */
/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2_namespaceObject.clone([0, 0])
    };
    var pointMap = {};
    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }
    function updateCenter() {
      var i;
      var sum = 0;
      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }
      center.rad = sum / points.length;
      center.vec = vec2_namespaceObject.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }
    function init() {
      _add(point);
      updateCenter();
    }
    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);
          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2_namespaceObject.dot(otherPoint.point.vec, center.vec));
        if (similarity > threshold) {
          return true;
        }
        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */
/* eslint-disable no-bitwise */




/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */
function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return vec2_namespaceObject.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3_namespaceObject.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}

/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */
function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y;

  // sum up first column
  posB = width;
  sum = 0;
  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }
  posA = 0;
  posB = 1;
  sum = 0;
  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }
  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;
    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;

  // sum up first row
  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }
  for (var v = 1; v < height; v++) {
    sum = 0;
    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }
  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;
  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }
  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);
  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }
  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;
  for (i = 1; i < length - 1; i++) {
    right = line[i + 1];
    //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign
    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }
  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;
  function px(init, end) {
    var sum = 0;
    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }
    return sum;
  }
  function mx(init, end) {
    var sum = 0;
    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }
    return sum;
  }
  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);
    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;
      if (p12 === 0) {
        p12 = 1;
      }
      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }
    return array_helper.maxIndex(vet);
  }
  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
}

// local thresholding
function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }
  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1);

  // clear out top & bottom-border
  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  }

  // clear out left & right border
  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }
  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];
  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }
  function addToCluster(newPoint) {
    var found = false;
    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];
      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }
    return found;
  }

  // iterate over each cloud
  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);
    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }
  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;
    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;
      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }
        return false;
      }

      // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met

      var from = points[idx];
      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }
      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx];
      // eslint-disable-next-line no-cond-assign
      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }
      return found ? toIdx : null;
    }
    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length);

      // trace forward
      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]);
      // eslint-disable-next-line no-cond-assign
      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }
      if (centerPos > 0) {
        currentPos = centerPos;
        // eslint-disable-next-line no-cond-assign
        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }
      if (top.length > result.length) {
        result = top;
      }
    }
    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;
  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;
  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function cv_utils_subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }
  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;
  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }
  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;
  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;
  while (length--) {
    sum += data[length];
  }
  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;
  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }
  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);
    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;
      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }
  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;
  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }
    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;
  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;
  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width;
    // eslint-disable-next-line no-param-reassign
    canvas.height = this.height;
    console.warn('* loadImageArray getContext 2d');
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);
    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
      data = _ctx$getImageData.data;
    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };
  img.src = src;
}

/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */
function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;
  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }
    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;
  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  }
  // eslint-disable-next-line no-param-reassign
  rgb[0] = (r + m) * 255 | 0;
  // eslint-disable-next-line no-param-reassign
  rgb[1] = (g + m) * 255 | 0;
  // eslint-disable-next-line no-param-reassign
  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  // Handle edge cases
  // NaN: Not a number - no meaningful divisors
  // Infinity: Infinite values have no finite divisors
  // Non-positive: Divisors are typically defined for positive integers only
  // While negative numbers technically have divisors, returning them would complicate
  // the API (would need to return both positive and negative divisors, or make assumptions)
  if (!Number.isFinite(n) || n < 1) {
    return [];
  }
  var largeDivisors = [];
  var divisors = [];
  var sqrtN = Math.sqrt(n);
  for (var i = 1; i <= sqrtN; i++) {
    if (n % i === 0) {
      divisors.push(i);
      // Only add the complementary divisor if it's different (not a perfect square root)
      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }
  return divisors.concat(largeDivisors);
}
function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }
  return result;
}
function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);
  var divisorsY = _computeDivisors(imgSize.y);
  var wideSide = Math.max(imgSize.x, imgSize.y);
  var common = _computeIntersection(divisorsX, divisorsY);
  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;
  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];
    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }
    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }
    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }
    return null;
  }
  optimalPatchSize = findPatchSizeForDivisors(common);
  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));
    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }
  // Fallback: if no optimal patch size found, use image size (or 1x1 minimum)
  // This ensures the function always returns a valid {x, y} object
  if (!optimalPatchSize) {
    optimalPatchSize = {
      x: Math.max(1, imgSize.x),
      y: Math.max(1, imgSize.y)
    };
  }
  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];
    var parsed = _parseCSSDimensionValues(value);
    var calculated = _dimensionsConverters[key](parsed, context);

    // eslint-disable-next-line no-param-reassign
    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}
// CONCATENATED MODULE: ./src/common/image_wrapper.ts







function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}
var image_wrapper_ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;
    classCallCheck_default()(this, ImageWrapper);
    defineProperty_default()(this, "data", void 0);
    defineProperty_default()(this, "size", void 0);
    defineProperty_default()(this, "indexMapping", void 0);
    if (!data) {
      this.data = new ArrayType(size.x * size.y);
      if (initialize) {
        array_helper.init(this.data, 0);
      }
    } else {
      this.data = data;
    }
    this.size = size;
  }

  // tests if a position is within the image, extended out by a border on each side
  return createClass_default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border);
      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    }

    // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.
  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
        sizeX = _imageWrapper$size.x,
        sizeY = _imageWrapper$size.y;
      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }
      return imageWrapper;
      // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    }

    // Retrieve a grayscale value at the given pixel position of the image
  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    }

    // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)
  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };
        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }
        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }
      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    }

    // Sets a given pixel position in the image to the given grayscale value
  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    }

    // Sets the border of the image (1 pixel) to zero
  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
        width = _this$size.x,
        height = _this$size.y;
      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }
      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }
      delete this.indexMapping;
      return this;
    }

    // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.
  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;
      if (labelCount <= 0) {
        return result;
      }
      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }
      for (y = 0; y < height; y++) {
        ysq = y * y;
        for (x = 0; x < width; x++) {
          val = data[y * width + x];
          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }
      for (i = 0; i < labelCount; i++) {
        label = labelSum[i];
        // eslint-disable-next-line no-restricted-globals
        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI;
          // eslint-disable-next-line no-mixed-operators
          label.theta = (tmp * 180 / PI + 90) % 180 - 90;
          if (label.theta < 0) {
            label.theta += 180;
          }
          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2_namespaceObject.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }
      return result;
    }

    // return a Uint8ClampedArray containing this grayscale image converted to RGBA form
  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);
      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }
      return ret;
    }

    // Display this ImageWrapper in a given Canvas element at the specified scale
  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      console.warn('* imagewrapper show getcontext 2d');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }
      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale);
      // eslint-disable-next-line no-param-reassign
      canvas.width = this.size.x;
      // eslint-disable-next-line no-param-reassign
      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    }

    // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.
  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      console.warn('* imagewrapper overlay getcontext 2d');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }
      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;
      while (length--) {
        hsv[0] = this.data[length] * adjustedScale;
        // eslint-disable-next-line no-nested-ternary
        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : hsv2rgb(hsv, rgb);
        var pos = length * 4;
        var _result = result;
        var _result2 = slicedToArray_default()(_result, 3);
        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }
      ctx.putImageData(frame, from.x, from.y);
    }
  }]);
}();
/* harmony default export */ var image_wrapper = (image_wrapper_ImageWrapper);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(7);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(6);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// CONCATENATED MODULE: ./src/common/image_debug.ts
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.

// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.

/* harmony default export */ var image_debug = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);
    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }
    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;
    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }
    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }
    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(4);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(1);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(5);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts



/* eslint-disable no-unused-vars */
/* eslint-disable class-methods-use-this */
// eslint-disable-next-line import/no-cycle



// for some reason this throws a shadow error on itself?!
// eslint-disable-next-line no-shadow
var BarcodeDirection = /*#__PURE__*/function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
  return BarcodeDirection;
}({});
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);
    defineProperty_default()(this, "_row", []);
    defineProperty_default()(this, "config", {});
    defineProperty_default()(this, "supplements", []);
    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);
    defineProperty_default()(this, "FORMAT", 'unknown');
    defineProperty_default()(this, "CONFIG_KEYS", {});
    this._row = [];
    this.config = config || {};
    if (supplements) {
      this.supplements = supplements;
    }
  }
  return createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }
      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      var maxSingleError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.SINGLE_CODE_ERROR || 1;
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }
      if (sum < modulo) {
        return Number.MAX_VALUE;
      }
      barWidth = sum / modulo;
      // eslint-disable-next-line no-param-reassign
      maxSingleError *= barWidth;
      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;
        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }
        error += singleError;
      }
      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }
      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;
      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);
        if (tmp > 1) {
          // eslint-disable-next-line no-param-reassign
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern;
      // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));
      var result = this.decode();
      // console.warn('* first result=', result);
      if (result === null) {
        this._row.reverse();
        result = this.decode();
        // console.warn('* reversed result=', result);
        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }
      if (result) {
        result.format = this.FORMAT;
      }
      // console.warn('* returning', result);
      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      // eslint-disable-next-line no-param-reassign
      start = start < 0 ? 0 : start;
      var i;
      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;
      for (var i = offset; i < end; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          // eslint-disable-next-line no-param-reassign
          isWhite = !isWhite;
        }
      }
      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper.init(counters, 0);
      for (var i = start; i < end; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          // eslint-disable-next-line no-param-reassign
          counters[counterPos]++;
        } else {
          counterPos++;
          if (counterPos === numCounters) {
            break;
          } else {
            // eslint-disable-next-line no-param-reassign
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }
      return counters;
    }

    // override/implement this in your custom readers.
  }, {
    key: "decodeImage",
    value: function decodeImage(imageWrapper) {
      // eslint-disable-next-line no-void
      void imageWrapper;
      return null;
    }
  }], [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts






function _callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var N = 1;
var W = 3;
var START_PATTERN = [W, N, W, N, N, N];
var STOP_PATTERN = [W, N, N, N, W];
var CODE_PATTERN = [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]];
var START_PATTERN_LENGTH = START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);
var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  function TwoOfFiveReader() {
    var _this;
    classCallCheck_default()(this, TwoOfFiveReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, TwoOfFiveReader, [].concat(args));
    defineProperty_default()(_this, "barSpaceRatio", [1, 1]);
    defineProperty_default()(_this, "FORMAT", '2of5');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.78);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.30);
    return _this;
  }
  inherits_default()(TwoOfFiveReader, _BarcodeReader);
  return createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }
      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;
            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }
            error = this._matchPattern(counter, pattern);
            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }
            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;
      var offset = this._nextSet(this._row);
      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;
      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true);
        if (!startInfo) {
          return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();
      var offset = this._nextSet(this._row);
      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);
      this._row.reverse();
      if (endInfo === null) {
        return null;
      }

      // reverse numbers
      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      for (var code = 0; code < CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, CODE_PATTERN[code]);
        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }
      if (bestMatch.error < epsilon) {
        return bestMatch;
      }
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;
      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }
        code = this._decodeCode(counter);
        if (!code) {
          return null;
        }
        result.push("".concat(code.code));
        decodedCodes.push(code);
      }
      return code;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      var endInfo = this._findEnd();
      if (!endInfo) {
        return null;
      }
      var counters = this._fillCounters(startInfo.end, endInfo.start, false);
      if (!this._verifyCounterLength(counters)) {
        return null;
      }
      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];
      var code = this._decodePayload(counters, result, decodedCodes);
      if (!code) {
        return null;
      }
      if (result.length < 5) {
        return null;
      }
      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts






function codabar_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, codabar_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function codabar_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (codabar_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


// const ALPHABETH_STRING = '0123456789-$:/.+ABCD';
var ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;
var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  function NewCodabarReader() {
    var _this;
    classCallCheck_default()(this, NewCodabarReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = codabar_reader_callSuper(this, NewCodabarReader, [].concat(args));
    defineProperty_default()(_this, "_counters", []);
    defineProperty_default()(_this, "FORMAT", 'codabar');
    return _this;
  }
  inherits_default()(NewCodabarReader, _BarcodeReader);
  return createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;
      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];
        if (counter > max) {
          max = counter;
        }
        if (counter < min) {
          min = counter;
        }
      }
      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;
      if (end > this._counters.length) {
        return -1;
      }
      var barThreshold = this._computeAlternatingThreshold(offset, end);
      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);
      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;
      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;
        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }
        bitmask >>= 1;
      }
      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;
      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }
      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);
      var end = start;
      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);
        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }
      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;
      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }
      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);
      for (var i = 0; i < ALPHABET.length; i++) {
        if (ALPHABET[i] === charCode) {
          return CHARACTER_ENCODINGS[i];
        }
      }
      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;
      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);
        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }
        pos += 8;
      }
      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);
      var pos = startCounter;
      var pattern;
      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);
        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];
          if (size < cat.min || size > cat.max) {
            return false;
          }
          pattern >>= 1;
        }
        pos += 8;
      }
      return true;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();
      if (!start) {
        return null;
      }
      var nextStart = start.startCounter;
      var result = [];
      var pattern;
      do {
        pattern = this._toPattern(nextStart);
        if (pattern < 0) {
          return null;
        }
        var decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        nextStart += 8;
        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length);

      // verify end
      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      }

      // verify end white space
      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }
      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }
      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;
      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);
      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts






function code_128_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_128_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_128_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_128_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code128Reader() {
    var _this;
    classCallCheck_default()(this, Code128Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_128_reader_callSuper(this, Code128Reader, [].concat(args));
    defineProperty_default()(_this, "CODE_SHIFT", 98);
    defineProperty_default()(_this, "CODE_C", 99);
    defineProperty_default()(_this, "CODE_B", 100);
    defineProperty_default()(_this, "CODE_A", 101);
    defineProperty_default()(_this, "START_CODE_A", 103);
    defineProperty_default()(_this, "START_CODE_B", 104);
    defineProperty_default()(_this, "START_CODE_C", 105);
    defineProperty_default()(_this, "STOP_CODE", 106);
    defineProperty_default()(_this, "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.64);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.30);
    defineProperty_default()(_this, "FORMAT", 'code_128');
    defineProperty_default()(_this, "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });
    return _this;
  }
  inherits_default()(Code128Reader, _BarcodeReader);
  return createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }
            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            bestMatch.end = i;
            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }
            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }
            return bestMatch;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);
      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    value:
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = this._nextSet(this._row);
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);
            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }
            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }
            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var _this2 = this;
      var startInfo = this._findStart();
      if (startInfo === null) {
        return null;
      }
      // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;

      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;
      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;
          case _this2.START_CODE_B:
            return _this2.CODE_B;
          case _this2.START_CODE_C:
            return _this2.CODE_C;
          default:
            return null;
        }
      }(code.code);
      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);
        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }
          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }
          decodedCodes.push(code);
          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;
                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;
                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }
                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;
                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;
                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }
              break;
          }
        } else {
          done = true;
        }
        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }
      if (code === null) {
        return null;
      }
      code.end = this._nextUnset(this._row, code.end);
      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }
      checksum -= multiplier * rawResult[rawResult.length - 1];
      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }
      if (!result.length) {
        return null;
      }

      // remove last code from result (checksum)
      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }
      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
        trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
        sumNormalized = 0,
        sumExpected = 0;
      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }
      return sumExpected / sumNormalized;
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(10);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(25);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts







function code_39_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_39_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_39_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_39_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/* eslint-disable class-methods-use-this */


var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var code_39_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_39_reader_CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;
var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code39Reader() {
    var _this;
    classCallCheck_default()(this, Code39Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_39_reader_callSuper(this, Code39Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_39');
    return _this;
  }
  inherits_default()(Code39Reader, _BarcodeReader);
  return createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);
      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;
      for (var i = offset; i < this._row.length; i++) {
        // eslint-disable-next-line no-bitwise
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }
            patternStart += counter[0] + counter[1];
            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }
            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;
      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;
        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            // eslint-disable-next-line no-bitwise
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }
        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;
              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }
          return pattern;
        }
      }
      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;
      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }
      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_39_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_39_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_39_reader_ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper.sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;
      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }
      return false;
    }
  }, {
    key: "decode",
    value: function decode() {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      var start = this._findStart();
      if (!start) {
        return null;
      }
      var nextStart = this._nextSet(this._row, start.end);
      var decodedChar;
      var lastStart;
      do {
        counters = this._toCounters(nextStart, counters);
        var pattern = this._toPattern(counters);
        if (pattern < 0) {
          return null;
        }
        decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper.sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');
      result.pop();
      if (!result.length) {
        return null;
      }
      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }
      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts







function code_32_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_32_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_32_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_32_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }

var patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';
var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  function Code32Reader() {
    var _this;
    classCallCheck_default()(this, Code32Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_32_reader_callSuper(this, Code32Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_32_reader');
    return _this;
  }
  inherits_default()(Code32Reader, _Code39Reader);
  return createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }
      var res = 0;
      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }
      var code32 = "".concat(res);
      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }
      return 'A' + code32;
    }

    // TODO (this was todo in original repo, no text was there. sorry.)
  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "decode",
    value: function decode() {
      var result = _superPropGet(Code32Reader, "decode", this, 3)([]);
      if (!result) {
        return null;
      }
      var code = result.code;
      if (!code) {
        return null;
      }
      code = code.replace(patterns.AEIO, '');
      if (!this._checkChecksum(code)) {
        return null;
      }
      var code32 = this._decodeCode32(code);
      if (!code32) {
        return null;
      }
      result.code = code32;
      return result;
    }
  }]);
}(code_39_reader);
/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts







function code_39_vin_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_39_vin_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_39_vin_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_39_vin_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function code_39_vin_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
/* eslint-disable class-methods-use-this */


var code_39_vin_reader_patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};
var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  function Code39VINReader() {
    var _this;
    classCallCheck_default()(this, Code39VINReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_39_vin_reader_callSuper(this, Code39VINReader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_39_vin');
    return _this;
  }
  inherits_default()(Code39VINReader, _Code39Reader);
  return createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    value:
    // TODO (this was todo in original repo, no text was there. sorry.)
    function _checkChecksum(code) {
      return !!code;
    }

    // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
  }, {
    key: "decode",
    value: function decode() {
      var result = code_39_vin_reader_superPropGet(Code39VINReader, "decode", this, 3)([]);
      if (!result) {
        return null;
      }
      var code = result.code;
      if (!code) {
        return null;
      }
      code = code.replace(code_39_vin_reader_patterns.IOQ, '');
      if (!code.match(code_39_vin_reader_patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }
        return null;
      }
      if (!this._checkChecksum(code)) {
        return null;
      }
      result.code = code;
      return result;
    }
  }]);
}(code_39_reader);
/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts







function code_93_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, code_93_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function code_93_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (code_93_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }


var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;
var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  function Code93Reader() {
    var _this;
    classCallCheck_default()(this, Code93Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = code_93_reader_callSuper(this, Code93Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'code_93');
    return _this;
  }
  inherits_default()(Code93Reader, _BarcodeReader);
  return createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }
      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;
      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);
        if (normalized < 1 || normalized > 4) {
          return -1;
        }
        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }
      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);
      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }
            patternStart += counter[0] + counter[1];
            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }
            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }
      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];
      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];
        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }
          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;
          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }
              break;
            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }
              break;
            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }
              break;
            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }
              break;
            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }
          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }
      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      start = this._findStart();
      if (!start) {
        return null;
      }
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];
      var nextStart = this._nextSet(this._row, start.end);
      var lastStart;
      var decodedChar;
      do {
        counters = this._toCounters(nextStart, counters);
        var pattern = this._toPattern(counters);
        if (pattern < 0) {
          return null;
        }
        decodedChar = this._patternToChar(pattern);
        if (decodedChar === null) {
          return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper.sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');
      result.pop();
      if (!result.length) {
        return null;
      }
      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }
      if (!this._verifyChecksums(result)) {
        return null;
      }
      result = result.slice(0, result.length - 2);
      // yes, this is an assign inside an if.
      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }
      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/ean_reader.ts






function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function ean_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }



// const CODE_L_START = 0;
var CODE_G_START = 10;

var ean_reader_START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var ean_reader_CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
// const SINGLE_CODE_ERROR = 0.70;
var AVG_CODE_ERROR = 0.48;
var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  // TODO: does this need to be in the class?

  function EANReader(config, supplements) {
    var _this;
    classCallCheck_default()(this, EANReader);
    _this = ean_reader_callSuper(this, EANReader, [merge_default()({
      supplements: []
    }, config), supplements]);
    defineProperty_default()(_this, "FORMAT", 'ean_13');
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.70);
    defineProperty_default()(_this, "STOP_PATTERN", [1, 1, 1]);
    return _this;
  }
  inherits_default()(EANReader, _BarcodeReader);
  return createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR;
      // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);
      var counterPos = 0;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      var found = false;
      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern);
            // console.warn('* matchPattern', error, counter, pattern);
            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i;
              // console.warn('* return bestMatch', JSON.stringify(bestMatch));
              return bestMatch;
            }
            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      if (found) {
        // console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {
        // console.warn('* return null');
      }
      return found ? bestMatch : null;
    }

    // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?
  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;
      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = ean_reader_CODE_PATTERN.length;
        // console.warn('* decodeCode after length');
      }
      var found = false;
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, ean_reader_CODE_PATTERN[code]);
              bestMatch.end = i;
              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }
            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            }
            // console.warn('* return bestMatch', JSON.stringify(bestMatch));
            return bestMatch;
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);
      var startInfo = null;
      while (!startInfo) {
        startInfo = this._findPattern(ean_reader_START_PATTERN, offset, false, true);
        // console.warn('* startInfo=', JSON.stringify(startInfo));
        if (!startInfo) {
          return null;
        }
        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      // console.warn('* returning null');
      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      }
      // console.warn('* return null');
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);
      var codeFrequency = 0x0;
      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);
        // console.warn('* decodeCode=', outCode);
        if (!outCode) {
          // console.warn('* return null');
          return null;
        }
        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }
        result.push(outCode.code);
        decodedCodes.push(outCode);
      }
      var firstDigit = this._calculateFirstDigit(codeFrequency);
      // console.warn('* firstDigit=', firstDigit);
      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }
      result.unshift(firstDigit);
      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false);
      // console.warn('* findPattern=', JSON.stringify(middlePattern));

      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }
      decodedCodes.push(middlePattern);
      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START);
        // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }
        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      }

      // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);
      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      }
      // console.warn('* return null');
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;
      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }
      sum *= 3;
      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      }

      // console.warn('* end checksum', sum % 10 === 0);
      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);
      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);
      if (startInfo === null) {
        return null;
      }

      // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');
      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i].decode(this._row, startInfo.end);
          // console.warn('* decode result=', result);
          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      }

      // console.warn('* end decodeExtensions');
      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);
      if (!code) {
        return null;
      }
      code = this._findEnd(code.end, false);
      if (!code) {
        return null;
      }
      decodedCodes.push(code);

      // Checksum
      if (!this._checksum(result)) {
        return null;
      }

      // console.warn('* this.supplements=', this.supplements);
      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end);
        // console.warn('* decodeExtensions returns', supplement);
        if (!supplement) {
          return null;
        }
        if (!supplement.decodedCodes) {
          return null;
        }
        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };
        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }
        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }
      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);
}(barcode_reader);
/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts






function ean_2_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_2_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_2_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_2_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  function EAN2Reader() {
    var _this;
    classCallCheck_default()(this, EAN2Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_2_reader_callSuper(this, EAN2Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_2');
    return _this;
  }
  inherits_default()(EAN2Reader, _EANReader);
  return createClass_default()(EAN2Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (row) {
        this._row = row;
      }
      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;
      if (offset === undefined) {
        return null;
      }
      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }
        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }
      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }
      var startInfo = this._findStart();
      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);
}(ean_reader);
;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts






function ean_5_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_5_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_5_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_5_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }
  return null;
}
function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;
  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }
  sum *= 3;
  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }
  sum *= 3;
  return sum % 10;
}
var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  function EAN5Reader() {
    var _this;
    classCallCheck_default()(this, EAN5Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_5_reader_callSuper(this, EAN5Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_5');
    return _this;
  }
  inherits_default()(EAN5Reader, _EANReader);
  return createClass_default()(EAN5Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (start === undefined) {
        return null;
      }
      if (row) {
        this._row = row;
      }
      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];
      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }
        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }
      if (result.length !== 5) {
        return null;
      }
      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }
      var startInfo = this._findStart();
      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);
}(ean_reader);
;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts






function ean_8_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, ean_8_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function ean_8_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ean_8_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  function EAN8Reader() {
    var _this;
    classCallCheck_default()(this, EAN8Reader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = ean_8_reader_callSuper(this, EAN8Reader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'ean_8');
    return _this;
  }
  inherits_default()(EAN8Reader, _EANReader);
  return createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;
      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);
        if (!code) {
          return null;
        }
        result.push(code.code);
        decodedCodes.push(code);
      }
      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);
      if (code === null) {
        return null;
      }
      decodedCodes.push(code);
      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);
        if (!code) {
          return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
      }
      return code;
    }
  }]);
}(ean_reader);
/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts







function i2of5_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, i2of5_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function i2of5_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (i2of5_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function i2of5_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that



var i2of5_reader_N = 1;
var i2of5_reader_W = 3;
var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  function I2of5Reader(opts) {
    var _this;
    classCallCheck_default()(this, I2of5Reader);
    _this = i2of5_reader_callSuper(this, I2of5Reader, [merge_default()({
      normalizeBarSpaceWidth: false
    }, opts)]);
    defineProperty_default()(_this, "barSpaceRatio", [1, 1]);
    defineProperty_default()(_this, "SINGLE_CODE_ERROR", 0.78);
    defineProperty_default()(_this, "AVG_CODE_ERROR", 0.38);
    defineProperty_default()(_this, "START_PATTERN", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N]);
    defineProperty_default()(_this, "STOP_PATTERN", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W]);
    defineProperty_default()(_this, "CODE_PATTERN", [[i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N]]);
    defineProperty_default()(_this, "MAX_CORRECTION_FACTOR", 5);
    defineProperty_default()(_this, "FORMAT", 'i2of5');
    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }
    _this.config = opts;
    return possibleConstructorReturn_default()(_this, _this);
  }
  inherits_default()(I2of5Reader, _BarcodeReader);
  return createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;
        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }
        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;
        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }
      return i2of5_reader_superPropGet(I2of5Reader, "_matchPattern", this, 3)([counter, code]);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;
      if (!offset) {
        offset = this._nextSet(this._row);
      }
      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);
            var error = this._matchPattern(counter, pattern);
            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }
            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }
              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }
          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }
      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;
      var offset = this._nextSet(this._row);
      var startInfo = null;
      var narrowBarWidth = 1;
      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);
        if (!startInfo) {
          return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;
        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }
        offset = startInfo.end;
        startInfo = null;
      }
      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();
      var endInfo = this._findPattern(this.STOP_PATTERN);
      this._row.reverse();
      if (endInfo === null) {
        return null;
      }

      // reverse numbers
      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];
      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);
        if (!code) {
          return null;
        }
        codes.push(code);
      }
      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }
      if (bestMatch.error < epsilon) {
        return bestMatch;
      }
      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;
      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }
        codes = this._decodePair(counterPair);
        if (!codes) {
          return null;
        }
        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }
      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();
      var startInfo = this._findStart();
      if (!startInfo) {
        return null;
      }
      decodedCodes.push(startInfo);
      var endInfo = this._findEnd();
      if (!endInfo) {
        return null;
      }
      var counters = this._fillCounters(startInfo.end, endInfo.start, false);
      if (!this._verifyCounterLength(counters)) {
        return null;
      }
      var code = this._decodePayload(counters, result, decodedCodes);
      if (!code) {
        return null;
      }
      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }
      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);
}(barcode_reader);
/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts







function upc_e_reader_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function upc_e_reader_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? upc_e_reader_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : upc_e_reader_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function upc_e_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, upc_e_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function upc_e_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (upc_e_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function upc_e_reader_superPropGet(t, o, e, r) { var p = get_default()(getPrototypeOf_default()(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }

var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  function UPCEReader() {
    var _this;
    classCallCheck_default()(this, UPCEReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = upc_e_reader_callSuper(this, UPCEReader, [].concat(args));
    defineProperty_default()(_this, "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);
    defineProperty_default()(_this, "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);
    defineProperty_default()(_this, "FORMAT", 'upc_e');
    return _this;
  }
  inherits_default()(UPCEReader, _EANReader);
  return createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);
      var codeFrequency = 0x0;
      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);
        if (!outCode) {
          return null;
        }
        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }
        result.push(outCode.code);
        decodedCodes.push(outCode);
      }
      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }
      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];
      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }
      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return upc_e_reader_superPropGet(UPCEReader, "_checksum", this, 3)([this._convertToUPCA(result)]);
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return upc_e_reader_superPropGet(UPCEReader, "_findEnd", this, 3)([offset, true]);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }
      return null;
    }
  }]);
}(ean_reader);
/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts






function upc_reader_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, upc_reader_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function upc_reader_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (upc_reader_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }

var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  function UPCReader() {
    var _this;
    classCallCheck_default()(this, UPCReader);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = upc_reader_callSuper(this, UPCReader, [].concat(args));
    defineProperty_default()(_this, "FORMAT", 'upc_a');
    return _this;
  }
  inherits_default()(UPCReader, _EANReader);
  return createClass_default()(UPCReader, [{
    key: "decode",
    value: function decode(row, start) {
      var result = ean_reader.prototype.decode.call(this);
      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }
      return null;
    }
  }]);
}(ean_reader);
/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */
Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */
  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;
  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }
  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }
  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }
  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;
  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }
    error -= deltaY;
    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }
  return {
    line: line,
    min: min,
    max: max
  };
};

/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */
Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j;

  // 1. find extrema
  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });
  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];
    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }
    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }
  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });
  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  }

  // iterate over extrema and convert to binary based on avg between minmax
  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }
    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }
  return {
    line: line,
    threshold: threshold
  };
};

/**
 * Used for development only
 */
Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d');
    // eslint-disable-next-line no-param-reassign
    canvas.width = line.length;
    // eslint-disable-next-line no-param-reassign
    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }
    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i;

    // eslint-disable-next-line no-param-reassign
    canvas.width = line.length;
    ctx.fillColor = 'black';
    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js


function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

/* eslint-disable import/no-cycle */

/**
 * Barcode Decoder Module
 *
 * This module handles the decoding of barcodes using configured readers.
 *
 * READER ORDER GUARANTEE:
 * Readers are processed in the exact order they are specified in the `readers`
 * config array. The first reader to successfully decode the barcode wins.
 *
 * Example:
 *   readers: ['ean_reader', 'upc_e_reader', 'code_128_reader']
 *
 * Decoding order:
 *   1. ean_reader attempts to decode
 *   2. If ean_reader returns null, upc_e_reader attempts to decode
 *   3. If upc_e_reader returns null, code_128_reader attempts to decode
 *   4. First non-null result is returned
 *
 * EXTERNAL READERS:
 * External readers must be registered via registerReader() before use.
 * Once registered, they follow the same ordering rules as built-in readers.
 * Their position in the `readers` array determines their priority.
 *
 * To prioritize an external reader:
 *   Quagga.registerReader('my_reader', MyReader);
 *   config.decoder.readers = ['my_reader', 'ean_reader']; // my_reader tried first
 */

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  /**
   * Registers an external/custom barcode reader.
   * Once registered, the reader can be used in config.readers array.
   * The reader's position in config.readers determines its decoding priority.
   *
   * @param name - The identifier to use in config.readers (e.g., 'my_custom_reader')
   * @param reader - The reader class (must extend BarcodeReader)
   *
   * @example
   * // Register a custom reader
   * BarcodeDecoder.registerReader('my_reader', MyCustomReader);
   *
   * // Use it with high priority (first in array)
   * config.decoder.readers = ['my_reader', 'ean_reader', 'code_128_reader'];
   */
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();
    function initCanvas() {
      if ( true && typeof document !== 'undefined') {
        var _config$debug;
        var $debug = document.querySelector('#debug.detection');
        _canvas.dom.frequency = document.querySelector('canvas.frequency');
        if (!_canvas.dom.frequency) {
          _canvas.dom.frequency = document.createElement('canvas');
          _canvas.dom.frequency.className = 'frequency';
          if ($debug) {
            $debug.appendChild(_canvas.dom.frequency);
          }
        }
        if ( true && (_config$debug = config.debug) !== null && _config$debug !== void 0 && _config$debug.printReaderInfo) {
          console.warn('* barcode decoder initCanvas getcontext 2d');
        }
        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');
        if (!_canvas.dom.pattern) {
          _canvas.dom.pattern = document.createElement('canvas');
          _canvas.dom.pattern.className = 'patternBuffer';
          if ($debug) {
            $debug.appendChild(_canvas.dom.pattern);
          }
        }
        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');
        if (_canvas.dom.overlay) {
          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
        }
      }
    }

    /**
     * Initializes barcode readers from config.readers array.
     * Readers are instantiated and stored in the order they appear in config,
     * which determines their decoding priority (first in array = highest priority).
     */
    function initReaders() {
      var _config$debug3;
      config.readers.forEach(function (readerConfig) {
        var _config$debug2;
        var reader;
        var configuration = {};
        var supplements = [];
        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }
        if ( true && (_config$debug2 = config.debug) !== null && _config$debug2 !== void 0 && _config$debug2.printReaderInfo) {
          console.log('Before registering reader: ', reader);
        }
        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }
        try {
          var readerObj = new READERS[reader](configuration, supplements);
          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });
      if ( true && (_config$debug3 = config.debug) !== null && _config$debug3 !== void 0 && _config$debug3.printReaderInfo) {
        console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
          return JSON.stringify({
            format: reader.FORMAT,
            config: reader.config
          });
        }).join(', ')));
      }
    }
    function initConfig() {
      if ( true && typeof document !== 'undefined') {
        var i;
        var vis = [{
          node: _canvas.dom.frequency,
          prop: config.debug.showFrequency
        }, {
          node: _canvas.dom.pattern,
          prop: config.debug.showPattern
        }];
        for (i = 0; i < vis.length; i++) {
          if (vis[i].prop === true) {
            vis[i].node.style.display = 'block';
          } else {
            vis[i].node.style.display = 'none';
          }
        }
      }
    }

    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */
    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */
        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      }

      // check if inside image
      extendLine(ext);
      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }
      return line;
    }
    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    /**
     * Attempts to decode a barcode from a scan line.
     * Readers are tried in order (as specified in config.readers).
     * The first reader to return a non-null result wins.
     * @param {Array} line The scan line to decode
     * @returns {Object|null} Decoded result or null if no reader succeeded
     */
    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);
      if ( true && config.debug.showFrequency) {
        if (_canvas.ctx.overlay) {
          image_debug.drawPath(line, {
            x: 'x',
            y: 'y'
          }, _canvas.ctx.overlay, {
            color: 'red',
            lineWidth: 3
          });
        }
        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
      }
      bresenham.toBinaryLine(barcodeLine);
      if ( true && config.debug.showPattern) {
        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
      }

      // Iterate readers in order - first successful decode wins
      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }
      if (result === null) {
        return null;
      }
      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }

    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */
    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);
      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */
        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }
      return result;
    }
    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    /**
     * Decodes from a full image using readers that support image-based decoding.
     * Readers are tried in order (as specified in config.readers).
     * @param {Object} imageWrapper The image to decode
     * @returns {Object|null} Decoded result or null
     */
    function _decodeFromImage2(_x) {
      return _decodeFromImage.apply(this, arguments);
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */
    function _decodeFromImage() {
      _decodeFromImage = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2(imageWrapper) {
        var result, _iterator, _step, reader, _t;
        return regenerator_default.a.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              result = null; // Iterate readers in order - first successful decode wins
              _iterator = _createForOfIteratorHelper(_barcodeReaders);
              _context2.prev = 1;
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context2.next = 5;
                break;
              }
              reader = _step.value;
              if (!reader.decodeImage) {
                _context2.next = 4;
                break;
              }
              _context2.next = 3;
              return reader.decodeImage(imageWrapper);
            case 3:
              result = _context2.sent;
              if (!result) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("continue", 5);
            case 4:
              _context2.next = 2;
              break;
            case 5:
              _context2.next = 7;
              break;
            case 6:
              _context2.prev = 6;
              _t = _context2["catch"](1);
              _iterator.e(_t);
            case 7:
              _context2.prev = 7;
              _iterator.f();
              return _context2.finish(7);
            case 8:
              return _context2.abrupt("return", result);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[1, 6, 7, 8]]);
      }));
      return _decodeFromImage.apply(this, arguments);
    }
    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;
      if (true) {
        if (config.debug.drawBoundingBox && ctx) {
          image_debug.drawPath(box, {
            x: 0,
            y: 1
          }, ctx, {
            color: 'blue',
            lineWidth: 2
          });
        }
      }
      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));
      if (line === null) {
        return null;
      }
      result = tryDecode(line);
      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }
      if (result === null) {
        return null;
      }
      if ( true && result && config.debug.drawScanline && ctx) {
        image_debug.drawPath(line, {
          x: 'x',
          y: 'y'
        }, ctx, {
          color: 'red',
          lineWidth: 3
        });
      }
      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }
    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;
        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;
          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }
        return {
          barcodes: barcodes
        };
      },
      decodeFromImage: function decodeFromImage(imageWrapperIn) {
        return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
          var result;
          return regenerator_default.a.wrap(function (_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 1;
                return _decodeFromImage2(imageWrapperIn);
              case 1:
                result = _context.sent;
                return _context.abrupt("return", result);
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }))();
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }
        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/reader/index.ts
















// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};
  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }
    return events[eventName];
  }
  function clearEvents() {
    events = {};
  }
  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }
  function _subscribe(event, callback, async) {
    var subscription;
    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;
      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }
    getEvent(event).subscribers.push(subscription);
  }
  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers;

      // Publish one-time subscriptions
      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });

      // remove them from the subscriber
      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      });

      // publish the rest
      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);
        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__(59);
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(60);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var wrapNativeSuper = __webpack_require__(61);
var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper);

// CONCATENATED MODULE: ./src/quagga/Exception.ts







function Exception_callSuper(t, o, e) { return o = getPrototypeOf_default()(o), possibleConstructorReturn_default()(t, Exception_isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf_default()(t).constructor) : o.apply(t, e)); }
function Exception_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (Exception_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var Exception_Exception = /*#__PURE__*/function (_Error) {
  function Exception(m, code) {
    var _this;
    classCallCheck_default()(this, Exception);
    _this = Exception_callSuper(this, Exception, [m]);
    defineProperty_default()(_this, "code", void 0);
    _this.code = code;
    Object.setPrototypeOf(_this, Exception.prototype);
    return _this;
  }
  inherits_default()(Exception, _Error);
  return createClass_default()(Exception);
}(/*#__PURE__*/wrapNativeSuper_default()(Error));

// CONCATENATED MODULE: ./src/common/mediaDevices.ts

var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Exception_Exception("enumerateDevices is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Exception_Exception("getUserMedia is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts



var _excluded = ["deviceId"];
function camera_access_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function camera_access_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? camera_access_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : camera_access_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function camera_access_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = camera_access_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function camera_access_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return camera_access_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? camera_access_arrayLikeToArray(r, a) : void 0; } }
function camera_access_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

// TODO: when this file was written years ago, HTMLMediaElement.play() did not return a useful value
// to let us know when the video started playing.  Now, it does.  So, we shouldn't need to run this
// odd waitForVideo() function that polls to see if the video has started.



var streamRef;
function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;
    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (true) {
            console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
          }
          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Exception_Exception('Unable to play video stream. Is webcam working?', -1)); // TODO: add error code
      }
      attempts--;
    }
    checkVideo();
  });
}

/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */
function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}
function _initCamera() {
  _initCamera = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee4(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function (_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 1;
          return getUserMedia(constraints);
        case 1:
          stream = _context4.sent;
          streamRef = stream;
          if (!video) {
            _context4.next = 2;
            break;
          }
          video.setAttribute('autoplay', 'true');
          video.setAttribute('muted', 'true');
          video.setAttribute('playsinline', 'true'); // not listed on MDN...
          // eslint-disable-next-line no-param-reassign
          video.srcObject = stream;
          video.addEventListener('loadedmetadata', function () {
            video.play()["catch"](function (err) {
              console.warn('* Error while trying to play video stream:', err);
            });
          });
          return _context4.abrupt("return", waitForVideo(video));
        case 2:
          return _context4.abrupt("return", Promise.resolve());
        case 3:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _initCamera.apply(this, arguments);
}
function deprecatedConstraints(videoConstraints) {
  var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);
  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }
  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }
  return normalized;
}

// TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.
function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);
  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }
  return Promise.resolve({
    audio: false,
    video: video
  });
}

/**
 * Enumerates video input devices, optionally filtering by constraints.
 * @param videoConstraints Optional constraints to filter devices.
 * When provided, only devices that satisfy the given constraints will be returned.
 * This works by attempting to get a media stream for each device with the constraints
 * and returning only the devices that succeed.
 * @returns Promise resolving to an array of MediaDeviceInfo for video input devices.
 */
function enumerateVideoDevices(_x3) {
  return _enumerateVideoDevices.apply(this, arguments);
}
function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee5(videoConstraints) {
    var devices, videoDevices, constrainedDevices, processedConstraints, _, constraintsWithoutDeviceId, _iterator, _step, device, constraints, stream, _t3, _t4;
    return regenerator_default.a.wrap(function (_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 1;
          return enumerateDevices();
        case 1:
          devices = _context5.sent;
          videoDevices = devices.filter(function (device) {
            return device.kind === 'videoinput';
          }); // If no constraints are provided, return all video devices
          if (videoConstraints) {
            _context5.next = 2;
            break;
          }
          return _context5.abrupt("return", videoDevices);
        case 2:
          // Filter devices based on constraints by trying to get a media stream for each
          constrainedDevices = []; // Process constraints but exclude deviceId since we'll set it ourselves for each device
          processedConstraints = deprecatedConstraints(videoConstraints); // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _ = processedConstraints.deviceId, constraintsWithoutDeviceId = objectWithoutProperties_default()(processedConstraints, _excluded);
          _iterator = camera_access_createForOfIteratorHelper(videoDevices);
          _context5.prev = 3;
          _iterator.s();
        case 4:
          if ((_step = _iterator.n()).done) {
            _context5.next = 9;
            break;
          }
          device = _step.value;
          _context5.prev = 5;
          constraints = {
            audio: false,
            video: camera_access_objectSpread(camera_access_objectSpread({}, constraintsWithoutDeviceId), {}, {
              deviceId: {
                exact: device.deviceId
              }
            })
          };
          _context5.next = 6;
          return getUserMedia(constraints);
        case 6:
          stream = _context5.sent;
          // Stop all tracks immediately after testing
          stream.getTracks().forEach(function (track) {
            return track.stop();
          });
          constrainedDevices.push(device);
          _context5.next = 8;
          break;
        case 7:
          _context5.prev = 7;
          _t3 = _context5["catch"](5);
        case 8:
          _context5.next = 4;
          break;
        case 9:
          _context5.next = 11;
          break;
        case 10:
          _context5.prev = 10;
          _t4 = _context5["catch"](3);
          _iterator.e(_t4);
        case 11:
          _context5.prev = 11;
          _iterator.f();
          return _context5.finish(11);
        case 12:
          return _context5.abrupt("return", constrainedDevices);
        case 13:
        case "end":
          return _context5.stop();
      }
    }, _callee5, null, [[3, 10, 11, 12], [5, 7]]);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}
function getActiveTrack() {
  if (!streamRef) {
    return null;
  }
  var tracks = streamRef.getVideoTracks();
  return tracks && tracks !== null && tracks !== void 0 && tracks.length ? tracks[0] : null;
}

/**
 * Used for accessing information about the active stream track and available video devices.
 */
var QuaggaJSCameraAccess = {
  requestedVideoElement: null,
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            QuaggaJSCameraAccess.requestedVideoElement = video;
            _context.next = 1;
            return pickConstraints(videoConstraints);
          case 1:
            newConstraints = _context.sent;
            return _context.abrupt("return", initCamera(video, newConstraints));
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  },
  release: function release() {
    var tracks = streamRef && streamRef.getVideoTracks();
    if (QuaggaJSCameraAccess.requestedVideoElement !== null) {
      QuaggaJSCameraAccess.requestedVideoElement.pause();
    }
    return new Promise(function (resolve) {
      setTimeout(function () {
        if (tracks && tracks.length) {
          tracks.forEach(function (track) {
            return track.stop();
          });
        }
        streamRef = null;
        QuaggaJSCameraAccess.requestedVideoElement = null;
        resolve();
      }, 0);
    });
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack,
  disableTorch: function disableTorch() {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2() {
      var track, _t;
      return regenerator_default.a.wrap(function (_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
            // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?
            if (!track) {
              _context2.next = 4;
              break;
            }
            _context2.prev = 1;
            _context2.next = 2;
            return track.applyConstraints({
              advanced: [{
                torch: false
              }]
            });
          case 2:
            _context2.next = 4;
            break;
          case 3:
            _context2.prev = 3;
            _t = _context2["catch"](1);
            if (_t instanceof OverconstrainedError) {
              console.warn('quagga2/CameraAccess: Torch not supported on this device');
            }
            throw _t;
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 3]]);
    }))();
  },
  enableTorch: function enableTorch() {
    return asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee3() {
      var track, _t2;
      return regenerator_default.a.wrap(function (_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
            // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?
            if (!track) {
              _context3.next = 4;
              break;
            }
            _context3.prev = 1;
            _context3.next = 2;
            return track.applyConstraints({
              advanced: [{
                torch: true
              }]
            });
          case 2:
            _context3.next = 4;
            break;
          case 3:
            _context3.prev = 3;
            _t2 = _context3["catch"](1);
            if (_t2 instanceof OverconstrainedError) {
              console.warn('quagga2/CameraAccess: Torch not supported on this device');
            }
            throw _t2;
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 3]]);
    }))();
  }
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts

function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}
function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}
/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d', {
      willReadFrequently: !!config.willReadFrequently
    });
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;
    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }
    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|
        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;
          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug.drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }
          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"
    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
      // borderColor: 'rgba(0, 255, 0, 0.5)', // uncomment to draw area border
      // borderWidth: 2, // uncomment to draw area border
      // backgroundColor: 'rgba(0, 255, 0, 0.1)', // uncomment to tint the scan area
    },
    singleChannel: false,
    // true: only the red color-channel is read
    debug: {
      showImageDetails: false // logs frame grabber info, canvas size adjustments
    }
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false,
      printReaderInfo: false // logs reader registration and initialization
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      showPatchSize: false,
      // logs calculated patch size
      showImageDetails: false,
      // logs image wrapper size, canvas details
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large
  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"
    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read
  },
  locate: true,
  canvas: {
    createOverlay: true // set to false to skip creating overlay canvas (drawingBuffer)
  },
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large
  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts



var ExportConfig = function () {
  var QuaggaConfig;
  if (true) {
    QuaggaConfig = config_dev;
  } else {}
  return QuaggaConfig;
}();
/* harmony default export */ var config_config = (ExportConfig);
// CONCATENATED MODULE: ./src/common/area_overlay.ts
/**
 * Calculates the area rectangle from the area configuration percentages.
 * This converts percentage-based area boundaries to pixel coordinates.
 * 
 * @param canvasSize - The size of the canvas
 * @param area - The area configuration with top, right, bottom, left as percentage strings
 * @returns The calculated rectangle with x, y, width, height
 */
function calculateAreaRect(canvasSize, area) {
  var canvasWidth = canvasSize.x;
  var canvasHeight = canvasSize.y;
  var top = parseInt(area.top || '0', 10) / 100;
  var right = parseInt(area.right || '0', 10) / 100;
  var bottom = parseInt(area.bottom || '0', 10) / 100;
  var left = parseInt(area.left || '0', 10) / 100;
  var x = canvasWidth * left;
  var y = canvasHeight * top;
  var width = canvasWidth - canvasWidth * right - x;
  var height = canvasHeight - canvasHeight * bottom - y;
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}

/**
 * Checks if the area is defined and different from the default (full canvas).
 * 
 * @param area - The area configuration
 * @returns true if area is defined and not the default full canvas
 */
function isAreaDefined(area) {
  if (!area) {
    return false;
  }
  // Check if any value is different from 0%
  return area.top !== undefined && area.top !== '0%' || area.right !== undefined && area.right !== '0%' || area.bottom !== undefined && area.bottom !== '0%' || area.left !== undefined && area.left !== '0%';
}

/**
 * Checks if area visualization should be drawn based on borderColor or borderWidth being defined.
 * 
 * @param area - The area configuration
 * @returns true if visualization should be drawn (borderColor is defined or borderWidth > 0)
 */
function shouldDrawAreaOverlay(area) {
  if (!area) {
    return false;
  }
  return area.borderColor !== undefined && area.borderColor !== '' || area.borderWidth !== undefined && area.borderWidth > 0 || area.backgroundColor !== undefined && area.backgroundColor !== '';
}

/**
 * Draws the scan area boundary on the overlay canvas.
 * This visually highlights the region where Quagga is looking for barcodes.
 * 
 * @param ctx - The canvas 2D rendering context (overlay canvas)
 * @param canvasSize - The size of the canvas
 * @param area - The area configuration with top, right, bottom, left as percentage strings
 * @param borderColor - The color of the area border (default: 'rgba(0, 255, 0, 0.5)')
 * @param borderWidth - The width of the border line (default: 2)
 * @param backgroundColor - The background color to fill the area (optional)
 */
function drawAreaOverlay(ctx, canvasSize, area) {
  var borderColor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'rgba(0, 255, 0, 0.5)';
  var borderWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;
  var backgroundColor = arguments.length > 5 ? arguments[5] : undefined;
  var rect = calculateAreaRect(canvasSize, area);

  // Draw background fill if specified
  if (backgroundColor) {
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
  }

  // Draw border if borderWidth > 0
  if (borderWidth > 0) {
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderWidth;
    ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
  }
}

/**
 * Draws the area overlay if configured to do so.
 * This is the main function to call from the Quagga processing loop.
 * Drawing is triggered when area.borderColor or area.borderWidth is defined.
 * 
 * @param config - The Quagga configuration object
 * @param ctx - The canvas 2D rendering context (overlay canvas)
 * @param canvasSize - The size of the canvas
 */
function drawAreaIfConfigured(config, ctx, canvasSize) {
  var _area$borderColor, _area$borderWidth;
  if (!config || !ctx) {
    return;
  }
  var inputStream = config.inputStream;
  if (!inputStream) {
    return;
  }
  var area = inputStream.area;

  // Only draw if area visualization is configured and area is actually defined
  if (!area || !shouldDrawAreaOverlay(area) || !isAreaDefined(area)) {
    return;
  }
  var shouldDrawBorder = area.borderColor !== undefined || area.borderWidth !== undefined;
  var borderColor = (_area$borderColor = area.borderColor) !== null && _area$borderColor !== void 0 ? _area$borderColor : 'rgba(0, 255, 0, 0.5)';
  var borderWidth = shouldDrawBorder ? (_area$borderWidth = area.borderWidth) !== null && _area$borderWidth !== void 0 ? _area$borderWidth : 2 : 0;
  var backgroundColor = area.backgroundColor;
  drawAreaOverlay(ctx, canvasSize, area, borderColor, borderWidth, backgroundColor);
}
// CONCATENATED MODULE: ./src/input/frame_grabber_browser.js
// NOTE FOR ANYONE IN HERE IN THE FUTURE:
// webpack.config.js replaces the frame_grabber module with THIS module when it is building for a Browser environment.


var TO_RADIANS = Math.PI / 180;
function adjustCanvasSize(canvas, targetSize, debug) {
  if (canvas.width !== targetSize.x) {
    if ( true && debug !== null && debug !== void 0 && debug.showImageDetails) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }
    canvas.width = targetSize.x;
  }
  if (canvas.height !== targetSize.y) {
    if ( true && debug !== null && debug !== void 0 && debug.showImageDetails) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }
    canvas.height = targetSize.y;
  }
}
var FrameGrabber = {};
FrameGrabber.create = function (inputStream, canvas) {
  var _streamConfig$debug, _streamConfig$debug2;
  // console.warn('*** FrameGrabberBrowser create');
  var _that = {};
  var _streamConfig = inputStream.getConfig();
  var _videoSize = imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());
  var _canvasSize = inputStream.getCanvasSize();
  var _size = imageRef(inputStream.getWidth(), inputStream.getHeight());
  var topRight = inputStream.getTopRight();
  var _sx = topRight.x;
  var _sy = topRight.y;
  var _canvas;
  var _ctx = null;
  var _data = null;
  var willReadFrequently = _streamConfig.willReadFrequently;
  _canvas = canvas || document.createElement('canvas');
  _canvas.width = _canvasSize.x;
  _canvas.height = _canvasSize.y;
  if ( true && (_streamConfig$debug = _streamConfig.debug) !== null && _streamConfig$debug !== void 0 && _streamConfig$debug.showImageDetails) {
    console.warn('*** frame_grabber_browser: willReadFrequently=', willReadFrequently, 'canvas=', _canvas);
  }
  _ctx = _canvas.getContext('2d', {
    willReadFrequently: !!willReadFrequently
  }); // double not because we have an optional bool that needs to pass as a bool
  _data = new Uint8Array(_size.x * _size.y);
  if ( true && (_streamConfig$debug2 = _streamConfig.debug) !== null && _streamConfig$debug2 !== void 0 && _streamConfig$debug2.showImageDetails) {
    console.log('FrameGrabber', JSON.stringify({
      size: _size,
      topRight: topRight,
      videoSize: _videoSize,
      canvasSize: _canvasSize
    }));
  }

  /**
   * Uses the given array as frame-buffer
   */
  _that.attachData = function (data) {
    _data = data;
  };

  /**
   * Returns the used frame-buffer
   */
  _that.getData = function () {
    return _data;
  };

  // Bilinear interpolation for grayscale data (to match Node's behavior)
  function bilinearInterpolate(grayData, width, height, x, y) {
    var x0 = Math.floor(x);
    var y0 = Math.floor(y);
    var x1 = Math.min(x0 + 1, width - 1);
    var y1 = Math.min(y0 + 1, height - 1);
    var fx = x - x0;
    var fy = y - y0;
    var v00 = grayData[y0 * width + x0];
    var v10 = grayData[y0 * width + x1];
    var v01 = grayData[y1 * width + x0];
    var v11 = grayData[y1 * width + x1];
    var v0 = v00 * (1 - fx) + v10 * fx;
    var v1 = v01 * (1 - fx) + v11 * fx;
    return v0 * (1 - fy) + v1 * fy;
  }

  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   * 
   * For improved accuracy (matching Node's processing), non-half-sampled images
   * use bilinear interpolation on grayscale data instead of scaling RGB then converting.
   * 
   * IMPORTANT: The image is ALWAYS drawn to the visible canvas for overlays and display.
   */
  _that.grab = function () {
    var doHalfSample = _streamConfig.halfSample;
    var frame = inputStream.getFrame();
    var drawable = frame;
    var drawAngle = 0;
    if (drawable) {
      adjustCanvasSize(_canvas, _canvasSize, _streamConfig.debug);
      if (_streamConfig.type === 'ImageStream') {
        drawable = frame.img;
        if (frame.tags && frame.tags.orientation) {
          switch (frame.tags.orientation) {
            case 6:
              drawAngle = 90 * TO_RADIANS;
              break;
            case 8:
              drawAngle = -90 * TO_RADIANS;
              break;
          }
        }
      }

      // ALWAYS draw to visible canvas (for overlays, display, and toDataURL)
      if (drawAngle !== 0) {
        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);
        _ctx.rotate(drawAngle);
        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);
        _ctx.rotate(-drawAngle);
        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
      } else {
        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
      }
      if (doHalfSample) {
        // Half-sample path: use existing optimized approach
        var ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;
        grayAndHalfSampleFromCanvasData(ctxData, _size, _data);
      } else {
        // Non-half-sample: use improved bilinear interpolation for better accuracy
        // Process at original size, then scale grayscale data
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = _videoSize.x;
        tempCanvas.height = _videoSize.y;
        var tempCtx = tempCanvas.getContext('2d');
        if (drawAngle !== 0) {
          tempCtx.translate(_videoSize.x / 2, _videoSize.y / 2);
          tempCtx.rotate(drawAngle);
          tempCtx.drawImage(drawable, -_videoSize.y / 2, -_videoSize.x / 2, _videoSize.y, _videoSize.x);
        } else {
          tempCtx.drawImage(drawable, 0, 0, _videoSize.x, _videoSize.y);
        }

        // Convert to grayscale at original size
        var originalImageData = tempCtx.getImageData(0, 0, _videoSize.x, _videoSize.y).data;
        var grayData = new Uint8Array(_videoSize.x * _videoSize.y);
        computeGray(originalImageData, grayData, _streamConfig);

        // Scale grayscale data using bilinear interpolation
        var scaledGrayData = new Uint8Array(_canvasSize.x * _canvasSize.y);
        var stepSizeX = _videoSize.x / _canvasSize.x;
        var stepSizeY = _videoSize.y / _canvasSize.y;
        for (var y = 0; y < _canvasSize.y; y++) {
          for (var x = 0; x < _canvasSize.x; x++) {
            var srcX = x * stepSizeX;
            var srcY = y * stepSizeY;
            scaledGrayData[y * _canvasSize.x + x] = bilinearInterpolate(grayData, _videoSize.x, _videoSize.y, srcX, srcY) | 0;
          }
        }

        // Crop to target region
        for (var _y = 0; _y < _size.y; _y++) {
          for (var _x = 0; _x < _size.x; _x++) {
            var srcIdx = (_y + _sy) * _canvasSize.x + (_x + _sx);
            _data[_y * _size.x + _x] = scaledGrayData[srcIdx];
          }
        }
      }
      return true;
    }
    return false;
  };
  _that.getSize = function () {
    return _size;
  };
  return _that;
};
/* harmony default export */ var frame_grabber_browser = (FrameGrabber);
// CONCATENATED MODULE: ./src/input/exif_helper.js
// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
// need to port any part of this that doesn't work in Node to node?

// Tags scraped from https://github.com/exif-js/exif-js
var ExifTags = {
  0x0112: 'orientation'
};
var AvailableTags = Object.keys(ExifTags).map(function (key) {
  return ExifTags[key];
});
function findTagsInObjectURL(src) {
  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  if (/^blob:/i.test(src)) {
    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
      return findTagsInBuffer(buffer, tags);
    });
  }
  return Promise.resolve(null);
}
function base64ToArrayBuffer(dataUrl) {
  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);
  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }
  return buffer;
}
function readToBuffer(blob) {
  return new Promise(function (resolve) {
    var fileReader = new FileReader();
    fileReader.onload = function (e) {
      return resolve(e.target.result);
    };
    fileReader.readAsArrayBuffer(blob);
  });
}
function objectURLToBlob(url) {
  return new Promise(function (resolve, reject) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';
    http.onreadystatechange = function () {
      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
        resolve(this.response);
      }
    };
    http.onerror = reject;
    http.send();
  });
}
function findTagsInBuffer(file) {
  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  var dataView = new DataView(file);
  var length = file.byteLength;
  var exifTags = selectedTags.reduce(function (result, selectedTag) {
    var exifTag = Object.keys(ExifTags).filter(function (tag) {
      return ExifTags[tag] === selectedTag;
    })[0];
    if (exifTag) {
      result[exifTag] = selectedTag;
    }
    return result;
  }, {});
  var offset = 2;
  var marker;
  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false;
  }
  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false;
    }
    marker = dataView.getUint8(offset + 1);
    if (marker === 0xE1) {
      return readEXIFData(dataView, offset + 4, exifTags);
    }
    offset += 2 + dataView.getUint16(offset + 2);
  }
  return false;
}
function readEXIFData(file, start, exifTags) {
  if (getStringFromBuffer(file, start, 4) !== 'Exif') {
    return false;
  }
  var tiffOffset = start + 6;
  var bigEnd;
  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }
  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }
  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);
  if (firstIFDOffset < 0x00000008) {
    return false;
  }
  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
  return tags;
}
function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};
  for (var i = 0; i < entries; i++) {
    var entryOffset = dirStart + i * 12 + 2;
    var tag = strings[file.getUint16(entryOffset, !bigEnd)];
    if (tag) {
      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
    }
  }
  return tags;
}
function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);
  switch (type) {
    case 3:
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      }
  }
  return null;
}
function getStringFromBuffer(buffer, start, length) {
  var outstr = '';
  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }
  return outstr;
}
// CONCATENATED MODULE: ./src/input/image_loader.js


// Exported helper for filename generation
function generateImageFilename(directory, num) {
  return "".concat(directory, "image-").concat(num.toString().padStart(3, '0'), ".jpg");
}
var ImageLoader = {};
ImageLoader.load = function (directory, callback, offset, size, sequence, config) {
  var htmlImagesSrcArray = new Array(size);
  var htmlImagesArray = new Array(htmlImagesSrcArray.length);
  var i;
  var img;
  var num;
  if (sequence === false) {
    htmlImagesSrcArray[0] = directory;
  } else {
    for (i = 0; i < htmlImagesSrcArray.length; i++) {
      num = offset + i;
      htmlImagesSrcArray[i] = generateImageFilename(directory, num);
    }
  }
  htmlImagesArray.notLoaded = [];
  htmlImagesArray.addImage = function (image) {
    htmlImagesArray.notLoaded.push(image);
  };
  htmlImagesArray.loaded = function (loadedImg) {
    var notloadedImgs = htmlImagesArray.notLoaded;
    for (var x = 0; x < notloadedImgs.length; x++) {
      if (notloadedImgs[x] === loadedImg) {
        notloadedImgs.splice(x, 1);
        for (var y = 0; y < htmlImagesSrcArray.length; y++) {
          // Use encodeURI for matching filenames with spaces and special characters
          var imgName = encodeURI(htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/')));
          if (loadedImg.src.lastIndexOf(imgName) !== -1) {
            htmlImagesArray[y] = {
              img: loadedImg
            };
            break;
          }
        }
        break;
      }
    }
    if (notloadedImgs.length === 0) {
      var _config$debug;
      if ( true && config !== null && config !== void 0 && (_config$debug = config.debug) !== null && _config$debug !== void 0 && _config$debug.showImageDetails) {
        console.log("Images loaded: ".concat(htmlImagesArray.length, " image").concat(htmlImagesArray.length !== 1 ? 's' : '', " from ").concat(sequence === false ? directory : directory + ' (sequence)'));
      }
      if (sequence === false) {
        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
          htmlImagesArray[0].tags = tags;
          callback(htmlImagesArray);
        })["catch"](function (e) {
          console.log(e);
          callback(htmlImagesArray);
        });
      } else {
        callback(htmlImagesArray);
      }
    }
  };
  for (i = 0; i < htmlImagesSrcArray.length; i++) {
    img = new Image();
    htmlImagesArray.addImage(img);
    addOnloadHandler(img, htmlImagesArray);
    img.src = htmlImagesSrcArray[i];
  }
};
function addOnloadHandler(img, htmlImagesArray) {
  img.onload = function () {
    htmlImagesArray.loaded(this);
  };
  img.onerror = function () {
    htmlImagesArray.loaded(this);
  };
}
/* harmony default export */ var image_loader = (ImageLoader);
// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
/* eslint-disable @typescript-eslint/no-explicit-any */


var inputStreamFactory = {
  createVideoStream: function createVideoStream(video) {
    console.warn('**** InputStreamBrowser createVideoStream');
    var _config = null;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _calculatedWidth;
    var _calculatedHeight;
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    function initSize() {
      var _config2, _config3;
      var width = video.videoWidth;
      var height = video.videoHeight;

      // eslint-disable-next-line no-nested-ternary
      _calculatedWidth = (_config2 = _config) !== null && _config2 !== void 0 && _config2.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
      // eslint-disable-next-line no-nested-ternary
      _calculatedHeight = (_config3 = _config) !== null && _config3 !== void 0 && _config3.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
      _canvasSize.x = _calculatedWidth;
      _canvasSize.y = _calculatedHeight;
    }
    var inputStream = {
      getRealWidth: function getRealWidth() {
        return video.videoWidth;
      },
      getRealHeight: function getRealHeight() {
        return video.videoHeight;
      },
      getWidth: function getWidth() {
        return _calculatedWidth;
      },
      getHeight: function getHeight() {
        return _calculatedHeight;
      },
      setWidth: function setWidth(width) {
        _calculatedWidth = width;
      },
      setHeight: function setHeight(height) {
        _calculatedHeight = height;
      },
      setInputStream: function setInputStream(config) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = config;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
      },
      ended: function ended() {
        return video.ended;
      },
      getConfig: function getConfig() {
        return _config;
      },
      setAttribute: function setAttribute(name, value) {
        if (video) {
          video.setAttribute(name, value);
        }
      },
      pause: function pause() {
        video.pause();
      },
      play: function play() {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        video.play();
      },
      setCurrentTime: function setCurrentTime(time) {
        var _config4;
        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
          this.setAttribute('currentTime', time.toString());
        }
      },
      addEventListener: function addEventListener(event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }
          _eventHandlers[event].push(f);
        } else {
          video.addEventListener(event, f, bool);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        _eventNames.forEach(function (eventName) {
          var handlers = _eventHandlers[eventName];
          if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
              video.removeEventListener(eventName, handler);
            });
          }
        });
      },
      trigger: function trigger(eventName, args) {
        var j;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var handlers = _eventHandlers[eventName];
        if (eventName === 'canrecord') {
          initSize();
        }
        if (handlers && handlers.length > 0) {
          for (j = 0; j < handlers.length; j++) {
            handlers[j].apply(inputStream, args);
          }
        }
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        return video;
      }
    };
    return inputStream;
  },
  createLiveStream: function createLiveStream(video) {
    console.warn('**** InputStreamBrowser createLiveStream');
    if (video) {
      video.setAttribute('autoplay', 'true');
    }
    var that = inputStreamFactory.createVideoStream(video);
    that.ended = function ended() {
      return false;
    };
    return that;
  },
  createImageStream: function createImageStream() {
    // console.warn('**** InputStreamBrowser createImageStream');
    var _config = null;
    var width = 0;
    var height = 0;
    var frameIdx = 0;
    var paused = true;
    var loaded = false;
    var imgArray = null;
    var size = 0;
    var offset = 1;
    var baseUrl = null;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    function loadImages() {
      var _config7;
      loaded = false;
      image_loader.load(baseUrl, function (imgs) {
        var _config5, _config6;
        imgArray = imgs;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (imgs[0].tags && imgs[0].tags.orientation) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          switch (imgs[0].tags.orientation) {
            case 6:
            case 8:
              width = imgs[0].img.height;
              height = imgs[0].img.width;
              break;
            default:
              width = imgs[0].img.width;
              height = imgs[0].img.height;
          }
        } else {
          width = imgs[0].img.width;
          height = imgs[0].img.height;
        }
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = (_config5 = _config) !== null && _config5 !== void 0 && _config5.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
        // eslint-disable-next-line no-nested-ternary
        calculatedHeight = (_config6 = _config) !== null && _config6 !== void 0 && _config6.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        loaded = true;
        frameIdx = 0;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence, _config);
    }
    function publishEvent(eventName, args) {
      var j;
      var handlers = _eventHandlers[eventName];
      if (handlers && handlers.length > 0) {
        for (j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
        }
      }
    }

    // TODO: any code shared with the first InputStream above should be shared not copied
    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
    // eslint-disable-next-line no-var,vars-on-top
    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(newWidth) {
        calculatedWidth = newWidth;
      },
      setHeight: function setHeight(newHeight) {
        calculatedHeight = newHeight;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (stream.sequence === false) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          size = 1;
        } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          size = stream.length;
        }
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }
          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        var frame;
        if (!loaded) {
          return null;
        }
        if (!paused) {
          var _imgArray;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];
          if (frameIdx < size - 1) {
            frameIdx++;
          } else {
            setTimeout(function () {
              _ended = true;
              publishEvent('ended', []);
            }, 0);
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
// CONCATENATED MODULE: ./src/locator/tracer.js
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var tracer_Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;
    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;
      for (i = 0; i < searchDirections.length; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;
        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }
        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }
        current.dir = (current.dir + 1) % 8;
      }
      return false;
    }
    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }
    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };
      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;
        var totalPixelCount = imageWrapper.size.x * imageWrapper.size.y;
        var pixelCounter = 0;
        do {
          current.dir = (current.dir + 6) % 8;
          _trace(current, color, label, edgelabel);
          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }
          ldir = current.dir;
        } while ((current.cx !== sx || current.cy !== sy) && ++pixelCounter < totalPixelCount);
        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }
      return Fv;
    }
    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ var locator_tracer = (tracer_Tracer);
// CONCATENATED MODULE: ./src/locator/rasterizer.js


/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = locator_tracer.create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;
        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }
        colorMap[0] = imageData[0];
        cc = null;
        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];
          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;
            if (labelData[pos] === 0) {
              color = imageData[pos];
              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);
                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;
                    if (cc !== null) {
                      cc.prevpeer = p;
                    }
                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);
                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;
                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }
                    p.index = depthlabel;
                    sc = cc;
                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }
                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;
                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }
                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;
              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }
        sc = cc;
        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }
        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;
          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }
          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;
              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }
            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;
              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;
              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }
            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);
            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ var locator_rasterizer = (Rasterizer);
// CONCATENATED MODULE: ./src/locator/skeletonizer.js
/* eslint-disable no-param-reassign */
/* eslint-disable no-bitwise */
/* eslint-disable eqeqeq */
/* @preserve ASM BEGIN */
/**
 * Morphological skeletonization using iterative thinning algorithm.
 * Reduces binary images to single-pixel-wide skeletons while preserving topology.
 *
 * Memory layout in shared ArrayBuffer (4 regions of size):
 * - Region 0: Working image (subImagePtr = 0)
 * - Region 1: Eroded result (erodedImagePtr = size)
 * - Region 2: Temp/scratch space (tempImagePtr = 2*size)
 * - Region 3: Final skeleton output (skelImagePtr = 3*size)
 */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  /**
   * Morphological erosion with 5-pixel cross structuring element.
   * A pixel survives only if all 5 pixels in the cross pattern are set:
   * top-left, top-right, center, bottom-left, bottom-right.
   */
  function erode(inImagePtr, outImagePtr) {
    inImagePtr = inImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;
    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;
      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
        // Pixel survives erosion only if all 5 cross neighbors are set
        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  // Pixel-wise subtraction: out = a - b (captures the "peeled" layer)
  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr = aImagePtr | 0;
    bImagePtr = bImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  // Pixel-wise OR: out = a | b (accumulates skeleton layers)
  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr = aImagePtr | 0;
    bImagePtr = bImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  // Counts non-zero pixels to detect when erosion is complete
  function countNonZero(imagePtr) {
    imagePtr = imagePtr | 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }
    return sum | 0;
  }

  // Fills image region with a constant value
  function init(imagePtr, value) {
    imagePtr = imagePtr | 0;
    value = value | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  // Morphological dilation with 5-pixel cross - pixel is set if any neighbor is set
  function dilate(inImagePtr, outImagePtr) {
    inImagePtr = inImagePtr | 0;
    outImagePtr = outImagePtr | 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;
    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;
      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  // Copies image data from src to dst region
  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr = srcImagePtr | 0;
    dstImagePtr = dstImagePtr | 0;
    var length = 0;
    length = imul(size, size) | 0;
    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  /**
   * Zeros out the border pixels of the image.
   * First loop: handles top, left, and right edges simultaneously
   * Second loop: handles bottom edge
   */
  function zeroBorder(imagePtr) {
    imagePtr = imagePtr | 0;
    var x = 0;
    var y = 0;
    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  /**
   * Main skeletonization algorithm using iterative thinning:
   * 1. Erode the working image
   * 2. Dilate the eroded version
   * 3. Subtract dilated from original (extracts "peeled" layer)
   * 4. OR the peeled layer into skeleton accumulator
   * 5. Copy eroded image back to working image
   * 6. Repeat until working image is empty
   *
   * @returns {void} No return value - operates directly on shared buffer.
   *   Input image is read from buffer offset 0 (subImagePtr).
   *   Output skeleton is written to buffer offset 3*size (skelImagePtr).
   */
  function skeletonize() {
    var subImagePtr = 0; // Region 0: Working image (input, offset = 0)
    var erodedImagePtr = 0; // Region 1: Eroded result (offset = size)
    var tempImagePtr = 0; // Region 2: Scratch space (offset = 2*size)
    var skelImagePtr = 0; // Region 3: Final skeleton (output, offset = 3*size)
    var sum = 0;
    var done = 0;

    // Calculate byte offsets for each region in the shared buffer
    erodedImagePtr = imul(size, size) | 0; // Region 1: size bytes in
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0; // Region 2: 2*size bytes in
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // Region 3: 3*size bytes in

    // Initialize skeleton accumulator to zero
    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);
    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }
  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */

/* harmony default export */ var skeletonizer = (Skeletonizer);
/* eslint-enable eqeqeq */
// CONCATENATED MODULE: ./src/locator/barcode_locator.js








var barcode_locator_config;
var _currentImageWrapper;
var _skelImageWrapper;
var _subImageWrapper;
var _labelImageWrapper;
var _patchGrid;
var _patchLabelGrid;
var _imageToPatchGrid;
var _binaryImageWrapper;
var _patchSize;
var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};
var _inputImageWrapper;
var _skeletonizer;
function barcode_locator_initBuffers() {
  if (barcode_locator_config.halfSample) {
    _currentImageWrapper = new image_wrapper({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }
  _patchSize = calculatePatchSize(barcode_locator_config.patchSize, _currentImageWrapper.size);

  // eslint-disable-next-line no-bitwise
  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0;
  // eslint-disable-next-line no-bitwise
  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new image_wrapper(_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new image_wrapper(_patchSize, undefined, Array, true);

  // Calculate required buffer size (4 regions for asm.js skeletonizer)
  var skeletonImageDataSize = _patchSize.x * _patchSize.y * 4;
  // Round up to next power of 2 for asm.js heap requirement
  // Use minimum 64KB for optimal asm.js performance (avoids V8 warnings)
  var bufferSize = Math.max(65536, Math.pow(2, Math.ceil(Math.log2(skeletonImageDataSize))));
  var skeletonImageData = new ArrayBuffer(bufferSize);
  _subImageWrapper = new image_wrapper(_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new image_wrapper(_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = skeletonizer({
    Math: Math,
    Uint8Array: Uint8Array
  }, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new image_wrapper({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new image_wrapper(_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new image_wrapper(_imageToPatchGrid.size, undefined, Int32Array, true);
}
function barcode_locator_initCanvas() {
  var _config$debug;
  if (barcode_locator_config.useWorker || typeof document === 'undefined') {
    return;
  }
  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';
  if ( true && barcode_locator_config.debug.showCanvas === true) {
    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
  }
  var willReadFrequently = !!barcode_locator_config.willReadFrequently;
  if ( true && (_config$debug = barcode_locator_config.debug) !== null && _config$debug !== void 0 && _config$debug.showCanvas) {
    console.warn('* initCanvas willReadFrequently', willReadFrequently, barcode_locator_config);
  }
  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d', {
    willReadFrequently: willReadFrequently
  });
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}

/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */
function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale;

  // draw all patches which are to be taken into consideration
  overAvg = 0;
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;
    if ( true && barcode_locator_config.debug.showPatches) {
      image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: 'red'
      });
    }
  }
  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;
  if (overAvg < 0) {
    overAvg += 180;
  }
  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = mat2_namespaceObject.copy(mat2_namespaceObject.create(), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]);

  // iterate over patches and rotate by angle
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    for (j = 0; j < 4; j++) {
      vec2_namespaceObject.transformMat2(patch.box[j], patch.box[j], transMat);
    }
    if ( true && barcode_locator_config.debug.boxFromPatches.showTransformed) {
      image_debug.drawPath(patch.box, {
        x: 0,
        y: 1
      }, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }

  // find bounding box
  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }
      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }
      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }
      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }
  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];
  if ( true && barcode_locator_config.debug.boxFromPatches.showTransformedBox) {
    image_debug.drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }
  scale = barcode_locator_config.halfSample ? 2 : 1;
  // reverse rotation;
  transMat = mat2_namespaceObject.invert(transMat, transMat);
  for (j = 0; j < 4; j++) {
    vec2_namespaceObject.transformMat2(box[j], box[j], transMat);
  }
  if ( true && barcode_locator_config.debug.boxFromPatches.showBB) {
    image_debug.drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }
  for (j = 0; j < 4; j++) {
    vec2_namespaceObject.scale(box[j], box[j], scale);
  }
  return box;
}

/**
 * Creates a binary image of the current image
 */
function binarizeImage() {
  otsuThreshold(_currentImageWrapper, _binaryImageWrapper);
  _binaryImageWrapper.zeroBorder();
  if ( true && barcode_locator_config.debug.showCanvas) {
    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
  }
}

/**
 * Iterate over the entire image
 * extract patches
 */
function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;
  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j;

      // seperate parts
      skeletonize(x, y);

      // Rasterize, find individual bars
      _skelImageWrapper.zeroBorder();
      array_helper.init(_labelImageWrapper.data, 0);
      rasterizer = locator_rasterizer.create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);
      if ( true && barcode_locator_config.debug.showLabels) {
        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
          x: x,
          y: y
        });
      }

      // calculate moments from the skeletonized patch
      moments = _labelImageWrapper.moments(rasterResult.count);

      // extract eligible patches
      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }
  if ( true && barcode_locator_config.debug.showFoundPatches) {
    for (i = 0; i < patchesFound.length; i++) {
      patch = patchesFound[i];
      image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }
  return patchesFound;
}

/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */
function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];
  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }
  sum = _patchLabelGrid.data.length;
  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }
  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  });

  // extract top areas with at least 6 patches present
  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}

/**
 *
 */
function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];
  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;
    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }
    box = boxFromPatches(patches);
    if (box) {
      boxes.push(box);

      // draw patch-labels if requested
      if ( true && barcode_locator_config.debug.showRemainingPatchLabels) {
        for (j = 0; j < patches.length; j++) {
          patch = patches[j];
          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
          hsv2rgb(hsv, rgb);
          image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
            color: "rgb(".concat(rgb.join(','), ")"),
            lineWidth: 2
          });
        }
      }
    }
  }
  return boxes;
}

/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */
function similarMoments(moments) {
  var clusters = cv_utils_cluster(moments, 0.90);
  var topCluster = topGeneric(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];
  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();
    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }
  return result;
}
function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, imageRef(x, y));
  _skeletonizer.skeletonize();

  // Show skeleton if requested
  if ( true && barcode_locator_config.debug.showSkeleton) {
    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, imageRef(x, y));
  }
}

/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */
function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);
  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    }

    // if at least 2 moments are found which have at least minComponentWeights covered
    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0;
      // determine the similarity of the moments
      for (k = 0; k < matchingMoments.length; k++) {
        var _matchingMoments$k$ra, _matchingMoments$k;
        avg += (_matchingMoments$k$ra = (_matchingMoments$k = matchingMoments[k]) === null || _matchingMoments$k === void 0 ? void 0 : _matchingMoments$k.rad) !== null && _matchingMoments$k$ra !== void 0 ? _matchingMoments$k$ra : 0;
      }

      // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set
      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [vec2_namespaceObject.clone([x, y]), vec2_namespaceObject.clone([x + _subImageWrapper.size.x, y]), vec2_namespaceObject.clone([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), vec2_namespaceObject.clone([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: vec2_namespaceObject.clone([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }
  return patchesFound;
}

/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */
function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];
  function notYetProcessed() {
    var i;
    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }
    return _patchLabelGrid.data.length;
  }
  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;
    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx];
      // assign label
      _patchLabelGrid.data[currentIdx] = label;
      for (dir = 0; dir < locator_tracer.searchDirections.length; dir++) {
        y = current.y + locator_tracer.searchDirections[dir][0];
        x = current.x + locator_tracer.searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x;

        // continue if patch empty
        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE;
          // eslint-disable-next-line no-continue
          continue;
        }
        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(vec2_namespaceObject.dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec));
          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  }

  // prepare for finding the right patches
  array_helper.init(_patchGrid.data, 0);
  array_helper.init(_patchLabelGrid.data, 0);
  array_helper.init(_imageToPatchGrid.data, null);
  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  }

  // rasterize the patches found to determine area
  _patchGrid.zeroBorder();

  // eslint-disable-next-line no-cond-assign
  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  }

  // draw patch-labels if requested
  if ( true && barcode_locator_config.debug.showPatchLabels) {
    for (j = 0; j < _patchLabelGrid.data.length; j++) {
      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
        patch = _imageToPatchGrid.data[j];
        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
        hsv2rgb(hsv, rgb);
        image_debug.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
          color: "rgb(".concat(rgb.join(','), ")"),
          lineWidth: 2
        });
      }
    }
  }
  return label;
}
/* harmony default export */ var barcode_locator = ({
  init: function init(inputImageWrapper, config) {
    barcode_locator_config = config;
    _inputImageWrapper = inputImageWrapper;
    barcode_locator_initBuffers();
    barcode_locator_initCanvas();
  },
  locate: function locate() {
    if (barcode_locator_config.halfSample) {
      halfSample(_inputImageWrapper, _currentImageWrapper);
    }
    binarizeImage();
    var patchesFound = findPatches();
    // return unless 5% or more patches are found
    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    }

    // rasterrize area by comparing angular similarity;
    var maxLabel = rasterizeAngularSimilarity(patchesFound);
    if (maxLabel < 1) {
      return null;
    }

    // search for area with the most patches (biggest connected area)
    var topLabels = findBiggestConnectedAreas(maxLabel);
    if (topLabels.length === 0) {
      return null;
    }
    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var _config$debug2;
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area;

    // calculate width and height based on area
    if (inputStream.getConfig().area) {
      area = computeImageArea(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }
    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = calculatePatchSize(config.patchSize, size);
    if ( true && (_config$debug2 = config.debug) !== null && _config$debug2 !== void 0 && _config$debug2.showPatchSize) {
      console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
    }
    inputStream.setWidth(Math.max(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x), patchSize.x));
    inputStream.setHeight(Math.max(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y), patchSize.y));
    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }
    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
// CONCATENATED MODULE: ./src/QuaggaContext.ts



var QuaggaContext_QuaggaContext = /*#__PURE__*/createClass_default()(function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);
  defineProperty_default()(this, "config", void 0);
  defineProperty_default()(this, "inputStream", void 0);
  defineProperty_default()(this, "framegrabber", void 0);
  defineProperty_default()(this, "inputImageWrapper", void 0);
  defineProperty_default()(this, "stopped", false);
  /**
   * Flag indicating that stop() was called while init() was still in progress.
   * This is used to handle race conditions in React StrictMode where components
   * are mounted/unmounted rapidly, causing init() to be called, then stop(),
   * then init() again before the first init() completes.
   */
  defineProperty_default()(this, "initAborted", false);
  defineProperty_default()(this, "boxSize", void 0);
  defineProperty_default()(this, "resultCollector", void 0);
  defineProperty_default()(this, "decoder", void 0);
  defineProperty_default()(this, "workerPool", []);
  defineProperty_default()(this, "onUIThread", true);
  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
});
var QuaggaContext_CanvasInfo = /*#__PURE__*/createClass_default()(function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);
  defineProperty_default()(this, "image", void 0);
  defineProperty_default()(this, "overlay", void 0);
});
var QuaggaContext_CanvasContainer = /*#__PURE__*/createClass_default()(function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);
  defineProperty_default()(this, "ctx", void 0);
  defineProperty_default()(this, "dom", void 0);
  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
});
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  }

  // Check if target is already a DOM element
  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  }
  // Use '#interactive.viewport' as a fallback selector (backwards compatibility)
  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initBuffers.ts




// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var _config, _config$debug;
  var inputImageWrapper = imageWrapper || new image_wrapper({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });
  if ( true && (_config = locator.config) !== null && _config !== void 0 && (_config$debug = _config.debug) !== null && _config$debug !== void 0 && _config$debug.showImageDetails) {
    console.log("image wrapper size ".concat(inputImageWrapper.size));
  }
  var boxSize = [vec2_namespaceObject.clone([0, 0]), vec2_namespaceObject.clone([0, inputImageWrapper.size.y]), vec2_namespaceObject.clone([inputImageWrapper.size.x, inputImageWrapper.size.y]), vec2_namespaceObject.clone([inputImageWrapper.size.x, 0])];
  barcode_locator.init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts

function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);
  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }
  return canvas;
}
function getCanvasAndContext(selector, className, options) {
  var _options$debug;
  var canvas = findOrCreateCanvas(selector, className);
  if ( true && (_options$debug = options.debug) !== null && _options$debug !== void 0 && _options$debug.showImageDetails) {
    console.warn('* initCanvas getCanvasAndContext');
  }
  var context = canvas.getContext('2d', {
    willReadFrequently: options.willReadFrequently
  });
  return {
    canvas: canvas,
    context: context
  };
}
function initCanvases(canvasSize, _ref) {
  var willReadFrequently = _ref.willReadFrequently,
    createOverlay = _ref.createOverlay,
    debug = _ref.debug;
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer', {
      willReadFrequently: willReadFrequently,
      debug: debug
    });
    image.canvas.width = canvasSize.x;
    image.canvas.height = canvasSize.y;

    // Only create overlay canvas if createOverlay is true (default behavior)
    var overlay = {
      canvas: null,
      context: null
    };
    if (createOverlay) {
      var overlayResult = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer', {
        willReadFrequently: willReadFrequently,
        debug: debug
      });
      overlayResult.canvas.width = canvasSize.x;
      overlayResult.canvas.height = canvasSize.y;
      overlay = overlayResult;
    }
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }
  return null;
}
function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu, _context$config3, _context$config3$canv, _context$config4, _context$config4$inpu, _context$config5, _context$config5$loca;
  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;

  // Default to true for backwards compatibility
  var createOverlay = (context === null || context === void 0 ? void 0 : (_context$config3 = context.config) === null || _context$config3 === void 0 ? void 0 : (_context$config3$canv = _context$config3.canvas) === null || _context$config3$canv === void 0 ? void 0 : _context$config3$canv.createOverlay) !== false;
  var container = initCanvases(context.inputStream.getCanvasSize(), {
    willReadFrequently: !!(context !== null && context !== void 0 && (_context$config4 = context.config) !== null && _context$config4 !== void 0 && (_context$config4$inpu = _context$config4.inputStream) !== null && _context$config4$inpu !== void 0 && _context$config4$inpu.willReadFrequently),
    createOverlay: createOverlay,
    debug: context === null || context === void 0 ? void 0 : (_context$config5 = context.config) === null || _context$config5 === void 0 ? void 0 : (_context$config5$loca = _context$config5.locator) === null || _context$config5$loca === void 0 ? void 0 : _context$config5$loca.debug
  });
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;
  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }
      if (dom.overlay && !viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }
  return container;
}
// CONCATENATED MODULE: ./src/quagga/qworker.ts

function qworker_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function qworker_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? qworker_ownKeys(Object(t), !0).forEach(function (r) { defineProperty_default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : qworker_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */

// TODO: need a typescript interface for FrameGrabber

var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;
  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];
    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);
      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }
      return true;
    } else {
      return false;
    }
  }
  return null;
}
function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
}

// @ts-ignore
function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];
    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  }
  // @ts-ignore
  var imageWrapper;

  // @ts-ignore
  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result
      // @ts-ignore
    }, [imageWrapper.data.buffer]);
  }
  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data
      // @ts-ignore
    }, [imageWrapper.data.buffer]);
  }

  // @ts-ignore
  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}
function generateWorkerBlob() {
  var blob, factorySource;

  /* jshint ignore:start */
  // @ts-ignore
  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */

  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}
function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };
  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);
      if (true) {
        console.log('Worker initialized');
      }
      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false;
      // TODO: how to thread publishResult into here? TypeScript says it's not here. https://github.com/ericblade/quagga2/issues/466#issuecomment-1724248080 says it's necessary?
      // @ts-ignore
      if (typeof publishResult !== 'undefined') {
        // @ts-ignore
        publishResult(e.data.result, workerThread.imageData);
      }
    } else if (e.data.event === 'error') {
      if (true) {
        console.log('Worker error: ' + e.data.message);
      }
    }
  };
  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;
  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();
      if (true) {
        console.log('Worker terminated!');
      }
    });
    workerPool = workerPool.slice(0, increaseBy);
    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);
      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };
    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var inputStreamFactory = arguments.length > 2 ? arguments[2] : undefined;
  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: inputStreamFactory.createVideoStream(video)
        };
      }
    case 'ImageStream':
      return {
        inputStream: inputStreamFactory.createImageStream()
      };
    case 'LiveStream':
      {
        var _video = null;
        if (viewport) {
          _video = viewport.querySelector('video');
          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }
        return {
          video: _video,
          inputStream: inputStreamFactory.createLiveStream(_video)
        };
      }
    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */

function moveBox(box, xOffset, yOffset) {
  var corner = box.length;
  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts




















var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;
    classCallCheck_default()(this, Quagga);
    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());
    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;
      // Check if init was aborted (e.g., by calling stop() during initialization)
      // This can happen in React StrictMode where components are mounted/unmounted rapidly
      if (_this.context.initAborted) {
        callback(new Error('Initialization was aborted'));
        return;
      }
      if (!_this.context.config) {
        callback(new Error('Configuration not initialized'));
        return;
      }
      // Check if inputStream is properly initialized before proceeding
      if (!_this.context.inputStream) {
        callback(new Error('Input stream not initialized'));
        return;
      }
      barcode_locator.checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);
      _this.initCanvas();
      _this.context.framegrabber = frame_grabber_browser.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);
      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }
      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;
        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }
        _this.ready(callback);
      });
    });
    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);
        if (!workersUpdated) {
          var _this$context$inputIm;
          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);
          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;
        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);
        _this.context.framegrabber.grab();
        _this.locateAndDecode();
      }
    });
  }
  return createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }
      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
        inputImageWrapper = _initBuffers2.inputImageWrapper,
        boxSize = _initBuffers2.boxSize;
      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }
      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }
      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);
      if (!container) {
        return;
      }
      var ctx = container.ctx,
        dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;

      // Draw area overlay if configured
      drawAreaIfConfigured(this.context.config, this.context.canvasContainer.ctx.overlay, this.context.inputStream.getCanvasSize());
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }
      var _this$context$config$ = this.context.config.inputStream,
        inputType = _this$context$config$.type,
        constraints = _this$context$config$.constraints;
      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream_browser),
        video = _setupInputStream.video,
        inputStream = _setupInputStream.inputStream;
      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }
      if (inputStream) {
        inputStream.setAttribute('preload', 'auto');
        inputStream.setInputStream(this.context.config.inputStream);
        inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      }
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;
      return (_this$context$config3 = this.context.config) !== null && _this$context$config3 !== void 0 && _this$context$config3.locate ? barcode_locator.locate() : [[vec2_namespaceObject.clone(this.context.boxSize[0]), vec2_namespaceObject.clone(this.context.boxSize[1]), vec2_namespaceObject.clone(this.context.boxSize[2]), vec2_namespaceObject.clone(this.context.boxSize[3])]];
    }

    // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;
      var transformedBoxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;
      if (xOffset === 0 && yOffset === 0) {
        return;
      }
      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode, transformedBoxes);
        });
      }
      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }
      if (result.box && !transformedBoxes.has(result.box)) {
        moveBox(result.box, xOffset, yOffset);
        transformedBoxes.add(result.box);
      }
      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          // Skip if this box has already been transformed (either as result.box or through barcodes)
          if (!transformedBoxes.has(result.boxes[i])) {
            moveBox(result.boxes[i], xOffset, yOffset);
            transformedBoxes.add(result.boxes[i]);
          }
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;
      if (!imageData || !this.context.resultCollector) {
        return;
      }

      // TODO: Figure out what data structure holds a "barcodes" result, if any...
      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    }

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    }

    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;
      if (result && this.context.onUIThread) {
        var _result$barcodes;
        this.transformResult(result);
        this.addResult(result, imageData);
        // @ts-ignore
        resultToPublish = (result === null || result === void 0 ? void 0 : (_result$barcodes = result.barcodes) === null || _result$barcodes === void 0 ? void 0 : _result$barcodes.length) > 0 ? result.barcodes : result;
      }
      events.publish('processed', resultToPublish);
      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function () {
      var _locateAndDecode = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee() {
        var boxes, _this$context$inputIm3, decodeResult, imageResult, _this$context$inputIm4, _t;
        return regenerator_default.a.wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              boxes = this.getBoundingBoxes();
              if (!boxes) {
                _context.next = 3;
                break;
              }
              _context.next = 1;
              return this.context.decoder.decodeFromBoundingBoxes(boxes);
            case 1:
              _t = _context.sent;
              if (_t) {
                _context.next = 2;
                break;
              }
              _t = {};
            case 2:
              decodeResult = _t;
              decodeResult.boxes = boxes;
              this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
              _context.next = 5;
              break;
            case 3:
              _context.next = 4;
              return this.context.decoder.decodeFromImage(this.context.inputImageWrapper);
            case 4:
              imageResult = _context.sent;
              if (imageResult) {
                this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
              } else {
                this.publishResult();
              }
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function locateAndDecode() {
        return _locateAndDecode.apply(this, arguments);
      }
      return locateAndDecode;
    }()
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
        _this4 = this;
      var next = null;
      // frequency specifies a maximum rate, not an absolute. If the system cannot
      // achieve the requested frequency, scans will occur as fast as possible.
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;
      var _newFrame = function newFrame(timestamp) {
        next = next || timestamp;
        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;
            _this4.update();
          }
          window.requestAnimationFrame(_newFrame);
        }
      };
      _newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;
      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function () {
      var _stop = asyncToGenerator_default()(/*#__PURE__*/regenerator_default.a.mark(function _callee2() {
        var _this$context$config7;
        var _this$context$inputSt;
        return regenerator_default.a.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.context.stopped = true;
              // Set initAborted flag if stop() is called while init() is still in progress
              // (i.e., before framegrabber is initialized). This prevents the canRecord
              // callback from continuing after stop() was called.
              if (!this.context.framegrabber) {
                this.context.initAborted = true;
              }
              adjustWorkerPool(0);
              if (!((_this$context$config7 = this.context.config) !== null && _this$context$config7 !== void 0 && _this$context$config7.inputStream && this.context.config.inputStream.type === 'LiveStream')) {
                _context2.next = 2;
                break;
              }
              _context2.next = 1;
              return camera_access.release();
            case 1:
              (_this$context$inputSt = this.context.inputStream) === null || _this$context$inputSt === void 0 ? void 0 : _this$context$inputSt.clearEventHandlers();
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function stop() {
        return _stop.apply(this, arguments);
      }
      return stop;
    }()
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }
      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);
      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }
      qworker_registerReader(name, reader);
    }
  }]);
}();

// CONCATENATED MODULE: ./src/quagga.js


 // eslint-disable-line no-unused-vars









var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;
    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }
    // Reset the initAborted flag when starting a new init
    quaggaInstance.context.initAborted = false;
    quaggaInstance.context.config = merge_default()({}, config_config, config);
    // TODO #179: pending restructure in Issue #179, we are temp disabling workers
    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }
    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);
      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }
    return promise;
  },
  start: function start(config, cb) {
    // If config is provided, call init() then start()
    if (config) {
      var promise;
      if (!cb) {
        promise = new Promise(function (resolve, reject) {
          cb = function cb(err) {
            err ? reject(err) : resolve();
          };
        });
      }
      this.init(config, function (err) {
        if (err) {
          cb(err);
          return;
        }
        try {
          instance.start();
          cb();
        } catch (startErr) {
          cb(startErr);
        }
      });
      return promise;
    }
    // If init() hasn't been completed, throw an error
    if (!_context.framegrabber) {
      throw new Error('start() was called before init() completed. ' + 'Call init() first, or call start(config) to combine init and start.');
    }
    return instance.start();
  },
  stop: function stop() {
    return instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }
    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }
    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }
    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }
    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }
    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },
  get canvas() {
    return _context.canvasContainer;
  },
  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;
    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  true && config.debug ? 0 : 1,
      locator: {
        halfSample: false
      }
    }, config);
    // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/
    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    }
    // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.
    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }
    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();
            if (resultCallback) {
              resultCallback.call(null, result);
            }
            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },
  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },
  Readers: reader_namespaceObject,
  CameraAccess: camera_access,
  ImageDebug: image_debug,
  ImageWrapper: image_wrapper,
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface);
// export BarcodeReader and other utilities for external plugins


/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvT3ZlcmxvYWRZaWVsZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckRlZmluZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvckFzeW5jR2VuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcGljay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9QcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcmVnZW5lcmF0b3JSdW50aW1lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yQXN5bmMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcmVnZW5lcmF0b3JLZXlzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yVmFsdWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZUZ1bmN0aW9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vY29tbW9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vYXJyYXlfaGVscGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vY2x1c3Rlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2N2X3V0aWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGFiYXJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8xMjhfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzMyX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl8yX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl81X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl84X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2kyb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19lX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2luZGV4LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vZXZlbnRzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvRXhjZXB0aW9uLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5kZXYudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcubm9kZS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5wcm9kLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vYXJlYV9vdmVybGF5LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2V4aWZfaGVscGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbWFnZV9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fYnJvd3Nlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci90cmFjZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvcmFzdGVyaXplci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci9za2VsZXRvbml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9RdWFnZ2FDb250ZXh0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvZ2V0Vmlld1BvcnQudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9pbml0QnVmZmVycy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9xd29ya2VyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2Evc2V0dXBJbnB1dFN0cmVhbS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3RyYW5zZm9ybS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F1YWdnYS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhLmpzIl0sIm5hbWVzIjpbIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsIk1hdGgiLCJpbXVsIiwiYSIsImIiLCJhaCIsImFsIiwiYmgiLCJibCIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldCIsIlR5cGVFcnJvciIsInRvIiwiaW5kZXgiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJuZXh0U291cmNlIiwibmV4dEtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluaXQiLCJhcnIiLCJ2YWwiLCJmaWxsIiwic2h1ZmZsZSIsImkiLCJqIiwiZmxvb3IiLCJyYW5kb20iLCJfcmVmIiwidG9Qb2ludExpc3QiLCJyb3dzIiwicmVkdWNlIiwicCIsIm4iLCJyb3ciLCJjb25jYXQiLCJqb2luIiwicHVzaCIsInRocmVzaG9sZCIsInNjb3JlRnVuYyIsInF1ZXVlIiwicHJldiIsIm5leHQiLCJhcHBseSIsIm1heEluZGV4IiwibWF4Iiwic3VtIiwiY3JlYXRlIiwicG9pbnQiLCJwb2ludHMiLCJjZW50ZXIiLCJyYWQiLCJ2ZWMiLCJ2ZWMyIiwiY2xvbmUiLCJwb2ludE1hcCIsImFkZCIsInBvaW50VG9BZGQiLCJpZCIsInVwZGF0ZUNlbnRlciIsImNvcyIsInNpbiIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImRvdCIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsImltYWdlUmVmIiwieCIsInkiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwidmVjMyIsInJvdW5kIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwidW5kZWZpbmVkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwib3RzdVRocmVzaG9sZCIsImNvbXB1dGVCaW5hcnlJbWFnZSIsImtlcm5lbCIsIkEiLCJCIiwiQyIsIkQiLCJhdmciLCJjbHVzdGVyIiwidGhpc0NsdXN0ZXIiLCJjbHVzdGVycyIsImFkZFRvQ2x1c3RlciIsImZvdW5kIiwiQ2x1c3RlcjIiLCJUcmFjZXIiLCJ0cmFjZSIsIml0ZXJhdGlvbiIsIm1heEl0ZXJhdGlvbnMiLCJ0b3AiLCJyZXN1bHQiLCJjZW50ZXJQb3MiLCJjdXJyZW50UG9zIiwiaWR4IiwiZm9yd2FyZCIsInRvSWR4IiwicHJlZGljdGVkUG9zIiwidGhyZXNob2xkWCIsInRocmVzaG9sZFkiLCJtYXRjaCIsInBvcyIsInByZWRpY3RlZCIsImZyb20iLCJESUxBVEUiLCJFUk9ERSIsImRpbGF0ZSIsImluSW1hZ2VXcmFwcGVyIiwib3V0SW1hZ2VXcmFwcGVyIiwiaW5JbWFnZURhdGEiLCJvdXRJbWFnZURhdGEiLCJ5U3RhcnQxIiwieVN0YXJ0MiIsInhTdGFydDEiLCJ4U3RhcnQyIiwiZXJvZGUiLCJzdWJ0cmFjdCIsImFJbWFnZVdyYXBwZXIiLCJiSW1hZ2VXcmFwcGVyIiwicmVzdWx0SW1hZ2VXcmFwcGVyIiwiYUltYWdlRGF0YSIsImJJbWFnZURhdGEiLCJjSW1hZ2VEYXRhIiwiYml0d2lzZU9yIiwiY291bnROb25aZXJvIiwidG9wR2VuZXJpYyIsImxpc3QiLCJtaW5JZHgiLCJtaW4iLCJzY29yZSIsImhpdCIsIml0ZW0iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiY3R4IiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJsIiwic2luZ2xlQ2hhbm5lbCIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJjb25zb2xlIiwid2FybiIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiX2N0eCRnZXRJbWFnZURhdGEiLCJoYWxmU2FtcGxlIiwiaW5JbWdXcmFwcGVyIiwib3V0SW1nV3JhcHBlciIsImluSW1nIiwib3V0SW1nIiwiaHN2MnJnYiIsImhzdiIsInJnYiIsImgiLCJzIiwiYyIsIm0iLCJyIiwiZyIsIl9jb21wdXRlRGl2aXNvcnMiLCJpc0Zpbml0ZSIsImxhcmdlRGl2aXNvcnMiLCJkaXZpc29ycyIsInNxcnROIiwic3FydCIsInVuc2hpZnQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwidmFsdWUiLCJkaW1lbnNpb24iLCJwYXJzZUZsb2F0IiwidW5pdCIsImluZGV4T2YiLCJfZGltZW5zaW9uc0NvbnZlcnRlcnMiLCJjb250ZXh0IiwiYm90dG9tIiwiY29tcHV0ZUltYWdlQXJlYSIsImlucHV0V2lkdGgiLCJpbnB1dEhlaWdodCIsImFyZWEiLCJwYXJzZWRBcmVhIiwia2V5cyIsImtleSIsInBhcnNlZCIsImNhbGN1bGF0ZWQiLCJzeCIsInN5Iiwic3ciLCJzaCIsImFzc2VydE51bWJlclBvc2l0aXZlIiwiRXJyb3IiLCJJbWFnZVdyYXBwZXIiLCJBcnJheVR5cGUiLCJpbml0aWFsaXplIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2RlZmluZVByb3BlcnR5IiwiX2NyZWF0ZUNsYXNzIiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJpbWdSZWYiLCJib3JkZXIiLCJzdWJJbWFnZUFzQ29weSIsIl9pbWFnZVdyYXBwZXIkc2l6ZSIsInNpemVYIiwic2l6ZVkiLCJnZXQiLCJnZXRTYWZlIiwiaW5kZXhNYXBwaW5nIiwic2V0IiwiemVyb0JvcmRlciIsIl90aGlzJHNpemUiLCJtb21lbnRzIiwibGFiZWxDb3VudCIsInlzcSIsImxhYmVsU3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwidG1wIiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJpc05hTiIsImF0YW4iLCJnZXRBc1JHQkEiLCJzY2FsZSIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50Iiwic2hvdyIsImZyYW1lIiwibmV3RnJhbWUiLCJJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJvdmVybGF5IiwiaW5TY2FsZSIsImFkanVzdGVkU2NhbGUiLCJ3aGl0ZVJnYiIsImJsYWNrUmdiIiwiX3Jlc3VsdCIsIl9yZXN1bHQyIiwiX3NsaWNlZFRvQXJyYXkiLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwiQmFyY29kZURpcmVjdGlvbiIsIkJhcmNvZGVSZWFkZXIiLCJzdXBwbGVtZW50cyIsIl9yb3ciLCJfbmV4dFVuc2V0Iiwic3RhcnQiLCJfbWF0Y2hQYXR0ZXJuIiwiY291bnRlciIsImNvZGUiLCJtYXhTaW5nbGVFcnJvciIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiZXJyb3IiLCJzaW5nbGVFcnJvciIsIm1vZHVsbyIsImJhcldpZHRoIiwiY291bnQiLCJzY2FsZWQiLCJfbmV4dFNldCIsIl9jb3JyZWN0QmFycyIsImNvcnJlY3Rpb24iLCJpbmRpY2VzIiwiZGVjb2RlUGF0dGVybiIsInBhdHRlcm4iLCJkZWNvZGUiLCJyZXZlcnNlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbWF0Y2hSYW5nZSIsIl9maWxsQ291bnRlcnMiLCJpc1doaXRlIiwiY291bnRlcnMiLCJjb3VudGVyUG9zIiwiX3RvQ291bnRlcnMiLCJudW1Db3VudGVycyIsImRlY29kZUltYWdlIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsIk4iLCJXIiwiU1RBUlRfUEFUVEVSTiIsIlNUT1BfUEFUVEVSTiIsIkNPREVfUEFUVEVSTiIsIlNUQVJUX1BBVFRFUk5fTEVOR1RIIiwiVHdvT2ZGaXZlUmVhZGVyIiwiX0JhcmNvZGVSZWFkZXIiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiX2NhbGxTdXBlciIsIl9pbmhlcml0cyIsIl9maW5kUGF0dGVybiIsInRyeUhhcmRlciIsImJlc3RNYXRjaCIsImVwc2lsb24iLCJBVkdfQ09ERV9FUlJPUiIsIl9maW5kU3RhcnQiLCJzdGFydEluZm8iLCJuYXJyb3dCYXJXaWR0aCIsImxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQiLCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlIiwiZW5kSW5mbyIsInRyYWlsaW5nV2hpdGVzcGFjZUVuZCIsIl9maW5kRW5kIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJfZGVjb2RlQ29kZSIsIl9kZWNvZGVQYXlsb2FkIiwiZGVjb2RlZENvZGVzIiwiY291bnRlckxlbmd0aCIsImJhclNwYWNlUmF0aW8iLCJBTFBIQUJFVCIsIkNIQVJBQ1RFUl9FTkNPRElOR1MiLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsIk5ld0NvZGFiYXJSZWFkZXIiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwiX2NvdW50ZXJzIiwiX3RvUGF0dGVybiIsImJhclRocmVzaG9sZCIsInNwYWNlVGhyZXNob2xkIiwiYml0bWFzayIsIl9pc1N0YXJ0RW5kIiwiX3N1bUNvdW50ZXJzIiwic3RhcnRDb3VudGVyIiwiZW5kQ291bnRlciIsIl9wYXR0ZXJuVG9DaGFyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJfdmVyaWZ5V2hpdGVzcGFjZSIsIl9jaGFyVG9QYXR0ZXJuIiwiY2hhciIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsIl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuIiwiY2F0ZWdvcml6YXRpb24iLCJzcGFjZSIsIm5hcnJvdyIsImNvdW50cyIsIndpZGUiLCJiYXIiLCJraW5kIiwiY2F0IiwiZm9yRWFjaCIsIm5ld2tpbmQiLCJjZWlsIiwiX3ZhbGlkYXRlUmVzdWx0IiwidGhyZXNob2xkcyIsIm5leHRTdGFydCIsImRlY29kZWRDaGFyIiwiQ29kZTEyOFJlYWRlciIsIl9jb3JyZWN0IiwiY2FsY3VsYXRlQ29ycmVjdGlvbiIsIk1PRFVMRV9JTkRJQ0VTIiwiU1RBUlRfQ09ERV9BIiwiU1RBUlRfQ09ERV9DIiwiX3RoaXMyIiwiY2hlY2tzdW0iLCJjb2Rlc2V0IiwiQ09ERV9BIiwiU1RBUlRfQ09ERV9CIiwiQ09ERV9CIiwiQ09ERV9DIiwiZG9uZSIsInNoaWZ0TmV4dCIsInJlbW92ZUxhc3RDaGFyYWN0ZXIiLCJtdWx0aXBsaWVyIiwicmF3UmVzdWx0IiwiU1RPUF9DT0RFIiwiQ09ERV9TSElGVCIsInNwbGljZSIsInNlbGYiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJBTFBIQUJFVEhfU1RSSU5HIiwiVWludDE2QXJyYXkiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJtYXAiLCJBU1RFUklTSyIsIkNvZGUzOVJlYWRlciIsInBhdHRlcm5TdGFydCIsIndoaXRlU3BhY2VNdXN0U3RhcnQiLCJtYXhOYXJyb3dXaWR0aCIsIm51bVdpZGVCYXJzIiwid2lkZUJhcldpZHRoIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsImxhc3RTdGFydCIsInBhdHRlcm5TaXplIiwicG9wIiwicGF0dGVybnMiLCJBRUlPIiwiQVowOSIsImNvZGUzMnNldCIsIkNvZGUzMlJlYWRlciIsIl9Db2RlMzlSZWFkZXIiLCJfZGVjb2RlQ29kZTMyIiwidGVzdCIsInJlcyIsImNvZGUzMiIsInNsaWNlIiwiX2NoZWNrQ2hlY2tzdW0iLCJfc3VwZXJQcm9wR2V0IiwicmVwbGFjZSIsIklPUSIsIkNvZGUzOVZJTlJlYWRlciIsImxvZyIsIkNvZGU5M1JlYWRlciIsIl92ZXJpZnlFbmQiLCJfZGVjb2RlRXh0ZW5kZWQiLCJjaGFyQXJyYXkiLCJuZXh0Q2hhciIsIm5leHRDaGFyQ29kZSIsIl9tYXRjaENoZWNrQ2hhciIsIm1heFdlaWdodCIsImFycmF5VG9DaGVjayIsIndlaWdodGVkU3VtcyIsIndlaWdodCIsImNoZWNrQ2hhciIsIl92ZXJpZnlDaGVja3N1bXMiLCJDT0RFX0dfU1RBUlQiLCJNSURETEVfUEFUVEVSTiIsIkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOIiwiQ09ERV9GUkVRVUVOQ1kiLCJFQU5SZWFkZXIiLCJtZXJnZSIsImNvZGVyYW5nZSIsIl9jYWxjdWxhdGVGaXJzdERpZ2l0IiwiY29kZUZyZXF1ZW5jeSIsImluQ29kZSIsIm91dENvZGUiLCJfb2JqZWN0U3ByZWFkIiwiZmlyc3REaWdpdCIsIm1pZGRsZVBhdHRlcm4iLCJfY2hlY2tzdW0iLCJfZGVjb2RlRXh0ZW5zaW9ucyIsImVyciIsInJlc3VsdEluZm8iLCJzdXBwbGVtZW50IiwibGFzdENvZGUiLCJFQU4yUmVhZGVyIiwiX0VBTlJlYWRlciIsInBhcnNlSW50IiwiQ0hFQ0tfRElHSVRfRU5DT0RJTkdTIiwiZGV0ZXJtaW5lQ2hlY2tEaWdpdCIsImV4dGVuc2lvbkNoZWNrc3VtIiwiRUFONVJlYWRlciIsIkVBTjhSZWFkZXIiLCJJMm9mNVJlYWRlciIsIm9wdHMiLCJub3JtYWxpemVCYXJTcGFjZVdpZHRoIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJjb3VudGVyU3VtIiwiY29kZVN1bSIsImNvcnJlY3Rpb25SYXRpbyIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvcnJlY3Rpb25SYXRpb0ludmVyc2UiLCJfZGVjb2RlUGFpciIsImNvdW50ZXJQYWlyIiwiY29kZXMiLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwiX2NvbnZlcnRUb1VQQ0EiLCJ1cGNhIiwibGFzdERpZ2l0IiwiVVBDUmVhZGVyIiwiY2hhckF0Iiwic3Vic3RyaW5nIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJESVIiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJyZWFkIiwiZGVsdGFYIiwiZGVsdGFZIiwieVN0ZXAiLCJ0b0JpbmFyeUxpbmUiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiZGlyIiwiclRocmVzaG9sZCIsImRlYnVnIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwibmFtZSIsInJlYWRlciIsImlucHV0SW1hZ2VXcmFwcGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsImRvbSIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRDYW52YXMiLCJpbml0UmVhZGVycyIsImluaXRDb25maWciLCJfY29uZmlnJGRlYnVnIiwiJGRlYnVnIiwicXVlcnlTZWxlY3RvciIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwicHJpbnRSZWFkZXJJbmZvIiwiX2NvbmZpZyRkZWJ1ZzMiLCJyZWFkZXJzIiwicmVhZGVyQ29uZmlnIiwiX2NvbmZpZyRkZWJ1ZzIiLCJjb25maWd1cmF0aW9uIiwiX3R5cGVvZiIsInJlYWRlck9iaiIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2aXMiLCJub2RlIiwicHJvcCIsInNob3dGcmVxdWVuY3kiLCJzaG93UGF0dGVybiIsImRpc3BsYXkiLCJnZXRFeHRlbmRlZExpbmUiLCJhbmdsZSIsImV4dCIsImV4dGVuZExpbmUiLCJhbW91bnQiLCJleHRlbnNpb24iLCJnZXRMaW5lIiwiYm94IiwidHJ5RGVjb2RlIiwiYmFyY29kZUxpbmUiLCJJbWFnZURlYnVnIiwiY29kZVJlc3VsdCIsInRyeURlY29kZUJydXRlRm9yY2UiLCJsaW5lQW5nbGUiLCJzaWRlTGVuZ3RoIiwicG93Iiwic2xpY2VzIiwieGRpciIsInlkaXIiLCJnZXRMaW5lTGVuZ3RoIiwiZGVjb2RlRnJvbUltYWdlIiwiX3giLCJfZGVjb2RlRnJvbUltYWdlIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJfcmVnZW5lcmF0b3JSdW50aW1lIiwibWFyayIsIl9jYWxsZWUyIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfdCIsIndyYXAiLCJfY29udGV4dDIiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsInNlbnQiLCJhYnJ1cHQiLCJlIiwiZiIsImZpbmlzaCIsInN0b3AiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3giLCJkcmF3Qm91bmRpbmdCb3giLCJsaW5lTGVuZ3RoIiwiYXRhbjIiLCJkcmF3U2NhbmxpbmUiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyIsImJveGVzIiwiYmFyY29kZXMiLCJtdWx0aXBsZSIsImltYWdlV3JhcHBlckluIiwiX2NhbGxlZSIsIl9jb250ZXh0Iiwic2V0UmVhZGVycyIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRzIiwiZ2V0RXZlbnQiLCJldmVudE5hbWUiLCJzdWJzY3JpYmVycyIsImNsZWFyRXZlbnRzIiwicHVibGlzaFN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbiIsImFzeW5jIiwiX3N1YnNjcmliZSIsImV2ZW50Iiwic3Vic2NyaWJlIiwicHVibGlzaCIsImZpbHRlciIsInN1YnNjcmliZXIiLCJvbmNlIiwidW5zdWJzY3JpYmUiLCJFeGNlcHRpb24iLCJfRXJyb3IiLCJzZXRQcm90b3R5cGVPZiIsIl93cmFwTmF0aXZlU3VwZXIiLCJFUlJPUl9ERVNDIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsIlByb21pc2UiLCJyZWplY3QiLCJnZXRVc2VyTWVkaWEiLCJjb25zdHJhaW50cyIsInN0cmVhbVJlZiIsIndhaXRGb3JWaWRlbyIsInZpZGVvIiwicmVzb2x2ZSIsImF0dGVtcHRzIiwiY2hlY2tWaWRlbyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImluaXRDYW1lcmEiLCJfeDIiLCJfaW5pdENhbWVyYSIsIl9jYWxsZWU0Iiwic3RyZWFtIiwiX2NvbnRleHQ0Iiwic2V0QXR0cmlidXRlIiwic3JjT2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwicGljayIsIm1pbkFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJmYWNpbmciLCJmYWNpbmdNb2RlIiwicGlja0NvbnN0cmFpbnRzIiwiZGV2aWNlSWQiLCJhdWRpbyIsImVudW1lcmF0ZVZpZGVvRGV2aWNlcyIsIl94MyIsIl9lbnVtZXJhdGVWaWRlb0RldmljZXMiLCJfY2FsbGVlNSIsImRldmljZXMiLCJ2aWRlb0RldmljZXMiLCJjb25zdHJhaW5lZERldmljZXMiLCJwcm9jZXNzZWRDb25zdHJhaW50cyIsIl8iLCJjb25zdHJhaW50c1dpdGhvdXREZXZpY2VJZCIsImRldmljZSIsIl90MyIsIl90NCIsIl9jb250ZXh0NSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9leGNsdWRlZCIsImV4YWN0IiwiZ2V0VHJhY2tzIiwidHJhY2siLCJnZXRBY3RpdmVUcmFjayIsInRyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiUXVhZ2dhSlNDYW1lcmFBY2Nlc3MiLCJyZXF1ZXN0ZWRWaWRlb0VsZW1lbnQiLCJyZXF1ZXN0IiwibmV3Q29uc3RyYWludHMiLCJyZWxlYXNlIiwicGF1c2UiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsImRpc2FibGVUb3JjaCIsImFwcGx5Q29uc3RyYWludHMiLCJhZHZhbmNlZCIsInRvcmNoIiwiT3ZlcmNvbnN0cmFpbmVkRXJyb3IiLCJlbmFibGVUb3JjaCIsIl9jYWxsZWUzIiwiX3QyIiwiX2NvbnRleHQzIiwiY29udGFpbnMiLCJzb21lIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJfY29uZmlnJGNhcGFjaXR5Iiwid2lsbFJlYWRGcmVxdWVudGx5IiwicmVzdWx0cyIsImNhcGFjaXR5IiwiY2FwdHVyZSIsIm1hdGNoZXNDb25zdHJhaW50cyIsImJsYWNrbGlzdCIsImFkZFJlc3VsdCIsImltYWdlU2l6ZSIsInRvRGF0YVVSTCIsImdldFJlc3VsdHMiLCJEZXZDb25maWciLCJpbnB1dFN0cmVhbSIsInR5cGUiLCJzaG93SW1hZ2VEZXRhaWxzIiwibG9jYXRlIiwiY3JlYXRlT3ZlcmxheSIsImRlY29kZXIiLCJsb2NhdG9yIiwic2hvd0NhbnZhcyIsInNob3dQYXRjaGVzIiwic2hvd0ZvdW5kUGF0Y2hlcyIsInNob3dTa2VsZXRvbiIsInNob3dMYWJlbHMiLCJzaG93UGF0Y2hMYWJlbHMiLCJzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMiLCJzaG93UGF0Y2hTaXplIiwiYm94RnJvbVBhdGNoZXMiLCJzaG93VHJhbnNmb3JtZWQiLCJzaG93VHJhbnNmb3JtZWRCb3giLCJzaG93QkIiLCJOb2RlQ29uZmlnIiwic2VxdWVuY2UiLCJQcm9kQ29uZmlnIiwiRXhwb3J0Q29uZmlnIiwiUXVhZ2dhQ29uZmlnIiwiY2FsY3VsYXRlQXJlYVJlY3QiLCJjYW52YXNTaXplIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJpc0FyZWFEZWZpbmVkIiwic2hvdWxkRHJhd0FyZWFPdmVybGF5IiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsImJhY2tncm91bmRDb2xvciIsImRyYXdBcmVhT3ZlcmxheSIsInJlY3QiLCJkcmF3QXJlYUlmQ29uZmlndXJlZCIsIl9hcmVhJGJvcmRlckNvbG9yIiwiX2FyZWEkYm9yZGVyV2lkdGgiLCJzaG91bGREcmF3Qm9yZGVyIiwiVE9fUkFESUFOUyIsImFkanVzdENhbnZhc1NpemUiLCJ0YXJnZXRTaXplIiwiRnJhbWVHcmFiYmVyIiwiX3N0cmVhbUNvbmZpZyRkZWJ1ZyIsIl9zdHJlYW1Db25maWckZGVidWcyIiwiX3RoYXQiLCJfc3RyZWFtQ29uZmlnIiwiZ2V0Q29uZmlnIiwiX3ZpZGVvU2l6ZSIsImdldFJlYWxXaWR0aCIsImdldFJlYWxIZWlnaHQiLCJfY2FudmFzU2l6ZSIsImdldENhbnZhc1NpemUiLCJfc2l6ZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwidG9wUmlnaHQiLCJnZXRUb3BSaWdodCIsIl9zeCIsIl9zeSIsIl9jdHgiLCJfZGF0YSIsInZpZGVvU2l6ZSIsImF0dGFjaERhdGEiLCJnZXREYXRhIiwiYmlsaW5lYXJJbnRlcnBvbGF0ZSIsImdyYXlEYXRhIiwiZngiLCJmeSIsInYwMCIsInYxMCIsInYwMSIsInYxMSIsInYwIiwidjEiLCJncmFiIiwiZG9IYWxmU2FtcGxlIiwiZ2V0RnJhbWUiLCJkcmF3YWJsZSIsImRyYXdBbmdsZSIsInRhZ3MiLCJvcmllbnRhdGlvbiIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInRlbXBDYW52YXMiLCJ0ZW1wQ3R4Iiwib3JpZ2luYWxJbWFnZURhdGEiLCJzY2FsZWRHcmF5RGF0YSIsInN0ZXBTaXplWCIsInN0ZXBTaXplWSIsInNyY1giLCJzcmNZIiwic3JjSWR4IiwiZ2V0U2l6ZSIsIkV4aWZUYWdzIiwiQXZhaWxhYmxlVGFncyIsImZpbmRUYWdzSW5PYmplY3RVUkwiLCJvYmplY3RVUkxUb0Jsb2IiLCJ0aGVuIiwicmVhZFRvQnVmZmVyIiwiYnVmZmVyIiwiZmluZFRhZ3NJbkJ1ZmZlciIsImJhc2U2NFRvQXJyYXlCdWZmZXIiLCJkYXRhVXJsIiwiYmFzZTY0IiwiYmluYXJ5IiwiYXRvYiIsImxlbiIsIkFycmF5QnVmZmVyIiwidmlldyIsImJsb2IiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0FycmF5QnVmZmVyIiwidXJsIiwiaHR0cCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJET05FIiwic3RhdHVzIiwicmVzcG9uc2UiLCJvbmVycm9yIiwic2VuZCIsImZpbGUiLCJzZWxlY3RlZFRhZ3MiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiYnl0ZUxlbmd0aCIsImV4aWZUYWdzIiwic2VsZWN0ZWRUYWciLCJleGlmVGFnIiwidGFnIiwibWFya2VyIiwiZ2V0VWludDgiLCJyZWFkRVhJRkRhdGEiLCJnZXRVaW50MTYiLCJnZXRTdHJpbmdGcm9tQnVmZmVyIiwidGlmZk9mZnNldCIsImJpZ0VuZCIsImZpcnN0SUZET2Zmc2V0IiwiZ2V0VWludDMyIiwicmVhZFRhZ3MiLCJ0aWZmU3RhcnQiLCJkaXJTdGFydCIsInN0cmluZ3MiLCJlbnRyaWVzIiwiZW50cnlPZmZzZXQiLCJyZWFkVGFnVmFsdWUiLCJudW1WYWx1ZXMiLCJvdXRzdHIiLCJnZW5lcmF0ZUltYWdlRmlsZW5hbWUiLCJkaXJlY3RvcnkiLCJudW0iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiSW1hZ2VMb2FkZXIiLCJsb2FkIiwiaHRtbEltYWdlc1NyY0FycmF5IiwiaHRtbEltYWdlc0FycmF5Iiwibm90TG9hZGVkIiwiYWRkSW1hZ2UiLCJpbWFnZSIsImxvYWRlZCIsImxvYWRlZEltZyIsIm5vdGxvYWRlZEltZ3MiLCJpbWdOYW1lIiwiZW5jb2RlVVJJIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJhZGRPbmxvYWRIYW5kbGVyIiwiaW5wdXRTdHJlYW1GYWN0b3J5IiwiY3JlYXRlVmlkZW9TdHJlYW0iLCJfY29uZmlnIiwiX2V2ZW50TmFtZXMiLCJfZXZlbnRIYW5kbGVycyIsIl9jYWxjdWxhdGVkV2lkdGgiLCJfY2FsY3VsYXRlZEhlaWdodCIsIl90b3BSaWdodCIsImluaXRTaXplIiwiX2NvbmZpZzIiLCJfY29uZmlnMyIsInNldFdpZHRoIiwic2V0SGVpZ2h0Iiwic2V0SW5wdXRTdHJlYW0iLCJlbmRlZCIsInNldEN1cnJlbnRUaW1lIiwidGltZSIsIl9jb25maWc0IiwiYm9vbCIsImNsZWFyRXZlbnRIYW5kbGVycyIsImhhbmRsZXJzIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmlnZ2VyIiwic2V0VG9wUmlnaHQiLCJzZXRDYW52YXNTaXplIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiZnJhbWVJZHgiLCJwYXVzZWQiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsIl9jb25maWc3IiwiaW1ncyIsIl9jb25maWc1IiwiX2NvbmZpZzYiLCJwdWJsaXNoRXZlbnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImluZCIsIl9pbWdBcnJheSIsInNlYXJjaERpcmVjdGlvbnMiLCJsYWJlbFdyYXBwZXIiLCJsYWJlbERhdGEiLCJlZGdlbGFiZWwiLCJjeSIsImN4IiwidmVydGV4MkQiLCJjb250b3VyVHJhY2luZyIsIkZ2IiwiQ3YiLCJQIiwibGRpciIsInRvdGFsUGl4ZWxDb3VudCIsInBpeGVsQ291bnRlciIsIlJhc3Rlcml6ZXIiLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJyYXN0ZXJpemUiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRyYXdDb250b3VyIiwiZmlyc3RDb250b3VyIiwicHEiLCJpcSIsInEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiaW1hZ2VzIiwiaW5JbWFnZVB0ciIsIm91dEltYWdlUHRyIiwiYUltYWdlUHRyIiwiYkltYWdlUHRyIiwiaW1hZ2VQdHIiLCJtZW1jcHkiLCJzcmNJbWFnZVB0ciIsImRzdEltYWdlUHRyIiwic2tlbGV0b25pemUiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwiX2N1cnJlbnRJbWFnZVdyYXBwZXIiLCJfc2tlbEltYWdlV3JhcHBlciIsIl9zdWJJbWFnZVdyYXBwZXIiLCJfbGFiZWxJbWFnZVdyYXBwZXIiLCJfcGF0Y2hHcmlkIiwiX3BhdGNoTGFiZWxHcmlkIiwiX2ltYWdlVG9QYXRjaEdyaWQiLCJfYmluYXJ5SW1hZ2VXcmFwcGVyIiwiX3BhdGNoU2l6ZSIsIl9jYW52YXNDb250YWluZXIiLCJfbnVtUGF0Y2hlcyIsIl9pbnB1dEltYWdlV3JhcHBlciIsIl9za2VsZXRvbml6ZXIiLCJpbml0QnVmZmVycyIsInNrZWxldG9uSW1hZ2VEYXRhU2l6ZSIsImJ1ZmZlclNpemUiLCJsb2cyIiwic2tlbGV0b25JbWFnZURhdGEiLCJza2VsZXRvbml6ZXIiLCJ1c2VXb3JrZXIiLCJwYXRjaGVzIiwib3ZlckF2ZyIsInBhdGNoIiwidHJhbnNNYXQiLCJtaW54IiwibWlueSIsIm1heHgiLCJtYXh5IiwibWF0MiIsImNvcHkiLCJ0cmFuc2Zvcm1NYXQyIiwiaW52ZXJ0IiwiYmluYXJpemVJbWFnZSIsImZpbmRQYXRjaGVzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsImRlc2NyaWJlUGF0Y2giLCJmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzIiwibWF4TGFiZWwiLCJsYWJlbEhpc3QiLCJ0b3BMYWJlbHMiLCJzb3J0IiwiZWwiLCJmaW5kQm94ZXMiLCJzaW1pbGFyTW9tZW50cyIsInRvcENsdXN0ZXIiLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsIl9tYXRjaGluZ01vbWVudHMkayRyYSIsIl9tYXRjaGluZ01vbWVudHMkayIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJjaGVja0ltYWdlQ29uc3RyYWludHMiLCJ0aGlzSGFsZlNhbXBsZSIsIlF1YWdnYUNvbnRleHQiLCJDYW52YXNDb250YWluZXIiLCJDYW52YXNJbmZvIiwiZ2V0Vmlld1BvcnQiLCJIVE1MRWxlbWVudCIsIm5vZGVOYW1lIiwibm9kZVR5cGUiLCJzZWxlY3RvciIsImJveFNpemUiLCJCYXJjb2RlTG9jYXRvciIsImZpbmRPckNyZWF0ZUNhbnZhcyIsImdldENhbnZhc0FuZENvbnRleHQiLCJvcHRpb25zIiwiX29wdGlvbnMkZGVidWciLCJpbml0Q2FudmFzZXMiLCJvdmVybGF5UmVzdWx0IiwiX2NvbnRleHQkY29uZmlnIiwiX2NvbnRleHQkY29uZmlnJGlucHV0IiwiX2NvbnRleHQkY29uZmlnMiIsIl9jb250ZXh0JGNvbmZpZzIkaW5wdSIsIl9jb250ZXh0JGNvbmZpZzMiLCJfY29udGV4dCRjb25maWczJGNhbnYiLCJfY29udGV4dCRjb25maWc0IiwiX2NvbnRleHQkY29uZmlnNCRpbnB1IiwiX2NvbnRleHQkY29uZmlnNSIsIl9jb250ZXh0JGNvbmZpZzUkbG9jYSIsInZpZXdwb3J0IiwiY29udGFpbmVyIiwid29ya2VyUG9vbCIsInVwZGF0ZVdvcmtlcnMiLCJmcmFtZUdyYWJiZXIiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5Iiwid29ya2VyIiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwibWVzc2FnZSIsIm9uUHJvY2Vzc2VkIiwid29ya2VySW50ZXJmYWNlUmVhZHkiLCJvbm1lc3NhZ2UiLCJudW1PZldvcmtlcnMiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJmYWN0b3J5U291cmNlIiwiX19mYWN0b3J5U291cmNlX18iLCJCbG9iIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiaW5pdFdvcmtlciIsImNiIiwiYmxvYlVSTCIsIldvcmtlciIsInJldm9rZU9iamVjdFVSTCIsInB1Ymxpc2hSZXN1bHQiLCJhZGp1c3RXb3JrZXJQb29sIiwiaW5jcmVhc2VCeSIsIndvcmtlcnNUb1Rlcm1pbmF0ZSIsInRlcm1pbmF0ZSIsIndvcmtlckluaXRpYWxpemVkIiwic2V0dXBJbnB1dFN0cmVhbSIsIm1vdmVCb3giLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lciIsIm1vdmVMaW5lIiwiX3RoaXMkY29udGV4dCRjb25maWciLCJpbml0QWJvcnRlZCIsImZyYW1lZ3JhYmJlciIsImNhbnZhc0NvbnRhaW5lciIsIlFXb3JrZXJzIiwiX3RoaXMkY29udGV4dCRjb25maWcyIiwiaW5pdGlhbGl6ZURhdGEiLCJyZWFkeSIsIm9uVUlUaHJlYWQiLCJ3b3JrZXJzVXBkYXRlZCIsIl90aGlzJGNvbnRleHQkaW5wdXRJbSIsImxvY2F0ZUFuZERlY29kZSIsIl90aGlzJGNvbnRleHQkaW5wdXRJbTIiLCJfaW5pdEJ1ZmZlcnMyIiwiX2luaXRCdWZmZXJzIiwiQmFyY29kZURlY29kZXIiLCJfZ2V0Vmlld1BvcnQiLCJfaW5pdENhbnZhcyIsImluaXRJbnB1dFN0cmVhbSIsIl90aGlzJGNvbnRleHQkY29uZmlnJCIsImlucHV0VHlwZSIsIl9zZXR1cElucHV0U3RyZWFtIiwiSW5wdXRTdHJlYW0iLCJDYW1lcmFBY2Nlc3MiLCJjYW5SZWNvcmQiLCJiaW5kIiwiZ2V0Qm91bmRpbmdCb3hlcyIsIl90aGlzJGNvbnRleHQkY29uZmlnMyIsInRyYW5zZm9ybVJlc3VsdCIsInRyYW5zZm9ybWVkQm94ZXMiLCJTZXQiLCJiYXJjb2RlIiwiaGFzIiwiX3RoaXMzIiwicmVzdWx0Q29sbGVjdG9yIiwiaGFzQ29kZVJlc3VsdCIsInJlc3VsdFRvUHVibGlzaCIsIl9yZXN1bHQkYmFyY29kZXMiLCJFdmVudHMiLCJfbG9jYXRlQW5kRGVjb2RlIiwiX3RoaXMkY29udGV4dCRpbnB1dEltMyIsImRlY29kZVJlc3VsdCIsImltYWdlUmVzdWx0IiwiX3RoaXMkY29udGV4dCRpbnB1dEltNCIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsIl90aGlzJGNvbnRleHQkY29uZmlnNCIsIl90aGlzNCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwibm93IiwiX3RoaXMkY29udGV4dCRjb25maWc1IiwiX3RoaXMkY29udGV4dCRjb25maWc2IiwiX3N0b3AiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzciLCJfdGhpcyRjb250ZXh0JGlucHV0U3QiLCJpbnN0YW5jZSIsIlF1YWdnYUpTU3RhdGljSW50ZXJmYWNlIiwicXVhZ2dhSW5zdGFuY2UiLCJwcm9taXNlIiwiQ29uZmlnIiwic3RhcnRFcnIiLCJvbkRldGVjdGVkIiwib2ZmRGV0ZWN0ZWQiLCJvZmZQcm9jZXNzZWQiLCJyZWdpc3RlclJlc3VsdENvbGxlY3RvciIsImRlY29kZVNpbmdsZSIsInJlc3VsdENhbGxiYWNrIiwiZGVmYXVsdCIsIlJlYWRlcnMiLCJSZXN1bHRDb2xsZWN0b3IiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FB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QUEsa0JBQ0gsR0FBRztJQUFBMUgsd0JBQUEsQ0FBQTBILEtBQUEsa0JBQ0gsR0FBRztJQUFBMUgsd0JBQUEsQ0FBQTBILEtBQUEsZUFDTixHQUFHO0lBQUExSCx3QkFBQSxDQUFBMEgsS0FBQSxrQkFDQSxDQUNQLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDbEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMs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QU1sSix3QkFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDL0IsSUFBTW1KLGNBQWMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDWjtBQUMxQixJQUFNQyx1QkFBdUIsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3pDLElBQU1sSix1QkFBWSxHQUFHLENBQ2pCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ1osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENB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TUFBTSxFQUFFLFlBQU07VUFDcEJvakMsTUFBTSxDQUFDM2hCLElBQUksQ0FBQyxXQUFXLEVBQUUsVUFBQ3hsQixNQUFNLEVBQUs7WUFDakN5b0MsY0FBYyxDQUFDOWtCLElBQUksQ0FBQyxDQUFDO1lBQ3JCLElBQUl1bEIsY0FBYyxFQUFFO2NBQ2hCQSxjQUFjLENBQUMvd0MsSUFBSSxDQUFDLElBQUksRUFBRTZILE1BQU0sQ0FBQztZQUNyQztZQUNBeW1CLE9BQU8sQ0FBQ3ptQixNQUFNLENBQUM7VUFDbkIsQ0FBQyxFQUFFLElBQUksQ0FBQztVQUNSeW9DLGNBQWMsQ0FBQ3Y2QixLQUFLLENBQUMsQ0FBQztRQUMxQixDQUFDLEVBQUUsSUFBSSxFQUFFdTZCLGNBQWMsQ0FBQztNQUM1QixDQUFDLENBQUMsT0FBTy90QixHQUFHLEVBQUU7UUFDVnlMLE1BQU0sQ0FBQ3pMLEdBQUcsQ0FBQztNQUNmO0lBQ0osQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUNEO0VBQ0E7RUFDQSxJQUFJeXVCLE9BQU9BLENBQUEsRUFBRztJQUNWLE9BQU9YLHVCQUF1QjtFQUNsQyxDQUFDO0VBQ0RZLE9BQU8sRUFBUEEsc0JBQU87RUFDUGhELFlBQVksRUFBWkEsYUFBWTtFQUNacmtCLFVBQVUsRUFBVkEsV0FBVTtFQUNWL1ksWUFBWSxFQUFaQSxhQUFZO0VBQ1pxZ0MsZUFBZSxFQUFmQSxnQkFBZUE7QUFDbkIsQ0FBQztBQUVjYixtR0FBdUIsRUFBQztBQUN2QyIsImZpbGUiOiJxdWFnZ2EuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY4KTtcbiIsInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX2dldFByb3RvdHlwZU9mKHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZSAmJiBzZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiLy8gVE9ETyhCYWJlbCA4KTogUmVtb3ZlIHRoaXMgZmlsZS5cblxudmFyIHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWVcIikoKTtcbm1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9wYWNrYWdlcy9ydW50aW1lL3J1bnRpbWUuanMjTDczNj1cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKG4sIHQsIGUsIHIsIG8sIGEsIGMpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaSA9IG5bYV0oYyksXG4gICAgICB1ID0gaS52YWx1ZTtcbiAgfSBjYXRjaCAobikge1xuICAgIHJldHVybiB2b2lkIGUobik7XG4gIH1cbiAgaS5kb25lID8gdCh1KSA6IFByb21pc2UucmVzb2x2ZSh1KS50aGVuKHIsIG8pO1xufVxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3Iobikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ID0gdGhpcyxcbiAgICAgIGUgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyLCBvKSB7XG4gICAgICB2YXIgYSA9IG4uYXBwbHkodCwgZSk7XG4gICAgICBmdW5jdGlvbiBfbmV4dChuKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdGhyb3cobikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBuKTtcbiAgICAgIH1cbiAgICAgIF9uZXh0KHZvaWQgMCk7XG4gICAgfSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF90eXBlb2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0ID8gUmVmbGVjdC5nZXQuYmluZCgpIDogZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICB2YXIgcCA9IHN1cGVyUHJvcEJhc2UoZSwgdCk7XG4gICAgaWYgKHApIHtcbiAgICAgIHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCB0KTtcbiAgICAgIHJldHVybiBuLmdldCA/IG4uZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBlIDogcikgOiBuLnZhbHVlO1xuICAgIH1cbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfZ2V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKHIpIHx8IGl0ZXJhYmxlVG9BcnJheShyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IGFycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKFwiLi90b1ByaW1pdGl2ZS5qc1wiKTtcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX092ZXJsb2FkWWllbGQoZSwgZCkge1xuICB0aGlzLnYgPSBlLCB0aGlzLmsgPSBkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfT3ZlcmxvYWRZaWVsZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciByZWdlbmVyYXRvckRlZmluZSA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yRGVmaW5lLmpzXCIpO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkge1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2Jsb2IvbWFpbi9wYWNrYWdlcy9iYWJlbC1oZWxwZXJzL0xJQ0VOU0UgKi9cbiAgdmFyIGUsXG4gICAgdCxcbiAgICByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICBuID0gci5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICBvID0gci50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgZnVuY3Rpb24gaShyLCBuLCBvLCBpKSB7XG4gICAgdmFyIGMgPSBuICYmIG4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gbiA6IEdlbmVyYXRvcixcbiAgICAgIHUgPSBPYmplY3QuY3JlYXRlKGMucHJvdG90eXBlKTtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJfaW52b2tlXCIsIGZ1bmN0aW9uIChyLCBuLCBvKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgYyxcbiAgICAgICAgdSxcbiAgICAgICAgZiA9IDAsXG4gICAgICAgIHAgPSBvIHx8IFtdLFxuICAgICAgICB5ID0gITEsXG4gICAgICAgIEcgPSB7XG4gICAgICAgICAgcDogMCxcbiAgICAgICAgICBuOiAwLFxuICAgICAgICAgIHY6IGUsXG4gICAgICAgICAgYTogZCxcbiAgICAgICAgICBmOiBkLmJpbmQoZSwgNCksXG4gICAgICAgICAgZDogZnVuY3Rpb24gZCh0LCByKSB7XG4gICAgICAgICAgICByZXR1cm4gaSA9IHQsIGMgPSAwLCB1ID0gZSwgRy5uID0gciwgYTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBmdW5jdGlvbiBkKHIsIG4pIHtcbiAgICAgICAgZm9yIChjID0gciwgdSA9IG4sIHQgPSAwOyAheSAmJiBmICYmICFvICYmIHQgPCBwLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdmFyIG8sXG4gICAgICAgICAgICBpID0gcFt0XSxcbiAgICAgICAgICAgIGQgPSBHLnAsXG4gICAgICAgICAgICBsID0gaVsyXTtcbiAgICAgICAgICByID4gMyA/IChvID0gbCA9PT0gbikgJiYgKHUgPSBpWyhjID0gaVs0XSkgPyA1IDogKGMgPSAzLCAzKV0sIGlbNF0gPSBpWzVdID0gZSkgOiBpWzBdIDw9IGQgJiYgKChvID0gciA8IDIgJiYgZCA8IGlbMV0pID8gKGMgPSAwLCBHLnYgPSBuLCBHLm4gPSBpWzFdKSA6IGQgPCBsICYmIChvID0gciA8IDMgfHwgaVswXSA+IG4gfHwgbiA+IGwpICYmIChpWzRdID0gciwgaVs1XSA9IG4sIEcubiA9IGwsIGMgPSAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8gfHwgciA+IDEpIHJldHVybiBhO1xuICAgICAgICB0aHJvdyB5ID0gITAsIG47XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHAsIGwpIHtcbiAgICAgICAgaWYgKGYgPiAxKSB0aHJvdyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgICBmb3IgKHkgJiYgMSA9PT0gcCAmJiBkKHAsIGwpLCBjID0gcCwgdSA9IGw7ICh0ID0gYyA8IDIgPyBlIDogdSkgfHwgIXk7KSB7XG4gICAgICAgICAgaSB8fCAoYyA/IGMgPCAzID8gKGMgPiAxICYmIChHLm4gPSAtMSksIGQoYywgdSkpIDogRy5uID0gdSA6IEcudiA9IHUpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDIsIGkpIHtcbiAgICAgICAgICAgICAgaWYgKGMgfHwgKG8gPSBcIm5leHRcIiksIHQgPSBpW29dKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodCA9IHQuY2FsbChpLCB1KSkpIHRocm93IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIGlmICghdC5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB1ID0gdC52YWx1ZSwgYyA8IDIgJiYgKGMgPSAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIDEgPT09IGMgJiYgKHQgPSBpW1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoaSksIGMgPCAyICYmICh1ID0gVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBvICsgXCInIG1ldGhvZFwiKSwgYyA9IDEpO1xuICAgICAgICAgICAgICBpID0gZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHQgPSAoeSA9IEcubiA8IDApID8gdSA6IHIuY2FsbChuLCBHKSkgIT09IGEpIGJyZWFrO1xuICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgIGkgPSBlLCBjID0gMSwgdSA9IHQ7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGYgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB0LFxuICAgICAgICAgIGRvbmU6IHlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfShyLCBvLCBpKSwgITApLCB1O1xuICB9XG4gIHZhciBhID0ge307XG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuICB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgYyA9IFtdW25dID8gdCh0KFtdW25dKCkpKSA6IChyZWdlbmVyYXRvckRlZmluZSh0ID0ge30sIG4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCB0KSxcbiAgICB1ID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYyk7XG4gIGZ1bmN0aW9uIGYoZSkge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGUuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHJlZ2VuZXJhdG9yRGVmaW5lKGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodSksIGU7XG4gIH1cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCByZWdlbmVyYXRvckRlZmluZSh1LCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgcmVnZW5lcmF0b3JEZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiwgcmVnZW5lcmF0b3JEZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIHJlZ2VuZXJhdG9yRGVmaW5lKHUpLCByZWdlbmVyYXRvckRlZmluZSh1LCBvLCBcIkdlbmVyYXRvclwiKSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pLCAobW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3IgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6IGksXG4gICAgICBtOiBmXG4gICAgfTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3IsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgbiwgdCkge1xuICB2YXIgaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdHJ5IHtcbiAgICBpKHt9LCBcIlwiLCB7fSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpID0gMDtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvckRlZmluZSA9IGZ1bmN0aW9uIHJlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIG4sIHQpIHtcbiAgICBmdW5jdGlvbiBvKHIsIG4pIHtcbiAgICAgIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKHIsIG4sIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHIgPyBpID8gaShlLCByLCB7XG4gICAgICB2YWx1ZTogbixcbiAgICAgIGVudW1lcmFibGU6ICF0LFxuICAgICAgY29uZmlndXJhYmxlOiAhdCxcbiAgICAgIHdyaXRhYmxlOiAhdFxuICAgIH0pIDogZVtyXSA9IG4gOiAobyhcIm5leHRcIiwgMCksIG8oXCJ0aHJvd1wiLCAxKSwgbyhcInJldHVyblwiLCAyKSk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX3JlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIG4sIHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JEZWZpbmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgcmVnZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvci5qc1wiKTtcbnZhciByZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jSXRlcmF0b3IuanNcIik7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JBc3luY0dlbihyLCBlLCB0LCBvLCBuKSB7XG4gIHJldHVybiBuZXcgcmVnZW5lcmF0b3JBc3luY0l0ZXJhdG9yKHJlZ2VuZXJhdG9yKCkudyhyLCBlLCB0LCBvKSwgbiB8fCBQcm9taXNlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yQXN5bmNHZW4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgT3ZlcmxvYWRZaWVsZCA9IHJlcXVpcmUoXCIuL092ZXJsb2FkWWllbGQuanNcIik7XG52YXIgcmVnZW5lcmF0b3JEZWZpbmUgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckRlZmluZS5qc1wiKTtcbmZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IodCwgZSkge1xuICBmdW5jdGlvbiBuKHIsIG8sIGksIGYpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGMgPSB0W3JdKG8pLFxuICAgICAgICB1ID0gYy52YWx1ZTtcbiAgICAgIHJldHVybiB1IGluc3RhbmNlb2YgT3ZlcmxvYWRZaWVsZCA/IGUucmVzb2x2ZSh1LnYpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgbihcIm5leHRcIiwgdCwgaSwgZik7XG4gICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICBuKFwidGhyb3dcIiwgdCwgaSwgZik7XG4gICAgICB9KSA6IGUucmVzb2x2ZSh1KS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGMudmFsdWUgPSB0LCBpKGMpO1xuICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG4oXCJ0aHJvd1wiLCB0LCBpLCBmKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIGYodCk7XG4gICAgfVxuICB9XG4gIHZhciByO1xuICB0aGlzLm5leHQgfHwgKHJlZ2VuZXJhdG9yRGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgcmVnZW5lcmF0b3JEZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQGFzeW5jSXRlcmF0b3JcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSksIHJlZ2VuZXJhdG9yRGVmaW5lKHRoaXMsIFwiX2ludm9rZVwiLCBmdW5jdGlvbiAodCwgbywgaSkge1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgbih0LCBpLCBlLCByKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gciA9IHIgPyByLnRoZW4oZiwgZikgOiBmKCk7XG4gIH0sICEwKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXN5bmNJdGVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzLmpzXCIpO1xudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIik7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IHJlcXVpcmUoXCIuL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanNcIik7XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkge1xuICBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307XG4gIHZhciBvLFxuICAgIHIsXG4gICAgaSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgLTEgPT09IHQuaW5kZXhPZihvKSAmJiB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBiYXNlUGljayA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrJyksXG4gICAgZmxhdFJlc3QgPSByZXF1aXJlKCcuL19mbGF0UmVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGljaztcbiIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcih0KSB7XG4gIHZhciByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBNYXAgPyBuZXcgTWFwKCkgOiB2b2lkIDA7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKHQpIHtcbiAgICBpZiAobnVsbCA9PT0gdCB8fCAhaXNOYXRpdmVGdW5jdGlvbih0KSkgcmV0dXJuIHQ7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIGlmICh2b2lkIDAgIT09IHIpIHtcbiAgICAgIGlmIChyLmhhcyh0KSkgcmV0dXJuIHIuZ2V0KHQpO1xuICAgICAgci5zZXQodCwgV3JhcHBlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0KHQsIGFyZ3VtZW50cywgZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfVxuICAgIH0pLCBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCB0KTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfd3JhcE5hdGl2ZVN1cGVyKHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwiLypcclxuICogdHlwZWRlZnMuanNcclxuICogTm9ybWFsaXplcyBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzIGFuZCBwcm92aWRlIHNvbWUgYmFzaWMgcG9seWZpbGxzXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uICgvKiBmdW5jdGlvbiBGcmFtZVJlcXVlc3RDYWxsYmFjayAqLyBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5pZiAodHlwZW9mIE1hdGguaW11bCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xyXG4gICAgTWF0aC5pbXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhaCA9IChhID4+PiAxNikgJiAweGZmZmY7XHJcbiAgICAgICAgY29uc3QgYWwgPSBhICYgMHhmZmZmO1xyXG4gICAgICAgIGNvbnN0IGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZjtcclxuICAgICAgICBjb25zdCBibCA9IGIgJiAweGZmZmY7XHJcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydFxyXG4gICAgICAgIC8vIHRoZSBmaW5hbCB8MCBjb252ZXJ0cyB0aGUgdW5zaWduZWQgdmFsdWUgaW50byBhIHNpZ25lZCB2YWx1ZVxyXG4gICAgICAgIHJldHVybiAoKGFsICogYmwpICsgKCgoYWggKiBibCArIGFsICogYmgpIDw8IDE2KSA+Pj4gMCkgfCAwKTtcclxuICAgIH07XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cclxufVxyXG5cclxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkgeyAvLyAubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0byA9IE9iamVjdCh0YXJnZXQpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0U291cmNlLCBuZXh0S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIH07XHJcbn1cclxuIiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gITAsXG4gICAgICBvID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9ICEwLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1ByaW1pdGl2ZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbnZhciByZWdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmNHZW4gPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jR2VuLmpzXCIpO1xudmFyIHJlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoXCIuL3JlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvci5qc1wiKTtcbnZhciByZWdlbmVyYXRvcktleXMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvcktleXMuanNcIik7XG52YXIgcmVnZW5lcmF0b3JWYWx1ZXMgPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvclZhbHVlcy5qc1wiKTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciByID0gcmVnZW5lcmF0b3IoKSxcbiAgICBlID0gci5tKF9yZWdlbmVyYXRvclJ1bnRpbWUpLFxuICAgIHQgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpIDogZS5fX3Byb3RvX18pLmNvbnN0cnVjdG9yO1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICB2YXIgZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgciAmJiByLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiAhIWUgJiYgKGUgPT09IHQgfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUpKTtcbiAgfVxuICB2YXIgbyA9IHtcbiAgICBcInRocm93XCI6IDEsXG4gICAgXCJyZXR1cm5cIjogMixcbiAgICBcImJyZWFrXCI6IDMsXG4gICAgXCJjb250aW51ZVwiOiAzXG4gIH07XG4gIGZ1bmN0aW9uIGEocikge1xuICAgIHZhciBlLCB0O1xuICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgZSB8fCAoZSA9IHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICByZXR1cm4gdChuLmEsIDIpO1xuICAgICAgICB9LFxuICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gbi52O1xuICAgICAgICB9LFxuICAgICAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdChyLCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQobi5hLCBvW3JdLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChyLCBvLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIGUucmVzdWx0TmFtZSA9IG8sIHQobi5kLCByZWdlbmVyYXRvclZhbHVlcyhyKSwgYSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHIpIHtcbiAgICAgICAgICByZXR1cm4gdChuLmYsIHIpO1xuICAgICAgICB9XG4gICAgICB9LCB0ID0gZnVuY3Rpb24gdChyLCBfdCwgbykge1xuICAgICAgICBuLnAgPSBlLnByZXYsIG4ubiA9IGUubmV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcihfdCwgbyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZS5uZXh0ID0gbi5uO1xuICAgICAgICB9XG4gICAgICB9KSwgZS5yZXN1bHROYW1lICYmIChlW2UucmVzdWx0TmFtZV0gPSBuLnYsIGUucmVzdWx0TmFtZSA9IHZvaWQgMCksIGUuc2VudCA9IG4udiwgZS5uZXh0ID0gbi5uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHIuY2FsbCh0aGlzLCBlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG4ucCA9IGUucHJldiwgbi5uID0gZS5uZXh0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cmFwOiBmdW5jdGlvbiB3cmFwKGUsIHQsIG4sIG8pIHtcbiAgICAgICAgcmV0dXJuIHIudyhhKGUpLCB0LCBuLCBvICYmIG8ucmV2ZXJzZSgpKTtcbiAgICAgIH0sXG4gICAgICBpc0dlbmVyYXRvckZ1bmN0aW9uOiBuLFxuICAgICAgbWFyazogci5tLFxuICAgICAgYXdyYXA6IGZ1bmN0aW9uIGF3cmFwKHIsIGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybG9hZFlpZWxkKHIsIGUpO1xuICAgICAgfSxcbiAgICAgIEFzeW5jSXRlcmF0b3I6IHJlZ2VuZXJhdG9yQXN5bmNJdGVyYXRvcixcbiAgICAgIGFzeW5jOiBmdW5jdGlvbiBhc3luYyhyLCBlLCB0LCBvLCB1KSB7XG4gICAgICAgIHJldHVybiAobihlKSA/IHJlZ2VuZXJhdG9yQXN5bmNHZW4gOiByZWdlbmVyYXRvckFzeW5jKShhKHIpLCBlLCB0LCBvLCB1KTtcbiAgICAgIH0sXG4gICAgICBrZXlzOiByZWdlbmVyYXRvcktleXMsXG4gICAgICB2YWx1ZXM6IHJlZ2VuZXJhdG9yVmFsdWVzXG4gICAgfTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHJlZ2VuZXJhdG9yQXN5bmNHZW4gPSByZXF1aXJlKFwiLi9yZWdlbmVyYXRvckFzeW5jR2VuLmpzXCIpO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yQXN5bmMobiwgZSwgciwgdCwgbykge1xuICB2YXIgYSA9IHJlZ2VuZXJhdG9yQXN5bmNHZW4obiwgZSwgciwgdCwgbyk7XG4gIHJldHVybiBhLm5leHQoKS50aGVuKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uZG9uZSA/IG4udmFsdWUgOiBhLm5leHQoKTtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvckFzeW5jLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX3JlZ2VuZXJhdG9yS2V5cyhlKSB7XG4gIHZhciBuID0gT2JqZWN0KGUpLFxuICAgIHIgPSBbXTtcbiAgZm9yICh2YXIgdCBpbiBuKSByLnVuc2hpZnQodCk7XG4gIHJldHVybiBmdW5jdGlvbiBlKCkge1xuICAgIGZvciAoOyByLmxlbmd0aDspIGlmICgodCA9IHIucG9wKCkpIGluIG4pIHJldHVybiBlLnZhbHVlID0gdCwgZS5kb25lID0gITEsIGU7XG4gICAgcmV0dXJuIGUuZG9uZSA9ICEwLCBlO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JLZXlzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yVmFsdWVzKGUpIHtcbiAgaWYgKG51bGwgIT0gZSkge1xuICAgIHZhciB0ID0gZVtcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdLFxuICAgICAgciA9IDA7XG4gICAgaWYgKHQpIHJldHVybiB0LmNhbGwoZSk7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5uZXh0KSByZXR1cm4gZTtcbiAgICBpZiAoIWlzTmFOKGUubGVuZ3RoKSkgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBlICYmIHIgPj0gZS5sZW5ndGggJiYgKGUgPSB2b2lkIDApLCB7XG4gICAgICAgICAgdmFsdWU6IGUgJiYgZVtyKytdLFxuICAgICAgICAgIGRvbmU6ICFlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKF90eXBlb2YoZSkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclZhbHVlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZSh0LCBvKSB7XG4gIGZvciAoOyAhe30uaGFzT3duUHJvcGVydHkuY2FsbCh0LCBvKSAmJiBudWxsICE9PSAodCA9IGdldFByb3RvdHlwZU9mKHQpKTspO1xuICByZXR1cm4gdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2UsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkocik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGJhc2VQaWNrQnkgPSByZXF1aXJlKCcuL19iYXNlUGlja0J5JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGljaztcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTZXQgPSByZXF1aXJlKCcuL19iYXNlU2V0JyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGlja0J5O1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW4nKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdFJlc3Q7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbih0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIC0xICE9PSBGdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpO1xuICB9IGNhdGNoIChuKSB7XG4gICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVGdW5jdGlvbiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanNcIik7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QodCwgZSwgcikge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB2YXIgbyA9IFtudWxsXTtcbiAgby5wdXNoLmFwcGx5KG8sIGUpO1xuICB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpO1xuICByZXR1cm4gciAmJiBzZXRQcm90b3R5cGVPZihwLCByLnByb3RvdHlwZSksIHA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICB0cnkge1xuICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgfSBjYXRjaCAodCkge31cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cykoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8qKlxuICogQ29tbW9uIHV0aWxpdGllc1xuICogQG1vZHVsZSBnbE1hdHJpeFxuICovXG5cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCB2YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG5leHBvcnQgdmFyIEFOR0xFX09SREVSID0gXCJ6eXhcIjtcblxuLyoqXG4gKiBTeW1tZXRyaWMgcm91bmRcbiAqIHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yb3VuZC1oYWxmLXVwLXN5bW1ldHJpYyN1c2VyLWNvbnRlbnQtZGV0YWlsZWQtYmFja2dyb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIHZhbHVlIHRvIHJvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChhKSB7XG4gIGlmIChhID49IDApIHJldHVybiBNYXRoLnJvdW5kKGEpO1xuICByZXR1cm4gYSAlIDAuNSA9PT0gMCA/IE1hdGguZmxvb3IoYSkgOiBNYXRoLnJvdW5kKGEpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSkge1xuICBBUlJBWV9UWVBFID0gdHlwZTtcbn1cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xudmFyIHJhZGlhbiA9IDE4MCAvIE1hdGguUEk7XG5cbi8qKlxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IFJhZGlhbiBUbyBEZWdyZWVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBSYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZShhKSB7XG4gIHJldHVybiBhICogcmFkaWFuO1xufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3NcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSAgICAgICAgICBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gYiAgICAgICAgICBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZSAgQWJzb2x1dGUgb3IgcmVsYXRpdmUgdG9sZXJhbmNlIChkZWZhdWx0IGdsTWF0cml4LkVQU0lMT04pXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogRVBTSUxPTjtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSB0b2xlcmFuY2UgKiBNYXRoLm1heCgxLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufSIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIDJ4MiBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0MlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlXG4gIC8vIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTEgPSBhWzFdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYTE7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGFbMV07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MiB8IG51bGx9IG91dCwgb3IgbnVsbCBpZiBzb3VyY2UgbWF0cml4IGlzIG5vdCBpbnZlcnRpYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhMyAqIGRldDtcbiAgb3V0WzFdID0gLWExICogZGV0O1xuICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gIG91dFszXSA9IGEwICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lY2Vzc2FyeSBpZiBvdXQgPT0gYVxuICB2YXIgYTAgPSBhWzBdO1xuICBvdXRbMF0gPSBhWzNdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGEwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV0sXG4gICAgYTIgPSBhWzJdLFxuICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV0sXG4gICAgYTIgPSBhWzJdLFxuICAgIGEzID0gYVszXTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSArIGFbMl0gKiBhWzJdICsgYVszXSAqIGFbM10pO1xufVxuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBMRFUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXSAvIGFbMF07XG4gIFVbMF0gPSBhWzBdO1xuICBVWzFdID0gYVsxXTtcbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTtcbiAgcmV0dXJuIFtMLCBELCBVXTtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXSxcbiAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIHN5bW1ldHJpYyByb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gZ2xNYXRyaXgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IGdsTWF0cml4LnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHk7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlID09PSB1bmRlZmluZWQgPyAxLjAgOiBzY2FsZTtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCBiLCByYWQpIHtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICB2YXIgcDAgPSBhWzBdIC0gYlswXSxcbiAgICBwMSA9IGFbMV0gLSBiWzFdLFxuICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgIGNvc0MgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgb3V0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNtYWxsZXN0IGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdLFxuICAgIGJ4ID0gYlswXSxcbiAgICBieSA9IGJbMV07XG4gIHJldHVybiBNYXRoLmFicyhNYXRoLmF0YW4yKGF5ICogYnggLSBheCAqIGJ5LCBheCAqIGJ4ICsgYXkgKiBieSkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2lnbmVkIGFuZ2xlIGluIHRoZSBpbnRlcnZhbCBbLXBpLHBpXSBiZXR3ZWVuIHR3byAyRCB2ZWN0b3JzIChwb3NpdGl2ZSBpZiBgYWAgaXMgdG8gdGhlIHJpZ2h0IG9mIGBiYClcbiAqIFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3JcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzaWduZWQgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkQW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXSxcbiAgICBieCA9IGJbMF0sXG4gICAgYnkgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hdGFuMihheCAqIGJ5IC0gYXkgKiBieCwgYXggKiBieCArIGF5ICogYnkpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBzeW1tZXRyaWMgcm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IGdsTWF0cml4LnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBnbE1hdHJpeC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gZ2xNYXRyaXgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdLFxuICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICBieSA9IGJbMV0sXG4gICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYW5nbGUgPSBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoZG90KGEsIGIpLCAtMSksIDEpKTtcbiAgdmFyIHNpblRvdGFsID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oKDEgLSB0KSAqIGFuZ2xlKSAvIHNpblRvdGFsO1xuICB2YXIgcmF0aW9CID0gTWF0aC5zaW4odCAqIGFuZ2xlKSAvIHNpblRvdGFsO1xuICBvdXRbMF0gPSByYXRpb0EgKiBhWzBdICsgcmF0aW9CICogYlswXTtcbiAgb3V0WzFdID0gcmF0aW9BICogYVsxXSArIHJhdGlvQiAqIGJbMV07XG4gIG91dFsyXSA9IHJhdGlvQSAqIGFbMl0gKyByYXRpb0IgKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIHZhciBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIHZhciBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEuMCA6IHNjYWxlO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXSxcbiAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV0sXG4gICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIG5vcm1hbGl6ZWQgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgLy8gRmFzdCBWZWN0b3IgUm90YXRpb24gdXNpbmcgUXVhdGVybmlvbnMgYnkgUm9iZXJ0IEVpc2VsZVxuICAvLyBodHRwczovL3Jhdy5vcmcvcHJvb2YvdmVjdG9yLXJvdGF0aW9uLXVzaW5nLXF1YXRlcm5pb25zL1xuXG4gIHZhciBxeCA9IHFbMF0sXG4gICAgcXkgPSBxWzFdLFxuICAgIHF6ID0gcVsyXSxcbiAgICBxdyA9IHFbM107XG4gIHZhciB2eCA9IGFbMF0sXG4gICAgdnkgPSBhWzFdLFxuICAgIHZ6ID0gYVsyXTtcblxuICAvLyB0ID0gcSB4IHZcbiAgdmFyIHR4ID0gcXkgKiB2eiAtIHF6ICogdnk7XG4gIHZhciB0eSA9IHF6ICogdnggLSBxeCAqIHZ6O1xuICB2YXIgdHogPSBxeCAqIHZ5IC0gcXkgKiB2eDtcblxuICAvLyB0ID0gMnRcbiAgdHggPSB0eCArIHR4O1xuICB0eSA9IHR5ICsgdHk7XG4gIHR6ID0gdHogKyB0ejtcblxuICAvLyB2ICsgdyB0ICsgcSB4IHRcbiAgb3V0WzBdID0gdnggKyBxdyAqIHR4ICsgcXkgKiB0eiAtIHF6ICogdHk7XG4gIG91dFsxXSA9IHZ5ICsgcXcgKiB0eSArIHF6ICogdHggLSBxeCAqIHR6O1xuICBvdXRbMl0gPSB2eiArIHF3ICogdHogKyBxeCAqIHR5IC0gcXkgKiB0eDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFswXTtcbiAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhyYWQpIC0gcFsyXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMl0gPSBwWzFdICogTWF0aC5zaW4ocmFkKSArIHBbMl0gKiBNYXRoLmNvcyhyYWQpO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdLFxuICAgIGF6ID0gYVsyXSxcbiAgICBieCA9IGJbMF0sXG4gICAgYnkgPSBiWzFdLFxuICAgIGJ6ID0gYlsyXSxcbiAgICBtYWcgPSBNYXRoLnNxcnQoKGF4ICogYXggKyBheSAqIGF5ICsgYXogKiBheikgKiAoYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6KSksXG4gICAgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjMyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiKVwiO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSBcIi4vbWF0Mi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MmQgZnJvbSBcIi4vbWF0MmQuanNcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0My5qc1wiO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiLi9tYXQ0LmpzXCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL3F1YXQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQyIGZyb20gXCIuL3F1YXQyLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gXCIuL3ZlYzIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vdmVjMy5qc1wiO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tIFwiLi92ZWM0LmpzXCI7XG5leHBvcnQgeyBnbE1hdHJpeCwgbWF0MiwgbWF0MmQsIG1hdDMsIG1hdDQsIHF1YXQsIHF1YXQyLCB2ZWMyLCB2ZWMzLCB2ZWM0IH07IiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cclxuaW1wb3J0IHsgVHlwZWRBcnJheSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGluaXQoYXJyOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPiwgdmFsOiBudW1iZXIpIHtcclxuICAgICAgICBhcnIuZmlsbCh2YWwpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIElOLVBMQUNFIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHNodWZmbGUoYXJyOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgLy8gRHVyc3RlbmZlbGQgc2h1ZmZsZSBhbGdvcml0aG1cclxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDUwOTU0L2hvdy10by1yYW5kb21pemUtc2h1ZmZsZS1hLWphdmFzY3JpcHQtYXJyYXlcclxuICAgICAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgICAgICBbYXJyW2ldLCBhcnJbal1dID0gW2FycltqXSwgYXJyW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH0sXHJcblxyXG4gICAgdG9Qb2ludExpc3QoYXJyOiBBcnJheTxBcnJheTxudW1iZXI+Pikge1xyXG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGBbJHtuLmpvaW4oJywnKX1dYDtcclxuICAgICAgICAgICAgcC5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0sIFtdIGFzIEFycmF5PHN0cmluZz4pO1xyXG4gICAgICAgIHJldHVybiBgWyR7cm93cy5qb2luKCcsXFxyXFxuJyl9XWA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gICAgdGhyZXNob2xkKGFycjogQXJyYXk8bnVtYmVyPiwgdGhyZXNob2xkOiBudW1iZXIsIHNjb3JlRnVuYzogKChzY29yZTogbnVtYmVyKSA9PiBudW1iZXIpKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSBhcnIucmVkdWNlKChwcmV2OiBBcnJheTxudW1iZXI+LCBuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcHJldi5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICByZXR1cm4gcXVldWU7XHJcbiAgICB9LFxyXG5cclxuICAgIG1heEluZGV4KGFycjogQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIGxldCBtYXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfSxcclxuXHJcbiAgICBtYXgoYXJyOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgbGV0IG1heCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFycltpXSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9LFxyXG5cclxuICAgIHN1bShhcnI6IEFycmF5PG51bWJlcj4gfCBUeXBlZEFycmF5KTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGFycjtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH0sXHJcbn07XHJcbiIsIi8vIFRPRE86IGNsdXN0ZXIuanMgYW5kIGN2X3V0aWxzLmpzIGFyZSBwcmV0dHkgdGlnaHRseSBpbnRlcnR3aW5lZCwgbWFraW5nIGZvciBhIGNvbXBsZXggY29udmVyc2lvblxyXG4vLyBpbnRvIHR5cGVzY3JpcHQuIGJlIHdhcm5lZC4gOi0pXHJcblxyXG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2x1c3RlciBmb3IgZ3JvdXBpbmcgc2ltaWxhciBvcmllbnRhdGlvbnMgb2YgZGF0YXBvaW50c1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpIHtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcclxuICAgICAgICBjb25zdCBjZW50ZXIgPSB7XHJcbiAgICAgICAgICAgIHJhZDogMCxcclxuICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFswLCAwXSksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwb2ludE1hcCA9IHt9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGQocG9pbnRUb0FkZCkge1xyXG4gICAgICAgICAgICBwb2ludE1hcFtwb2ludFRvQWRkLmlkXSA9IHBvaW50VG9BZGQ7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9BZGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgaTsgbGV0XHJcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gcG9pbnRzW2ldLnJhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgY2VudGVyLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKGNlbnRlci5yYWQpLCBNYXRoLnNpbihjZW50ZXIucmFkKV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgICAgICAgICAgYWRkKHBvaW50KTtcclxuICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbml0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50TWFwW3BvaW50VG9BZGQuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmaXRzKG90aGVyUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvc2luZSBzaW1pbGFyaXR5IHRvIGNlbnRlci1hbmdsZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KG90aGVyUG9pbnQucG9pbnQudmVjLCBjZW50ZXIudmVjKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRQb2ludHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRDZW50ZXIoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlUG9pbnQobmV3UG9pbnQsIGlkLCBwcm9wZXJ0eSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxyXG4gICAgICAgICAgICBwb2ludDogbmV3UG9pbnQsXHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xyXG5pbXBvcnQgeyB2ZWMyLCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcclxuaW1wb3J0IENsdXN0ZXIyIGZyb20gJy4vY2x1c3Rlcic7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHggeC1jb29yZGluYXRlXHJcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxyXG4gKiBAcmV0dXJuIEltYWdlUmVmZXJlbmNlIHt4LHl9IENvb3JkaW5hdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XHJcbiAgICBjb25zdCB0aGF0ID0ge1xyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgICAgICB0b1ZlYzIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLmNsb25lKFt0aGlzLngsIHRoaXMueV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9WZWMzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmVjMy5jbG9uZShbdGhpcy54LCB0aGlzLnksIDFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdW5kKCkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueCArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueCAtIDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gdGhhdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFuIGludGVncmFsIGltYWdlIG9mIGEgZ2l2ZW4gZ3JheXNjYWxlIGltYWdlLlxyXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UyKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xyXG4gICAgbGV0IHN1bSA9IDA7IGxldCBwb3NBID0gMDsgbGV0IHBvc0IgPSAwOyBsZXQgcG9zQyA9IDA7IGxldCBwb3NEID0gMDsgbGV0IHg7IGxldFxyXG4gICAgICAgIHk7XHJcblxyXG4gICAgLy8gc3VtIHVwIGZpcnN0IGNvbHVtblxyXG4gICAgcG9zQiA9IHdpZHRoO1xyXG4gICAgc3VtID0gMDtcclxuICAgIGZvciAoeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XHJcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xyXG4gICAgICAgIHBvc0EgKz0gd2lkdGg7XHJcbiAgICAgICAgcG9zQiArPSB3aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBwb3NBID0gMDtcclxuICAgIHBvc0IgPSAxO1xyXG4gICAgc3VtID0gMDtcclxuICAgIGZvciAoeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcclxuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XHJcbiAgICAgICAgcG9zQSsrO1xyXG4gICAgICAgIHBvc0IrKztcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICBwb3NBID0geSAqIHdpZHRoICsgMTtcclxuICAgICAgICBwb3NCID0gKHkgLSAxKSAqIHdpZHRoICsgMTtcclxuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xyXG4gICAgICAgIHBvc0QgPSAoeSAtIDEpICogd2lkdGg7XHJcbiAgICAgICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cclxuICAgICAgICAgICAgICAgICs9IGltYWdlRGF0YVtwb3NBXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQ10gLSBpbnRlZ3JhbEltYWdlRGF0YVtwb3NEXTtcclxuICAgICAgICAgICAgcG9zQSsrO1xyXG4gICAgICAgICAgICBwb3NCKys7XHJcbiAgICAgICAgICAgIHBvc0MrKztcclxuICAgICAgICAgICAgcG9zRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgLy8gc3VtIHVwIGZpcnN0IHJvd1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtpXTtcclxuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtpXSA9IHN1bTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCB2ID0gMTsgdiA8IGhlaWdodDsgdisrKSB7XHJcbiAgICAgICAgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XTtcclxuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpIHtcclxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTsgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZURhdGE7IGNvbnN0XHJcbiAgICAgICAgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICB0YXJnZXREYXRhW2xlbmd0aF0gPSBpbWFnZURhdGFbbGVuZ3RoXSA8IHRocmVzaG9sZCA/IDEgOiAwO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xyXG4gICAgaWYgKCFiaXRzUGVyUGl4ZWwpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcclxuICAgIGNvbnN0IGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcclxuICAgIGNvbnN0IGJ1Y2tldENudCA9IDEgPDwgYml0c1BlclBpeGVsO1xyXG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XHJcblxyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcclxuICAgIH1cclxuICAgIHJldHVybiBoaXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2hhcnBlbkxpbmUobGluZSkge1xyXG4gICAgbGV0IGk7XHJcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gbGluZTtcclxuICAgIGxldCBsZWZ0ID0gbGluZVswXTtcclxuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xyXG4gICAgbGV0IHJpZ2h0O1xyXG5cclxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICByaWdodCA9IGxpbmVbaSArIDFdO1xyXG4gICAgICAgIC8vICAtMSA0IC0xIGtlcm5lbFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGxpbmVbaSAtIDFdID0gKCgoY2VudGVyICogMikgLSBsZWZ0IC0gcmlnaHQpKSAmIDI1NTtcclxuICAgICAgICBsZWZ0ID0gY2VudGVyO1xyXG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsID0gOCkge1xyXG4gICAgbGV0IGhpc3Q7XHJcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XHJcblxyXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXgoaW5pdCwgZW5kKSB7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xyXG4gICAgICAgIGNvbnN0IHZldCA9IFswXTtcclxuICAgICAgICBsZXQgcDE7XHJcbiAgICAgICAgbGV0IHAyO1xyXG4gICAgICAgIGxldCBwMTI7XHJcbiAgICAgICAgbGV0IG0xO1xyXG4gICAgICAgIGxldCBtMjtcclxuICAgICAgICBsZXQgbTEyO1xyXG4gICAgICAgIGNvbnN0IG1heCA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xyXG5cclxuICAgICAgICBoaXN0ID0gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCk7XHJcbiAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBtYXg7IGsrKykge1xyXG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xyXG4gICAgICAgICAgICBwMiA9IHB4KGsgKyAxLCBtYXgpO1xyXG4gICAgICAgICAgICBwMTIgPSBwMSAqIHAyO1xyXG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwMTIgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcclxuICAgICAgICAgICAgbTIgPSBteChrICsgMSwgbWF4KSAqIHAxO1xyXG4gICAgICAgICAgICBtMTIgPSBtMSAtIG0yO1xyXG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBcnJheUhlbHBlci5tYXhJbmRleCh2ZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZVRocmVzaG9sZCgpO1xyXG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlcik7XHJcblxyXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xyXG4gICAgcmV0dXJuIHRocmVzaG9sZDtcclxufVxyXG5cclxuLy8gbG9jYWwgdGhyZXNob2xkaW5nXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQmluYXJ5SW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcclxuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcclxuXHJcbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICB0YXJnZXRXcmFwcGVyID0gaW1hZ2VXcmFwcGVyO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XHJcbiAgICBsZXQgc3VtID0gMDsgbGV0IHY7IGxldCB1OyBjb25zdCBrZXJuZWwgPSAzOyBsZXQgQTsgbGV0IEI7IGxldCBDOyBsZXQgRDsgbGV0IGF2ZzsgY29uc3RcclxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XHJcblxyXG4gICAgLy8gY2xlYXIgb3V0IHRvcCAmIGJvdHRvbS1ib3JkZXJcclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcclxuICAgICAgICBmb3IgKHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xyXG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XHJcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2xlYXIgb3V0IGxlZnQgJiByaWdodCBib3JkZXJcclxuICAgIGZvciAodiA9IGtlcm5lbDsgdiA8IGhlaWdodCAtIGtlcm5lbDsgdisrKSB7XHJcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xyXG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XHJcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArICh3aWR0aCAtIDEgLSB1KV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XHJcbiAgICAgICAgZm9yICh1ID0ga2VybmVsICsgMTsgdSA8IHdpZHRoIC0ga2VybmVsOyB1KyspIHtcclxuICAgICAgICAgICAgQSA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xyXG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcclxuICAgICAgICAgICAgQyA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XHJcbiAgICAgICAgICAgIEQgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XHJcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XHJcbiAgICAgICAgICAgIGF2ZyA9IHN1bSAvIChzaXplKTtcclxuICAgICAgICAgICAgdGFyZ2V0RGF0YVt2ICogd2lkdGggKyB1XSA9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA+IChhdmcgKyA1KSA/IDAgOiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsdXN0ZXIocG9pbnRzLCB0aHJlc2hvbGQsIHByb3BlcnR5KSB7XHJcbiAgICBsZXQgaTsgbGV0IGs7IGxldCB0aGlzQ2x1c3RlcjsgbGV0IHBvaW50OyBjb25zdFxyXG4gICAgICAgIGNsdXN0ZXJzID0gW107XHJcblxyXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIHByb3BlcnR5ID0gJ3JhZCc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkVG9DbHVzdGVyKG5ld1BvaW50KSB7XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIHRoaXNDbHVzdGVyID0gY2x1c3RlcnNba107XHJcbiAgICAgICAgICAgIGlmICh0aGlzQ2x1c3Rlci5maXRzKG5ld1BvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGVhY2ggY2xvdWRcclxuICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xyXG4gICAgICAgIGlmICghYWRkVG9DbHVzdGVyKHBvaW50KSkge1xyXG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKENsdXN0ZXIyLmNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVHJhY2VyID0ge1xyXG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcclxuICAgICAgICBsZXQgaXRlcmF0aW9uO1xyXG4gICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAxMDtcclxuICAgICAgICBsZXQgdG9wID0gW107XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGxldCBjZW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoaWR4LCBmb3J3YXJkKSB7XHJcbiAgICAgICAgICAgIGxldCB0bztcclxuICAgICAgICAgICAgbGV0IHRvSWR4O1xyXG4gICAgICAgICAgICBsZXQgcHJlZGljdGVkUG9zO1xyXG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcclxuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkWSA9IE1hdGguYWJzKHZlY1sxXSAvIDEwKTtcclxuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaChwb3MsIHByZWRpY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcy54ID4gKHByZWRpY3RlZC54IC0gdGhyZXNob2xkWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueSA+IChwcmVkaWN0ZWQueSAtIHRocmVzaG9sZFkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55IDwgKHByZWRpY3RlZC55ICsgdGhyZXNob2xkWSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5leHQgaW5kZXggaXMgd2l0aGluIHRoZSB2ZWMgc3BlY2lmaWNhdGlvbnNcclxuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gcG9pbnRzW2lkeF07XHJcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54ICsgdmVjWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54IC0gdmVjWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSAtIHZlY1sxXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xyXG4gICAgICAgICAgICB0byA9IHBvaW50c1t0b0lkeF07XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxyXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcclxuICAgICAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IHRvSWR4ICsgMSA6IHRvSWR4IC0gMTtcclxuICAgICAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gdG9JZHggOiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xyXG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxyXG4gICAgICAgICAgICBjZW50ZXJQb3MgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcclxuICAgICAgICAgICAgdG9wID0gW107XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XHJcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxyXG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCB0cnVlKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNlbnRlclBvcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cclxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIGZhbHNlKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodG9wLmxlbmd0aCA+IHJlc3VsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xyXG5leHBvcnQgY29uc3QgRVJPREUgPSAyO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICBsZXQgdjtcclxuICAgIGxldCB1O1xyXG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGxldCBzdW07XHJcbiAgICBsZXQgeVN0YXJ0MTtcclxuICAgIGxldCB5U3RhcnQyO1xyXG4gICAgbGV0IHhTdGFydDE7XHJcbiAgICBsZXQgeFN0YXJ0MjtcclxuXHJcbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XHJcbiAgICAgICAgZm9yICh1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XHJcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcclxuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xyXG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XHJcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcclxuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxyXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdXHJcbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcclxuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID4gMCA/IDEgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcclxuICAgIGxldCB2O1xyXG4gICAgbGV0IHU7XHJcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgbGV0IHN1bTtcclxuICAgIGxldCB5U3RhcnQxO1xyXG4gICAgbGV0IHlTdGFydDI7XHJcbiAgICBsZXQgeFN0YXJ0MTtcclxuICAgIGxldCB4U3RhcnQyO1xyXG5cclxuICAgIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcclxuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcclxuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xyXG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XHJcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcclxuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xyXG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdXHJcbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cclxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xyXG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPT09IDUgPyAxIDogMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcclxuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcclxuICAgIH1cclxuICAgIGxldCB7IGxlbmd0aCB9ID0gYUltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XHJcblxyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIC0gYkltYWdlRGF0YVtsZW5ndGhdO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xyXG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xyXG4gICAgfVxyXG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gfHwgYkltYWdlRGF0YVtsZW5ndGhdO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xyXG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHsgZGF0YSB9ID0gaW1hZ2VXcmFwcGVyO1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdW07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b3BHZW5lcmljKGxpc3QsIHRvcCwgc2NvcmVGdW5jKSB7XHJcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxyXG4gICAgICAgIHBvcztcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcclxuICAgICAgICBxdWV1ZVtpXSA9IHtcclxuICAgICAgICAgICAgc2NvcmU6IDAsXHJcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHNjb3JlID0gc2NvcmVGdW5jLmFwcGx5KHRoaXMsIFtsaXN0W2ldXSk7XHJcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XHJcbiAgICAgICAgICAgIGhpdCA9IHF1ZXVlW21pbklkeF07XHJcbiAgICAgICAgICAgIGhpdC5zY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XHJcbiAgICAgICAgICAgIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIGZvciAocG9zID0gMDsgcG9zIDwgdG9wOyBwb3MrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBxdWV1ZVtwb3NdLnNjb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbklkeCA9IHBvcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcXVldWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tSW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCBjdHgsIGFycmF5KSB7XHJcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcclxuICAgIGNvbnN0IGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCkuZGF0YTtcclxuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21Db250ZXh0KGN0eCwgc2l6ZSwgb2Zmc2V0LCBhcnJheSkge1xyXG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcclxuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY2FudmFzRGF0YSwgc2l6ZSwgb3V0QXJyYXkpIHtcclxuICAgIGxldCB0b3BSb3dJZHggPSAwO1xyXG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcclxuICAgIGNvbnN0IGVuZElkeCA9IE1hdGguZmxvb3IoY2FudmFzRGF0YS5sZW5ndGggLyA0KTtcclxuICAgIGNvbnN0IG91dFdpZHRoID0gc2l6ZS54IC8gMjtcclxuICAgIGxldCBvdXRJbWdJZHggPSAwO1xyXG4gICAgY29uc3QgaW5XaWR0aCA9IHNpemUueDtcclxuICAgIGxldCBpO1xyXG5cclxuICAgIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW1nSWR4XSA9IChcclxuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDBdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDJdKVxyXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAwXVxyXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxyXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAyXSlcclxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAwXVxyXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMl0pXHJcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDBdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDJdKSkgLyA0O1xyXG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcclxuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XHJcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcclxuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVHcmF5KGltYWdlRGF0YSwgb3V0QXJyYXksIGNvbmZpZykge1xyXG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xyXG4gICAgY29uc3Qgc2luZ2xlQ2hhbm5lbCA9IGNvbmZpZyAmJiBjb25maWcuc2luZ2xlQ2hhbm5lbCA9PT0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgIG91dEFycmF5W2ldID0gMC4yOTkgKiBpbWFnZURhdGFbaSAqIDQgKyAwXSArIDAuNTg3ICogaW1hZ2VEYXRhW2kgKiA0ICsgMV0gKyAwLjExNCAqIGltYWdlRGF0YVtpICogNCArIDJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRJbWFnZUFycmF5KHNyYywgY2FsbGJhY2ssIGNhbnZhcyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKSB7XHJcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICBjb25zb2xlLndhcm4oJyogbG9hZEltYWdlQXJyYXkgZ2V0Q29udGV4dCAyZCcpO1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayhhcnJheSwge1xyXG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBpbWcuc3JjID0gc3JjO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIGluSW1nIHtJbWFnZVdyYXBwZXJ9IGlucHV0IGltYWdlIHRvIGJlIHNhbXBsZWRcclxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYWxmU2FtcGxlKGluSW1nV3JhcHBlciwgb3V0SW1nV3JhcHBlcikge1xyXG4gICAgY29uc3QgaW5JbWcgPSBpbkltZ1dyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xyXG4gICAgY29uc3Qgb3V0SW1nID0gb3V0SW1nV3JhcHBlci5kYXRhO1xyXG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XHJcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcclxuICAgIGNvbnN0IGVuZElkeCA9IGluSW1nLmxlbmd0aDtcclxuICAgIGNvbnN0IG91dFdpZHRoID0gaW5XaWR0aCAvIDI7XHJcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcclxuICAgIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxyXG4gICAgICAgICAgICAgICAgKGluSW1nW3RvcFJvd0lkeF0gKyBpbkltZ1t0b3BSb3dJZHggKyAxXSArIGluSW1nW2JvdHRvbVJvd0lkeF0gKyBpbkltZ1tib3R0b21Sb3dJZHggKyAxXSkgLyA0LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcclxuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XHJcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcclxuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcclxuICAgIGNvbnN0IGggPSBoc3ZbMF07XHJcbiAgICBjb25zdCBzID0gaHN2WzFdO1xyXG4gICAgY29uc3QgdiA9IGhzdlsyXTtcclxuICAgIGNvbnN0IGMgPSB2ICogcztcclxuICAgIGNvbnN0IHggPSBjICogKDEgLSBNYXRoLmFicygoaCAvIDYwKSAlIDIgLSAxKSk7XHJcbiAgICBjb25zdCBtID0gdiAtIGM7XHJcbiAgICBsZXQgciA9IDA7XHJcbiAgICBsZXQgZyA9IDA7XHJcbiAgICBsZXQgYiA9IDA7XHJcblxyXG4gICAgaWYgKGggPCA2MCkge1xyXG4gICAgICAgIHIgPSBjO1xyXG4gICAgICAgIGcgPSB4O1xyXG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XHJcbiAgICAgICAgciA9IHg7XHJcbiAgICAgICAgZyA9IGM7XHJcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcclxuICAgICAgICBnID0gYztcclxuICAgICAgICBiID0geDtcclxuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xyXG4gICAgICAgIGcgPSB4O1xyXG4gICAgICAgIGIgPSBjO1xyXG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XHJcbiAgICAgICAgciA9IHg7XHJcbiAgICAgICAgYiA9IGM7XHJcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcclxuICAgICAgICByID0gYztcclxuICAgICAgICBiID0geDtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgcmdiWzBdID0gKChyICsgbSkgKiAyNTUpIHwgMDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgcmdiWzJdID0gKChiICsgbSkgKiAyNTUpIHwgMDtcclxuICAgIHJldHVybiByZ2I7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcclxuICAgIC8vIEhhbmRsZSBlZGdlIGNhc2VzXHJcbiAgICAvLyBOYU46IE5vdCBhIG51bWJlciAtIG5vIG1lYW5pbmdmdWwgZGl2aXNvcnNcclxuICAgIC8vIEluZmluaXR5OiBJbmZpbml0ZSB2YWx1ZXMgaGF2ZSBubyBmaW5pdGUgZGl2aXNvcnNcclxuICAgIC8vIE5vbi1wb3NpdGl2ZTogRGl2aXNvcnMgYXJlIHR5cGljYWxseSBkZWZpbmVkIGZvciBwb3NpdGl2ZSBpbnRlZ2VycyBvbmx5XHJcbiAgICAvLyBXaGlsZSBuZWdhdGl2ZSBudW1iZXJzIHRlY2huaWNhbGx5IGhhdmUgZGl2aXNvcnMsIHJldHVybmluZyB0aGVtIHdvdWxkIGNvbXBsaWNhdGVcclxuICAgIC8vIHRoZSBBUEkgKHdvdWxkIG5lZWQgdG8gcmV0dXJuIGJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGRpdmlzb3JzLCBvciBtYWtlIGFzc3VtcHRpb25zKVxyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobikgfHwgbiA8IDEpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGFyZ2VEaXZpc29ycyA9IFtdO1xyXG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcclxuICAgIGNvbnN0IHNxcnROID0gTWF0aC5zcXJ0KG4pO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNxcnROOyBpKyspIHtcclxuICAgICAgICBpZiAobiAlIGkgPT09IDApIHtcclxuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcclxuICAgICAgICAgICAgLy8gT25seSBhZGQgdGhlIGNvbXBsZW1lbnRhcnkgZGl2aXNvciBpZiBpdCdzIGRpZmZlcmVudCAobm90IGEgcGVyZmVjdCBzcXVhcmUgcm9vdClcclxuICAgICAgICAgICAgaWYgKGkgIT09IG4gLyBpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXJnZURpdmlzb3JzLnVuc2hpZnQoTWF0aC5mbG9vcihuIC8gaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgbGV0IGogPSAwO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcblxyXG4gICAgd2hpbGUgKGkgPCBhcnIxLmxlbmd0aCAmJiBqIDwgYXJyMi5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnIxW2ldKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcnIxW2ldID4gYXJyMltqXSkge1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQYXRjaFNpemUocGF0Y2hTaXplLCBpbWdTaXplKSB7XHJcbiAgICBjb25zdCBkaXZpc29yc1ggPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueCk7XHJcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XHJcbiAgICBjb25zdCB3aWRlU2lkZSA9IE1hdGgubWF4KGltZ1NpemUueCwgaW1nU2l6ZS55KTtcclxuICAgIGNvbnN0IGNvbW1vbiA9IF9jb21wdXRlSW50ZXJzZWN0aW9uKGRpdmlzb3JzWCwgZGl2aXNvcnNZKTtcclxuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcclxuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTWFwID0ge1xyXG4gICAgICAgICd4LXNtYWxsJzogNSxcclxuICAgICAgICBzbWFsbDogNCxcclxuICAgICAgICBtZWRpdW06IDMsXHJcbiAgICAgICAgbGFyZ2U6IDIsXHJcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IG5yT2ZQYXRjaGVzSWR4ID0gbnJPZlBhdGNoZXNNYXBbcGF0Y2hTaXplXSB8fCBuck9mUGF0Y2hlc01hcC5tZWRpdW07XHJcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XHJcbiAgICBjb25zdCBkZXNpcmVkUGF0Y2hTaXplID0gTWF0aC5mbG9vcih3aWRlU2lkZSAvIG5yT2ZQYXRjaGVzKTtcclxuICAgIGxldCBvcHRpbWFsUGF0Y2hTaXplO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhkaXZpc29ycykge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPCAoZGl2aXNvcnMubGVuZ3RoIC0gMSkgJiYgZGl2aXNvcnNbaV0gPCBkZXNpcmVkUGF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaSAtIDFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXHJcbiAgICAgICAgICAgICYmIGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA+IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCAtIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBmb3VuZCwgeTogZm91bmQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhjb21tb24pO1xyXG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XHJcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XHJcbiAgICAgICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoKF9jb21wdXRlRGl2aXNvcnMoZGVzaXJlZFBhdGNoU2l6ZSAqIG5yT2ZQYXRjaGVzKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZhbGxiYWNrOiBpZiBubyBvcHRpbWFsIHBhdGNoIHNpemUgZm91bmQsIHVzZSBpbWFnZSBzaXplIChvciAxeDEgbWluaW11bSlcclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgZnVuY3Rpb24gYWx3YXlzIHJldHVybnMgYSB2YWxpZCB7eCwgeX0gb2JqZWN0XHJcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcclxuICAgICAgICBvcHRpbWFsUGF0Y2hTaXplID0ge1xyXG4gICAgICAgICAgICB4OiBNYXRoLm1heCgxLCBpbWdTaXplLngpLFxyXG4gICAgICAgICAgICB5OiBNYXRoLm1heCgxLCBpbWdTaXplLnkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3B0aW1hbFBhdGNoU2l6ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSkge1xyXG4gICAgY29uc3QgZGltZW5zaW9uID0ge1xyXG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcclxuICAgICAgICB1bml0OiB2YWx1ZS5pbmRleE9mKCclJykgPT09IHZhbHVlLmxlbmd0aCAtIDEgPyAnJScgOiAnJScsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBkaW1lbnNpb247XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBfZGltZW5zaW9uc0NvbnZlcnRlcnMgPSB7XHJcbiAgICB0b3AoZGltZW5zaW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcclxuICAgIH0sXHJcbiAgICByaWdodChkaW1lbnNpb24sIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XHJcbiAgICB9LFxyXG4gICAgYm90dG9tKGRpbWVuc2lvbiwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xyXG4gICAgfSxcclxuICAgIGxlZnQoZGltZW5zaW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW1hZ2VBcmVhKGlucHV0V2lkdGgsIGlucHV0SGVpZ2h0LCBhcmVhKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0geyB3aWR0aDogaW5wdXRXaWR0aCwgaGVpZ2h0OiBpbnB1dEhlaWdodCB9O1xyXG5cclxuICAgIGNvbnN0IHBhcnNlZEFyZWEgPSBPYmplY3Qua2V5cyhhcmVhKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmVhW2tleV07XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcclxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkID0gX2RpbWVuc2lvbnNDb252ZXJ0ZXJzW2tleV0ocGFyc2VkLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxjdWxhdGVkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxyXG4gICAgICAgIHN5OiBwYXJzZWRBcmVhLnRvcCxcclxuICAgICAgICBzdzogcGFyc2VkQXJlYS5yaWdodCAtIHBhcnNlZEFyZWEubGVmdCxcclxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcclxuICAgIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XHJcbmltcG9ydCB7XHJcbiAgICBYWVNpemUsXHJcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXHJcbiAgICBUeXBlZEFycmF5LFxyXG4gICAgV3JhcHBlckluZGV4TWFwcGluZyxcclxuICAgIE1vbWVudCxcclxuICAgIFNwYXJzZUltYWdlV3JhcHBlcixcclxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcclxuaW1wb3J0IHsgaHN2MnJnYiB9IGZyb20gJy4vY3ZfdXRpbHMnO1xyXG5cclxudHlwZSBQb3NpdGl2ZU51bWJlciA9IG51bWJlcjtcclxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XHJcbiAgICBpZiAodmFsIDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyLCByZWNlaXZlZCAke3ZhbH1gKTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcclxuICAgIGRhdGE6IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+O1xyXG5cclxuICAgIHNpemU6IFhZU2l6ZTtcclxuXHJcbiAgICBpbmRleE1hcHBpbmc/OiBXcmFwcGVySW5kZXhNYXBwaW5nO1xyXG5cclxuICAgIC8vIFJlcHJlc2VudHMgYSBiYXNpYyBpbWFnZSBjb21iaW5pbmcgdGhlIGRhdGEgYW5kIHNpemUuIEluIGFkZGl0aW9uLCBzb21lIG1ldGhvZHMgZm9yXHJcbiAgICAvLyBtYW5pcHVsYXRpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4uXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBzaXplOiBYWVNpemUsXHJcbiAgICAgICAgZGF0YT86IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LFxyXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXHJcbiAgICAgICAgaW5pdGlhbGl6ZT86IGJvb2xlYW4sXHJcbiAgICApIHtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IChBcnJheVR5cGUpKHNpemUueCAqIHNpemUueSk7XHJcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRlc3RzIGlmIGEgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbWFnZSwgZXh0ZW5kZWQgb3V0IGJ5IGEgYm9yZGVyIG9uIGVhY2ggc2lkZVxyXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XHJcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoYm9yZGVyKTtcclxuICAgICAgICByZXR1cm4gKGltZ1JlZi54ID49IDApXHJcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA+PSAwKVxyXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggKyAoYm9yZGVyICogMikpKVxyXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPCAodGhpcy5zaXplLnkgKyAoYm9yZGVyICogMikpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb3B5IGZyb20gVEhJUyBJbWFnZVdyYXBwZXIgdG8gdGhlIG5ldyBpbWFnZVdyYXBwZXIgcGFyYW1ldGVyLCBzdGFydGluZyBhdCBmcm9tLCBzdG9wcGluZyBhdFxyXG4gICAgLy8gZW5kIG9mIG5ldyBpbWFnZVdyYXBwZXIgc2l6ZS5cclxuICAgIHN1YkltYWdlQXNDb3B5KGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyLCBmcm9tOiBYWVNpemUpOiBJbWFnZVdyYXBwZXIge1xyXG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueCk7XHJcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS55KTtcclxuICAgICAgICBjb25zdCB7IHg6IHNpemVYLCB5OiBzaXplWSB9ID0gaW1hZ2VXcmFwcGVyLnNpemU7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplWDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZVk7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YVt5ICogc2l6ZVggKyB4XSA9IHRoaXMuZGF0YVsoZnJvbS55ICsgeSkgKiB0aGlzLnNpemUueCArIGZyb20ueCArIHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWFnZVdyYXBwZXI7XHJcbiAgICAgICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiByZWFsbHkgcHJvYmFibHkgc2hvdWxkIGNhbGwgaW50byBJbWFnZVdyYXBwZXIgc29tZXdoZXJlIHRvIG1ha2VcclxuICAgICAgICAvLyBzdXJlIHRoYXQgYWxsIG9mIGl0J3MgcGFyYW1ldGVycyBhcmUgc2V0IHByb3Blcmx5LCBzb21ldGhpbmcgbGlrZVxyXG4gICAgICAgIC8vIEltYWdlV3JhcHBlci5VcGRhdGVGcm9tKClcclxuICAgICAgICAvLyB0aGF0IG1pZ2h0IHRha2UgYSBwcm92aWRlZCBkYXRhIGFuZCBzaXplLCBhbmQgbWFrZSBzdXJlIHRoZXJlJ3Mgbm8gaW52YWxpZCBpbmRleE1hcHBpbmdcclxuICAgICAgICAvLyBoYW5naW5nIGFyb3VuZCwgYW5kIHN1Y2guXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZVxyXG4gICAgZ2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UgKHNhZmUsIHdoYXRldmVyIHRoYXRcclxuICAgIC8vIG1lYW5zKVxyXG4gICAgZ2V0U2FmZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgLy8gY2FjaGUgaW5kZXhNYXBwaW5nIGJlY2F1c2UgaWYgd2UncmUgdXNpbmcgaXQgb25jZSwgd2UnbGwgcHJvYmFibHkgbmVlZCBpdCBhIGJ1bmNoIG1vcmVcclxuICAgICAgICAvLyB0b29cclxuICAgICAgICBpZiAoIXRoaXMuaW5kZXhNYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nID0ge1xyXG4gICAgICAgICAgICAgICAgeDogW10sXHJcbiAgICAgICAgICAgICAgICB5OiBbXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaSArIHRoaXMuc2l6ZS54XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBncmF5c2NhbGUgdmFsdWVcclxuICAgIHNldCh4OiBudW1iZXIsIHk6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IEltYWdlV3JhcHBlciB7XHJcbiAgICAgICAgdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdID0gdmFsdWU7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldHMgdGhlIGJvcmRlciBvZiB0aGUgaW1hZ2UgKDEgcGl4ZWwpIHRvIHplcm9cclxuICAgIHplcm9Cb3JkZXIoKTogSW1hZ2VXcmFwcGVyIHtcclxuICAgICAgICBjb25zdCB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSA9IHRoaXMuc2l6ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB0aGlzLmRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cclxuICAgICAgICAgICAgdGhpcy5kYXRhW2kgKiB3aWR0aF0gPSB0aGlzLmRhdGFbaSAqIHdpZHRoICsgKHdpZHRoIC0gMSldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gaXMgZW50aXJlbHkgdG9vIGxhcmdlIGZvciBtZSB0byByZWFzb24gb3V0IHJpZ2h0IGF0IHRoaXMgbW9tZW50IHRoYXQgaSdtIGhhbmRsaW5nXHJcbiAgICAvLyBhbGwgdGhlIHJlc3Qgb2YgaXQsIHNvIHRoaXMgaXMgYSB2ZXJiYXRpbSBjb3B5IG9mIHRoZSBqYXZhc2NyaXB0IHNvdXJjZSwgd2l0aCBvbmx5IHR3ZWFrc1xyXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGdldCBpdCB0byBydW4sIG5vIHRob3VnaHQgcHV0IGludG8gaXQgeWV0LlxyXG4gICAgbW9tZW50cyhsYWJlbENvdW50OiBudW1iZXIpOiBBcnJheTxNb21lbnQ+IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IHg7XHJcbiAgICAgICAgbGV0IHk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5zaXplLnk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemUueDtcclxuICAgICAgICBsZXQgdmFsO1xyXG4gICAgICAgIGxldCB5c3E7XHJcbiAgICAgICAgY29uc3QgbGFiZWxTdW06IEFycmF5PE1vbWVudD4gPSBbXTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgbGFiZWw7XHJcbiAgICAgICAgbGV0IG11MTE7XHJcbiAgICAgICAgbGV0IG11MDI7XHJcbiAgICAgICAgbGV0IG11MjA7XHJcbiAgICAgICAgbGV0IHhfO1xyXG4gICAgICAgIGxldCB5XztcclxuICAgICAgICBsZXQgdG1wO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8TW9tZW50PiA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHsgUEkgfSA9IE1hdGg7XHJcbiAgICAgICAgY29uc3QgUElfNCA9IFBJIC8gNDtcclxuXHJcbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsYWJlbFN1bVtpXSA9IHtcclxuICAgICAgICAgICAgICAgIG0wMDogMCxcclxuICAgICAgICAgICAgICAgIG0wMTogMCxcclxuICAgICAgICAgICAgICAgIG0xMDogMCxcclxuICAgICAgICAgICAgICAgIG0xMTogMCxcclxuICAgICAgICAgICAgICAgIG0wMjogMCxcclxuICAgICAgICAgICAgICAgIG0yMDogMCxcclxuICAgICAgICAgICAgICAgIHRoZXRhOiAwLFxyXG4gICAgICAgICAgICAgICAgcmFkOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHlzcSA9IHkgKiB5O1xyXG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVt2YWwgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDEgKz0geTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTAgKz0geDtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAyICs9IHlzcTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMjAgKz0geCAqIHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVtpXTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGxhYmVsLm0wMCkgJiYgbGFiZWwubTAwICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB4XyA9IGxhYmVsLm0xMCAvIGxhYmVsLm0wMDtcclxuICAgICAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xyXG4gICAgICAgICAgICAgICAgbXUxMSA9IGxhYmVsLm0xMSAvIGxhYmVsLm0wMCAtIHhfICogeV87XHJcbiAgICAgICAgICAgICAgICBtdTAyID0gbGFiZWwubTAyIC8gbGFiZWwubTAwIC0geV8gKiB5XztcclxuICAgICAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xyXG4gICAgICAgICAgICAgICAgdG1wID0gKG11MDIgLSBtdTIwKSAvICgyICogbXUxMSk7XHJcbiAgICAgICAgICAgICAgICB0bXAgPSAwLjUgKiBNYXRoLmF0YW4odG1wKSArIChtdTExID49IDAgPyBQSV80IDogLVBJXzQpICsgUEk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXHJcbiAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSA9ICh0bXAgKiAxODAgLyBQSSArIDkwKSAlIDE4MCAtIDkwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsLnRoZXRhIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhYmVsLnJhZCA9IHRtcCA+IFBJID8gdG1wIC0gUEkgOiB0bXA7XHJcbiAgICAgICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm4gYSBVaW50OENsYW1wZWRBcnJheSBjb250YWluaW5nIHRoaXMgZ3JheXNjYWxlIGltYWdlIGNvbnZlcnRlZCB0byBSR0JBIGZvcm1cclxuICAgIGdldEFzUkdCQShzY2FsZSA9IDEuMCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcclxuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDBdID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDNdID0gMjU1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGlzIEltYWdlV3JhcHBlciBpbiBhIGdpdmVuIENhbnZhcyBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgc2NhbGVcclxuICAgIHNob3coY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGUgPSAxLjApOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJyogaW1hZ2V3cmFwcGVyIHNob3cgZ2V0Y29udGV4dCAyZCcpO1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGlmICghY3R4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRBc1JHQkEoc2NhbGUpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUueTtcclxuICAgICAgICBjb25zdCBuZXdGcmFtZSA9IG5ldyBJbWFnZURhdGEoZGF0YSBhcyBVaW50OENsYW1wZWRBcnJheTxBcnJheUJ1ZmZlcj4sIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXHJcbiAgICAvLyBjcmVhdGluZyBhIG5ldyBTdWJJbWFnZSBhbmQgdXNpbmcgaXQncyBzaG93KCkgbWV0aG9kLiBXaHk/IEkgZG9uJ3QgaGF2ZSB0aGUgYW5zd2VyIHRvIHRoYXRcclxuICAgIC8vIHlldC4gIEkgc3VzcGVjdCB0aGUgSFNWL1JHQiBvcGVyYXRpb25zIGludm9sdmVkIGhlcmUgYXJlIG1ha2luZyBpdCBzaWduaWZpY2FudGx5IGRpZmZlcmVudCxcclxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcclxuICAgIC8vIGltcGxlbWVudGF0aW9uLlxyXG4gICAgb3ZlcmxheShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBpblNjYWxlOiBudW1iZXIsIGZyb206IFhZU2l6ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcclxuICAgICAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XHJcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XHJcbiAgICAgICAgY29uc3QgYmxhY2tSZ2IgPSBbMCwgMCwgMF07XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGNvbnNvbGUud2FybignKiBpbWFnZXdyYXBwZXIgb3ZlcmxheSBnZXRjb250ZXh0IDJkJyk7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgaWYgKCFjdHgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZyYW1lID0gY3R4LmdldEltYWdlRGF0YShmcm9tLngsIGZyb20ueSwgdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcclxuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGZyYW1lO1xyXG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICAgICAgICByZXN1bHQgPSBoc3ZbMF0gPD0gMCA/IHdoaXRlUmdiIDogaHN2WzBdID49IDM2MCA/IGJsYWNrUmdiIDogaHN2MnJnYihoc3YsIHJnYik7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxlbmd0aCAqIDQ7XHJcbiAgICAgICAgICAgIFtkYXRhW3Bvc10sIGRhdGFbcG9zICsgMV0sIGRhdGFbcG9zICsgMl1dID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBkYXRhW3BvcyArIDNdID0gMjU1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGZyYW1lLCBmcm9tLngsIGZyb20ueSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlV3JhcHBlcjtcclxuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG4vLyBUT0RPOiBYWVBvc2l0aW9uIHNob3VsZCBiZSBhbiBYWU9iamVjdCwgYnV0IHRoYXQgYnJlYWtzIFhZRGVmaW5pdGlvbiwgd2hpY2ggYnJlYWtzIGRyYXdQYXRoKCkgYmVsb3cuXHJcbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xyXG4gICAgeDogbnVtYmVyO1xyXG4gICAgeTogbnVtYmVyO1xyXG59XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBDYW52YXNTdHlsZSB7XHJcbiAgICBjb2xvcjogc3RyaW5nO1xyXG4gICAgbGluZVdpZHRoOiBudW1iZXI7XHJcbn1cclxuXHJcbi8vIFhZRGVmaW5pdGlvbiB0ZWxscyB1cyB3aGljaCBjb21wb25lbnQgb2YgYSBnaXZlbiBhcnJheSBvciBvYmplY3QgaXMgdGhlIFwiWFwiIGFuZCB3aGljaCBpcyB0aGUgXCJZXCIuXHJcbi8vIFVzdWFsbHkgdGhpcyBpcyAwIGZvciBYIGFuZCAxIGZvciBZLCBidXQgbWlnaHQgYmUgdXNlZCBhcyAneCcgZm9yIHggYW5kICd5JyBmb3IgWS5cclxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcclxuICAgIHg6IGtleW9mIFhZUG9zaXRpb247XHJcbiAgICB5OiBrZXlvZiBYWVBvc2l0aW9uO1xyXG59XHJcblxyXG5kZWNsYXJlIHR5cGUgUGF0aCA9IEFycmF5PFhZUG9zaXRpb24+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZHJhd1JlY3QocG9zOiBYWVBvc2l0aW9uLCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aCB8fCAxO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlUmVjdChwb3MueCwgcG9zLnksIHNpemUueCwgc2l6ZS55KTtcclxuICAgIH0sXHJcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHBhdGhbMF1bZGVmLnhdLCBwYXRoWzBdW2RlZi55XSk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocGF0aFtqXVtkZWYueF0sIHBhdGhbal1bZGVmLnldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH0sXHJcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZS54LCBzaXplLnkpO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gY2FudmFzRGF0YTtcclxuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGxldCBpbWFnZURhdGFQb3MgPSBpbWFnZURhdGEubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGltYWdlRGF0YVtpbWFnZURhdGFQb3NdO1xyXG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSAyNTU7XHJcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2FudmFzRGF0YSwgMCwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG59O1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcclxuaW1wb3J0IHsgSW1hZ2VXcmFwcGVyIH0gZnJvbSAncXVhZ2dhJztcclxuaW1wb3J0IHsgUXVhZ2dhSlNSZXN1bHRPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYSc7XHJcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcclxuXHJcbi8vIGZvciBzb21lIHJlYXNvbiB0aGlzIHRocm93cyBhIHNoYWRvdyBlcnJvciBvbiBpdHNlbGY/IVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XHJcbmV4cG9ydCBlbnVtIEJhcmNvZGVEaXJlY3Rpb24ge1xyXG4gICAgRm9yd2FyZCA9IDEsXHJcbiAgICBSZXZlcnNlID0gLTFcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgQmFyY29kZVJlYWRlclR5cGUgPSBzdHJpbmc7XHJcbmV4cG9ydCB0eXBlIEJhcmNvZGVGb3JtYXQgPSBzdHJpbmc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVSZWFkZXJDb25maWcge1xyXG4gICAgbm9ybWFsaXplQmFyU3BhY2VXaWR0aD86IGJvb2xlYW4sXHJcbiAgICBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXJUeXBlPixcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlQ29ycmVjdGlvbiB7XHJcbiAgICBiYXI6IG51bWJlcixcclxuICAgIHNwYWNlOiBudW1iZXIsXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVBvc2l0aW9uIHtcclxuICAgIGVuZDogbnVtYmVyLFxyXG4gICAgZW5kQ291bnRlcj86IG51bWJlcixcclxuICAgIGVycm9yPzogbnVtYmVyLFxyXG4gICAgc3RhcnQ6IG51bWJlcixcclxuICAgIHN0YXJ0Q291bnRlcj86IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVJbmZvIGV4dGVuZHMgQmFyY29kZVBvc2l0aW9uIHtcclxuICAgIGNvZGU6IG51bWJlcixcclxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlIHtcclxuICAgIGNvZGU6IHN0cmluZyxcclxuICAgIGNvZGVzZXQ/OiBudW1iZXIsXHJcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXHJcbiAgICBkZWNvZGVkQ29kZXM/OiBBcnJheTxzdHJpbmcgfCBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4sXHJcbiAgICBkaXJlY3Rpb24/OiBCYXJjb2RlRGlyZWN0aW9uLFxyXG4gICAgZW5kOiBudW1iZXIsXHJcbiAgICBlbmRJbmZvPzogQmFyY29kZVBvc2l0aW9uLFxyXG4gICAgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LFxyXG4gICAgc3RhcnQ6IG51bWJlcixcclxuICAgIHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLFxyXG4gICAgc3VwcGxlbWVudD86IEJhcmNvZGUsXHJcbn1cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIF9yb3c6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuXHJcbiAgICBjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcclxuXHJcbiAgICBzdXBwbGVtZW50czogQXJyYXk8QmFyY29kZVJlYWRlcj4gPSBbXTtcclxuXHJcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDA7XHJcblxyXG4gICAgRk9STUFUOiBCYXJjb2RlRm9ybWF0ID0gJ3Vua25vd24nO1xyXG5cclxuICAgIENPTkZJR19LRVlTOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XHJcbiAgICAvLyBUT0RPOiBzaG91bGQgYWRkIEFMUEhBQkVUSF9TVFJJTkcsIEFMUEhBQkVULCBDSEFSQUNURVJfRU5DT0RJTkdTIHRvIGJhc2UgY2xhc3MsIGlmIHRoZXlcclxuICAgIC8vIGFyZSB1c2VmdWwgaW4gbW9zdCByZWFkZXJzLlxyXG5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbDtcclxuXHJcbiAgICBzdGF0aWMgZ2V0IEV4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBTdGFydE5vdEZvdW5kRXhjZXB0aW9uOiAnU3RhcnQtSW5mbyB3YXMgbm90IGZvdW5kIScsXHJcbiAgICAgICAgICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogJ0NvZGUgY291bGQgbm90IGJlIGZvdW5kIScsXHJcbiAgICAgICAgICAgIFBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbjogJ1BhdHRlcm4gY291bGQgbm90IGJlIGZvdW5kIScsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcclxuICAgICAgICB0aGlzLl9yb3cgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICBpZiAoc3VwcGxlbWVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5zdXBwbGVtZW50cyA9IHN1cHBsZW1lbnRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX25leHRVbnNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHN0YXJ0ID0gMCk6IG51bWJlciB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWxpbmVbaV0pIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9tYXRjaFBhdHRlcm4oY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG1heFNpbmdsZUVycm9yID0gdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgZXJyb3IgPSAwO1xyXG4gICAgICAgIGxldCBzaW5nbGVFcnJvciA9IDA7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgbGV0IG1vZHVsbyA9IDA7XHJcbiAgICAgICAgbGV0IGJhcldpZHRoID0gMDtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGxldCBzY2FsZWQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XHJcbiAgICAgICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYmFyV2lkdGggPSBzdW0gLyBtb2R1bG87XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcclxuICAgICAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xyXG4gICAgICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcclxuICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3IgLyBtb2R1bG87XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9uZXh0U2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0ID0gMCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaW5lW2ldKSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfY29ycmVjdEJhcnMoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogbnVtYmVyLCBpbmRpY2VzOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSBpbmRpY2VzO1xyXG4gICAgICAgIGxldCB0bXAgPSAwO1xyXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgoMSAtIGNvcnJlY3Rpb24pIC8gMikpO1xyXG4gICAgICAgICAgICBpZiAodG1wID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlY29kZVBhdHRlcm4ocGF0dGVybjogQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XHJcbiAgICAgICAgdGhpcy5fcm93ID0gcGF0dGVybjtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybiBjYWxsaW5nIGRlY29kZScsIHR5cGVvZiB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLkZPUk1BVCwgSlNPTi5zdHJpbmdpZnkodGhpcykpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdCByZXN1bHQ9JywgcmVzdWx0KTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGVjb2RlKCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXZlcnNlZCByZXN1bHQ9JywgcmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uUmV2ZXJzZTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5lbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5Gb3J3YXJkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSB0aGlzLkZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIHJlc3VsdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX21hdGNoUmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBzdGFydCA9IHN0YXJ0IDwgMCA/IDAgOiBzdGFydDtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maWxsQ291bnRlcnMob2Zmc2V0OiBudW1iZXIgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KSwgZW5kOiBudW1iZXIgPSB0aGlzLl9yb3cubGVuZ3RoLCBpc1doaXRlID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdG9Db3VudGVycyhzdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkgfCBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcclxuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbc3RhcnRdO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuXHJcbiAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChjb3VudGVycywgMCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gbnVtQ291bnRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY291bnRlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gb3ZlcnJpZGUvaW1wbGVtZW50IHRoaXMgaW4geW91ciBjdXN0b20gcmVhZGVycy5cclxuICAgIHByb3RlY3RlZCBkZWNvZGVJbWFnZShpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcik6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZvaWRcclxuICAgICAgICB2b2lkIGltYWdlV3JhcHBlcjtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFyY29kZVJlYWRlcjtcclxuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5cclxuY29uc3QgTiA9IDE7XHJcbmNvbnN0IFcgPSAzO1xyXG5jb25zdCBTVEFSVF9QQVRURVJOID0gW1csIE4sIFcsIE4sIE4sIE5dO1xyXG5jb25zdCBTVE9QX1BBVFRFUk4gPSBbVywgTiwgTiwgTiwgV107XHJcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcclxuICAgIFtOLCBOLCBXLCBXLCBOXSxcclxuICAgIFtXLCBOLCBOLCBOLCBXXSxcclxuICAgIFtOLCBXLCBOLCBOLCBXXSxcclxuICAgIFtXLCBXLCBOLCBOLCBOXSxcclxuICAgIFtOLCBOLCBXLCBOLCBXXSxcclxuICAgIFtXLCBOLCBXLCBOLCBOXSxcclxuICAgIFtOLCBXLCBXLCBOLCBOXSxcclxuICAgIFtOLCBOLCBOLCBXLCBXXSxcclxuICAgIFtXLCBOLCBOLCBXLCBOXSxcclxuICAgIFtOLCBXLCBOLCBXLCBOXSxcclxuXTtcclxuY29uc3QgU1RBUlRfUEFUVEVSTl9MRU5HVEggPSBTVEFSVF9QQVRURVJOLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XHJcblxyXG5jbGFzcyBUd29PZkZpdmVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XHJcblxyXG4gICAgRk9STUFUID0gJzJvZjUnO1xyXG5cclxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcclxuXHJcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlID0gZmFsc2UsIHRyeUhhcmRlciA9IGZhbHNlKTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIGNvZGU6IC0xLFxyXG4gICAgICAgICAgICBzdGFydDogMCxcclxuICAgICAgICAgICAgZW5kOiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgbGV0IGVycm9yID0gMDtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcclxuXHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXJbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIGxldCBzdGFydEluZm8gPSBudWxsO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcclxuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIFNUQVJUX1BBVFRFUk5fTEVOR1RIKTtcclxuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcclxuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcclxuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbyk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZEVuZCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICAvLyBUT0RPOiByZXZlcnNlLCBmb2xsb3dlZCBieSBzb21lIGNhbGNzLCBmb2xsb3dlZCBieSBhbm90aGVyIHJldmVyc2U/IHJlYWxseT9cclxuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xyXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XHJcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcclxuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XHJcblxyXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+KTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IENPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA8IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xyXG4gICAgICAgIGxldCBwb3MgPSAwO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwXTtcclxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbaV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlcik7XHJcbiAgICAgICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYCR7Y29kZS5jb2RlfWApO1xyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XHJcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xyXG4gICAgICAgIGlmICghZW5kSW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcclxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcclxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xyXG5cclxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcclxuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xyXG4gICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCA1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxyXG4gICAgICAgICAgICBzdGFydEluZm8sXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUd29PZkZpdmVSZWFkZXI7XHJcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5cclxuLy8gY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5LSQ6Ly4rQUJDRCc7XHJcbmNvbnN0IEFMUEhBQkVUID0gWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0NSwgMzYsIDU4LCA0NywgNDYsIDQzLCA2NSwgNjYsIDY3LCA2OF07XHJcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPVxyXG4gICAgWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXHJcbiAgICAgICAgMHgwNDUsIDB4MDUxLCAweDA1NCwgMHgwMTUsIDB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcclxuY29uc3QgU1RBUlRfRU5EID0gWzB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcclxuY29uc3QgTUlOX0VOQ09ERURfQ0hBUlMgPSA0O1xyXG5jb25zdCBNQVhfQUNDRVBUQUJMRSA9IDIuMDtcclxuY29uc3QgUEFERElORyA9IDEuNTtcclxuXHJcbmludGVyZmFjZSBUaHJlc2hvbGRTaXplIHtcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIGNvdW50czogbnVtYmVyLFxyXG4gICAgbWluOiBudW1iZXIsXHJcbiAgICBtYXg6IG51bWJlcixcclxufTtcclxuXHJcbmludGVyZmFjZSBUaHJlc2hvbGQge1xyXG4gICAgc3BhY2U6IHtcclxuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXHJcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcclxuICAgIH0sXHJcbiAgICBiYXI6IHtcclxuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXHJcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcclxuICAgIH0sXHJcbn07XHJcblxyXG5jbGFzcyBOZXdDb2RhYmFyUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XHJcbiAgICBfY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICAgIEZPUk1BVCA9ICdjb2RhYmFyJztcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcclxuICAgICAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgbWF4ID0gMDtcclxuICAgICAgICBsZXQgY291bnRlciA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBjb3VudGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBjb3VudGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKChtaW4gKyBtYXgpIC8gMi4wKSB8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdG9QYXR0ZXJuKG9mZnNldDogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSA3O1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIG51bUNvdW50ZXJzO1xyXG5cclxuICAgICAgICBpZiAoZW5kID4gdGhpcy5fY291bnRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJhclRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQsIGVuZCk7XHJcbiAgICAgICAgY29uc3Qgc3BhY2VUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0ICsgMSwgZW5kKTtcclxuXHJcbiAgICAgICAgbGV0IGJpdG1hc2sgPSAxIDw8IChudW1Db3VudGVycyAtIDEpO1xyXG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xyXG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChpICYgMSkgPT09IDAgPyBiYXJUaHJlc2hvbGQgOiBzcGFjZVRocmVzaG9sZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJzW29mZnNldCArIGldID4gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYml0bWFzayA+Pj0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2lzU3RhcnRFbmQocGF0dGVybjogbnVtYmVyKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTVEFSVF9FTkQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKFNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3N1bUNvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oaSk7XHJcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuICE9PSAtMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBMb29rIGZvciB3aGl0ZXNwYWNlIGFoZWFkXHJcbiAgICAgICAgICAgICAgICBzdGFydCArPSB0aGlzLl9zdW1Db3VudGVycygwLCBpKTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoaSwgaSArIDgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudGVyOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZENvdW50ZXI6IGkgKyA4LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfY2FsY3VsYXRlUGF0dGVybkxlbmd0aChvZmZzZXQ6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5V2hpdGVzcGFjZShzdGFydENvdW50ZXI6IG51bWJlciwgZW5kQ291bnRlcjogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKChzdGFydENvdW50ZXIgLSAxIDw9IDApXHJcbiAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW3N0YXJ0Q291bnRlciAtIDFdID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKHN0YXJ0Q291bnRlcikgLyAyLjApKSB7XHJcbiAgICAgICAgICAgIGlmICgoZW5kQ291bnRlciArIDggPj0gdGhpcy5fY291bnRlcnMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbZW5kQ291bnRlciArIDddID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKGVuZENvdW50ZXIpIC8gMi4wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NoYXJUb1BhdHRlcm4oY2hhcjogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKEFMUEhBQkVUW2ldID09PSBjaGFyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENIQVJBQ1RFUl9FTkNPRElOR1NbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDB4MDtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3JpemF0aW9uOiBUaHJlc2hvbGQgPSB7XHJcbiAgICAgICAgICAgICAgICBzcGFjZToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYmFyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcclxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcclxuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAyID8gY2F0ZWdvcml6YXRpb24uYmFyIDogY2F0ZWdvcml6YXRpb24uc3BhY2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XHJcbiAgICAgICAgICAgICAgICBjYXQuc2l6ZSArPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcclxuICAgICAgICAgICAgICAgIGNhdC5jb3VudHMrKztcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zICs9IDg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAoWydzcGFjZScsICdiYXInXSBhcyBjb25zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld2tpbmQgPSBjYXRlZ29yaXphdGlvbltrZXldO1xyXG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWluID1cclxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG5ld2tpbmQubmFycm93LnNpemUgLyBuZXdraW5kLm5hcnJvdy5jb3VudHMgKyBuZXdraW5kLndpZGUuc2l6ZSAvIG5ld2tpbmQud2lkZS5jb3VudHMpIC8gMik7XHJcbiAgICAgICAgICAgIG5ld2tpbmQubmFycm93Lm1heCA9IE1hdGguY2VpbChuZXdraW5kLndpZGUubWluKTtcclxuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1heCA9IE1hdGguY2VpbCgobmV3a2luZC53aWRlLnNpemUgKiBNQVhfQUNDRVBUQUJMRSArIFBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF92YWxpZGF0ZVJlc3VsdChyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gdGhpcy5fdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlcik7XHJcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcclxuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAwID8gdGhyZXNob2xkcy5iYXIgOiB0aHJlc2hvbGRzLnNwYWNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPCBjYXQubWluIHx8IHNpemUgPiBjYXQubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3MgKz0gODtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIgfCBudWxsKTogQmFyY29kZSB8IG51bGwge1xyXG5cclxuICAgICAgICB0aGlzLl9jb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycygpO1xyXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XHJcbiAgICAgICAgaWYgKCFzdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xyXG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKG5leHRTdGFydCk7XHJcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xyXG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcclxuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IDg7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKG5leHRTdGFydCA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIC8vIHZlcmlmeSBlbmRcclxuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IE1JTl9FTkNPREVEX0NIQVJTIHx8ICF0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdmVyaWZ5IGVuZCB3aGl0ZSBzcGFjZVxyXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5V2hpdGVzcGFjZShzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVSZXN1bHQocmVzdWx0LCBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5leHRTdGFydCA9IG5leHRTdGFydCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA/IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA6IG5leHRTdGFydDtcclxuICAgICAgICBjb25zdCBlbmQgPSBzdGFydC5zdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmQsXHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULCAvLyBUT0RPOiBpIHRoaW5rIGl0IHNob3VsZCBub3QgYmUgcmVxdWlyZWQgdG8gcmV0dXJuIGZvcm1hdCBmcm9tIHRoaXMsIGFzIGJhcmNvZGVfcmVhZGVyIGZvcmNlIHNldHMgdGhlIGZvcm1hdCBhbnl3YXlcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTmV3Q29kYWJhclJlYWRlcjtcclxuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZUNvcnJlY3Rpb24sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIENPREVfU0hJRlQgPSA5ODtcclxuICAgIENPREVfQyA9IDk5O1xyXG4gICAgQ09ERV9CID0gMTAwO1xyXG4gICAgQ09ERV9BID0gMTAxO1xyXG4gICAgU1RBUlRfQ09ERV9BID0gMTAzO1xyXG4gICAgU1RBUlRfQ09ERV9CID0gMTA0O1xyXG4gICAgU1RBUlRfQ09ERV9DID0gMTA1O1xyXG4gICAgU1RPUF9DT0RFID0gMTA2O1xyXG4gICAgQ09ERV9QQVRURVJOID0gW1xyXG4gICAgICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzIsIDIsIDIsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXHJcbiAgICAgICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDMsIDEsIDIsIDIsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXHJcbiAgICAgICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcclxuICAgICAgICAgICAgWzEsIDMsIDIsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcclxuICAgICAgICAgICAgWzIsIDMsIDEsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDMsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcclxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcclxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXHJcbiAgICAgICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzMsIDIsIDEsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXHJcbiAgICAgICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcclxuICAgICAgICAgICAgWzMsIDIsIDIsIDIsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXHJcbiAgICAgICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcclxuICAgICAgICAgICAgWzIsIDMsIDIsIDEsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXHJcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcclxuICAgICAgICAgICAgWzEsIDMsIDEsIDMsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXHJcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcclxuICAgICAgICAgICAgWzEsIDMsIDIsIDMsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXHJcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcclxuICAgICAgICAgICAgWzIsIDMsIDEsIDMsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXHJcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcclxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXHJcbiAgICAgICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcclxuICAgICAgICAgICAgWzEsIDMsIDMsIDEsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcclxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXHJcbiAgICAgICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcclxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXHJcbiAgICAgICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcclxuICAgICAgICAgICAgWzMsIDMsIDEsIDEsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXHJcbiAgICAgICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcclxuICAgICAgICAgICAgWzMsIDMsIDIsIDEsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcclxuICAgICAgICAgICAgWzQsIDMsIDEsIDEsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXHJcbiAgICAgICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDIsIDRdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXHJcbiAgICAgICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDQsIDEsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXHJcbiAgICAgICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDEsIDRdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcclxuICAgICAgICAgICAgWzEsIDQsIDIsIDIsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcclxuICAgICAgICAgICAgWzQsIDEsIDMsIDEsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDQsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDQsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcclxuICAgICAgICAgICAgWzQsIDEsIDEsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXHJcbiAgICAgICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcclxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDQsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXHJcbiAgICAgICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDEsIDEsIDQsIDNdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXHJcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDEsIDNdLFxyXG4gICAgICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXHJcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcclxuICAgICAgICAgICAgWzQsIDEsIDEsIDMsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXHJcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcclxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDQsIDFdLFxyXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXHJcbiAgICAgICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcclxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDEsIDRdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXHJcbiAgICAgICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXSxcclxuICAgICAgICBdO1xyXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjY0O1xyXG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xyXG4gICAgRk9STUFUID0gJ2NvZGVfMTI4JztcclxuICAgIE1PRFVMRV9JTkRJQ0VTID0geyBiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XSB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIGNvZGU6IC0xLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogc3RhcnQsXHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIGJhcjogMSxcclxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3QoY291bnRlciwgY29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gdGhpcy5BVkdfQ09ERV9FUlJPUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NvcnJlY3QoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogQmFyY29kZUNvcnJlY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xyXG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uc3BhY2UsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPOiBfZmluZFN0YXJ0IGFuZCBkZWNvZGVDb2RlIHNoYXJlIHNpbWlsYXIgY29kZSwgY2FuIHdlIHJlLXVzZSBzb21lP1xyXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgYmFyOiAxLFxyXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSB0aGlzLlNUQVJUX0NPREVfQTsgY29kZSA8PSB0aGlzLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgdGhpcy5BVkdfQ09ERV9FUlJPUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAvLyAgICAgZG9uZSA9IGZhbHNlLFxyXG4gICAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAvLyAgICAgbXVsdGlwbGllciA9IDAsXHJcbiAgICAgICAgLy8gICAgIGNoZWNrc3VtID0gMCxcclxuICAgICAgICAvLyAgICAgY29kZXNldCxcclxuICAgICAgICAvLyAgICAgcmF3UmVzdWx0ID0gW10sXHJcbiAgICAgICAgLy8gICAgIGRlY29kZWRDb2RlcyA9IFtdLFxyXG4gICAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcclxuICAgICAgICAvLyAgICAgdW5zaGlmdCxcclxuICAgICAgICAvLyAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XHJcbiAgICAgICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmQsXHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLmJhcixcclxuICAgICAgICAgICAgICAgIHNwYWNlOiBzdGFydEluZm8uY29ycmVjdGlvbiEuc3BhY2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcclxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuICAgICAgICBsZXQgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XHJcbiAgICAgICAgbGV0IGNvZGVzZXQgPSAoKGM6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0E6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9BO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0I7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9DOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KShjb2RlLmNvZGUpO1xyXG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHNoaWZ0TmV4dCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB1bnNoaWZ0ID0gc2hpZnROZXh0O1xyXG4gICAgICAgIGxldCByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcclxuICAgICAgICBsZXQgbXVsdGlwbGllciA9IDA7XHJcbiAgICAgICAgbGV0IHJhd1Jlc3VsdDogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBbXTsgLy8gVE9ETzogaSB0aGluayB0aGlzIHNob3VsZCBiZSBzdHJpbmcgb25seSwgYnV0IGl0IGNyZWF0ZXMgcHJvYmxlbXMgaWYgaXQgaXNcclxuXHJcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XHJcbiAgICAgICAgICAgIHVuc2hpZnQgPSBzaGlmdE5leHQ7XHJcbiAgICAgICAgICAgIHNoaWZ0TmV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlIS5lbmQsIGNvZGUhLmNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd1Jlc3VsdC5wdXNoKGNvZGUuY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcisrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IG11bHRpcGxpZXIgKiBjb2RlLmNvZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29kZSA8IDk2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA5Nikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgPCAxMCA/ICcwJyArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5zaGlmdCkge1xyXG4gICAgICAgICAgICAgICAgY29kZXNldCA9IGNvZGVzZXQgPT09IHRoaXMuQ09ERV9BID8gdGhpcy5DT0RFX0IgOiB0aGlzLkNPREVfQTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2RlLmVuZCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcclxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXHJcbiAgICAgICAgaWYgKHJlbW92ZUxhc3RDaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShyZXN1bHQubGVuZ3RoIC0gMSwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxyXG4gICAgICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0IGFzIG51bWJlcixcclxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxyXG4gICAgICAgICAgICBlbmRJbmZvOiBjb2RlLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XHJcblxyXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgcHVibGljIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCA9IDAsXHJcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XHJcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgKz0gbm9ybWFsaXplZFtpbmRpY2VzW2xlbmd0aF1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb2RlMTI4UmVhZGVyO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXHJcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcclxuaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgdHlwZSBCYXJjb2RlUG9zaXRpb24sIHR5cGUgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5cclxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XHJcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xyXG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID0gbmV3IFVpbnQxNkFycmF5KFtcclxuICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LCAweDEwOSwgMHgwNDksXHJcbiAgICAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNixcclxuICAgIDB4MDQ2LCAweDAxNiwgMHgxODEsIDB4MEMxLCAweDFDMCwgMHgwOTEsIDB4MTkwLCAweDBEMCwgMHgwODUsIDB4MTg0LCAweDBDNCwgMHgwOTQsIDB4MEE4LCAweDBBMiwgMHgwOEEsIDB4MDJBLFxyXG5dKTtcclxuY29uc3QgQVNURVJJU0sgPSAweDA5NDtcclxuXHJcbmNsYXNzIENvZGUzOVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2NvZGVfMzknO1xyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcclxuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XHJcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbN10gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbOF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF90b1BhdHRlcm4oY291bnRlcnM6IFVpbnQxNkFycmF5KTogbnVtYmVyIHtcclxuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcclxuICAgICAgICBsZXQgbWF4TmFycm93V2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBudW1XaWRlQmFycyA9IG51bUNvdW50ZXJzO1xyXG4gICAgICAgIGxldCB3aWRlQmFyV2lkdGggPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAobnVtV2lkZUJhcnMgPiAzKSB7XHJcbiAgICAgICAgICAgIG1heE5hcnJvd1dpZHRoID0gdGhpcy5fZmluZE5leHRXaWR0aChjb3VudGVycywgbWF4TmFycm93V2lkdGgpO1xyXG4gICAgICAgICAgICBudW1XaWRlQmFycyA9IDA7XHJcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcclxuICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGVCYXJXaWR0aCArPSBjb3VudGVyc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzICYmIG51bVdpZGVCYXJzID4gMDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudGVyc1tpXSAqIDIpID49IHdpZGVCYXJXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZE5leHRXaWR0aChjb3VudGVyczogVWludDE2QXJyYXksIGN1cnJlbnQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gY291bnRlcnNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtaW5XaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xyXG4gICAgICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKCk6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcclxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcclxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG5cclxuICAgICAgICBpZiAoIXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XHJcblxyXG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcclxuICAgICAgICBsZXQgbGFzdFN0YXJ0OiBudW1iZXI7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjb3VudGVycyA9IHRoaXMuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycykgYXMgVWludDE2QXJyYXk8QXJyYXlCdWZmZXI+O1xyXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcclxuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XHJcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xyXG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XHJcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xyXG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcclxuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcclxuICAgICAgICByZXN1bHQucG9wKCk7XHJcblxyXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvZGUzOVJlYWRlcjtcclxuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcclxuXHJcbmNvbnN0IHBhdHRlcm5zID0ge1xyXG4gICAgQUVJTzogL1tBRUlPXS9nLFxyXG4gICAgQVowOTogL1tBLVowLTldLyxcclxufTtcclxuXHJcbmNvbnN0IGNvZGUzMnNldCA9ICcwMTIzNDU2Nzg5QkNERkdISktMTU5QUVJTVFVWV1hZWic7XHJcblxyXG5jbGFzcyBDb2RlMzJSZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2NvZGVfMzJfcmVhZGVyJztcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUzMihjb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXMgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXMgPSByZXMgKiAzMiArIGNvZGUzMnNldC5pbmRleE9mKGNvZGVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29kZTMyID0gYCR7cmVzfWA7XHJcbiAgICAgICAgaWYgKGNvZGUzMi5sZW5ndGggPCA5KSB7XHJcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ0EnICsgY29kZTMyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcclxuICAgIHByb3RlY3RlZCBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gISFjb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZWNvZGUoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZGVjb2RlKCk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29kZSA9IHJlc3VsdC5jb2RlO1xyXG5cclxuICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLkFFSU8sICcnKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29kZTMyID0gdGhpcy5fZGVjb2RlQ29kZTMyKGNvZGUpO1xyXG5cclxuICAgICAgICBpZiAoIWNvZGUzMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTMyO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvZGUzMlJlYWRlcjtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xyXG5pbXBvcnQgeyBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XHJcblxyXG5jb25zdCBwYXR0ZXJucyA9IHtcclxuICAgIElPUTogL1tJT1FdL2csXHJcbiAgICBBWjA5OiAvW0EtWjAtOV17MTd9LyxcclxufTtcclxuXHJcbmNsYXNzIENvZGUzOVZJTlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XHJcbiAgICBGT1JNQVQgPSAnY29kZV8zOV92aW4nO1xyXG5cclxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcclxuICAgIHByb3RlY3RlZCBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gISFjb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyaWJiZWQgZnJvbTpcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iL21hc3Rlci9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9jbGllbnQvcmVzdWx0L1ZJTlJlc3VsdFBhcnNlci5qYXZhXHJcbiAgICBwdWJsaWMgZGVjb2RlKCk6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUoKTtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB7IGNvZGUgfSA9IHJlc3VsdDtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5JT1EsICcnKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlLm1hdGNoKHBhdHRlcm5zLkFaMDkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgQVowOSBwYXR0ZXJuIGNvZGU6JywgY29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5VklOUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xyXG5cclxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xyXG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XHJcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXHJcbiAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcclxuICAgIDB4MTFBLCAweDE1OCwgMHgxNEMsIDB4MTQ2LCAweDEyQywgMHgxMTYsIDB4MUI0LCAweDFCMiwgMHgxQUMsIDB4MUE2LFxyXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXHJcbiAgICAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUUsXHJcbl0pO1xyXG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xyXG5cclxuY2xhc3MgQ29kZTkzUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XHJcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XHJcbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSk6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3VtID0gY291bnRlcnMucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XHJcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBNYXRoLnJvdW5kKGNvdW50ZXJzW2ldICogOSAvIHN1bSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkIDwgMSB8fCBub3JtYWxpemVkID4gNCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoaSAmIDEpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAocGF0dGVybiA8PCAxKSB8IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIDw8PSBub3JtYWxpemVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUVuZChsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KTogc3RyaW5nW10gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBjaGFyQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJheVtpXTtcclxuICAgICAgICAgICAgaWYgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ2QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IG5leHRDaGFyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVjb2RlZENoYXI7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnSycgJiYgbmV4dENoYXIgPD0gJ08nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyA0Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogY29kZV85M19yZWFkZXIgX2RlY29kZUV4dGVuZGVkIGhpdCBkZWZhdWx0IGNhc2UsIHRoaXMgbWF5IGJlIGFuIGVycm9yJywgZGVjb2RlZENoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+LCBpbmRleDogbnVtYmVyLCBtYXhXZWlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IGFycmF5VG9DaGVjayA9IGNoYXJBcnJheS5zbGljZSgwLCBpbmRleCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlUb0NoZWNrLmxlbmd0aDtcclxuICAgICAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gKCgoaSAqIC0xKSArIChsZW5ndGggLSAxKSkgJSBtYXhXZWlnaHQpICsgMTtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBTFBIQUJFVC5pbmRleE9mKGNoYXIuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyAod2VpZ2h0ICogdmFsdWUpO1xyXG4gICAgICAgIH0sIDApO1xyXG5cclxuICAgICAgICBjb25zdCBjaGVja0NoYXIgPSBBTFBIQUJFVFsod2VpZ2h0ZWRTdW1zICUgNDcpXTtcclxuICAgICAgICByZXR1cm4gY2hlY2tDaGFyID09PSBjaGFyQXJyYXlbaW5kZXhdLmNoYXJDb2RlQXQoMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5Q2hlY2tzdW1zKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAyLCAyMClcclxuICAgICAgICAgICAgJiYgdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMSwgMTUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG4gICAgICAgIGlmICghc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcclxuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmc+IHwgbnVsbCA9IFtdO1xyXG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcclxuICAgICAgICBsZXQgbGFzdFN0YXJ0O1xyXG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjogc3RyaW5nIHwgbnVsbDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTxBcnJheUJ1ZmZlcj47XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xyXG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcclxuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XHJcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcclxuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XHJcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xyXG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xyXG4gICAgICAgIHJlc3VsdC5wb3AoKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlFbmQobGFzdFN0YXJ0LCBuZXh0U3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgLy8geWVzLCB0aGlzIGlzIGFuIGFzc2lnbiBpbnNpZGUgYW4gaWYuXHJcbiAgICAgICAgaWYgKChyZXN1bHQgPSB0aGlzLl9kZWNvZGVFeHRlbmRlZChyZXN1bHQpKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvZGU5M1JlYWRlcjtcclxuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcclxuXHJcbi8vIGNvbnN0IENPREVfTF9TVEFSVCA9IDA7XHJcbmNvbnN0IENPREVfR19TVEFSVCA9IDEwO1xyXG5leHBvcnQgeyBDT0RFX0dfU1RBUlQgfTtcclxuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAxXTtcclxuY29uc3QgTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XHJcbmV4cG9ydCB7IE1JRERMRV9QQVRURVJOIH07XHJcbmNvbnN0IEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOID0gWzEsIDEsIDJdO1xyXG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXHJcbiAgICBbMywgMiwgMSwgMV0sXHJcbiAgICBbMiwgMiwgMiwgMV0sXHJcbiAgICBbMiwgMSwgMiwgMl0sXHJcbiAgICBbMSwgNCwgMSwgMV0sXHJcbiAgICBbMSwgMSwgMywgMl0sXHJcbiAgICBbMSwgMiwgMywgMV0sXHJcbiAgICBbMSwgMSwgMSwgNF0sXHJcbiAgICBbMSwgMywgMSwgMl0sXHJcbiAgICBbMSwgMiwgMSwgM10sXHJcbiAgICBbMywgMSwgMSwgMl0sXHJcbiAgICBbMSwgMSwgMiwgM10sXHJcbiAgICBbMSwgMiwgMiwgMl0sXHJcbiAgICBbMiwgMiwgMSwgMl0sXHJcbiAgICBbMSwgMSwgNCwgMV0sXHJcbiAgICBbMiwgMywgMSwgMV0sXHJcbiAgICBbMSwgMywgMiwgMV0sXHJcbiAgICBbNCwgMSwgMSwgMV0sXHJcbiAgICBbMiwgMSwgMywgMV0sXHJcbiAgICBbMywgMSwgMiwgMV0sXHJcbiAgICBbMiwgMSwgMSwgM10sXHJcbl07XHJcbmNvbnN0IENPREVfRlJFUVVFTkNZID0gWzAsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdO1xyXG4vLyBjb25zdCBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzA7XHJcbmNvbnN0IEFWR19DT0RFX0VSUk9SID0gMC40ODtcclxuXHJcbmNsYXNzIEVBTlJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2Vhbl8xMyc7XHJcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzA7XHJcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSwgMSwgMV07IC8vIFRPRE86IGRvZXMgdGhpcyBuZWVkIHRvIGJlIGluIHRoZSBjbGFzcz9cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWc/OiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XHJcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBzdXBwbGVtZW50czogW10gfSwgY29uZmlnKSwgc3VwcGxlbWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbiwgdHJ5SGFyZGVyOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZVBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybicsIHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyLCBlcHNpbG9uKTtcclxuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgKiBsb29wIGk9JHtvZmZzZXR9IGxlbj0ke3RoaXMuX3Jvdy5sZW5ndGh9IGlzV2hpdGU9JHtpc1doaXRlfSBjb3VudGVyUG9zPSR7Y291bnRlclBvc31gKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdICs9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIG1hdGNoUGF0dGVybicsIGVycm9yLCBjb3VudGVyLCBwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uICYmIGJlc3RNYXRjaC5lcnJvciAmJiBlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gY291bnRlci5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGZpbmRQYXR0ZXJuIGFuZCBkZWNvZGVDb2RlIGFwcGVhciB0byBzaGFyZSBxdWl0ZSBzaW1pbGFyIGNvZGUsIGNhbiBpdCBiZSByZWR1Y2VkP1xyXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvZGVyYW5nZT86IG51bWJlcik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUnLCBzdGFydCwgY29kZXJhbmdlKTtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZUluZm8gPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XHJcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG5cclxuICAgICAgICBpZiAoIWNvZGVyYW5nZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBiZWZvcmUgbGVuZ3RoJyk7XHJcbiAgICAgICAgICAgIGNvZGVyYW5nZSA9IENPREVfUEFUVEVSTi5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGFmdGVyIGxlbmd0aCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IGNvZGVyYW5nZTsgY29kZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA+IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRTdGFydCcpO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogc3RhcnRJbmZvPScsIEpTT04uc3RyaW5naWZ5KHN0YXJ0SW5mbykpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSAoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBzdGFydEluZm8nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xyXG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIG51bGwnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcik6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBjYWxjdWxhdGVGaXJzdERpZ2l0JywgY29kZUZyZXF1ZW5jeSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ09ERV9GUkVRVUVOQ1lbaV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXlsb2FkJywgaW5Db2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XHJcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XHJcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9Jywgb3V0Q29kZSk7XHJcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XHJcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtPSBDT0RFX0dfU1RBUlQ7XHJcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDUgLSBpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMCA8PCAoNSAtIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBmaXJzdERpZ2l0ID0gdGhpcy5fY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5KTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3REaWdpdD0nLCBmaXJzdERpZ2l0KTtcclxuICAgICAgICBpZiAoZmlyc3REaWdpdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHQudW5zaGlmdChmaXJzdERpZ2l0KTtcclxuXHJcbiAgICAgICAgbGV0IG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgb3V0Q29kZS5lbmQsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm49JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xyXG5cclxuICAgICAgICBpZiAobWlkZGxlUGF0dGVybiA9PT0gbnVsbCB8fCAhbWlkZGxlUGF0dGVybi5lbmQpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9kZWNvZGVDb2RlKG1pZGRsZVBhdHRlcm4hLmVuZCwgQ09ERV9HX1NUQVJUKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFtaWRkbGVQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm8pLmNvZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIHJlc3VsdD0nLCBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZWRDb2Rlcz0nLCBkZWNvZGVkQ29kZXMpO1xyXG4gICAgICAgIHJldHVybiBtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB2ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XHJcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZEVuZCcsIG9mZnNldCwgaXNXaGl0ZSk7XHJcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGlzV2hpdGUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIF9jaGVja3N1bScsIHJlc3VsdCk7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcclxuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN1bSAqPSAzO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNoZWNrc3VtJywgc3VtICUgMTAgPT09IDApO1xyXG4gICAgICAgIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9kZWNvZGVFeHRlbnNpb25zKG9mZnNldDogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG9mZnNldCk7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sIHN0YXJ0LCBmYWxzZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMnLCB0aGlzLnN1cHBsZW1lbnRzKTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhlcmUgYXJlICcsIHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoLCAnIHN1cHBsZW1lbnRzJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBleHRlbnNpb25zIGxvb3AnLCBpLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3VwcGxlbWVudHNbaV0uZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlIHJlc3VsdD0nLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5jb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHJlc3VsdC5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LmRlY29kZWRDb2RlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnN1cHBsZW1lbnRzW2ldLkZPUk1BVCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogZGVjb2RlRXh0ZW5zaW9ucyBlcnJvciBpbiAnLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCAnOiAnLCBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZUV4dGVuc2lvbnMnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCByb3cpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCBzdGFydCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PG51bWJlcj4oKTtcclxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdEluZm86IEJhcmNvZGUgfCB7fSA9IHt9O1xyXG4gICAgICAgIGxldCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuXHJcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29kZTogQmFyY29kZVBvc2l0aW9uIHwgQmFyY29kZUluZm8gfCBudWxsID0ge1xyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xyXG5cclxuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XHJcblxyXG4gICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xyXG5cclxuICAgICAgICAvLyBDaGVja3N1bVxyXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGlzLnN1cHBsZW1lbnRzPScsIHRoaXMuc3VwcGxlbWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgc3VwcGxlbWVudCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucyByZXR1cm5zJywgc3VwcGxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsYXN0Q29kZSA9IHN1cHBsZW1lbnQuZGVjb2RlZENvZGVzW3N1cHBsZW1lbnQuZGVjb2RlZENvZGVzLmxlbmd0aCAtIDFdIGFzIEJhcmNvZGVJbmZvO1xyXG4gICAgICAgICAgICBjb25zdCBlbmRJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcclxuICAgICAgICAgICAgICAgIGVuZDogbGFzdENvZGUuZW5kXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdEluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpICsgc3VwcGxlbWVudC5jb2RlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogY29kZS5lbmQsXHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxyXG4gICAgICAgICAgICAuLi5yZXN1bHRJbmZvLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVBTlJlYWRlcjtcclxuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xyXG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcblxyXG5cclxuY2xhc3MgRUFOMlJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XHJcbiAgICBGT1JNQVQgPSAnZWFuXzInO1xyXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBpZiAocm93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcclxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xyXG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xyXG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCAocGFyc2VJbnQocmVzdWx0LmpvaW4oJycpKSAlIDQpICE9PSBjb2RlRnJlcXVlbmN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxyXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbixcclxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRUFOMlJlYWRlcjtcclxuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xyXG5pbXBvcnQgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcblxyXG5jb25zdCBDSEVDS19ESUdJVF9FTkNPRElOR1MgPSBbMjQsIDIwLCAxOCwgMTcsIDEyLCA2LCAzLCAxMCwgOSwgNV07XHJcblxyXG5mdW5jdGlvbiBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENIRUNLX0RJR0lUX0VOQ09ESU5HU1tpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XHJcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcclxuICAgIH1cclxuICAgIHN1bSAqPSAzO1xyXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XHJcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcclxuICAgIH1cclxuICAgIHN1bSAqPSAzO1xyXG4gICAgcmV0dXJuIHN1bSAlIDEwO1xyXG59XHJcblxyXG5jbGFzcyBFQU41UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcclxuICAgIEZPUk1BVCA9ICdlYW5fNSc7XHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJvdykge1xyXG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNSAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XHJcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDQgLSBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSAhPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSA1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkgIT09IGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxyXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFQU41UmVhZGVyO1xyXG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCwgTUlERExFX1BBVFRFUk4gfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xyXG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcblxyXG5jbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcclxuICAgIEZPUk1BVCA9ICdlYW5fOCc7XHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gaW5Db2RlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcclxuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgoY29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XHJcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBjb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XHJcbiAgICAgICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb2RlIGFzIEJhcmNvZGVJbmZvO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcclxuIiwiLy8gVE9ETzogaTJvZjVfcmVhZGVyIGFuZCAyb2Y1X3JlYWRlciBzaGFyZSB2ZXJ5IHNpbWlsYXIgY29kZSwgbWFrZSB1c2Ugb2YgdGhhdFxyXG5cclxuaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcclxuXHJcbmNvbnN0IE4gPSAxO1xyXG5jb25zdCBXID0gMztcclxuXHJcbmNsYXNzIEkyb2Y1UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XHJcbiAgICBwcml2YXRlIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XHJcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XHJcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzg7XHJcblxyXG4gICAgU1RBUlRfUEFUVEVSTiA9IFtOLCBOLCBOLCBOXTtcclxuICAgIFNUT1BfUEFUVEVSTiA9IFtOLCBOLCBXXTtcclxuICAgIENPREVfUEFUVEVSTiA9IFtcclxuICAgICAgICBbTiwgTiwgVywgVywgTl0sXHJcbiAgICAgICAgW1csIE4sIE4sIE4sIFddLFxyXG4gICAgICAgIFtOLCBXLCBOLCBOLCBXXSxcclxuICAgICAgICBbVywgVywgTiwgTiwgTl0sXHJcbiAgICAgICAgW04sIE4sIFcsIE4sIFddLFxyXG4gICAgICAgIFtXLCBOLCBXLCBOLCBOXSxcclxuICAgICAgICBbTiwgVywgVywgTiwgTl0sXHJcbiAgICAgICAgW04sIE4sIE4sIFcsIFddLFxyXG4gICAgICAgIFtXLCBOLCBOLCBXLCBOXSxcclxuICAgICAgICBbTiwgVywgTiwgVywgTl0sXHJcbiAgICBdO1xyXG4gICAgTUFYX0NPUlJFQ1RJT05fRkFDVE9SID0gNTtcclxuICAgIEZPUk1BVCA9ICdpMm9mNSc7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0czogQmFyY29kZVJlYWRlckNvbmZpZykge1xyXG4gICAgICAgIHN1cGVyKG1lcmdlKHsgbm9ybWFsaXplQmFyU3BhY2VXaWR0aDogZmFsc2UgfSwgb3B0cykpO1xyXG4gICAgICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiA9IDAuMzg7XHJcbiAgICAgICAgICAgIHRoaXMuQVZHX0NPREVfRVJST1IgPSAwLjA5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IG9wdHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9tYXRjaFBhdHRlcm4oY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29kZTogUmVhZG9ubHlBcnJheTxudW1iZXI+KTogbnVtYmVyIHtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudGVyU3VtID0gWzAsIDBdO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlU3VtID0gWzAsIDBdO1xyXG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gWzAsIDBdO1xyXG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW8gPSB0aGlzLk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUjtcclxuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvSW52ZXJzZSA9IDEgLyBjb3JyZWN0aW9uUmF0aW87XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJTdW1baSAlIDJdICs9IGNvdW50ZXJbaV07XHJcbiAgICAgICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMF0gPSBjb2RlU3VtWzBdIC8gY291bnRlclN1bVswXTtcclxuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xyXG5cclxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMF0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xyXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblsxXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFyU3BhY2VSYXRpbyA9IGNvcnJlY3Rpb247XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIGNvZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuID0gZmFsc2UsIHRyeUhhcmRlcjogYm9vbGVhbiA9IGZhbHNlKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxyXG4gICAgICAgICAgICBlbmQ6IDAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XHJcblxyXG4gICAgICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xyXG4gICAgICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcclxuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyA0KTtcclxuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XHJcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xyXG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOKTtcclxuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xyXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XHJcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcclxuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XHJcblxyXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyOiBBcnJheTxBcnJheTxudW1iZXI+Pik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IGNvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyUGFpcltpXSk7XHJcbiAgICAgICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29kZXMucHVzaChjb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoY291bnRlcjogQXJyYXk8bnVtYmVyPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XHJcblxyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZUluZm8gPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcclxuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPCBlcHNpbG9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xyXG4gICAgICAgIGxldCBwb3MgPSAwO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgY291bnRlclBhaXIgPSBbWzAsIDAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMCwgMF1dO1xyXG4gICAgICAgIGxldCBjb2RlczogQmFyY29kZUluZm9bXSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMF1baV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xyXG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMV1baV0gPSBjb3VudGVyc1twb3MgKyAxXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1sxXTtcclxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvZGVzID0gdGhpcy5fZGVjb2RlUGFpcihjb3VudGVyUGFpcik7XHJcbiAgICAgICAgICAgIGlmICghY29kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGVzW2ldLmNvZGUgKyAnJyk7XHJcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcclxuICAgICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XHJcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XHJcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xyXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHxcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZW5ndGggPCA2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxyXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEkyb2Y1UmVhZGVyO1xyXG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XHJcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNsYXNzIFVQQ0VSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xyXG4gICAgQ09ERV9GUkVRVUVOQ1kgPSBbXHJcbiAgICAgICAgWyA1NiwgNTIsIDUwLCA0OSwgNDQsIDM4LCAzNSwgNDIsIDQxLCAzNyBdLFxyXG4gICAgICAgIFs3LCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XV07XHJcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogN107XHJcbiAgICBGT1JNQVQgPSAndXBjX2UnO1xyXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XHJcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcclxuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XHJcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA9IChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC0gQ09ERV9HX1NUQVJUO1xyXG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAoMSA8PCAoNSAtIGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XHJcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0Q29kZSBhcyBCYXJjb2RlSW5mbztcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeTogbnVtYmVyLCByZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICBmb3IgKGxldCBuclN5c3RlbSA9IDA7IG5yU3lzdGVtIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IG5yU3lzdGVtKyspe1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV1baV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NvbnZlcnRUb1VQQ0EocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgbGV0IHVwY2EgPSBbcmVzdWx0WzBdXTtcclxuICAgICAgICBjb25zdCBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xyXG5cclxuICAgICAgICBpZiAobGFzdERpZ2l0IDw9IDIpIHtcclxuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCAzKSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQoW2xhc3REaWdpdCwgMCwgMCwgMCwgMF0pXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSgzLCA2KSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDMpIHtcclxuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA0KSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDBdKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoNCwgNikpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSA0KSB7XHJcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNSkpXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwLCByZXN1bHRbNV1dKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDYpKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgbGFzdERpZ2l0XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1cGNhLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHVwY2E7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jaGVja3N1bSh0aGlzLl9jb252ZXJ0VG9VUENBKHJlc3VsdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5fZmluZEVuZChvZmZzZXQsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVVBDRVJlYWRlcjtcclxuIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xyXG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNsYXNzIFVQQ1JlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XHJcbiAgICBGT1JNQVQgPSAndXBjX2EnO1xyXG4gICAgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEVBTlJlYWRlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmNvZGUgJiYgcmVzdWx0LmNvZGUubGVuZ3RoID09PSAxMyAmJiByZXN1bHQuY29kZS5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFVQQ1JlYWRlcjtcclxuIiwiY29uc3QgQnJlc2VuaGFtID0ge307XHJcblxyXG5jb25zdCBTbG9wZSA9IHtcclxuICAgIERJUjoge1xyXG4gICAgICAgIFVQOiAxLFxyXG4gICAgICAgIERPV046IC0xLFxyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiAqIFNjYW5zIGEgbGluZSBvZiB0aGUgZ2l2ZW4gaW1hZ2UgZnJvbSBwb2ludCBwMSB0byBwMiBhbmQgcmV0dXJucyBhIHJlc3VsdCBvYmplY3QgY29udGFpbmluZ1xyXG4gKiBncmF5LXNjYWxlIHZhbHVlcyAoMC0yNTUpIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVscyBpbiBhZGRpdGlvbiB0byB0aGUgbWluXHJcbiAqIGFuZCBtYXggdmFsdWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VXcmFwcGVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSBUaGUgc3RhcnQgcG9pbnQge3gseX1cclxuICogQHBhcmFtIHtPYmplY3R9IHAyIFRoZSBlbmQgcG9pbnQge3gseX1cclxuICogQHJldHVybnMge2xpbmUsIG1pbiwgbWF4fVxyXG4gKi9cclxuQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lID0gZnVuY3Rpb24gKGltYWdlV3JhcHBlciwgcDEsIHAyKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXHJcbiAgICBsZXQgeDAgPSBwMS54IHwgMDtcclxuICAgIGxldCB5MCA9IHAxLnkgfCAwO1xyXG4gICAgbGV0IHgxID0gcDIueCB8IDA7XHJcbiAgICBsZXQgeTEgPSBwMi55IHwgMDtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuICAgIGNvbnN0IHN0ZWVwID0gTWF0aC5hYnMoeTEgLSB5MCkgPiBNYXRoLmFicyh4MSAtIHgwKTtcclxuICAgIGxldCBlcnJvcjtcclxuICAgIGxldCB5O1xyXG4gICAgbGV0IHRtcDtcclxuICAgIGxldCB4O1xyXG4gICAgY29uc3QgbGluZSA9IFtdO1xyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICBsZXQgdmFsO1xyXG4gICAgbGV0IG1pbiA9IDI1NTtcclxuICAgIGxldCBtYXggPSAwO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWQoYSwgYikge1xyXG4gICAgICAgIHZhbCA9IGltYWdlRGF0YVtiICogd2lkdGggKyBhXTtcclxuICAgICAgICBtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XHJcbiAgICAgICAgbWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xyXG4gICAgICAgIGxpbmUucHVzaCh2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGVlcCkge1xyXG4gICAgICAgIHRtcCA9IHgwO1xyXG4gICAgICAgIHgwID0geTA7XHJcbiAgICAgICAgeTAgPSB0bXA7XHJcblxyXG4gICAgICAgIHRtcCA9IHgxO1xyXG4gICAgICAgIHgxID0geTE7XHJcbiAgICAgICAgeTEgPSB0bXA7XHJcbiAgICB9XHJcbiAgICBpZiAoeDAgPiB4MSkge1xyXG4gICAgICAgIHRtcCA9IHgwO1xyXG4gICAgICAgIHgwID0geDE7XHJcbiAgICAgICAgeDEgPSB0bXA7XHJcblxyXG4gICAgICAgIHRtcCA9IHkwO1xyXG4gICAgICAgIHkwID0geTE7XHJcbiAgICAgICAgeTEgPSB0bXA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWx0YVggPSB4MSAtIHgwO1xyXG4gICAgY29uc3QgZGVsdGFZID0gTWF0aC5hYnMoeTEgLSB5MCk7XHJcbiAgICBlcnJvciA9IChkZWx0YVggLyAyKSB8IDA7XHJcbiAgICB5ID0geTA7XHJcbiAgICBjb25zdCB5U3RlcCA9IHkwIDwgeTEgPyAxIDogLTE7XHJcbiAgICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcclxuICAgICAgICBpZiAoc3RlZXApIHtcclxuICAgICAgICAgICAgcmVhZCh5LCB4KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZWFkKHgsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlcnJvciAtPSBkZWx0YVk7XHJcbiAgICAgICAgaWYgKGVycm9yIDwgMCkge1xyXG4gICAgICAgICAgICB5ICs9IHlTdGVwO1xyXG4gICAgICAgICAgICBlcnJvciArPSBkZWx0YVg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGluZSxcclxuICAgICAgICBtaW4sXHJcbiAgICAgICAgbWF4LFxyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgcmVzdWx0IGZyb20gZ2V0QmFyY29kZUxpbmUgaW50byBhIGJpbmFyeSByZXByZXNlbnRhdGlvblxyXG4gKiBhbHNvIGNvbnNpZGVyaW5nIHRoZSBmcmVxdWVuY3kgYW5kIHNsb3BlIG9mIHRoZSBzaWduYWwgZm9yIG1vcmUgcm9idXN0IHJlc3VsdHNcclxuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB7bGluZSwgbWluLCBtYXh9XHJcbiAqL1xyXG5CcmVzZW5oYW0udG9CaW5hcnlMaW5lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgY29uc3QgeyBtaW4gfSA9IHJlc3VsdDtcclxuICAgIGNvbnN0IHsgbWF4IH0gPSByZXN1bHQ7XHJcbiAgICBjb25zdCB7IGxpbmUgfSA9IHJlc3VsdDtcclxuICAgIGxldCBzbG9wZTtcclxuICAgIGxldCBzbG9wZTI7XHJcbiAgICBjb25zdCBjZW50ZXIgPSBtaW4gKyAobWF4IC0gbWluKSAvIDI7XHJcbiAgICBjb25zdCBleHRyZW1hID0gW107XHJcbiAgICBsZXQgY3VycmVudERpcjtcclxuICAgIGxldCBkaXI7XHJcbiAgICBsZXQgdGhyZXNob2xkID0gKG1heCAtIG1pbikgLyAxMjtcclxuICAgIGNvbnN0IHJUaHJlc2hvbGQgPSAtdGhyZXNob2xkO1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgajtcclxuXHJcbiAgICAvLyAxLiBmaW5kIGV4dHJlbWFcclxuICAgIGN1cnJlbnREaXIgPSBsaW5lWzBdID4gY2VudGVyID8gU2xvcGUuRElSLlVQIDogU2xvcGUuRElSLkRPV047XHJcbiAgICBleHRyZW1hLnB1c2goe1xyXG4gICAgICAgIHBvczogMCxcclxuICAgICAgICB2YWw6IGxpbmVbMF0sXHJcbiAgICB9KTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgIHNsb3BlID0gKGxpbmVbaSArIDFdIC0gbGluZVtpXSk7XHJcbiAgICAgICAgc2xvcGUyID0gKGxpbmVbaSArIDJdIC0gbGluZVtpICsgMV0pO1xyXG4gICAgICAgIGlmICgoc2xvcGUgKyBzbG9wZTIpIDwgclRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA8IChjZW50ZXIgKiAxLjUpKSB7XHJcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5ET1dOO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKHNsb3BlICsgc2xvcGUyKSA+IHRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA+IChjZW50ZXIgKiAwLjUpKSB7XHJcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5VUDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaXIgPSBjdXJyZW50RGlyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnREaXIgIT09IGRpcikge1xyXG4gICAgICAgICAgICBleHRyZW1hLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgcG9zOiBpLFxyXG4gICAgICAgICAgICAgICAgdmFsOiBsaW5lW2ldLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3VycmVudERpciA9IGRpcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHRyZW1hLnB1c2goe1xyXG4gICAgICAgIHBvczogbGluZS5sZW5ndGgsXHJcbiAgICAgICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKGogPSBleHRyZW1hWzBdLnBvczsgaiA8IGV4dHJlbWFbMV0ucG9zOyBqKyspIHtcclxuICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IGNlbnRlciA/IDAgOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGl0ZXJhdGUgb3ZlciBleHRyZW1hIGFuZCBjb252ZXJ0IHRvIGJpbmFyeSBiYXNlZCBvbiBhdmcgYmV0d2VlbiBtaW5tYXhcclxuICAgIGZvciAoaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIGlmIChleHRyZW1hW2kgKyAxXS52YWwgPiBleHRyZW1hW2ldLnZhbCkge1xyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpXS52YWwgKyAoKGV4dHJlbWFbaSArIDFdLnZhbCAtIGV4dHJlbWFbaV0udmFsKSAvIDMpICogMikgfCAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2kgKyAxXS52YWwgKyAoKGV4dHJlbWFbaV0udmFsIC0gZXh0cmVtYVtpICsgMV0udmFsKSAvIDMpKSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGogPSBleHRyZW1hW2ldLnBvczsgaiA8IGV4dHJlbWFbaSArIDFdLnBvczsgaisrKSB7XHJcbiAgICAgICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGluZSxcclxuICAgICAgICB0aHJlc2hvbGQsXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgZm9yIGRldmVsb3BtZW50IG9ubHlcclxuICovXHJcbkJyZXNlbmhhbS5kZWJ1ZyA9IHtcclxuICAgIHByaW50RnJlcXVlbmN5KGxpbmUsIGNhbnZhcykge1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyNTY7XHJcblxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhpLCAyNTUpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKGksIDI1NSAtIGxpbmVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcmludFBhdHRlcm4obGluZSwgY2FudmFzKSB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7IGxldFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcclxuICAgICAgICBjdHguZmlsbENvbG9yID0gJ2JsYWNrJztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGluZVtpXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGksIDAsIDEsIDEwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQnJlc2VuaGFtO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tY3ljbGUgKi9cclxuXHJcbi8qKlxyXG4gKiBCYXJjb2RlIERlY29kZXIgTW9kdWxlXHJcbiAqXHJcbiAqIFRoaXMgbW9kdWxlIGhhbmRsZXMgdGhlIGRlY29kaW5nIG9mIGJhcmNvZGVzIHVzaW5nIGNvbmZpZ3VyZWQgcmVhZGVycy5cclxuICpcclxuICogUkVBREVSIE9SREVSIEdVQVJBTlRFRTpcclxuICogUmVhZGVycyBhcmUgcHJvY2Vzc2VkIGluIHRoZSBleGFjdCBvcmRlciB0aGV5IGFyZSBzcGVjaWZpZWQgaW4gdGhlIGByZWFkZXJzYFxyXG4gKiBjb25maWcgYXJyYXkuIFRoZSBmaXJzdCByZWFkZXIgdG8gc3VjY2Vzc2Z1bGx5IGRlY29kZSB0aGUgYmFyY29kZSB3aW5zLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiAgIHJlYWRlcnM6IFsnZWFuX3JlYWRlcicsICd1cGNfZV9yZWFkZXInLCAnY29kZV8xMjhfcmVhZGVyJ11cclxuICpcclxuICogRGVjb2Rpbmcgb3JkZXI6XHJcbiAqICAgMS4gZWFuX3JlYWRlciBhdHRlbXB0cyB0byBkZWNvZGVcclxuICogICAyLiBJZiBlYW5fcmVhZGVyIHJldHVybnMgbnVsbCwgdXBjX2VfcmVhZGVyIGF0dGVtcHRzIHRvIGRlY29kZVxyXG4gKiAgIDMuIElmIHVwY19lX3JlYWRlciByZXR1cm5zIG51bGwsIGNvZGVfMTI4X3JlYWRlciBhdHRlbXB0cyB0byBkZWNvZGVcclxuICogICA0LiBGaXJzdCBub24tbnVsbCByZXN1bHQgaXMgcmV0dXJuZWRcclxuICpcclxuICogRVhURVJOQUwgUkVBREVSUzpcclxuICogRXh0ZXJuYWwgcmVhZGVycyBtdXN0IGJlIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyUmVhZGVyKCkgYmVmb3JlIHVzZS5cclxuICogT25jZSByZWdpc3RlcmVkLCB0aGV5IGZvbGxvdyB0aGUgc2FtZSBvcmRlcmluZyBydWxlcyBhcyBidWlsdC1pbiByZWFkZXJzLlxyXG4gKiBUaGVpciBwb3NpdGlvbiBpbiB0aGUgYHJlYWRlcnNgIGFycmF5IGRldGVybWluZXMgdGhlaXIgcHJpb3JpdHkuXHJcbiAqXHJcbiAqIFRvIHByaW9yaXRpemUgYW4gZXh0ZXJuYWwgcmVhZGVyOlxyXG4gKiAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcignbXlfcmVhZGVyJywgTXlSZWFkZXIpO1xyXG4gKiAgIGNvbmZpZy5kZWNvZGVyLnJlYWRlcnMgPSBbJ215X3JlYWRlcicsICdlYW5fcmVhZGVyJ107IC8vIG15X3JlYWRlciB0cmllZCBmaXJzdFxyXG4gKi9cclxuXHJcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XHJcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyLzJvZjVfcmVhZGVyJztcclxuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcclxuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMTI4X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzJfcmVhZGVyJztcclxuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzkzX3JlYWRlcic7XHJcbmltcG9ydCBFQU4yUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fMl9yZWFkZXInO1xyXG5pbXBvcnQgRUFONVJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzVfcmVhZGVyJztcclxuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl84X3JlYWRlcic7XHJcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl9yZWFkZXInO1xyXG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XHJcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfZV9yZWFkZXInO1xyXG5pbXBvcnQgVVBDUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfcmVhZGVyJztcclxuaW1wb3J0IEJyZXNlbmhhbSBmcm9tICcuL2JyZXNlbmhhbSc7XHJcblxyXG5jb25zdCBSRUFERVJTID0ge1xyXG4gICAgY29kZV8xMjhfcmVhZGVyOiBDb2RlMTI4UmVhZGVyLFxyXG4gICAgZWFuX3JlYWRlcjogRUFOUmVhZGVyLFxyXG4gICAgZWFuXzVfcmVhZGVyOiBFQU41UmVhZGVyLFxyXG4gICAgZWFuXzJfcmVhZGVyOiBFQU4yUmVhZGVyLFxyXG4gICAgZWFuXzhfcmVhZGVyOiBFQU44UmVhZGVyLFxyXG4gICAgY29kZV8zOV9yZWFkZXI6IENvZGUzOVJlYWRlcixcclxuICAgIGNvZGVfMzlfdmluX3JlYWRlcjogQ29kZTM5VklOUmVhZGVyLFxyXG4gICAgY29kYWJhcl9yZWFkZXI6IENvZGFiYXJSZWFkZXIsXHJcbiAgICB1cGNfcmVhZGVyOiBVUENSZWFkZXIsXHJcbiAgICB1cGNfZV9yZWFkZXI6IFVQQ0VSZWFkZXIsXHJcbiAgICBpMm9mNV9yZWFkZXI6IEkyb2Y1UmVhZGVyLFxyXG4gICAgJzJvZjVfcmVhZGVyJzogVHdvT2ZGaXZlUmVhZGVyLFxyXG4gICAgY29kZV85M19yZWFkZXI6IENvZGU5M1JlYWRlcixcclxuICAgIGNvZGVfMzJfcmVhZGVyOiBDb2RlMzJSZWFkZXIsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBleHRlcm5hbC9jdXN0b20gYmFyY29kZSByZWFkZXIuXHJcbiAgICAgKiBPbmNlIHJlZ2lzdGVyZWQsIHRoZSByZWFkZXIgY2FuIGJlIHVzZWQgaW4gY29uZmlnLnJlYWRlcnMgYXJyYXkuXHJcbiAgICAgKiBUaGUgcmVhZGVyJ3MgcG9zaXRpb24gaW4gY29uZmlnLnJlYWRlcnMgZGV0ZXJtaW5lcyBpdHMgZGVjb2RpbmcgcHJpb3JpdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgaWRlbnRpZmllciB0byB1c2UgaW4gY29uZmlnLnJlYWRlcnMgKGUuZy4sICdteV9jdXN0b21fcmVhZGVyJylcclxuICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIGNsYXNzIChtdXN0IGV4dGVuZCBCYXJjb2RlUmVhZGVyKVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBSZWdpc3RlciBhIGN1c3RvbSByZWFkZXJcclxuICAgICAqIEJhcmNvZGVEZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKCdteV9yZWFkZXInLCBNeUN1c3RvbVJlYWRlcik7XHJcbiAgICAgKlxyXG4gICAgICogLy8gVXNlIGl0IHdpdGggaGlnaCBwcmlvcml0eSAoZmlyc3QgaW4gYXJyYXkpXHJcbiAgICAgKiBjb25maWcuZGVjb2Rlci5yZWFkZXJzID0gWydteV9yZWFkZXInLCAnZWFuX3JlYWRlcicsICdjb2RlXzEyOF9yZWFkZXInXTtcclxuICAgICAqL1xyXG4gICAgcmVnaXN0ZXJSZWFkZXI6IChuYW1lLCByZWFkZXIpID0+IHtcclxuICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZShjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICAgICAgY29uc3QgX2NhbnZhcyA9IHtcclxuICAgICAgICAgICAgY3R4OiB7XHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZG9tOiB7XHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IF9iYXJjb2RlUmVhZGVycyA9IFtdO1xyXG5cclxuICAgICAgICBpbml0Q2FudmFzKCk7XHJcbiAgICAgICAgaW5pdFJlYWRlcnMoKTtcclxuICAgICAgICBpbml0Q29uZmlnKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnLmRldGVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmZyZXF1ZW5jeScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kuY2xhc3NOYW1lID0gJ2ZyZXF1ZW5jeSc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zz8ucHJpbnRSZWFkZXJJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIGJhcmNvZGUgZGVjb2RlciBpbml0Q2FudmFzIGdldGNvbnRleHQgMmQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LmZyZXF1ZW5jeSA9IF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMucGF0dGVybkJ1ZmZlcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4uY2xhc3NOYW1lID0gJ3BhdHRlcm5CdWZmZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLnBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LnBhdHRlcm4gPSBfY2FudmFzLmRvbS5wYXR0ZXJuLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ub3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5kcmF3aW5nQnVmZmVyJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5kb20ub3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4Lm92ZXJsYXkgPSBfY2FudmFzLmRvbS5vdmVybGF5LmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGJhcmNvZGUgcmVhZGVycyBmcm9tIGNvbmZpZy5yZWFkZXJzIGFycmF5LlxyXG4gICAgICAgICAqIFJlYWRlcnMgYXJlIGluc3RhbnRpYXRlZCBhbmQgc3RvcmVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhciBpbiBjb25maWcsXHJcbiAgICAgICAgICogd2hpY2ggZGV0ZXJtaW5lcyB0aGVpciBkZWNvZGluZyBwcmlvcml0eSAoZmlyc3QgaW4gYXJyYXkgPSBoaWdoZXN0IHByaW9yaXR5KS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBpbml0UmVhZGVycygpIHtcclxuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaCgocmVhZGVyQ29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGxldCBzdXBwbGVtZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWc/LnByaW50UmVhZGVySW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiAnLCByZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3VwcGxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKHJlYWRlck9iaik7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIEVycm9yIGNvbnN0cnVjdGluZyByZWFkZXIgJywgcmVhZGVyLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnPy5wcmludFJlYWRlckluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWdpc3RlcmVkIFJlYWRlcnM6ICR7X2JhcmNvZGVSZWFkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7IGZvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzID0gW3tcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3ksXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcclxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4sXHJcbiAgICAgICAgICAgICAgICB9XTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkTGluZShsaW5lLCBhbmdsZSwgZXh0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeTogYW1vdW50ICogTWF0aC5zaW4oYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcclxuICAgICAgICAgICAgZXh0ZW5kTGluZShleHQpO1xyXG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe1xyXG4gICAgICAgICAgICAgICAgeDogKGJveFsxXVswXSAtIGJveFswXVswXSkgLyAyICsgYm94WzBdWzBdLFxyXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdLFxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICB4OiAoYm94WzNdWzBdIC0gYm94WzJdWzBdKSAvIDIgKyBib3hbMl1bMF0sXHJcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV0sXHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXR0ZW1wdHMgdG8gZGVjb2RlIGEgYmFyY29kZSBmcm9tIGEgc2NhbiBsaW5lLlxyXG4gICAgICAgICAqIFJlYWRlcnMgYXJlIHRyaWVkIGluIG9yZGVyIChhcyBzcGVjaWZpZWQgaW4gY29uZmlnLnJlYWRlcnMpLlxyXG4gICAgICAgICAqIFRoZSBmaXJzdCByZWFkZXIgdG8gcmV0dXJuIGEgbm9uLW51bGwgcmVzdWx0IHdpbnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgc2NhbiBsaW5lIHRvIGRlY29kZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gRGVjb2RlZCByZXN1bHQgb3IgbnVsbCBpZiBubyByZWFkZXIgc3VjY2VlZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5jdHgub3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwgeyB4OiAneCcsIHk6ICd5JyB9LCBfY2FudmFzLmN0eC5vdmVybGF5LCB7IGNvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50RnJlcXVlbmN5KGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEJyZXNlbmhhbS50b0JpbmFyeUxpbmUoYmFyY29kZUxpbmUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludFBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20ucGF0dGVybik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgcmVhZGVycyBpbiBvcmRlciAtIGZpcnN0IHN1Y2Nlc3NmdWwgZGVjb2RlIHdpbnNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF9iYXJjb2RlUmVhZGVycy5sZW5ndGggJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNsaWNlcyB0aGUgZ2l2ZW4gYXJlYSBhcGFydCBhbmQgdHJpZXMgdG8gZGV0ZWN0IGEgYmFyY29kZS1wYXR0ZXJuXHJcbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGJveFxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KGJveFsxXVswXSAtIGJveFswXVswXSwgMikgKyBNYXRoLnBvdygoYm94WzFdWzFdIC0gYm94WzBdWzFdKSwgMikpO1xyXG4gICAgICAgICAgICBsZXQgaTtcclxuICAgICAgICAgICAgY29uc3Qgc2xpY2VzID0gMTY7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgZGlyO1xyXG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uO1xyXG4gICAgICAgICAgICBjb25zdCB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKTtcclxuICAgICAgICAgICAgY29uc3QgeWRpciA9IE1hdGguY29zKGxpbmVBbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgc2xpY2VzICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGxpbmUgcGVycGVuZGljdWxhciB0byBhbmdsZVxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgZGlyID0gc2lkZUxlbmd0aCAvIHNsaWNlcyAqIGkgKiAoaSAlIDIgPT09IDAgPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHk6IGRpciAqIHhkaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogZGlyICogeWRpcixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS55ICs9IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS54IC09IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChsaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnkgLSBsaW5lWzBdLnkpLCAyKVxyXG4gICAgICAgICAgICAgICAgKyBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnggLSBsaW5lWzBdLngpLCAyKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgZnJvbSBhIGZ1bGwgaW1hZ2UgdXNpbmcgcmVhZGVycyB0aGF0IHN1cHBvcnQgaW1hZ2UtYmFzZWQgZGVjb2RpbmcuXHJcbiAgICAgICAgICogUmVhZGVycyBhcmUgdHJpZWQgaW4gb3JkZXIgKGFzIHNwZWNpZmllZCBpbiBjb25maWcucmVhZGVycykuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlciBUaGUgaW1hZ2UgdG8gZGVjb2RlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdHxudWxsfSBEZWNvZGVkIHJlc3VsdCBvciBudWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlcikge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSByZWFkZXJzIGluIG9yZGVyIC0gZmlyc3Qgc3VjY2Vzc2Z1bCBkZWNvZGUgd2luc1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBfYmFyY29kZVJlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWFkZXIuZGVjb2RlSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCByZWFkZXIuZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaXRoIHRoZSBoZWxwIG9mIHRoZSBjb25maWd1cmVkIHJlYWRlcnMgKENvZGUxMjggb3IgRUFOKSB0aGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGRldGVjdCBhXHJcbiAgICAgICAgICogdmFsaWQgYmFyY29kZSBwYXR0ZXJuIHdpdGhpbiB0aGUgZ2l2ZW4gYXJlYS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYm94IFRoZSBhcmVhIHRvIHNlYXJjaCBpblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXN1bHQge2NvZGVSZXN1bHQsIGxpbmUsIGFuZ2xlLCBwYXR0ZXJuLCB0aHJlc2hvbGR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xyXG4gICAgICAgICAgICBsZXQgbGluZTtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gX2NhbnZhcy5jdHgub3ZlcmxheTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcuZHJhd0JvdW5kaW5nQm94ICYmIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgY3R4LCB7IGNvbG9yOiAnYmx1ZScsIGxpbmVXaWR0aDogMiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGluZSA9IGdldExpbmUoYm94KTtcclxuICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGdldExpbmVMZW5ndGgobGluZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmdsZSA9IE1hdGguYXRhbjIobGluZVsxXS55IC0gbGluZVswXS55LCBsaW5lWzFdLnggLSBsaW5lWzBdLngpO1xyXG4gICAgICAgICAgICBsaW5lID0gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGxpbmVBbmdsZSwgTWF0aC5mbG9vcihsaW5lTGVuZ3RoICogMC4xKSk7XHJcbiAgICAgICAgICAgIGlmIChsaW5lID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgcmVzdWx0ICYmIGNvbmZpZy5kZWJ1Zy5kcmF3U2NhbmxpbmUgJiYgY3R4KSB7XHJcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgY3R4LCB7IGNvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LmNvZGVSZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgYW5nbGU6IGxpbmVBbmdsZSxcclxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHJlc3VsdC5iYXJjb2RlTGluZS5saW5lLFxyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiByZXN1bHQuYmFyY29kZUxpbmUudGhyZXNob2xkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGk7IGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJjb2RlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBtdWx0aXBsZSB9ID0gY29uZmlnO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IGJveGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib3ggPSBib3g7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2Rlcy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXN5bmMgZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlckluKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWNvZGVGcm9tSW1hZ2UoaW1hZ2VXcmFwcGVySW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlZ2lzdGVyIGV4aXN0aW5nIHJlYWRlcicsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0UmVhZGVycyhyZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzID0gcmVhZGVycztcclxuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi8yb2Y1X3JlYWRlcic7XHJcbmltcG9ydCBOZXdDb2RhYmFyUmVhZGVyIGZyb20gJy4vY29kYWJhcl9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTEyOFJlYWRlciBmcm9tICcuL2NvZGVfMTI4X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi9jb2RlXzMyX3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3Zpbl9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4vY29kZV85M19yZWFkZXInO1xyXG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuL2Vhbl8yX3JlYWRlcic7XHJcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4vZWFuXzVfcmVhZGVyJztcclxuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi9lYW5fOF9yZWFkZXInO1xyXG5pbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XHJcbmltcG9ydCBJMm9mNVJlYWRlciBmcm9tICcuL2kyb2Y1X3JlYWRlcic7XHJcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4vdXBjX2VfcmVhZGVyJztcclxuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuL3VwY19yZWFkZXInO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIEJhcmNvZGVSZWFkZXIsXHJcbiAgICBUd29PZkZpdmVSZWFkZXIsXHJcbiAgICBOZXdDb2RhYmFyUmVhZGVyLFxyXG4gICAgQ29kZTEyOFJlYWRlcixcclxuICAgIENvZGUzMlJlYWRlcixcclxuICAgIENvZGUzOVJlYWRlcixcclxuICAgIENvZGUzOVZJTlJlYWRlcixcclxuICAgIENvZGU5M1JlYWRlcixcclxuICAgIEVBTjJSZWFkZXIsXHJcbiAgICBFQU41UmVhZGVyLFxyXG4gICAgRUFOOFJlYWRlcixcclxuICAgIEVBTlJlYWRlcixcclxuICAgIEkyb2Y1UmVhZGVyLFxyXG4gICAgVVBDRVJlYWRlcixcclxuICAgIFVQQ1JlYWRlciwgICAgXHJcbn1cclxuIiwidHlwZSBFdmVudE5hbWUgPSBzdHJpbmc7XHJcblxyXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcclxuICAgIGFzeW5jPzogYm9vbGVhbjtcclxuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcclxuICAgIG9uY2U/OiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRXZlbnREYXRhIHtcclxuICAgIHN1YnNjcmliZXJzOiBBcnJheTxTdWJzY3JpcHRpb24+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRXZlbnRzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IEV2ZW50RGF0YTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEV2ZW50SW50ZXJmYWNlIHtcclxuICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkO1xyXG4gICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoKTogRXZlbnRJbnRlcmZhY2Uge1xyXG4gICAgbGV0IGV2ZW50czogRXZlbnRzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lOiBFdmVudE5hbWUpOiBFdmVudERhdGEge1xyXG4gICAgICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpOiB2b2lkIHtcclxuICAgICAgICBldmVudHMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLCBkYXRhOiBuZXZlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XHJcbiAgICAgICAgICAgIH0sIDQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBhc3luYyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgd2FzIG5vdCBzcGVjaWZpZWQgb24gb3B0aW9ucycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIG9uZS10aW1lIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhIXN1YnNjcmliZXIub25jZSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhc3Vic2NyaWJlci5vbmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmMgPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICAgICAgICBfc3Vic2NyaWJlKGV2ZW50LCB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIGFzeW5jLFxyXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufSgpKTtcclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29kZT86IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihtOiBzdHJpbmcsIGNvZGU/OiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlcihtKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBFeGNlcHRpb24ucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL3F1YWdnYS9FeGNlcHRpb24nO1xyXG5cclxuY29uc3QgRVJST1JfREVTQyA9ICdUaGlzIG1heSBtZWFuIHRoYXQgdGhlIHVzZXIgaGFzIGRlY2xpbmVkIGNhbWVyYSBhY2Nlc3MsIG9yIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbWVkaWEgQVBJcy4gSWYgeW91IGFyZSBydW5uaW5nIGluIGlPUywgeW91IG11c3QgdXNlIFNhZmFyaS4nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFeGNlcHRpb24oYGVudW1lcmF0ZURldmljZXMgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gLCAtMSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFeGNlcHRpb24oYGdldFVzZXJNZWRpYSBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWAsIC0xKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIFRPRE86IHdoZW4gdGhpcyBmaWxlIHdhcyB3cml0dGVuIHllYXJzIGFnbywgSFRNTE1lZGlhRWxlbWVudC5wbGF5KCkgZGlkIG5vdCByZXR1cm4gYSB1c2VmdWwgdmFsdWVcclxuLy8gdG8gbGV0IHVzIGtub3cgd2hlbiB0aGUgdmlkZW8gc3RhcnRlZCBwbGF5aW5nLiAgTm93LCBpdCBkb2VzLiAgU28sIHdlIHNob3VsZG4ndCBuZWVkIHRvIHJ1biB0aGlzXHJcbi8vIG9kZCB3YWl0Rm9yVmlkZW8oKSBmdW5jdGlvbiB0aGF0IHBvbGxzIHRvIHNlZSBpZiB0aGUgdmlkZW8gaGFzIHN0YXJ0ZWQuXHJcbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC9waWNrJztcclxuaW1wb3J0IHsgZ2V0VXNlck1lZGlhLCBlbnVtZXJhdGVEZXZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL21lZGlhRGV2aWNlcyc7XHJcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vcXVhZ2dhL0V4Y2VwdGlvbic7XHJcbmltcG9ydCB0eXBlIHtcclxuICAgIE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkLFxyXG4gICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MgYXMgQ2FtZXJhQWNjZXNzVHlwZSxcclxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuXHJcbmxldCBzdHJlYW1SZWY6IE1lZGlhU3RyZWFtIHwgbnVsbDtcclxuXHJcbmZ1bmN0aW9uIHdhaXRGb3JWaWRlbyh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAxMDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpOiB2b2lkIHtcclxuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvLnZpZGVvV2lkdGggPiAxMCAmJiB2aWRlby52aWRlb0hlaWdodCA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgKiBkZXY6IGNoZWNrVmlkZW8gZm91bmQgJHt2aWRlby52aWRlb1dpZHRofXB4IHggJHt2aWRlby52aWRlb0hlaWdodH1weGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVmlkZW8sIDUwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEV4Y2VwdGlvbignVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nLCAtMSkpOyAvLyBUT0RPOiBhZGQgZXJyb3IgY29kZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF0dGVtcHRzLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoZWNrVmlkZW8oKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxyXG4gKiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGNvbnRlbnQgaXMgcmVhZHlcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xyXG4gICAgaWYgKHZpZGVvKSB7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsICd0cnVlJyk7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7IC8vIG5vdCBsaXN0ZWQgb24gTUROLi4uXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB2aWRlby5wbGF5KCkuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIEVycm9yIHdoaWxlIHRyeWluZyB0byBwbGF5IHZpZGVvIHN0cmVhbTonLCBlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gd2FpdEZvclZpZGVvKHZpZGVvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2ZhY2luZ01vZGUnLFxyXG4gICAgICAgICdhc3BlY3RSYXRpbycsICdkZXZpY2VJZCddKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICYmIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gPiAwKSB7XHJcbiAgICAgICAgbm9ybWFsaXplZC5hc3BlY3RSYXRpbyA9IHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW87XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnbWluQXNwZWN0UmF0aW9cXCcgaXMgZGVwcmVjYXRlZDsgVXNlIFxcJ2FzcGVjdFJhdGlvXFwnIGluc3RlYWQnKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5mYWNpbmcgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgbm9ybWFsaXplZC5mYWNpbmdNb2RlID0gdmlkZW9Db25zdHJhaW50cy5mYWNpbmc7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnZmFjaW5nXFwnIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXCdmYWNpbmdNb2RlXFwnIGluc3RlYWRcXCcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG59XHJcblxyXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxyXG4vLyBJIHRoaW5rIGl0IHdhcyBqdXN0IHRoYXQgd2F5IHNvIGl0IGNvdWxkIGJlIGNoYWluZWQgdG8gb3RoZXIgZnVuY3Rpb25zIHRoYXQgZGlkIHJldHVybiBhIFByb21pc2UuXHJcbi8vIFRoYXQncyBub3QgbmVjZXNzYXJ5IHdpdGggYXN5bmMgZnVuY3Rpb25zIGJlaW5nIGEgdGhpbmcsIHNvIHRoYXQgc2hvdWxkIGJlIGZpeGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkID0ge30pOiBQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+IHtcclxuICAgIGNvbnN0IHZpZGVvID0gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpO1xyXG5cclxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5kZXZpY2VJZCAmJiB2aWRlby5mYWNpbmdNb2RlKSB7XHJcbiAgICAgICAgZGVsZXRlIHZpZGVvLmZhY2luZ01vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXVkaW86IGZhbHNlLCB2aWRlbyB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVudW1lcmF0ZXMgdmlkZW8gaW5wdXQgZGV2aWNlcywgb3B0aW9uYWxseSBmaWx0ZXJpbmcgYnkgY29uc3RyYWludHMuXHJcbiAqIEBwYXJhbSB2aWRlb0NvbnN0cmFpbnRzIE9wdGlvbmFsIGNvbnN0cmFpbnRzIHRvIGZpbHRlciBkZXZpY2VzLlxyXG4gKiBXaGVuIHByb3ZpZGVkLCBvbmx5IGRldmljZXMgdGhhdCBzYXRpc2Z5IHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBUaGlzIHdvcmtzIGJ5IGF0dGVtcHRpbmcgdG8gZ2V0IGEgbWVkaWEgc3RyZWFtIGZvciBlYWNoIGRldmljZSB3aXRoIHRoZSBjb25zdHJhaW50c1xyXG4gKiBhbmQgcmV0dXJuaW5nIG9ubHkgdGhlIGRldmljZXMgdGhhdCBzdWNjZWVkLlxyXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhbiBhcnJheSBvZiBNZWRpYURldmljZUluZm8gZm9yIHZpZGVvIGlucHV0IGRldmljZXMuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbnVtZXJhdGVWaWRlb0RldmljZXMoXHJcbiAgICB2aWRlb0NvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQsXHJcbik6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xyXG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IGVudW1lcmF0ZURldmljZXMoKTtcclxuICAgIGNvbnN0IHZpZGVvRGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKChkZXZpY2U6IE1lZGlhRGV2aWNlSW5mbykgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XHJcblxyXG4gICAgLy8gSWYgbm8gY29uc3RyYWludHMgYXJlIHByb3ZpZGVkLCByZXR1cm4gYWxsIHZpZGVvIGRldmljZXNcclxuICAgIGlmICghdmlkZW9Db25zdHJhaW50cykge1xyXG4gICAgICAgIHJldHVybiB2aWRlb0RldmljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVyIGRldmljZXMgYmFzZWQgb24gY29uc3RyYWludHMgYnkgdHJ5aW5nIHRvIGdldCBhIG1lZGlhIHN0cmVhbSBmb3IgZWFjaFxyXG4gICAgY29uc3QgY29uc3RyYWluZWREZXZpY2VzOiBBcnJheTxNZWRpYURldmljZUluZm8+ID0gW107XHJcblxyXG4gICAgLy8gUHJvY2VzcyBjb25zdHJhaW50cyBidXQgZXhjbHVkZSBkZXZpY2VJZCBzaW5jZSB3ZSdsbCBzZXQgaXQgb3Vyc2VsdmVzIGZvciBlYWNoIGRldmljZVxyXG4gICAgY29uc3QgcHJvY2Vzc2VkQ29uc3RyYWludHMgPSBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBjb25zdCB7IGRldmljZUlkOiBfLCAuLi5jb25zdHJhaW50c1dpdGhvdXREZXZpY2VJZCB9ID0gcHJvY2Vzc2VkQ29uc3RyYWludHM7XHJcblxyXG4gICAgZm9yIChjb25zdCBkZXZpY2Ugb2YgdmlkZW9EZXZpY2VzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XHJcbiAgICAgICAgICAgICAgICBhdWRpbzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2aWRlbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnN0cmFpbnRzV2l0aG91dERldmljZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldmljZUlkOiB7IGV4YWN0OiBkZXZpY2UuZGV2aWNlSWQgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XHJcbiAgICAgICAgICAgIC8vIFN0b3AgYWxsIHRyYWNrcyBpbW1lZGlhdGVseSBhZnRlciB0ZXN0aW5nXHJcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcclxuICAgICAgICAgICAgY29uc3RyYWluZWREZXZpY2VzLnB1c2goZGV2aWNlKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgLy8gRGV2aWNlIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgY29uc3RyYWludHMsIHNraXAgaXQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2ggaXMgaW50ZW50aW9uYWxseSBlbXB0eSBhcyB3ZSdyZSB1c2luZyBnZXRVc2VyTWVkaWEgdG8gdGVzdCBpZlxyXG4gICAgICAgICAgICAvLyBlYWNoIGRldmljZSBzdXBwb3J0cyB0aGUgY29uc3RyYWludHMuIEVycm9ycyBoZXJlIGluZGljYXRlIHRoZSBkZXZpY2VcclxuICAgICAgICAgICAgLy8gZG9lc24ndCBtZWV0IHRoZSByZXF1aXJlbWVudHMgKE92ZXJjb25zdHJhaW5lZEVycm9yKSBvciBvdGhlciBpc3N1ZXNcclxuICAgICAgICAgICAgLy8gdGhhdCBtZWFuIHdlIHNob3VsZCBleGNsdWRlIHRoaXMgZGV2aWNlIGZyb20gdGhlIHJlc3VsdHMuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb25zdHJhaW5lZERldmljZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCBudWxsIHtcclxuICAgIGlmICghc3RyZWFtUmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcclxuICAgIHJldHVybiB0cmFja3MgJiYgdHJhY2tzPy5sZW5ndGggPyB0cmFja3NbMF0gOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZCBmb3IgYWNjZXNzaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3RpdmUgc3RyZWFtIHRyYWNrIGFuZCBhdmFpbGFibGUgdmlkZW8gZGV2aWNlcy5cclxuICovXHJcbmNvbnN0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzOiBDYW1lcmFBY2Nlc3NUeXBlID0ge1xyXG4gICAgcmVxdWVzdGVkVmlkZW9FbGVtZW50OiBudWxsLFxyXG4gICAgYXN5bmMgcmVxdWVzdCh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIHZpZGVvQ29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gdmlkZW87XHJcbiAgICAgICAgY29uc3QgbmV3Q29uc3RyYWludHMgPSBhd2FpdCBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XHJcbiAgICAgICAgcmV0dXJuIGluaXRDYW1lcmEodmlkZW8sIG5ld0NvbnN0cmFpbnRzKTtcclxuICAgIH0sXHJcbiAgICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZiAmJiBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcclxuICAgICAgICBpZiAoUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudC5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnN0b3AoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHJlYW1SZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxyXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuIHRyYWNrID8gdHJhY2subGFiZWwgOiAnJztcclxuICAgIH0sXHJcbiAgICBnZXRBY3RpdmVUcmFjayxcclxuICAgIGFzeW5jIGRpc2FibGVUb3JjaCgpIHtcclxuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XHJcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGFjcXVpcmUgY2FtZXJhIGFjY2VzcyBldmVuIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBjYW1lcmEgb3Blbj9cclxuICAgICAgICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgb24gaU9TIG9yIGFub3RoZXIgZGV2aWNlIHdoZXJlIHRvcmNoIGlzbid0IHN1cHBvcnRlZCBhdCBhbGw/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cclxuICAgICAgICBpZiAodHJhY2spIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRyYWNrLmFwcGx5Q29uc3RyYWludHMoeyBhZHZhbmNlZDogW3sgdG9yY2g6IGZhbHNlIH1dIH0gYXMgTWVkaWFUcmFja0NvbnN0cmFpbnRTZXQpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBPdmVyY29uc3RyYWluZWRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncXVhZ2dhMi9DYW1lcmFBY2Nlc3M6IFRvcmNoIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBhc3luYyBlbmFibGVUb3JjaCgpIHtcclxuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XHJcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGFjcXVpcmUgY2FtZXJhIGFjY2VzcyBldmVuIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBjYW1lcmEgb3Blbj9cclxuICAgICAgICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgb24gaU9TIG9yIGFub3RoZXIgZGV2aWNlIHdoZXJlIHRvcmNoIGlzbid0IHN1cHBvcnRlZCBhdCBhbGw/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cclxuICAgICAgICBpZiAodHJhY2spIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRyYWNrLmFwcGx5Q29uc3RyYWludHMoeyBhZHZhbmNlZDogW3sgdG9yY2g6IHRydWUgfV0gfSBhcyBNZWRpYVRyYWNrQ29uc3RyYWludFNldCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIE92ZXJjb25zdHJhaW5lZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdxdWFnZ2EyL0NhbWVyYUFjY2VzczogVG9yY2ggbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzO1xyXG4iLCJpbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xyXG5pbXBvcnQgdHlwZSB7XHJcbiAgICBRdWFnZ2FKU0NvZGVSZXN1bHQsXHJcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvcixcclxuICAgIFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24sXHJcbiAgICBYWVNpemUsXHJcbiAgICBRdWFnZ2FJbWFnZURhdGEsXHJcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG5mdW5jdGlvbiBjb250YWlucyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsIGxpc3Q6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pOiBib29sZWFuIHtcclxuICAgIHJldHVybiBsaXN0ICYmIGxpc3Quc29tZSgoaXRlbSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKSBhcyBBcnJheTxrZXlvZiBRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xyXG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IGl0ZW1ba2V5XSA9PT0gY29kZVJlc3VsdFtrZXldKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXNzZXNGaWx0ZXIoXHJcbiAgICBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsXHJcbiAgICBmaWx0ZXI6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24gfCB1bmRlZmluZWQsXHJcbik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgPyBmaWx0ZXIoY29kZVJlc3VsdCkgOiB0cnVlO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgUmVzdWx0Q29sbGVjdG9yIHtcclxuICAgIGFkZFJlc3VsdDogKGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCkgPT4gdm9pZDtcclxuICAgIGdldFJlc3VsdHM6ICgpID0+IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD47XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGNyZWF0ZShjb25maWc6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yKTogUmVzdWx0Q29sbGVjdG9yIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IHdpbGxSZWFkRnJlcXVlbnRseTogISFjb25maWcud2lsbFJlYWRGcmVxdWVudGx5IH0pIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgICAgICBjb25zdCByZXN1bHRzOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+ID0gW107XHJcbiAgICAgICAgbGV0IGNhcGFjaXR5ID0gY29uZmlnLmNhcGFjaXR5ID8/IDIwO1xyXG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBjb25maWcuY2FwdHVyZSA9PT0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IGJvb2xlYW4ge1xyXG4gICAgICAgICAgICByZXR1cm4gISFjYXBhY2l0eVxyXG4gICAgICAgICAgICAgICAgJiYgY29kZVJlc3VsdFxyXG4gICAgICAgICAgICAgICAgJiYgIWNvbnRhaW5zKGNvZGVSZXN1bHQsIGNvbmZpZy5ibGFja2xpc3QgYXMgQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PilcclxuICAgICAgICAgICAgICAgICYmIHBhc3Nlc0ZpbHRlcihjb2RlUmVzdWx0LCBjb25maWcuZmlsdGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFkZFJlc3VsdChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiB2b2lkIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0geyB9OyAvLyB0aGlzIGlzICdhbnknIHRvIGF2b2lkIGhhdmluZyB0byBjb25zdHJ1Y3QgYSB3aG9sZSBRdWFnZ2FKU0NvZGVSZXN1bHQgOnxcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0ID0gY29kZVJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlU2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdJbWFnZShkYXRhLCBpbWFnZVNpemUsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldFJlc3VsdHMoKTogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuXHJcbmNvbnN0IERldkNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XHJcbiAgICBpbnB1dFN0cmVhbToge1xyXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcclxuICAgICAgICBjb25zdHJhaW50czoge1xyXG4gICAgICAgICAgICB3aWR0aDogNjQwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcclxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXJlYToge1xyXG4gICAgICAgICAgICB0b3A6ICcwJScsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxyXG4gICAgICAgICAgICBib3R0b206ICcwJScsXHJcbiAgICAgICAgICAgIC8vIGJvcmRlckNvbG9yOiAncmdiYSgwLCAyNTUsIDAsIDAuNSknLCAvLyB1bmNvbW1lbnQgdG8gZHJhdyBhcmVhIGJvcmRlclxyXG4gICAgICAgICAgICAvLyBib3JkZXJXaWR0aDogMiwgLy8gdW5jb21tZW50IHRvIGRyYXcgYXJlYSBib3JkZXJcclxuICAgICAgICAgICAgLy8gYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAyNTUsIDAsIDAuMSknLCAvLyB1bmNvbW1lbnQgdG8gdGludCB0aGUgc2NhbiBhcmVhXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxyXG4gICAgICAgIGRlYnVnOiB7XHJcbiAgICAgICAgICAgIHNob3dJbWFnZURldGFpbHM6IGZhbHNlLCAvLyBsb2dzIGZyYW1lIGdyYWJiZXIgaW5mbywgY2FudmFzIHNpemUgYWRqdXN0bWVudHNcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIGxvY2F0ZTogdHJ1ZSxcclxuICAgIGNhbnZhczoge1xyXG4gICAgICAgIGNyZWF0ZU92ZXJsYXk6IHRydWUsIC8vIHNldCB0byBmYWxzZSB0byBza2lwIGNyZWF0aW5nIG92ZXJsYXkgY2FudmFzIChkcmF3aW5nQnVmZmVyKVxyXG4gICAgfSxcclxuICAgIGRlY29kZXI6IHtcclxuICAgICAgICByZWFkZXJzOiBbXHJcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGVidWc6IHtcclxuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0ZyZXF1ZW5jeTogZmFsc2UsXHJcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJpbnRSZWFkZXJJbmZvOiBmYWxzZSwgLy8gbG9ncyByZWFkZXIgcmVnaXN0cmF0aW9uIGFuZCBpbml0aWFsaXphdGlvblxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgbG9jYXRvcjoge1xyXG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXHJcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcclxuICAgICAgICBkZWJ1Zzoge1xyXG4gICAgICAgICAgICBzaG93Q2FudmFzOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd1BhdGNoZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93Rm91bmRQYXRjaGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd1NrZWxldG9uOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0xhYmVsczogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQYXRjaExhYmVsczogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dSZW1haW5pbmdQYXRjaExhYmVsczogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQYXRjaFNpemU6IGZhbHNlLCAvLyBsb2dzIGNhbGN1bGF0ZWQgcGF0Y2ggc2l6ZVxyXG4gICAgICAgICAgICBzaG93SW1hZ2VEZXRhaWxzOiBmYWxzZSwgLy8gbG9ncyBpbWFnZSB3cmFwcGVyIHNpemUsIGNhbnZhcyBkZXRhaWxzXHJcbiAgICAgICAgICAgIGJveEZyb21QYXRjaGVzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkQm94OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dCQjogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZXZDb25maWc7XHJcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG5jb25zdCBOb2RlQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcclxuICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcclxuICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXHJcbiAgICAgICAgc2l6ZTogODAwLFxyXG4gICAgICAgIGFyZWE6IHtcclxuICAgICAgICAgICAgdG9wOiAnMCUnLFxyXG4gICAgICAgICAgICByaWdodDogJzAlJyxcclxuICAgICAgICAgICAgbGVmdDogJzAlJyxcclxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcclxuICAgIH0sXHJcbiAgICBsb2NhdGU6IHRydWUsXHJcbiAgICBjYW52YXM6IHtcclxuICAgICAgICBjcmVhdGVPdmVybGF5OiB0cnVlLCAvLyBzZXQgdG8gZmFsc2UgdG8gc2tpcCBjcmVhdGluZyBvdmVybGF5IGNhbnZhcyAoZHJhd2luZ0J1ZmZlcilcclxuICAgIH0sXHJcbiAgICBkZWNvZGVyOiB7XHJcbiAgICAgICAgcmVhZGVyczogW1xyXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIGxvY2F0b3I6IHtcclxuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxyXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZUNvbmZpZztcclxuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuXHJcbmNvbnN0IFByb2RDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xyXG4gICAgaW5wdXRTdHJlYW06IHtcclxuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXHJcbiAgICAgICAgY29uc3RyYWludHM6IHtcclxuICAgICAgICAgICAgd2lkdGg6IDY0MCxcclxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXHJcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxyXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXHJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFyZWE6IHtcclxuICAgICAgICAgICAgdG9wOiAnMCUnLFxyXG4gICAgICAgICAgICByaWdodDogJzAlJyxcclxuICAgICAgICAgICAgbGVmdDogJzAlJyxcclxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcclxuICAgIH0sXHJcbiAgICBsb2NhdGU6IHRydWUsXHJcbiAgICBjYW52YXM6IHtcclxuICAgICAgICBjcmVhdGVPdmVybGF5OiB0cnVlLCAvLyBzZXQgdG8gZmFsc2UgdG8gc2tpcCBjcmVhdGluZyBvdmVybGF5IGNhbnZhcyAoZHJhd2luZ0J1ZmZlcilcclxuICAgIH0sXHJcbiAgICBkZWNvZGVyOiB7XHJcbiAgICAgICAgcmVhZGVyczogW1xyXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIGxvY2F0b3I6IHtcclxuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxyXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJvZENvbmZpZztcclxuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuaW1wb3J0IERldkNvbmZpZyBmcm9tICcuL2NvbmZpZy5kZXYnO1xyXG5pbXBvcnQgTm9kZUNvbmZpZyBmcm9tICcuL2NvbmZpZy5ub2RlJztcclxuaW1wb3J0IFByb2RDb25maWcgZnJvbSAnLi9jb25maWcucHJvZCc7XHJcblxyXG5jb25zdCBFeHBvcnRDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0gKCgpID0+IHtcclxuICAgIGxldCBRdWFnZ2FDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0O1xyXG4gICAgaWYgKHR5cGVvZiBFTlYgPT09ICd1bmRlZmluZWQnIHx8IEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgIFF1YWdnYUNvbmZpZyA9IERldkNvbmZpZztcclxuICAgIH0gZWxzZSBpZiAoRU5WLm5vZGUpIHtcclxuICAgICAgICBRdWFnZ2FDb25maWcgPSBOb2RlQ29uZmlnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBRdWFnZ2FDb25maWcgPSBQcm9kQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFF1YWdnYUNvbmZpZztcclxufSkoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEV4cG9ydENvbmZpZztcclxuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QsIFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuaW50ZXJmYWNlIEFyZWFSZWN0IHtcclxuICAgIHg6IG51bWJlcjtcclxuICAgIHk6IG51bWJlcjtcclxuICAgIHdpZHRoOiBudW1iZXI7XHJcbiAgICBoZWlnaHQ6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgcmVjdGFuZ2xlIGZyb20gdGhlIGFyZWEgY29uZmlndXJhdGlvbiBwZXJjZW50YWdlcy5cclxuICogVGhpcyBjb252ZXJ0cyBwZXJjZW50YWdlLWJhc2VkIGFyZWEgYm91bmRhcmllcyB0byBwaXhlbCBjb29yZGluYXRlcy5cclxuICogXHJcbiAqIEBwYXJhbSBjYW52YXNTaXplIC0gVGhlIHNpemUgb2YgdGhlIGNhbnZhc1xyXG4gKiBAcGFyYW0gYXJlYSAtIFRoZSBhcmVhIGNvbmZpZ3VyYXRpb24gd2l0aCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgYXMgcGVyY2VudGFnZSBzdHJpbmdzXHJcbiAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIHJlY3RhbmdsZSB3aXRoIHgsIHksIHdpZHRoLCBoZWlnaHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBcmVhUmVjdChcclxuICAgIGNhbnZhc1NpemU6IFhZU2l6ZSxcclxuICAgIGFyZWE6IHsgdG9wPzogc3RyaW5nOyByaWdodD86IHN0cmluZzsgYm90dG9tPzogc3RyaW5nOyBsZWZ0Pzogc3RyaW5nIH0sXHJcbik6IEFyZWFSZWN0IHtcclxuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gY2FudmFzU2l6ZS54O1xyXG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xyXG5cclxuICAgIGNvbnN0IHRvcCA9IHBhcnNlSW50KGFyZWEudG9wIHx8ICcwJywgMTApIC8gMTAwO1xyXG4gICAgY29uc3QgcmlnaHQgPSBwYXJzZUludChhcmVhLnJpZ2h0IHx8ICcwJywgMTApIC8gMTAwO1xyXG4gICAgY29uc3QgYm90dG9tID0gcGFyc2VJbnQoYXJlYS5ib3R0b20gfHwgJzAnLCAxMCkgLyAxMDA7XHJcbiAgICBjb25zdCBsZWZ0ID0gcGFyc2VJbnQoYXJlYS5sZWZ0IHx8ICcwJywgMTApIC8gMTAwO1xyXG5cclxuICAgIGNvbnN0IHggPSBjYW52YXNXaWR0aCAqIGxlZnQ7XHJcbiAgICBjb25zdCB5ID0gY2FudmFzSGVpZ2h0ICogdG9wO1xyXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXNXaWR0aCAtIGNhbnZhc1dpZHRoICogcmlnaHQgLSB4O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzSGVpZ2h0IC0gY2FudmFzSGVpZ2h0ICogYm90dG9tIC0geTtcclxuXHJcbiAgICByZXR1cm4geyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGFyZWEgaXMgZGVmaW5lZCBhbmQgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHQgKGZ1bGwgY2FudmFzKS5cclxuICogXHJcbiAqIEBwYXJhbSBhcmVhIC0gVGhlIGFyZWEgY29uZmlndXJhdGlvblxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIGFyZWEgaXMgZGVmaW5lZCBhbmQgbm90IHRoZSBkZWZhdWx0IGZ1bGwgY2FudmFzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBcmVhRGVmaW5lZChcclxuICAgIGFyZWE/OiB7IHRvcD86IHN0cmluZzsgcmlnaHQ/OiBzdHJpbmc7IGJvdHRvbT86IHN0cmluZzsgbGVmdD86IHN0cmluZyB9LFxyXG4pOiBib29sZWFuIHtcclxuICAgIGlmICghYXJlYSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIGlmIGFueSB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSAwJVxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICAoYXJlYS50b3AgIT09IHVuZGVmaW5lZCAmJiBhcmVhLnRvcCAhPT0gJzAlJylcclxuICAgICAgICB8fCAoYXJlYS5yaWdodCAhPT0gdW5kZWZpbmVkICYmIGFyZWEucmlnaHQgIT09ICcwJScpXHJcbiAgICAgICAgfHwgKGFyZWEuYm90dG9tICE9PSB1bmRlZmluZWQgJiYgYXJlYS5ib3R0b20gIT09ICcwJScpXHJcbiAgICAgICAgfHwgKGFyZWEubGVmdCAhPT0gdW5kZWZpbmVkICYmIGFyZWEubGVmdCAhPT0gJzAlJylcclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYXJlYSB2aXN1YWxpemF0aW9uIHNob3VsZCBiZSBkcmF3biBiYXNlZCBvbiBib3JkZXJDb2xvciBvciBib3JkZXJXaWR0aCBiZWluZyBkZWZpbmVkLlxyXG4gKiBcclxuICogQHBhcmFtIGFyZWEgLSBUaGUgYXJlYSBjb25maWd1cmF0aW9uXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdmlzdWFsaXphdGlvbiBzaG91bGQgYmUgZHJhd24gKGJvcmRlckNvbG9yIGlzIGRlZmluZWQgb3IgYm9yZGVyV2lkdGggPiAwKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZERyYXdBcmVhT3ZlcmxheShcclxuICAgIGFyZWE/OiB7IGJvcmRlckNvbG9yPzogc3RyaW5nOyBib3JkZXJXaWR0aD86IG51bWJlcjsgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIH0sXHJcbik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKCFhcmVhKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICAoYXJlYS5ib3JkZXJDb2xvciAhPT0gdW5kZWZpbmVkICYmIGFyZWEuYm9yZGVyQ29sb3IgIT09ICcnKVxyXG4gICAgICAgIHx8IChhcmVhLmJvcmRlcldpZHRoICE9PSB1bmRlZmluZWQgJiYgYXJlYS5ib3JkZXJXaWR0aCA+IDApXHJcbiAgICAgICAgfHwgKGFyZWEuYmFja2dyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgJiYgYXJlYS5iYWNrZ3JvdW5kQ29sb3IgIT09ICcnKVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIHRoZSBzY2FuIGFyZWEgYm91bmRhcnkgb24gdGhlIG92ZXJsYXkgY2FudmFzLlxyXG4gKiBUaGlzIHZpc3VhbGx5IGhpZ2hsaWdodHMgdGhlIHJlZ2lvbiB3aGVyZSBRdWFnZ2EgaXMgbG9va2luZyBmb3IgYmFyY29kZXMuXHJcbiAqIFxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNhbnZhcyAyRCByZW5kZXJpbmcgY29udGV4dCAob3ZlcmxheSBjYW52YXMpXHJcbiAqIEBwYXJhbSBjYW52YXNTaXplIC0gVGhlIHNpemUgb2YgdGhlIGNhbnZhc1xyXG4gKiBAcGFyYW0gYXJlYSAtIFRoZSBhcmVhIGNvbmZpZ3VyYXRpb24gd2l0aCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgYXMgcGVyY2VudGFnZSBzdHJpbmdzXHJcbiAqIEBwYXJhbSBib3JkZXJDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgYXJlYSBib3JkZXIgKGRlZmF1bHQ6ICdyZ2JhKDAsIDI1NSwgMCwgMC41KScpXHJcbiAqIEBwYXJhbSBib3JkZXJXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgYm9yZGVyIGxpbmUgKGRlZmF1bHQ6IDIpXHJcbiAqIEBwYXJhbSBiYWNrZ3JvdW5kQ29sb3IgLSBUaGUgYmFja2dyb3VuZCBjb2xvciB0byBmaWxsIHRoZSBhcmVhIChvcHRpb25hbClcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkcmF3QXJlYU92ZXJsYXkoXHJcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcclxuICAgIGNhbnZhc1NpemU6IFhZU2l6ZSxcclxuICAgIGFyZWE6IHsgdG9wPzogc3RyaW5nOyByaWdodD86IHN0cmluZzsgYm90dG9tPzogc3RyaW5nOyBsZWZ0Pzogc3RyaW5nIH0sXHJcbiAgICBib3JkZXJDb2xvciA9ICdyZ2JhKDAsIDI1NSwgMCwgMC41KScsXHJcbiAgICBib3JkZXJXaWR0aCA9IDIsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcsXHJcbik6IHZvaWQge1xyXG4gICAgY29uc3QgcmVjdCA9IGNhbGN1bGF0ZUFyZWFSZWN0KGNhbnZhc1NpemUsIGFyZWEpO1xyXG5cclxuICAgIC8vIERyYXcgYmFja2dyb3VuZCBmaWxsIGlmIHNwZWNpZmllZFxyXG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBib3JkZXIgaWYgYm9yZGVyV2lkdGggPiAwXHJcbiAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xyXG4gICAgICAgIGN0eC5zdHJva2VSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyB0aGUgYXJlYSBvdmVybGF5IGlmIGNvbmZpZ3VyZWQgdG8gZG8gc28uXHJcbiAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gY2FsbCBmcm9tIHRoZSBRdWFnZ2EgcHJvY2Vzc2luZyBsb29wLlxyXG4gKiBEcmF3aW5nIGlzIHRyaWdnZXJlZCB3aGVuIGFyZWEuYm9yZGVyQ29sb3Igb3IgYXJlYS5ib3JkZXJXaWR0aCBpcyBkZWZpbmVkLlxyXG4gKiBcclxuICogQHBhcmFtIGNvbmZpZyAtIFRoZSBRdWFnZ2EgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjYW52YXMgMkQgcmVuZGVyaW5nIGNvbnRleHQgKG92ZXJsYXkgY2FudmFzKVxyXG4gKiBAcGFyYW0gY2FudmFzU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBjYW52YXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkcmF3QXJlYUlmQ29uZmlndXJlZChcclxuICAgIGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgfCB1bmRlZmluZWQsXHJcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwsXHJcbiAgICBjYW52YXNTaXplOiBYWVNpemUsXHJcbik6IHZvaWQge1xyXG4gICAgaWYgKCFjb25maWcgfHwgIWN0eCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbnB1dFN0cmVhbSA9IGNvbmZpZy5pbnB1dFN0cmVhbTtcclxuICAgIGlmICghaW5wdXRTdHJlYW0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBhcmVhIH0gPSBpbnB1dFN0cmVhbTtcclxuXHJcbiAgICAvLyBPbmx5IGRyYXcgaWYgYXJlYSB2aXN1YWxpemF0aW9uIGlzIGNvbmZpZ3VyZWQgYW5kIGFyZWEgaXMgYWN0dWFsbHkgZGVmaW5lZFxyXG4gICAgaWYgKCFhcmVhIHx8ICFzaG91bGREcmF3QXJlYU92ZXJsYXkoYXJlYSkgfHwgIWlzQXJlYURlZmluZWQoYXJlYSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2hvdWxkRHJhd0JvcmRlciA9IGFyZWEuYm9yZGVyQ29sb3IgIT09IHVuZGVmaW5lZCB8fCBhcmVhLmJvcmRlcldpZHRoICE9PSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBib3JkZXJDb2xvciA9IGFyZWEuYm9yZGVyQ29sb3IgPz8gJ3JnYmEoMCwgMjU1LCAwLCAwLjUpJztcclxuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gc2hvdWxkRHJhd0JvcmRlciA/IChhcmVhLmJvcmRlcldpZHRoID8/IDIpIDogMDtcclxuICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGFyZWEuYmFja2dyb3VuZENvbG9yO1xyXG5cclxuICAgIGRyYXdBcmVhT3ZlcmxheShjdHgsIGNhbnZhc1NpemUsIGFyZWEsIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aCwgYmFja2dyb3VuZENvbG9yKTtcclxufVxyXG4iLCIvLyBOT1RFIEZPUiBBTllPTkUgSU4gSEVSRSBJTiBUSEUgRlVUVVJFOlxyXG4vLyB3ZWJwYWNrLmNvbmZpZy5qcyByZXBsYWNlcyB0aGUgZnJhbWVfZ3JhYmJlciBtb2R1bGUgd2l0aCBUSElTIG1vZHVsZSB3aGVuIGl0IGlzIGJ1aWxkaW5nIGZvciBhIEJyb3dzZXIgZW52aXJvbm1lbnQuXHJcblxyXG5pbXBvcnQge1xyXG4gICAgaW1hZ2VSZWYsXHJcbiAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhLFxyXG4gICAgY29tcHV0ZUdyYXksXHJcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcclxuXHJcbmNvbnN0IFRPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xyXG5cclxuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShjYW52YXMsIHRhcmdldFNpemUsIGRlYnVnKSB7XHJcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB0YXJnZXRTaXplLngpIHtcclxuICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRTaXplLng7XHJcbiAgICB9XHJcbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gdGFyZ2V0U2l6ZS55KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBkZWJ1Zz8uc2hvd0ltYWdlRGV0YWlscykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFNpemUueTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgRnJhbWVHcmFiYmVyID0ge307XHJcblxyXG5GcmFtZUdyYWJiZXIuY3JlYXRlID0gZnVuY3Rpb24gKGlucHV0U3RyZWFtLCBjYW52YXMpIHtcclxuICAgIC8vIGNvbnNvbGUud2FybignKioqIEZyYW1lR3JhYmJlckJyb3dzZXIgY3JlYXRlJyk7XHJcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xyXG4gICAgY29uc3QgX3N0cmVhbUNvbmZpZyA9IGlucHV0U3RyZWFtLmdldENvbmZpZygpO1xyXG4gICAgY29uc3QgX3ZpZGVvU2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xyXG4gICAgY29uc3QgX2NhbnZhc1NpemUgPSBpbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCk7XHJcbiAgICBjb25zdCBfc2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKTtcclxuICAgIGNvbnN0IHRvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcclxuICAgIGNvbnN0IF9zeCA9IHRvcFJpZ2h0Lng7XHJcbiAgICBjb25zdCBfc3kgPSB0b3BSaWdodC55O1xyXG4gICAgbGV0IF9jYW52YXM7XHJcbiAgICBsZXQgX2N0eCA9IG51bGw7XHJcbiAgICBsZXQgX2RhdGEgPSBudWxsO1xyXG4gICAgY29uc3QgeyB3aWxsUmVhZEZyZXF1ZW50bHkgfSA9IF9zdHJlYW1Db25maWc7XHJcblxyXG4gICAgX2NhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIF9jYW52YXMud2lkdGggPSBfY2FudmFzU2l6ZS54O1xyXG4gICAgX2NhbnZhcy5oZWlnaHQgPSBfY2FudmFzU2l6ZS55O1xyXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfc3RyZWFtQ29uZmlnLmRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCcqKiogZnJhbWVfZ3JhYmJlcl9icm93c2VyOiB3aWxsUmVhZEZyZXF1ZW50bHk9Jywgd2lsbFJlYWRGcmVxdWVudGx5LCAnY2FudmFzPScsIF9jYW52YXMpO1xyXG4gICAgfVxyXG4gICAgX2N0eCA9IF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IHdpbGxSZWFkRnJlcXVlbnRseTogISF3aWxsUmVhZEZyZXF1ZW50bHkgfSk7IC8vIGRvdWJsZSBub3QgYmVjYXVzZSB3ZSBoYXZlIGFuIG9wdGlvbmFsIGJvb2wgdGhhdCBuZWVkcyB0byBwYXNzIGFzIGEgYm9vbFxyXG4gICAgX2RhdGEgPSBuZXcgVWludDhBcnJheShfc2l6ZS54ICogX3NpemUueSk7XHJcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9zdHJlYW1Db25maWcuZGVidWc/LnNob3dJbWFnZURldGFpbHMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnRnJhbWVHcmFiYmVyJywgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICBzaXplOiBfc2l6ZSxcclxuICAgICAgICAgICAgdG9wUmlnaHQsXHJcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX3ZpZGVvU2l6ZSxcclxuICAgICAgICAgICAgY2FudmFzU2l6ZTogX2NhbnZhc1NpemUsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIF9kYXRhID0gZGF0YTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1c2VkIGZyYW1lLWJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZGF0YTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQmlsaW5lYXIgaW50ZXJwb2xhdGlvbiBmb3IgZ3JheXNjYWxlIGRhdGEgKHRvIG1hdGNoIE5vZGUncyBiZWhhdmlvcilcclxuICAgIGZ1bmN0aW9uIGJpbGluZWFySW50ZXJwb2xhdGUoZ3JheURhdGEsIHdpZHRoLCBoZWlnaHQsIHgsIHkpIHtcclxuICAgICAgICBjb25zdCB4MCA9IE1hdGguZmxvb3IoeCk7XHJcbiAgICAgICAgY29uc3QgeTAgPSBNYXRoLmZsb29yKHkpO1xyXG4gICAgICAgIGNvbnN0IHgxID0gTWF0aC5taW4oeDAgKyAxLCB3aWR0aCAtIDEpO1xyXG4gICAgICAgIGNvbnN0IHkxID0gTWF0aC5taW4oeTAgKyAxLCBoZWlnaHQgLSAxKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBmeCA9IHggLSB4MDtcclxuICAgICAgICBjb25zdCBmeSA9IHkgLSB5MDtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB2MDAgPSBncmF5RGF0YVt5MCAqIHdpZHRoICsgeDBdO1xyXG4gICAgICAgIGNvbnN0IHYxMCA9IGdyYXlEYXRhW3kwICogd2lkdGggKyB4MV07XHJcbiAgICAgICAgY29uc3QgdjAxID0gZ3JheURhdGFbeTEgKiB3aWR0aCArIHgwXTtcclxuICAgICAgICBjb25zdCB2MTEgPSBncmF5RGF0YVt5MSAqIHdpZHRoICsgeDFdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHYwID0gdjAwICogKDEgLSBmeCkgKyB2MTAgKiBmeDtcclxuICAgICAgICBjb25zdCB2MSA9IHYwMSAqICgxIC0gZngpICsgdjExICogZng7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHYwICogKDEgLSBmeSkgKyB2MSAqIGZ5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBhIGZyYW1lIGZyb20gdGhlIGlucHV0LXN0cmVhbSBhbmQgcHV0cyBpbnRvIHRoZSBmcmFtZS1idWZmZXIuXHJcbiAgICAgKiBUaGUgaW1hZ2UtZGF0YSBpcyBjb252ZXJ0ZWQgdG8gZ3JheS1zY2FsZSBhbmQgdGhlbiBoYWxmLXNhbXBsZWQgaWYgY29uZmlndXJlZC5cclxuICAgICAqIFxyXG4gICAgICogRm9yIGltcHJvdmVkIGFjY3VyYWN5IChtYXRjaGluZyBOb2RlJ3MgcHJvY2Vzc2luZyksIG5vbi1oYWxmLXNhbXBsZWQgaW1hZ2VzXHJcbiAgICAgKiB1c2UgYmlsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiBncmF5c2NhbGUgZGF0YSBpbnN0ZWFkIG9mIHNjYWxpbmcgUkdCIHRoZW4gY29udmVydGluZy5cclxuICAgICAqIFxyXG4gICAgICogSU1QT1JUQU5UOiBUaGUgaW1hZ2UgaXMgQUxXQVlTIGRyYXduIHRvIHRoZSB2aXNpYmxlIGNhbnZhcyBmb3Igb3ZlcmxheXMgYW5kIGRpc3BsYXkuXHJcbiAgICAgKi9cclxuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZG9IYWxmU2FtcGxlID0gX3N0cmVhbUNvbmZpZy5oYWxmU2FtcGxlO1xyXG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcclxuICAgICAgICBsZXQgZHJhd2FibGUgPSBmcmFtZTtcclxuICAgICAgICBsZXQgZHJhd0FuZ2xlID0gMDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZHJhd2FibGUpIHtcclxuICAgICAgICAgICAgYWRqdXN0Q2FudmFzU2l6ZShfY2FudmFzLCBfY2FudmFzU2l6ZSwgX3N0cmVhbUNvbmZpZy5kZWJ1Zyk7XHJcbiAgICAgICAgICAgIGlmIChfc3RyZWFtQ29uZmlnLnR5cGUgPT09ICdJbWFnZVN0cmVhbScpIHtcclxuICAgICAgICAgICAgICAgIGRyYXdhYmxlID0gZnJhbWUuaW1nO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRhZ3MgJiYgZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSA5MCAqIFRPX1JBRElBTlM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gLTkwICogVE9fUkFESUFOUztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQUxXQVlTIGRyYXcgdG8gdmlzaWJsZSBjYW52YXMgKGZvciBvdmVybGF5cywgZGlzcGxheSwgYW5kIHRvRGF0YVVSTClcclxuICAgICAgICAgICAgaWYgKGRyYXdBbmdsZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnkgLyAyKTtcclxuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKGRyYXdBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgLV9jYW52YXNTaXplLnkgLyAyLCAtX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnksIF9jYW52YXNTaXplLngpO1xyXG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoLWRyYXdBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBfY3R4LnRyYW5zbGF0ZSgtX2NhbnZhc1NpemUueCAvIDIsIC1fY2FudmFzU2l6ZS55IC8gMik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgMCwgMCwgX2NhbnZhc1NpemUueCwgX2NhbnZhc1NpemUueSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkb0hhbGZTYW1wbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEhhbGYtc2FtcGxlIHBhdGg6IHVzZSBleGlzdGluZyBvcHRpbWl6ZWQgYXBwcm9hY2hcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eERhdGEgPSBfY3R4LmdldEltYWdlRGF0YShfc3gsIF9zeSwgX3NpemUueCwgX3NpemUueSkuZGF0YTtcclxuICAgICAgICAgICAgICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY3R4RGF0YSwgX3NpemUsIF9kYXRhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vbi1oYWxmLXNhbXBsZTogdXNlIGltcHJvdmVkIGJpbGluZWFyIGludGVycG9sYXRpb24gZm9yIGJldHRlciBhY2N1cmFjeVxyXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhdCBvcmlnaW5hbCBzaXplLCB0aGVuIHNjYWxlIGdyYXlzY2FsZSBkYXRhXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gX3ZpZGVvU2l6ZS54O1xyXG4gICAgICAgICAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBfdmlkZW9TaXplLnk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhd0FuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC50cmFuc2xhdGUoX3ZpZGVvU2l6ZS54IC8gMiwgX3ZpZGVvU2l6ZS55IC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC5yb3RhdGUoZHJhd0FuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wQ3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgLV92aWRlb1NpemUueSAvIDIsIC1fdmlkZW9TaXplLnggLyAyLCBfdmlkZW9TaXplLnksIF92aWRlb1NpemUueCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAwLCAwLCBfdmlkZW9TaXplLngsIF92aWRlb1NpemUueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBncmF5c2NhbGUgYXQgb3JpZ2luYWwgc2l6ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJbWFnZURhdGEgPSB0ZW1wQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBfdmlkZW9TaXplLngsIF92aWRlb1NpemUueSkuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGdyYXlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3ZpZGVvU2l6ZS54ICogX3ZpZGVvU2l6ZS55KTtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVHcmF5KG9yaWdpbmFsSW1hZ2VEYXRhLCBncmF5RGF0YSwgX3N0cmVhbUNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgZ3JheXNjYWxlIGRhdGEgdXNpbmcgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkR3JheURhdGEgPSBuZXcgVWludDhBcnJheShfY2FudmFzU2l6ZS54ICogX2NhbnZhc1NpemUueSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwU2l6ZVggPSBfdmlkZW9TaXplLnggLyBfY2FudmFzU2l6ZS54O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFNpemVZID0gX3ZpZGVvU2l6ZS55IC8gX2NhbnZhc1NpemUueTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBfY2FudmFzU2l6ZS55OyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9jYW52YXNTaXplLng7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmNYID0geCAqIHN0ZXBTaXplWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjWSA9IHkgKiBzdGVwU2l6ZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlZEdyYXlEYXRhW3kgKiBfY2FudmFzU2l6ZS54ICsgeF0gPSBiaWxpbmVhckludGVycG9sYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JheURhdGEsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZGVvU2l6ZS54LCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWRlb1NpemUueSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNYLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1lcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBDcm9wIHRvIHRhcmdldCByZWdpb25cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX3NpemUueTsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBfc2l6ZS54OyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjSWR4ID0gKHkgKyBfc3kpICogX2NhbnZhc1NpemUueCArICh4ICsgX3N4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGFbeSAqIF9zaXplLnggKyB4XSA9IHNjYWxlZEdyYXlEYXRhW3NyY0lkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhhdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc2l6ZTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF90aGF0O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRnJhbWVHcmFiYmVyO1xyXG4iLCIvLyBOT1RFOiAoU09NRSBPRikgVEhJUyBJUyBCUk9XU0VSIE9OTFkgQ09ERS4gIE5vZGUgZG9lcyBub3QgaGF2ZSAnYXRvYicgYnVpbHQgaW4sIG5vciBYTUxIdHRwUmVxdWVzdC5cclxuLy8gSG93IGV4YWN0bHkgaXMgdGhpcyBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgaW4gUXVhZ2dhPyBEbyB3ZSBuZWVkIHRoZSBicm93c2VyIHNwZWNpZmljIGNvZGU/IERvIHdlXHJcbi8vIG5lZWQgdG8gcG9ydCBhbnkgcGFydCBvZiB0aGlzIHRoYXQgZG9lc24ndCB3b3JrIGluIE5vZGUgdG8gbm9kZT9cclxuXHJcbi8vIFRhZ3Mgc2NyYXBlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanNcclxuY29uc3QgRXhpZlRhZ3MgPSB7IDB4MDExMjogJ29yaWVudGF0aW9uJyB9O1xyXG5leHBvcnQgY29uc3QgQXZhaWxhYmxlVGFncyA9IE9iamVjdC5rZXlzKEV4aWZUYWdzKS5tYXAoKGtleSkgPT4gRXhpZlRhZ3Nba2V5XSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbk9iamVjdFVSTChzcmMsIHRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XHJcbiAgICBpZiAoL15ibG9iOi9pLnRlc3Qoc3JjKSkge1xyXG4gICAgICAgIHJldHVybiBvYmplY3RVUkxUb0Jsb2Ioc3JjKVxyXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXHJcbiAgICAgICAgICAgIC50aGVuKChidWZmZXIpID0+IGZpbmRUYWdzSW5CdWZmZXIoYnVmZmVyLCB0YWdzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJsKSB7XHJcbiAgICBjb25zdCBiYXNlNjQgPSBkYXRhVXJsLnJlcGxhY2UoL15kYXRhOihbXjtdKyk7YmFzZTY0LC9nbWksICcnKTtcclxuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcclxuICAgIGNvbnN0IGxlbiA9IGJpbmFyeS5sZW5ndGg7XHJcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuKTtcclxuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2aWV3W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVG9CdWZmZXIoYmxvYikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYmplY3RVUkxUb0Jsb2IodXJsKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICBodHRwLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICAgICAgaHR0cC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XHJcbiAgICAgICAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgKGh0dHAuc3RhdHVzID09PSAyMDAgfHwgaHR0cC5zdGF0dXMgPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICAgICAgaHR0cC5zZW5kKCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5CdWZmZXIoZmlsZSwgc2VsZWN0ZWRUYWdzID0gQXZhaWxhYmxlVGFncykge1xyXG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSk7XHJcbiAgICBjb25zdCBsZW5ndGggPSBmaWxlLmJ5dGVMZW5ndGg7XHJcbiAgICBjb25zdCBleGlmVGFncyA9IHNlbGVjdGVkVGFncy5yZWR1Y2UoKHJlc3VsdCwgc2VsZWN0ZWRUYWcpID0+IHtcclxuICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcigodGFnKSA9PiBFeGlmVGFnc1t0YWddID09PSBzZWxlY3RlZFRhZylbMF07XHJcbiAgICAgICAgaWYgKGV4aWZUYWcpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2V4aWZUYWddID0gc2VsZWN0ZWRUYWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCB7fSk7XHJcbiAgICBsZXQgb2Zmc2V0ID0gMjtcclxuICAgIGxldCBtYXJrZXI7XHJcblxyXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4RkYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XHJcbiAgICAgICAgaWYgKG1hcmtlciA9PT0gMHhFMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZEVYSUZEYXRhKGRhdGFWaWV3LCBvZmZzZXQgKyA0LCBleGlmVGFncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAyICsgZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZEVYSUZEYXRhKGZpbGUsIHN0YXJ0LCBleGlmVGFncykge1xyXG4gICAgaWYgKGdldFN0cmluZ0Zyb21CdWZmZXIoZmlsZSwgc3RhcnQsIDQpICE9PSAnRXhpZicpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcclxuICAgIGxldCBiaWdFbmQ7XHJcblxyXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcclxuICAgICAgICBiaWdFbmQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NEQ0RCkge1xyXG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMkEpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XHJcbiAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPCAweDAwMDAwMDA4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhZ3MgPSByZWFkVGFncyhmaWxlLCB0aWZmT2Zmc2V0LCB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQsIGV4aWZUYWdzLCBiaWdFbmQpO1xyXG4gICAgcmV0dXJuIHRhZ3M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xyXG4gICAgY29uc3QgZW50cmllcyA9IGZpbGUuZ2V0VWludDE2KGRpclN0YXJ0LCAhYmlnRW5kKTtcclxuICAgIGNvbnN0IHRhZ3MgPSB7fTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gZGlyU3RhcnQgKyBpICogMTIgKyAyO1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcclxuICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHJlYWRUYWdWYWx1ZShmaWxlLCBlbnRyeU9mZnNldCwgdGlmZlN0YXJ0LCBkaXJTdGFydCwgYmlnRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFncztcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpO1xyXG4gICAgY29uc3QgbnVtVmFsdWVzID0gZmlsZS5nZXRVaW50MzIoZW50cnlPZmZzZXQgKyA0LCAhYmlnRW5kKTtcclxuXHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21CdWZmZXIoYnVmZmVyLCBzdGFydCwgbGVuZ3RoKSB7XHJcbiAgICBsZXQgb3V0c3RyID0gJyc7XHJcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgb3V0c3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyLmdldFVpbnQ4KG4pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRzdHI7XHJcbn1cclxuIiwiaW1wb3J0IHsgZmluZFRhZ3NJbk9iamVjdFVSTCB9IGZyb20gJy4vZXhpZl9oZWxwZXInO1xyXG5cclxuLy8gRXhwb3J0ZWQgaGVscGVyIGZvciBmaWxlbmFtZSBnZW5lcmF0aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlRmlsZW5hbWUoZGlyZWN0b3J5LCBudW0pIHtcclxuICAgIHJldHVybiBgJHtkaXJlY3Rvcnl9aW1hZ2UtJHtudW0udG9TdHJpbmcoKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xyXG59XHJcblxyXG5jb25zdCBJbWFnZUxvYWRlciA9IHt9O1xyXG5JbWFnZUxvYWRlci5sb2FkID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgY2FsbGJhY2ssIG9mZnNldCwgc2l6ZSwgc2VxdWVuY2UsIGNvbmZpZykge1xyXG4gICAgY29uc3QgaHRtbEltYWdlc1NyY0FycmF5ID0gbmV3IEFycmF5KHNpemUpO1xyXG4gICAgY29uc3QgaHRtbEltYWdlc0FycmF5ID0gbmV3IEFycmF5KGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGgpO1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgaW1nO1xyXG4gICAgbGV0IG51bTtcclxuXHJcbiAgICBpZiAoc2VxdWVuY2UgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5WzBdID0gZGlyZWN0b3J5O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcclxuICAgICAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5W2ldID0gZ2VuZXJhdGVJbWFnZUZpbGVuYW1lKGRpcmVjdG9yeSwgbnVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkID0gW107XHJcbiAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcclxuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xyXG4gICAgfTtcclxuICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQgPSBmdW5jdGlvbiAobG9hZGVkSW1nKSB7XHJcbiAgICAgICAgY29uc3Qgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBub3Rsb2FkZWRJbWdzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChub3Rsb2FkZWRJbWdzW3hdID09PSBsb2FkZWRJbWcpIHtcclxuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZW5jb2RlVVJJIGZvciBtYXRjaGluZyBmaWxlbmFtZXMgd2l0aCBzcGFjZXMgYW5kIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ05hbWUgPSBlbmNvZGVVUkkoaHRtbEltYWdlc1NyY0FycmF5W3ldLnN1YnN0cihodG1sSW1hZ2VzU3JjQXJyYXlbeV0ubGFzdEluZGV4T2YoJy8nKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWRJbWcuc3JjLmxhc3RJbmRleE9mKGltZ05hbWUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7IGltZzogbG9hZGVkSW1nIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub3Rsb2FkZWRJbWdzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZz8uZGVidWc/LnNob3dJbWFnZURldGFpbHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJbWFnZXMgbG9hZGVkOiAke2h0bWxJbWFnZXNBcnJheS5sZW5ndGh9IGltYWdlJHtodG1sSW1hZ2VzQXJyYXkubGVuZ3RoICE9PSAxID8gJ3MnIDogJyd9IGZyb20gJHtzZXF1ZW5jZSA9PT0gZmFsc2UgPyBkaXJlY3RvcnkgOiBkaXJlY3RvcnkgKyAnIChzZXF1ZW5jZSknfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHRhZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5WzBdLnRhZ3MgPSB0YWdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZShpbWcpO1xyXG4gICAgICAgIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpO1xyXG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGRPbmxvYWRIYW5kbGVyKGltZywgaHRtbEltYWdlc0FycmF5KSB7XHJcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCh0aGlzKTtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IChJbWFnZUxvYWRlcik7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuXHJcbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuLi9pbWFnZV9sb2FkZXInO1xyXG5pbXBvcnQgeyBYWVNpemUsIFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcbmltcG9ydCB7IElucHV0U3RyZWFtRmFjdG9yeSwgSW5wdXRTdHJlYW0sIEV2ZW50SGFuZGxlckxpc3QgfSBmcm9tICcuL2lucHV0X3N0cmVhbS5kJztcclxuXHJcbmNvbnN0IGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5ID0ge1xyXG4gICAgY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pOiBJbnB1dFN0cmVhbSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVWaWRlb1N0cmVhbScpO1xyXG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgdHlwZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbDtcclxuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XHJcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcclxuICAgICAgICBsZXQgX2NhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xyXG4gICAgICAgIGxldCBfY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xyXG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcclxuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0U2l6ZSgpOiB2b2lkIHtcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB2aWRlby52aWRlb1dpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcclxuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICAgICAgICBfY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcclxuICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IF9jYWxjdWxhdGVkSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XHJcbiAgICAgICAgICAgIGdldFJlYWxXaWR0aCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb1dpZHRoO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0UmVhbEhlaWdodCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYWxjdWxhdGVkV2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRXaWR0aCh3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRJbnB1dFN0cmVhbShjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcclxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJywgKHR5cGVvZiBjb25maWcuc3JjICE9PSAndW5kZWZpbmVkJykgPyBjb25maWcuc3JjIDogJycpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZW5kZWQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZztcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHBhdXNlKCkge1xyXG4gICAgICAgICAgICAgICAgdmlkZW8ucGF1c2UoKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHBsYXkoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgICAgICAgICB2aWRlby5wbGF5KCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbmZpZz8udHlwZSAhPT0gJ0xpdmVTdHJlYW0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRUaW1lJywgdGltZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYsIGJvb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYsIGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xyXG4gICAgICAgICAgICAgICAgX2V2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICB0cmlnZ2VyKGV2ZW50TmFtZSwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGo7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2NhbnJlY29yZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbml0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XHJcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHNpemUpIHtcclxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gc2l6ZS55O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUxpdmVTdHJlYW0odmlkZW8pOiBJbnB1dFN0cmVhbSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVMaXZlU3RyZWFtJyk7XHJcbiAgICAgICAgaWYgKHZpZGVvKSB7XHJcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aGF0ID0gaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcclxuICAgICAgICB0aGF0LmVuZGVkID0gZnVuY3Rpb24gZW5kZWQoKTogZmFsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhhdDtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVJbWFnZVN0cmVhbScpO1xyXG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgc2VxdWVuY2U6IGFueSB9IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XHJcbiAgICAgICAgbGV0IGZyYW1lSWR4ID0gMDtcclxuICAgICAgICBsZXQgcGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGltZ0FycmF5OiBhbnlbXSB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIGxldCBzaXplID0gMDtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSAxO1xyXG4gICAgICAgIGxldCBiYXNlVXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBsZXQgZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRIZWlnaHQ6IG51bWJlcjtcclxuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XHJcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcclxuICAgICAgICBjb25zdCBfdG9wUmlnaHQ6IFBvaW50ID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnUG9pbnQnIH07XHJcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcygpOiB2b2lkIHtcclxuICAgICAgICAgICAgbG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgKGltZ3M6IEFycmF5PHsgdGFnczogYW55OyBpbWc6IEhUTUxJbWFnZUVsZW1lbnR9PikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW1nQXJyYXkgPSBpbWdzO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpIDogd2lkdGg7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gTWF0aC5mbG9vcigoaGVpZ2h0IC8gd2lkdGgpICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FsY3VsYXRlZEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IDA7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KCdjYW5yZWNvcmQnLCBbXSk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgfSwgb2Zmc2V0LCBzaXplLCBfY29uZmlnPy5zZXF1ZW5jZSwgX2NvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwdWJsaXNoRXZlbnQoZXZlbnROYW1lOiBzdHJpbmcsIGFyZ3M6IEFycmF5PGFueT4pOiB2b2lkIHtcclxuICAgICAgICAgICAgbGV0IGo7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MgYXMgYW55KTsgLy8gVE9ETzogdHlwZXNjcmlwdCBjb21wbGFpbnMgdGhhdCBhbnlbXSBpcyBub3QgdmFsaWQgZm9yIGEgc2Vjb25kIGFyZyBmb3IgYXBwbHk/IVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBhbnkgY29kZSBzaGFyZWQgd2l0aCB0aGUgZmlyc3QgSW5wdXRTdHJlYW0gYWJvdmUgc2hvdWxkIGJlIHNoYXJlZCBub3QgY29waWVkXHJcbiAgICAgICAgLy8gVE9ETzogcHVibGlzaEV2ZW50IG5lZWRzIGFjY2VzcyB0byBpbnB1dFN0cmVhbSwgYnV0IGlucHV0U3RyZWFtIG5lZWRzIGFjY2VzcyB0byBwdWJsaXNoRXZlbnRcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHdoeSBpdCdzIGEgJ3ZhcicsIHNvIGl0IGhvaXN0cyBiYWNrLiAgVGhpcyBpcyB1Z2x5LCBhbmQgc2hvdWxkIGJlIGNoYW5nZWQuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxyXG4gICAgICAgIHZhciBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XHJcblxyXG4gICAgICAgICAgICB0cmlnZ2VyOiBwdWJsaXNoRXZlbnQsXHJcblxyXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkV2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZEhlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldFdpZHRoKG5ld1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBuZXdXaWR0aDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldEhlaWdodChuZXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxyXG4gICAgICAgICAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcclxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc2VxdWVuY2UgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcclxuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcclxuICAgICAgICAgICAgICAgICAgICBzaXplID0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcclxuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9hZEltYWdlcygpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZW5kZWQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcclxuXHJcbiAgICAgICAgICAgIGdldENvbmZpZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgcGF1c2UoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgcGxheSgpIHtcclxuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9ldmVudEhhbmRsZXJzKS5mb3JFYWNoKChpbmQpID0+IGRlbGV0ZSBfZXZlbnRIYW5kbGVyc1tpbmRdKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XHJcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKGNhbnZhc1NpemUpIHtcclxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYW52YXNTaXplLng7XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FudmFzU2l6ZS55O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5Py5bZnJhbWVJZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUlkeCA8IChzaXplIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZHgrKztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnZW5kZWQnLCBbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcclxuIiwiLyoqXHJcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cclxuICovXHJcbmNvbnN0IFRyYWNlciA9IHtcclxuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXHJcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcclxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcclxuICAgICAgICBjb25zdCB7IHNlYXJjaERpcmVjdGlvbnMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgICAgIGxldCBwb3M7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBsZXQgeTtcclxuICAgICAgICAgICAgbGV0IHg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VhcmNoRGlyZWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQuY3kgKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVswXTtcclxuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XHJcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xyXG4gICAgICAgICAgICAgICAgaWYgKChpbWFnZURhdGFbcG9zXSA9PT0gY29sb3IpICYmICgobGFiZWxEYXRhW3Bvc10gPT09IDApIHx8IChsYWJlbERhdGFbcG9zXSA9PT0gbGFiZWwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGVkZ2VsYWJlbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgMSkgJSA4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGlyLFxyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcclxuICAgICAgICAgICAgbGV0IEZ2ID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IEN2O1xyXG4gICAgICAgICAgICBsZXQgUDtcclxuICAgICAgICAgICAgbGV0IGxkaXI7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XHJcbiAgICAgICAgICAgICAgICBjeDogc3gsXHJcbiAgICAgICAgICAgICAgICBjeTogc3ksXHJcbiAgICAgICAgICAgICAgICBkaXI6IDAsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBGdiA9IHZlcnRleDJEKHN4LCBzeSwgY3VycmVudC5kaXIpO1xyXG4gICAgICAgICAgICAgICAgQ3YgPSBGdjtcclxuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcclxuICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcclxuICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xyXG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XHJcbiAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgQ3YgPSBQO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB0b3RhbFBpeGVsQ291bnQgPSBpbWFnZVdyYXBwZXIuc2l6ZS54ICogaW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgICAgICAgICAgICAgIGxldCBwaXhlbENvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgNikgJSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gY3VycmVudC5kaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gbGRpcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnkgPSBjdXJyZW50LmN5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpICYmICsrcGl4ZWxDb3VudGVyIDwgdG90YWxQaXhlbENvdW50KTtcclxuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xyXG4gICAgICAgICAgICAgICAgQ3YucHJldi5uZXh0ID0gRnY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IChUcmFjZXIpO1xyXG4iLCJpbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcclxuXHJcbi8qKlxyXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXHJcbiAqL1xyXG5jb25zdCBSYXN0ZXJpemVyID0ge1xyXG4gICAgY3JlYXRlQ29udG91cjJEKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpcjogbnVsbCxcclxuICAgICAgICAgICAgaW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxyXG4gICAgICAgICAgICBpbnNpZGVDb250b3VyczogbnVsbCxcclxuICAgICAgICAgICAgbmV4dHBlZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgQ09OVE9VUl9ESVI6IHtcclxuICAgICAgICBDV19ESVI6IDAsXHJcbiAgICAgICAgQ0NXX0RJUjogMSxcclxuICAgICAgICBVTktOT1dOX0RJUjogMixcclxuICAgIH0sXHJcbiAgICBESVI6IHtcclxuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcclxuICAgICAgICBJTlNJREVfRURHRTogLTMyNzY2LFxyXG4gICAgfSxcclxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xyXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG4gICAgICAgIGNvbnN0IHRyYWNlciA9IFRyYWNlci5jcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYXN0ZXJpemUoZGVwdGhsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJjO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxjO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3g7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3k7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvck1hcCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZlcnRleDtcclxuICAgICAgICAgICAgICAgIGxldCBwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNjO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvcztcclxuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgaTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29sb3JNYXBbMF0gPSBpbWFnZURhdGFbMF07XHJcbiAgICAgICAgICAgICAgICBjYyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGN4ID0gMTsgY3ggPCB3aWR0aCAtIDE7IGN4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gY3kgKiB3aWR0aCArIGN4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT09IGJjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2xjXSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gbGFiZWxpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhsYWJlbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGRlcHRobGFiZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IGNjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IHNjLmluc2lkZUNvbnRvdXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYy5pbnNpZGVDb250b3VycyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gaW1hZ2VEYXRhW3Bvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwW2xhYmVsaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2MgPSBjYztcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjLmluZGV4ID0gZGVwdGhsYWJlbDtcclxuICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjYyxcclxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY29ubmVjdGVkQ291bnQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWJ1Zzoge1xyXG4gICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHEgPSBmaXJzdENvbnRvdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlxO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBxO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBpcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcSA9IHBxLm5leHRwZWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHEuZGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBxLmZpcnN0VmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHAgIT09IHEuZmlyc3RWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJhc3Rlcml6ZXI7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXHJcbi8qIEBwcmVzZXJ2ZSBBU00gQkVHSU4gKi9cclxuLyoqXHJcbiAqIE1vcnBob2xvZ2ljYWwgc2tlbGV0b25pemF0aW9uIHVzaW5nIGl0ZXJhdGl2ZSB0aGlubmluZyBhbGdvcml0aG0uXHJcbiAqIFJlZHVjZXMgYmluYXJ5IGltYWdlcyB0byBzaW5nbGUtcGl4ZWwtd2lkZSBza2VsZXRvbnMgd2hpbGUgcHJlc2VydmluZyB0b3BvbG9neS5cclxuICpcclxuICogTWVtb3J5IGxheW91dCBpbiBzaGFyZWQgQXJyYXlCdWZmZXIgKDQgcmVnaW9ucyBvZiBzaXplwrIpOlxyXG4gKiAtIFJlZ2lvbiAwOiBXb3JraW5nIGltYWdlIChzdWJJbWFnZVB0ciA9IDApXHJcbiAqIC0gUmVnaW9uIDE6IEVyb2RlZCByZXN1bHQgKGVyb2RlZEltYWdlUHRyID0gc2l6ZcKyKVxyXG4gKiAtIFJlZ2lvbiAyOiBUZW1wL3NjcmF0Y2ggc3BhY2UgKHRlbXBJbWFnZVB0ciA9IDIqc2l6ZcKyKVxyXG4gKiAtIFJlZ2lvbiAzOiBGaW5hbCBza2VsZXRvbiBvdXRwdXQgKHNrZWxJbWFnZVB0ciA9IDMqc2l6ZcKyKVxyXG4gKi9cclxuZnVuY3Rpb24gU2tlbGV0b25pemVyKHN0ZGxpYiwgZm9yZWlnbiwgYnVmZmVyKSB7XHJcbiAgICAndXNlIGFzbSc7XHJcblxyXG4gICAgdmFyIGltYWdlcyA9IG5ldyBzdGRsaWIuVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgdmFyIHNpemUgPSBmb3JlaWduLnNpemUgfCAwO1xyXG4gICAgdmFyIGltdWwgPSBzdGRsaWIuTWF0aC5pbXVsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9ycGhvbG9naWNhbCBlcm9zaW9uIHdpdGggNS1waXhlbCBjcm9zcyBzdHJ1Y3R1cmluZyBlbGVtZW50LlxyXG4gICAgICogQSBwaXhlbCBzdXJ2aXZlcyBvbmx5IGlmIGFsbCA1IHBpeGVscyBpbiB0aGUgY3Jvc3MgcGF0dGVybiBhcmUgc2V0OlxyXG4gICAgICogdG9wLWxlZnQsIHRvcC1yaWdodCwgY2VudGVyLCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlcm9kZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xyXG4gICAgICAgIGluSW1hZ2VQdHIgPSBpbkltYWdlUHRyIHwgMDtcclxuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcclxuXHJcbiAgICAgICAgdmFyIHYgPSAwO1xyXG4gICAgICAgIHZhciB1ID0gMDtcclxuICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICB2YXIgeVN0YXJ0MSA9IDA7XHJcbiAgICAgICAgdmFyIHlTdGFydDIgPSAwO1xyXG4gICAgICAgIHZhciB4U3RhcnQxID0gMDtcclxuICAgICAgICB2YXIgeFN0YXJ0MiA9IDA7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcclxuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xyXG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XHJcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcclxuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcclxuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcclxuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcclxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcclxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgLy8gUGl4ZWwgc3Vydml2ZXMgZXJvc2lvbiBvbmx5IGlmIGFsbCA1IGNyb3NzIG5laWdoYm9ycyBhcmUgc2V0XHJcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQaXhlbC13aXNlIHN1YnRyYWN0aW9uOiBvdXQgPSBhIC0gYiAoY2FwdHVyZXMgdGhlIFwicGVlbGVkXCIgbGF5ZXIpXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcclxuICAgICAgICBhSW1hZ2VQdHIgPSBhSW1hZ2VQdHIgfCAwO1xyXG4gICAgICAgIGJJbWFnZVB0ciA9IGJJbWFnZVB0ciB8IDA7XHJcbiAgICAgICAgb3V0SW1hZ2VQdHIgPSBvdXRJbWFnZVB0ciB8IDA7XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcclxuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSAtIChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBpeGVsLXdpc2UgT1I6IG91dCA9IGEgfCBiIChhY2N1bXVsYXRlcyBza2VsZXRvbiBsYXllcnMpXHJcbiAgICBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XHJcbiAgICAgICAgYUltYWdlUHRyID0gYUltYWdlUHRyIHwgMDtcclxuICAgICAgICBiSW1hZ2VQdHIgPSBiSW1hZ2VQdHIgfCAwO1xyXG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgfCAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb3VudHMgbm9uLXplcm8gcGl4ZWxzIHRvIGRldGVjdCB3aGVuIGVyb3Npb24gaXMgY29tcGxldGVcclxuICAgIGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVB0cikge1xyXG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xyXG5cclxuICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIHN1bSA9ICgoc3VtIHwgMCkgKyAoaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKHN1bSB8IDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbGxzIGltYWdlIHJlZ2lvbiB3aXRoIGEgY29uc3RhbnQgdmFsdWVcclxuICAgIGZ1bmN0aW9uIGluaXQoaW1hZ2VQdHIsIHZhbHVlKSB7XHJcbiAgICAgICAgaW1hZ2VQdHIgPSBpbWFnZVB0ciB8IDA7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSB8IDA7XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3JwaG9sb2dpY2FsIGRpbGF0aW9uIHdpdGggNS1waXhlbCBjcm9zcyAtIHBpeGVsIGlzIHNldCBpZiBhbnkgbmVpZ2hib3IgaXMgc2V0XHJcbiAgICBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcclxuICAgICAgICBpbkltYWdlUHRyID0gaW5JbWFnZVB0ciB8IDA7XHJcbiAgICAgICAgb3V0SW1hZ2VQdHIgPSBvdXRJbWFnZVB0ciB8IDA7XHJcblxyXG4gICAgICAgIHZhciB2ID0gMDtcclxuICAgICAgICB2YXIgdSA9IDA7XHJcbiAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgdmFyIHlTdGFydDEgPSAwO1xyXG4gICAgICAgIHZhciB5U3RhcnQyID0gMDtcclxuICAgICAgICB2YXIgeFN0YXJ0MSA9IDA7XHJcbiAgICAgICAgdmFyIHhTdGFydDIgPSAwO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XHJcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcclxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPiAoMCB8IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29waWVzIGltYWdlIGRhdGEgZnJvbSBzcmMgdG8gZHN0IHJlZ2lvblxyXG4gICAgZnVuY3Rpb24gbWVtY3B5KHNyY0ltYWdlUHRyLCBkc3RJbWFnZVB0cikge1xyXG4gICAgICAgIHNyY0ltYWdlUHRyID0gc3JjSW1hZ2VQdHIgfCAwO1xyXG4gICAgICAgIGRzdEltYWdlUHRyID0gZHN0SW1hZ2VQdHIgfCAwO1xyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIGltYWdlc1soZHN0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoaW1hZ2VzWyhzcmNJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFplcm9zIG91dCB0aGUgYm9yZGVyIHBpeGVscyBvZiB0aGUgaW1hZ2UuXHJcbiAgICAgKiBGaXJzdCBsb29wOiBoYW5kbGVzIHRvcCwgbGVmdCwgYW5kIHJpZ2h0IGVkZ2VzIHNpbXVsdGFuZW91c2x5XHJcbiAgICAgKiBTZWNvbmQgbG9vcDogaGFuZGxlcyBib3R0b20gZWRnZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB6ZXJvQm9yZGVyKGltYWdlUHRyKSB7XHJcbiAgICAgICAgaW1hZ2VQdHIgPSBpbWFnZVB0ciB8IDA7XHJcblxyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB2YXIgeSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHgpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XHJcbiAgICAgICAgICAgIHkgPSAoKHkgKyBzaXplKSAtIDEpIHwgMDtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFpbiBza2VsZXRvbml6YXRpb24gYWxnb3JpdGhtIHVzaW5nIGl0ZXJhdGl2ZSB0aGlubmluZzpcclxuICAgICAqIDEuIEVyb2RlIHRoZSB3b3JraW5nIGltYWdlXHJcbiAgICAgKiAyLiBEaWxhdGUgdGhlIGVyb2RlZCB2ZXJzaW9uXHJcbiAgICAgKiAzLiBTdWJ0cmFjdCBkaWxhdGVkIGZyb20gb3JpZ2luYWwgKGV4dHJhY3RzIFwicGVlbGVkXCIgbGF5ZXIpXHJcbiAgICAgKiA0LiBPUiB0aGUgcGVlbGVkIGxheWVyIGludG8gc2tlbGV0b24gYWNjdW11bGF0b3JcclxuICAgICAqIDUuIENvcHkgZXJvZGVkIGltYWdlIGJhY2sgdG8gd29ya2luZyBpbWFnZVxyXG4gICAgICogNi4gUmVwZWF0IHVudGlsIHdvcmtpbmcgaW1hZ2UgaXMgZW1wdHlcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gTm8gcmV0dXJuIHZhbHVlIC0gb3BlcmF0ZXMgZGlyZWN0bHkgb24gc2hhcmVkIGJ1ZmZlci5cclxuICAgICAqICAgSW5wdXQgaW1hZ2UgaXMgcmVhZCBmcm9tIGJ1ZmZlciBvZmZzZXQgMCAoc3ViSW1hZ2VQdHIpLlxyXG4gICAgICogICBPdXRwdXQgc2tlbGV0b24gaXMgd3JpdHRlbiB0byBidWZmZXIgb2Zmc2V0IDMqc2l6ZcKyIChza2VsSW1hZ2VQdHIpLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBza2VsZXRvbml6ZSgpIHtcclxuICAgICAgICB2YXIgc3ViSW1hZ2VQdHIgPSAwOyAgICAgICAgLy8gUmVnaW9uIDA6IFdvcmtpbmcgaW1hZ2UgKGlucHV0LCBvZmZzZXQgPSAwKVxyXG4gICAgICAgIHZhciBlcm9kZWRJbWFnZVB0ciA9IDA7ICAgICAvLyBSZWdpb24gMTogRXJvZGVkIHJlc3VsdCAob2Zmc2V0ID0gc2l6ZcKyKVxyXG4gICAgICAgIHZhciB0ZW1wSW1hZ2VQdHIgPSAwOyAgICAgICAvLyBSZWdpb24gMjogU2NyYXRjaCBzcGFjZSAob2Zmc2V0ID0gMipzaXplwrIpXHJcbiAgICAgICAgdmFyIHNrZWxJbWFnZVB0ciA9IDA7ICAgICAgIC8vIFJlZ2lvbiAzOiBGaW5hbCBza2VsZXRvbiAob3V0cHV0LCBvZmZzZXQgPSAzKnNpemXCsilcclxuICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICB2YXIgZG9uZSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBieXRlIG9mZnNldHMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBzaGFyZWQgYnVmZmVyXHJcbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDsgICAgICAgICAgICAgICAgICAvLyBSZWdpb24gMTogc2l6ZcKyIGJ5dGVzIGluXHJcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDsgIC8vIFJlZ2lvbiAyOiAyKnNpemXCsiBieXRlcyBpblxyXG4gICAgICAgIHNrZWxJbWFnZVB0ciA9ICh0ZW1wSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwOyAgICAvLyBSZWdpb24gMzogMypzaXplwrIgYnl0ZXMgaW5cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBza2VsZXRvbiBhY2N1bXVsYXRvciB0byB6ZXJvXHJcbiAgICAgICAgaW5pdChza2VsSW1hZ2VQdHIsIDApO1xyXG4gICAgICAgIHplcm9Cb3JkZXIoc3ViSW1hZ2VQdHIpO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGVyb2RlKHN1YkltYWdlUHRyLCBlcm9kZWRJbWFnZVB0cik7XHJcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcclxuICAgICAgICAgICAgc3VidHJhY3Qoc3ViSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcclxuICAgICAgICAgICAgYml0d2lzZU9yKHNrZWxJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCBza2VsSW1hZ2VQdHIpO1xyXG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcclxuICAgICAgICAgICAgc3VtID0gY291bnROb25aZXJvKHN1YkltYWdlUHRyKSB8IDA7XHJcbiAgICAgICAgICAgIGRvbmUgPSAoKHN1bSB8IDApID09IDAgfCAwKTtcclxuICAgICAgICB9IHdoaWxlICghZG9uZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBza2VsZXRvbml6ZTogc2tlbGV0b25pemUgfTtcclxufVxyXG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xyXG4vKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xyXG4iLCJpbXBvcnQgeyB2ZWMyLCBtYXQyIH0gZnJvbSAnZ2wtbWF0cml4JztcclxuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XHJcbmltcG9ydCB7XHJcbiAgICBjYWxjdWxhdGVQYXRjaFNpemUsXHJcbiAgICBvdHN1VGhyZXNob2xkLFxyXG4gICAgaHN2MnJnYixcclxuICAgIGNsdXN0ZXIsXHJcbiAgICB0b3BHZW5lcmljLFxyXG4gICAgaW1hZ2VSZWYsXHJcbiAgICBoYWxmU2FtcGxlLFxyXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcclxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xyXG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XHJcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XHJcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XHJcbmltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xyXG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcclxuXHJcbmxldCBfY29uZmlnO1xyXG5sZXQgX2N1cnJlbnRJbWFnZVdyYXBwZXI7XHJcbmxldCBfc2tlbEltYWdlV3JhcHBlcjtcclxubGV0IF9zdWJJbWFnZVdyYXBwZXI7XHJcbmxldCBfbGFiZWxJbWFnZVdyYXBwZXI7XHJcbmxldCBfcGF0Y2hHcmlkO1xyXG5sZXQgX3BhdGNoTGFiZWxHcmlkO1xyXG5sZXQgX2ltYWdlVG9QYXRjaEdyaWQ7XHJcbmxldCBfYmluYXJ5SW1hZ2VXcmFwcGVyO1xyXG5sZXQgX3BhdGNoU2l6ZTtcclxuY29uc3QgX2NhbnZhc0NvbnRhaW5lciA9IHtcclxuICAgIGN0eDoge1xyXG4gICAgICAgIGJpbmFyeTogbnVsbCxcclxuICAgIH0sXHJcbiAgICBkb206IHtcclxuICAgICAgICBiaW5hcnk6IG51bGwsXHJcbiAgICB9LFxyXG59O1xyXG5jb25zdCBfbnVtUGF0Y2hlcyA9IHsgeDogMCwgeTogMCB9O1xyXG5sZXQgX2lucHV0SW1hZ2VXcmFwcGVyO1xyXG5sZXQgX3NrZWxldG9uaXplcjtcclxuXHJcbmZ1bmN0aW9uIGluaXRCdWZmZXJzKCkge1xyXG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xyXG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIHg6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnggLyAyIHwgMCxcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgICAgICAgeTogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueSAvIDIgfCAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IF9pbnB1dEltYWdlV3JhcHBlcjtcclxuICAgIH1cclxuXHJcbiAgICBfcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKF9jb25maWcucGF0Y2hTaXplLCBfY3VycmVudEltYWdlV3JhcHBlci5zaXplKTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgX251bVBhdGNoZXMueCA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueCAvIF9wYXRjaFNpemUueCB8IDA7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XHJcblxyXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSwgdW5kZWZpbmVkLCBVaW50OEFycmF5LCBmYWxzZSk7XHJcblxyXG4gICAgX2xhYmVsSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgYnVmZmVyIHNpemUgKDQgcmVnaW9ucyBmb3IgYXNtLmpzIHNrZWxldG9uaXplcilcclxuICAgIGNvbnN0IHNrZWxldG9uSW1hZ2VEYXRhU2l6ZSA9IF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDQ7XHJcbiAgICAvLyBSb3VuZCB1cCB0byBuZXh0IHBvd2VyIG9mIDIgZm9yIGFzbS5qcyBoZWFwIHJlcXVpcmVtZW50XHJcbiAgICAvLyBVc2UgbWluaW11bSA2NEtCIGZvciBvcHRpbWFsIGFzbS5qcyBwZXJmb3JtYW5jZSAoYXZvaWRzIFY4IHdhcm5pbmdzKVxyXG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IE1hdGgubWF4KDY1NTM2LCBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHNrZWxldG9uSW1hZ2VEYXRhU2l6ZSkpKSk7XHJcbiAgICBjb25zdCBza2VsZXRvbkltYWdlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJTaXplKTtcclxuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXHJcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIDAsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSkpO1xyXG4gICAgX3NrZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXHJcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXHJcbiAgICAgICAgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIF9za2VsZXRvbml6ZXIgPSBza2VsZXRvbml6ZXIoXHJcbiAgICAgICAgeyBNYXRoLCBVaW50OEFycmF5IH0sXHJcbiAgICAgICAgeyBzaXplOiBfcGF0Y2hTaXplLnggfSxcclxuICAgICAgICBza2VsZXRvbkltYWdlRGF0YSxcclxuICAgICk7XHJcblxyXG4gICAgX2ltYWdlVG9QYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDAsXHJcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcclxuICAgIF9wYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIF9wYXRjaExhYmVsR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCBJbnQzMkFycmF5LCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcclxuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuY2xhc3NOYW1lID0gJ2JpbmFyeUJ1ZmZlcic7XHJcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1ZycpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3aWxsUmVhZEZyZXF1ZW50bHkgPSAhIV9jb25maWcud2lsbFJlYWRGcmVxdWVudGx5O1xyXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnPy5zaG93Q2FudmFzKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCcqIGluaXRDYW52YXMgd2lsbFJlYWRGcmVxdWVudGx5Jywgd2lsbFJlYWRGcmVxdWVudGx5LCBfY29uZmlnKTtcclxuICAgIH1cclxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KCcyZCcsIHsgd2lsbFJlYWRGcmVxdWVudGx5IH0pO1xyXG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LndpZHRoID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IHdoaWNoIGVuY2xvc2VzIGFsbCB0aGUgZ2l2ZW4gcGF0Y2hlc1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBtaW5pbWFsIGJvdW5kaW5nIGJveFxyXG4gKi9cclxuZnVuY3Rpb24gYm94RnJvbVBhdGNoZXMocGF0Y2hlcykge1xyXG4gICAgbGV0IG92ZXJBdmc7XHJcbiAgICBsZXQgaTtcclxuICAgIGxldCBqO1xyXG4gICAgbGV0IHBhdGNoO1xyXG4gICAgbGV0IHRyYW5zTWF0O1xyXG4gICAgbGV0IG1pbnggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGxldCBtaW55ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBsZXQgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGxldCBtYXh5ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG4gICAgbGV0IGJveDtcclxuICAgIGxldCBzY2FsZTtcclxuXHJcbiAgICAvLyBkcmF3IGFsbCBwYXRjaGVzIHdoaWNoIGFyZSB0byBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb25cclxuICAgIG92ZXJBdmcgPSAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XHJcbiAgICAgICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJ3JlZCcgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XHJcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XHJcbiAgICBpZiAob3ZlckF2ZyA8IDApIHtcclxuICAgICAgICBvdmVyQXZnICs9IDE4MDtcclxuICAgIH1cclxuXHJcbiAgICBvdmVyQXZnID0gKDE4MCAtIG92ZXJBdmcpICogTWF0aC5QSSAvIDE4MDtcclxuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcclxuXHJcbiAgICAvLyBpdGVyYXRlIG92ZXIgcGF0Y2hlcyBhbmQgcm90YXRlIGJ5IGFuZ2xlXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZCkge1xyXG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKHBhdGNoLmJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyM5OWZmMDAnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XHJcbiAgICAgICAgICAgICAgICBtaW54ID0gcGF0Y2guYm94W2pdWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXh4ID0gcGF0Y2guYm94W2pdWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XHJcbiAgICAgICAgICAgICAgICBtaW55ID0gcGF0Y2guYm94W2pdWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XHJcbiAgICAgICAgICAgICAgICBtYXh5ID0gcGF0Y2guYm94W2pdWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xyXG5cclxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWRCb3gpIHtcclxuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2NhbGUgPSBfY29uZmlnLmhhbGZTYW1wbGUgPyAyIDogMTtcclxuICAgIC8vIHJldmVyc2Ugcm90YXRpb247XHJcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgdmVjMi50cmFuc2Zvcm1NYXQyKGJveFtqXSwgYm94W2pdLCB0cmFuc01hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dCQikge1xyXG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBib3g7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYmluYXJ5IGltYWdlIG9mIHRoZSBjdXJyZW50IGltYWdlXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xyXG4gICAgb3RzdVRocmVzaG9sZChfY3VycmVudEltYWdlV3JhcHBlciwgX2JpbmFyeUltYWdlV3JhcHBlcik7XHJcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcclxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XHJcbiAgICAgICAgX2JpbmFyeUltYWdlV3JhcHBlci5zaG93KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMjU1KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXHJcbiAqIGV4dHJhY3QgcGF0Y2hlc1xyXG4gKi9cclxuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XHJcbiAgICBsZXQgaTtcclxuICAgIGxldCBqO1xyXG4gICAgbGV0IHg7XHJcbiAgICBsZXQgeTtcclxuICAgIGxldCBtb21lbnRzO1xyXG4gICAgbGV0IHBhdGNoZXNGb3VuZCA9IFtdO1xyXG4gICAgbGV0IHJhc3Rlcml6ZXI7XHJcbiAgICBsZXQgcmFzdGVyUmVzdWx0O1xyXG4gICAgbGV0IHBhdGNoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IF9udW1QYXRjaGVzLng7IGkrKykge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfbnVtUGF0Y2hlcy55OyBqKyspIHtcclxuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcclxuICAgICAgICAgICAgeSA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55ICogajtcclxuXHJcbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXHJcbiAgICAgICAgICAgIHNrZWxldG9uaXplKHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xyXG4gICAgICAgICAgICBfc2tlbEltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XHJcbiAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xyXG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XHJcbiAgICAgICAgICAgIHJhc3RlclJlc3VsdCA9IHJhc3Rlcml6ZXIucmFzdGVyaXplKDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIF9sYWJlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgTWF0aC5mbG9vcigzNjAgLyByYXN0ZXJSZXN1bHQuY291bnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXHJcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXHJcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dGb3VuZFBhdGNoZXMpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2ldO1xyXG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXHJcbiAgICAgICAgICAgICAgICB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIHRob3NlIGNvbm5lY3RlZCBhcmVhcyB3aGljaCBjb250YWluIGF0IGxlYXN0IDYgcGF0Y2hlc1xyXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYWJlbFxyXG4gKi9cclxuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgc3VtO1xyXG4gICAgbGV0IGxhYmVsSGlzdCA9IFtdO1xyXG4gICAgbGV0IHRvcExhYmVscyA9IFtdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XHJcbiAgICAgICAgbGFiZWxIaXN0LnB1c2goMCk7XHJcbiAgICB9XHJcbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoc3VtLS0pIHtcclxuICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA+IDApIHtcclxuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsYWJlbEhpc3QgPSBsYWJlbEhpc3QubWFwKCh2YWwsIGlkeCkgPT4gKHtcclxuICAgICAgICB2YWwsXHJcbiAgICAgICAgbGFiZWw6IGlkeCArIDEsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgbGFiZWxIaXN0LnNvcnQoKGEsIGIpID0+IGIudmFsIC0gYS52YWwpO1xyXG5cclxuICAgIC8vIGV4dHJhY3QgdG9wIGFyZWFzIHdpdGggYXQgbGVhc3QgNiBwYXRjaGVzIHByZXNlbnRcclxuICAgIHRvcExhYmVscyA9IGxhYmVsSGlzdC5maWx0ZXIoKGVsKSA9PiBlbC52YWwgPj0gNSk7XHJcblxyXG4gICAgcmV0dXJuIHRvcExhYmVscztcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCkge1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgajtcclxuICAgIGxldCBzdW07XHJcbiAgICBjb25zdCBwYXRjaGVzID0gW107XHJcbiAgICBsZXQgcGF0Y2g7XHJcbiAgICBsZXQgYm94O1xyXG4gICAgY29uc3QgYm94ZXMgPSBbXTtcclxuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcclxuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgIHBhdGNoZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcclxuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPT09IHRvcExhYmVsc1tpXS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3N1bV07XHJcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xyXG4gICAgICAgIGlmIChib3gpIHtcclxuICAgICAgICAgICAgYm94ZXMucHVzaChib3gpO1xyXG5cclxuICAgICAgICAgICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGhzdlswXSA9ICh0b3BMYWJlbHNbaV0ubGFiZWwgLyAobWF4TGFiZWwgKyAxKSkgKiAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XHJcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJveGVzO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZCBzaW1pbGFyIG1vbWVudHMgKHZpYSBjbHVzdGVyKVxyXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gc2ltaWxhck1vbWVudHMobW9tZW50cykge1xyXG4gICAgY29uc3QgY2x1c3RlcnMgPSBjbHVzdGVyKG1vbWVudHMsIDAuOTApO1xyXG4gICAgY29uc3QgdG9wQ2x1c3RlciA9IHRvcEdlbmVyaWMoY2x1c3RlcnMsIDEsIChlKSA9PiBlLmdldFBvaW50cygpLmxlbmd0aCk7XHJcbiAgICBsZXQgcG9pbnRzID0gW107IGNvbnN0XHJcbiAgICAgICAgcmVzdWx0ID0gW107XHJcbiAgICBpZiAodG9wQ2x1c3Rlci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwb2ludHMgPSB0b3BDbHVzdGVyWzBdLml0ZW0uZ2V0UG9pbnRzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzW2ldLnBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBza2VsZXRvbml6ZSh4LCB5KSB7XHJcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIGltYWdlUmVmKHgsIHkpKTtcclxuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcclxuXHJcbiAgICAvLyBTaG93IHNrZWxldG9uIGlmIHJlcXVlc3RlZFxyXG4gICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xyXG4gICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAzNjAsIGltYWdlUmVmKHgsIHkpKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cclxuICogQHBhcmFtIHtBcnJheX0gbW9tZW50c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hQb3MsXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBwYXRjaGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXNjcmliZVBhdGNoKG1vbWVudHMsIHBhdGNoUG9zLCB4LCB5KSB7XHJcbiAgICBsZXQgaztcclxuICAgIGxldCBhdmc7XHJcbiAgICBjb25zdCBlbGlnaWJsZU1vbWVudHMgPSBbXTtcclxuICAgIGxldCBtYXRjaGluZ01vbWVudHM7XHJcbiAgICBsZXQgcGF0Y2g7XHJcbiAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBbXTtcclxuICAgIGNvbnN0IG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcclxuXHJcbiAgICBpZiAobW9tZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgIC8vIG9ubHkgY29sbGVjdCBtb21lbnRzIHdoaWNoJ3MgYXJlYSBjb3ZlcnMgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0IHBpeGVscy5cclxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbW9tZW50cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBpZiAobW9tZW50c1trXS5tMDAgPiBtaW5Db21wb25lbnRXZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXHJcbiAgICAgICAgaWYgKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xyXG4gICAgICAgICAgICBhdmcgPSAwO1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgb2YgdGhlIG1vbWVudHNcclxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXT8ucmFkID8/IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBwYXRjaCB0byB0aGUgc2V0XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcclxuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gbW9tZW50cy5sZW5ndGggLyA0KSB7XHJcbiAgICAgICAgICAgICAgICBhdmcgLz0gbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXRjaFBvc1sxXSAqIF9udW1QYXRjaGVzLnggKyBwYXRjaFBvc1swXSxcclxuICAgICAgICAgICAgICAgICAgICBwb3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGJveDogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5XSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcclxuICAgICAgICAgICAgICAgICAgICByYWQ6IGF2ZyxcclxuICAgICAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoW01hdGguY29zKGF2ZyksIE1hdGguc2luKGF2ZyldKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwYXRjaGVzRm91bmQucHVzaChwYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xyXG59XHJcblxyXG4vKipcclxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hlc0ZvdW5kXHJcbiAqL1xyXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcclxuICAgIGxldCBsYWJlbCA9IDA7XHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjk1O1xyXG4gICAgbGV0IGN1cnJJZHggPSAwO1xyXG4gICAgbGV0IGo7XHJcbiAgICBsZXQgcGF0Y2g7XHJcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XHJcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XHJcblxyXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnRJZHgpIHtcclxuICAgICAgICBsZXQgeDtcclxuICAgICAgICBsZXQgeTtcclxuICAgICAgICBsZXQgY3VycmVudFBhdGNoO1xyXG4gICAgICAgIGxldCBpZHg7XHJcbiAgICAgICAgbGV0IGRpcjtcclxuICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xyXG4gICAgICAgICAgICB4OiBjdXJyZW50SWR4ICUgX3BhdGNoTGFiZWxHcmlkLnNpemUueCxcclxuICAgICAgICAgICAgeTogKGN1cnJlbnRJZHggLyBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54KSB8IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgc2ltaWxhcml0eTtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRJZHggPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcclxuICAgICAgICAgICAgLy8gYXNzaWduIGxhYmVsXHJcbiAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2N1cnJlbnRJZHhdID0gbGFiZWw7XHJcbiAgICAgICAgICAgIGZvciAoZGlyID0gMDsgZGlyIDwgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBkaXIrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQueSArIFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zW2Rpcl1bMF07XHJcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcclxuICAgICAgICAgICAgICAgIGlkeCA9IHkgKiBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54ICsgeDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxyXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbaWR4XSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3QoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtpZHhdLnZlYywgY3VycmVudFBhdGNoLnZlYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHByZXBhcmUgZm9yIGZpbmRpbmcgdGhlIHJpZ2h0IHBhdGNoZXNcclxuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoR3JpZC5kYXRhLCAwKTtcclxuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xyXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhLCBudWxsKTtcclxuXHJcbiAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzRm91bmRbal07XHJcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcclxuICAgICAgICBfcGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByYXN0ZXJpemUgdGhlIHBhdGNoZXMgZm91bmQgdG8gZGV0ZXJtaW5lIGFyZWFcclxuICAgIF9wYXRjaEdyaWQuemVyb0JvcmRlcigpO1xyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxyXG4gICAgd2hpbGUgKChjdXJySWR4ID0gbm90WWV0UHJvY2Vzc2VkKCkpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgbGFiZWwrKztcclxuICAgICAgICB0cmFjZShjdXJySWR4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcclxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hMYWJlbHMpIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2pdO1xyXG4gICAgICAgICAgICAgICAgaHN2WzBdID0gKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIC8gKGxhYmVsICsgMSkpICogMzYwO1xyXG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XHJcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXHJcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGFiZWw7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xyXG4gICAgICAgIF9jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgX2lucHV0SW1hZ2VXcmFwcGVyID0gaW5wdXRJbWFnZVdyYXBwZXI7XHJcblxyXG4gICAgICAgIGluaXRCdWZmZXJzKCk7XHJcbiAgICAgICAgaW5pdENhbnZhcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBsb2NhdGUoKSB7XHJcbiAgICAgICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xyXG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHBhdGNoZXNGb3VuZCA9IGZpbmRQYXRjaGVzKCk7XHJcbiAgICAgICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXHJcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByYXN0ZXJyaXplIGFyZWEgYnkgY29tcGFyaW5nIGFuZ3VsYXIgc2ltaWxhcml0eTtcclxuICAgICAgICBjb25zdCBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XHJcbiAgICAgICAgaWYgKG1heExhYmVsIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgYXJlYSB3aXRoIHRoZSBtb3N0IHBhdGNoZXMgKGJpZ2dlc3QgY29ubmVjdGVkIGFyZWEpXHJcbiAgICAgICAgY29uc3QgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XHJcbiAgICAgICAgaWYgKHRvcExhYmVscy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBib3hlcyA9IGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKTtcclxuICAgICAgICByZXR1cm4gYm94ZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50cyhpbnB1dFN0cmVhbSwgY29uZmlnKSB7XHJcbiAgICAgICAgbGV0IHBhdGNoU2l6ZTtcclxuICAgICAgICBsZXQgd2lkdGggPSBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCB0aGlzSGFsZlNhbXBsZSA9IGNvbmZpZy5oYWxmU2FtcGxlID8gMC41IDogMTtcclxuICAgICAgICBsZXQgYXJlYTtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxyXG4gICAgICAgIGlmIChpbnB1dFN0cmVhbS5nZXRDb25maWcoKS5hcmVhKSB7XHJcbiAgICAgICAgICAgIGFyZWEgPSBjb21wdXRlSW1hZ2VBcmVhKHdpZHRoLCBoZWlnaHQsIGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpO1xyXG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7IHg6IGFyZWEuc3gsIHk6IGFyZWEuc3kgfSk7XHJcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldENhbnZhc1NpemUoeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0pO1xyXG4gICAgICAgICAgICB3aWR0aCA9IGFyZWEuc3c7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGFyZWEuc2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzaXplID0ge1xyXG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKHdpZHRoICogdGhpc0hhbGZTYW1wbGUpLFxyXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIHRoaXNIYWxmU2FtcGxlKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoY29uZmlnLnBhdGNoU2l6ZSwgc2l6ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWc/LnNob3dQYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGgubWF4KE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSwgcGF0Y2hTaXplLngpKTtcclxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRIZWlnaHQoTWF0aC5tYXgoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueSAvIHBhdGNoU2l6ZS55KSAqICgxIC8gdGhpc0hhbGZTYW1wbGUpICogcGF0Y2hTaXplLnkpLCBwYXRjaFNpemUueSkpO1xyXG5cclxuICAgICAgICBpZiAoKGlucHV0U3RyZWFtLmdldFdpZHRoKCkgJSBwYXRjaFNpemUueCkgPT09IDAgJiYgKGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XHJcbiAgICAgICAgICAgIHdpZHRofSApYW5kIGhlaWdodCAoJHtoZWlnaHRcclxuICAgICAgICB9KSBtdXN0IGEgbXVsdGlwbGUgb2YgJHtwYXRjaFNpemUueH1gKTtcclxuICAgIH0sXHJcbn07XHJcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSBcIi4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XHJcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSBcImNvbW1vbi9pbWFnZV93cmFwcGVyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUXVhZ2dhQ29udGV4dCB7XHJcbiAgICBwdWJsaWMgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3Q7XHJcblxyXG4gICAgcHVibGljIGlucHV0U3RyZWFtOiBhbnk7XHJcblxyXG4gICAgcHVibGljIGZyYW1lZ3JhYmJlcjogYW55O1xyXG5cclxuICAgIHB1YmxpYyBpbnB1dEltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcjtcclxuXHJcbiAgICBwdWJsaWMgc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmxhZyBpbmRpY2F0aW5nIHRoYXQgc3RvcCgpIHdhcyBjYWxsZWQgd2hpbGUgaW5pdCgpIHdhcyBzdGlsbCBpbiBwcm9ncmVzcy5cclxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBoYW5kbGUgcmFjZSBjb25kaXRpb25zIGluIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgY29tcG9uZW50c1xyXG4gICAgICogYXJlIG1vdW50ZWQvdW5tb3VudGVkIHJhcGlkbHksIGNhdXNpbmcgaW5pdCgpIHRvIGJlIGNhbGxlZCwgdGhlbiBzdG9wKCksXHJcbiAgICAgKiB0aGVuIGluaXQoKSBhZ2FpbiBiZWZvcmUgdGhlIGZpcnN0IGluaXQoKSBjb21wbGV0ZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0QWJvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBib3hTaXplOiBhbnk7XHJcblxyXG4gICAgcHVibGljIHJlc3VsdENvbGxlY3RvcjogYW55O1xyXG5cclxuICAgIHB1YmxpYyBkZWNvZGVyOiBhbnk7XHJcblxyXG4gICAgcHVibGljIHdvcmtlclBvb2w6IGFueVtdID0gW107XHJcblxyXG4gICAgcHVibGljIG9uVUlUaHJlYWQgPSB0cnVlO1xyXG5cclxuICAgIHB1YmxpYyByZWFkb25seSBjYW52YXNDb250YWluZXIgPSBuZXcgQ2FudmFzQ29udGFpbmVyKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDYW52YXNJbmZvIHtcclxuICAgIGltYWdlOiBhbnk7XHJcbiAgICBvdmVybGF5OiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDYW52YXNDb250YWluZXIge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGN0eDogQ2FudmFzSW5mbztcclxuICAgIHB1YmxpYyByZWFkb25seSBkb206IENhbnZhc0luZm87XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgQ2FudmFzSW5mbygpO1xyXG4gICAgICAgIHRoaXMuZG9tID0gbmV3IENhbnZhc0luZm8oKTtcclxuICAgIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3UG9ydCh0YXJnZXQ/OiBFbGVtZW50IHwgc3RyaW5nKTogRWxlbWVudCB8IG51bGwge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYWxyZWFkeSBhIERPTSBlbGVtZW50XHJcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0Lm5vZGVOYW1lICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyBVc2UgJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCcgYXMgYSBmYWxsYmFjayBzZWxlY3RvciAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXHJcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XHJcbn1cclxuIiwiaW1wb3J0IHsgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XHJcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xyXG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcclxuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcclxuXHJcbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRCdWZmZXJzKFxyXG4gICAgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLFxyXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXHJcbiAgICBsb2NhdG9yOiBhbnksXHJcbikge1xyXG4gICAgY29uc3QgaW5wdXRJbWFnZVdyYXBwZXIgPSBpbWFnZVdyYXBwZXIgfHwgbmV3IEltYWdlV3JhcHBlcih7XHJcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcclxuICAgICAgICB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSxcclxuICAgICAgICB0eXBlOiAnWFlTaXplJyxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQgJiYgKGxvY2F0b3IgYXMgYW55KS5jb25maWc/LmRlYnVnPy5zaG93SW1hZ2VEZXRhaWxzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYGltYWdlIHdyYXBwZXIgc2l6ZSAke2lucHV0SW1hZ2VXcmFwcGVyLnNpemV9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBib3hTaXplID0gW1xyXG4gICAgICAgIHZlYzIuY2xvbmUoWzAsIDBdKSxcclxuICAgICAgICB2ZWMyLmNsb25lKFswLCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcclxuICAgICAgICB2ZWMyLmNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxyXG4gICAgICAgIHZlYzIuY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxyXG4gICAgXTtcclxuICAgIEJhcmNvZGVMb2NhdG9yLmluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGxvY2F0b3IpO1xyXG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBRdWFnZ2FDb250ZXh0LCBDYW52YXNDb250YWluZXIgfSBmcm9tICdRdWFnZ2FDb250ZXh0JztcclxuaW1wb3J0IGdldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xyXG5pbXBvcnQgdHlwZSB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcclxuICAgIGlmICghY2FudmFzKSB7XHJcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW52YXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcsIG9wdGlvbnM6IHsgd2lsbFJlYWRGcmVxdWVudGx5OiBib29sZWFuOyBkZWJ1Zz86IGFueSB9KSB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XHJcbiAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIG9wdGlvbnMuZGVidWc/LnNob3dJbWFnZURldGFpbHMpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJyogaW5pdENhbnZhcyBnZXRDYW52YXNBbmRDb250ZXh0Jyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywgeyB3aWxsUmVhZEZyZXF1ZW50bHk6IG9wdGlvbnMud2lsbFJlYWRGcmVxdWVudGx5IH0pO1xyXG4gICAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0IH07XHJcbn1cclxuXHJcbmludGVyZmFjZSBJbml0Q2FudmFzZXNPcHRpb25zIHtcclxuICAgIHdpbGxSZWFkRnJlcXVlbnRseTogYm9vbGVhbjtcclxuICAgIGNyZWF0ZU92ZXJsYXk6IGJvb2xlYW47XHJcbiAgICBkZWJ1Zz86IGFueTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdENhbnZhc2VzKGNhbnZhc1NpemU6IFhZU2l6ZSwgeyB3aWxsUmVhZEZyZXF1ZW50bHksIGNyZWF0ZU92ZXJsYXksIGRlYnVnIH06IEluaXRDYW52YXNlc09wdGlvbnMpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicsIHsgd2lsbFJlYWRGcmVxdWVudGx5LCBkZWJ1ZyB9KTtcclxuICAgICAgICBpbWFnZS5jYW52YXMud2lkdGggPSBjYW52YXNTaXplLng7XHJcbiAgICAgICAgaW1hZ2UuY2FudmFzLmhlaWdodCA9IGNhbnZhc1NpemUueTtcclxuXHJcbiAgICAgICAgLy8gT25seSBjcmVhdGUgb3ZlcmxheSBjYW52YXMgaWYgY3JlYXRlT3ZlcmxheSBpcyB0cnVlIChkZWZhdWx0IGJlaGF2aW9yKVxyXG4gICAgICAgIGxldCBvdmVybGF5OiB7IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsOyBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsIH0gPSB7XHJcbiAgICAgICAgICAgIGNhbnZhczogbnVsbCxcclxuICAgICAgICAgICAgY29udGV4dDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjcmVhdGVPdmVybGF5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlSZXN1bHQgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuZHJhd2luZ0J1ZmZlcicsICdkcmF3aW5nQnVmZmVyJywgeyB3aWxsUmVhZEZyZXF1ZW50bHksIGRlYnVnIH0pO1xyXG4gICAgICAgICAgICBvdmVybGF5UmVzdWx0LmNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueDtcclxuICAgICAgICAgICAgb3ZlcmxheVJlc3VsdC5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xyXG4gICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheVJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRvbToge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLmNhbnZhcyxcclxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjdHg6IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogb3ZlcmxheS5jb250ZXh0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdENhbnZhcyhjb250ZXh0OiBRdWFnZ2FDb250ZXh0KTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XHJcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XHJcbiAgICBjb25zdCB0eXBlID0gY29udGV4dD8uY29uZmlnPy5pbnB1dFN0cmVhbT8udHlwZTtcclxuICAgIGlmICghdHlwZSkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gRGVmYXVsdCB0byB0cnVlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgY29uc3QgY3JlYXRlT3ZlcmxheSA9IGNvbnRleHQ/LmNvbmZpZz8uY2FudmFzPy5jcmVhdGVPdmVybGF5ICE9PSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoXHJcbiAgICAgICAgY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEhY29udGV4dD8uY29uZmlnPy5pbnB1dFN0cmVhbT8ud2lsbFJlYWRGcmVxdWVudGx5LFxyXG4gICAgICAgICAgICBjcmVhdGVPdmVybGF5LFxyXG4gICAgICAgICAgICBkZWJ1ZzogY29udGV4dD8uY29uZmlnPy5sb2NhdG9yPy5kZWJ1Z1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIHsgZG9tOiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0sIGN0eDogeyBpbWFnZTogbnVsbCwgb3ZlcmxheTogbnVsbCB9IH07XHJcblxyXG4gICAgY29uc3QgeyBkb20gfSA9IGNvbnRhaW5lcjtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnSW1hZ2VTdHJlYW0nICYmICF2aWV3cG9ydC5jb250YWlucyhkb20uaW1hZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChkb20uaW1hZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb20ub3ZlcmxheSAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLm92ZXJsYXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChkb20ub3ZlcmxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG59XHJcbiIsIi8qIFdvcmtlciBmdW5jdGlvbnMuIFRoZXNlIGFyZSBzdHJhaWdodCBmcm9tIHRoZSBvcmlnaW5hbCBxdWFnZ2EuanMgZmlsZS5cclxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcclxuICogdG8gcmVmZXIgdG8gdW50aWwgaXQgaXMgcmUtaW1wbGVtZW50ZWQuIFdlIG1heSBiZSBhYmxlIHRvIGZpeC91c2Ugc29tZSBvZiB0aGlzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZywgQmFyY29kZVJlYWRlckNvbnN0cnVjdG9yIH0gZnJvbSBcIi4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XHJcblxyXG4vLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCBpbnRlcmZhY2UgZm9yIEZyYW1lR3JhYmJlclxyXG5cclxuaW50ZXJmYWNlIFFXb3JrZXJUaHJlYWQge1xyXG4gICAgaW1hZ2VEYXRhOiBVaW50OEFycmF5O1xyXG4gICAgYnVzeTogYm9vbGVhbjtcclxuICAgIHdvcmtlcjogV29ya2VyO1xyXG59XHJcblxyXG5sZXQgd29ya2VyUG9vbDogQXJyYXk8UVdvcmtlclRocmVhZD4gPSBbXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVXb3JrZXJzKGZyYW1lR3JhYmJlcjogYW55KSB7XHJcbiAgICBsZXQgYXZhaWxhYmxlV29ya2VyOiBRV29ya2VyVGhyZWFkO1xyXG4gICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoKSB7XHJcbiAgICAgICAgYXZhaWxhYmxlV29ya2VyID0gd29ya2VyUG9vbC5maWx0ZXIoKHdvcmtlclRocmVhZCkgPT4gIXdvcmtlclRocmVhZC5idXN5KVswXTtcclxuICAgICAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XHJcbiAgICAgICAgICAgIGZyYW1lR3JhYmJlci5hdHRhY2hEYXRhKGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEpO1xyXG4gICAgICAgICAgICBpZiAoZnJhbWVHcmFiYmVyLmdyYWIoKSkge1xyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLmJ1c3kgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY21kOiAncHJvY2VzcycsXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiBhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgICAgICAgfSwgW2F2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEuYnVmZmVyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5jb25maWcsXHJcbiAgICAgICAgaW5wdXRTdHJlYW06IHtcclxuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIEB0cy1pZ25vcmVcclxuZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlKGZhY3RvcnkpIHtcclxuICAgIGlmIChmYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIFF1YWdnYSA9IGZhY3RvcnkoKS5kZWZhdWx0O1xyXG4gICAgICAgIGlmICghUXVhZ2dhKSB7XHJcbi8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7ICdldmVudCc6ICdlcnJvcicsIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICB2YXIgaW1hZ2VXcmFwcGVyO1xyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgZnVuY3Rpb24gb25Qcm9jZXNzZWQocmVzdWx0KSB7XHJcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHdvcmtlckludGVyZmFjZVJlYWR5KCkge1xyXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAnZXZlbnQnOiAnaW5pdGlhbGl6ZWQnLFxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXHJcbi8vIEB0cy1pZ25vcmVcclxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XHJcbiAgICB9XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xyXG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZS5kYXRhLmNvbmZpZztcclxuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XHJcbiAgICAgICAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcclxuICAgICAgICAgICAgICAgIHg6IGUuZGF0YS5zaXplLngsXHJcbiAgICAgICAgICAgICAgICB5OiBlLmRhdGEuc2l6ZS55LFxyXG4gICAgICAgICAgICB9LCBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgd29ya2VySW50ZXJmYWNlUmVhZHksIGltYWdlV3JhcHBlcik7XHJcbiAgICAgICAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncHJvY2VzcycpIHtcclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xyXG4gICAgICAgICAgICBRdWFnZ2Euc3RhcnQoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xyXG4gICAgICAgICAgICBRdWFnZ2Euc2V0UmVhZGVycyhlLmRhdGEucmVhZGVycyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncmVnaXN0ZXJSZWFkZXInKSB7XHJcbiAgICAgICAgICAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcihlLmRhdGEubmFtZSwgZS5kYXRhLnJlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVXb3JrZXJCbG9iKCkge1xyXG4gICAgdmFyIGJsb2IsXHJcbiAgICAgICAgZmFjdG9yeVNvdXJjZTtcclxuXHJcbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBpZiAodHlwZW9mIF9fZmFjdG9yeVNvdXJjZV9fICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBmYWN0b3J5U291cmNlID0gX19mYWN0b3J5U291cmNlX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcclxuICAgIH1cclxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcblxyXG4gICAgYmxvYiA9IG5ldyBCbG9iKFsnKCcgKyB3b3JrZXJJbnRlcmZhY2UudG9TdHJpbmcoKSArICcpKCcgKyBmYWN0b3J5U291cmNlICsgJyk7J10sXHJcbiAgICAgICAgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcclxuXHJcbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0V29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtOiBhbnksIGNiOiBGdW5jdGlvbikge1xyXG4gICAgY29uc3QgYmxvYlVSTCA9IGdlbmVyYXRlV29ya2VyQmxvYigpO1xyXG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcclxuXHJcbiAgICBjb25zdCB3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQgPSB7XHJcbiAgICAgICAgd29ya2VyLFxyXG4gICAgICAgIGltYWdlRGF0YTogbmV3IFVpbnQ4QXJyYXkoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAqIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcclxuICAgICAgICBidXN5OiB0cnVlLFxyXG4gICAgfTtcclxuXHJcbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2luaXRpYWxpemVkJykge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WICE9PSAndW5kZWZpbmVkJyAmJiBFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgaW5pdGlhbGl6ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYih3b3JrZXJUaHJlYWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAncHJvY2Vzc2VkJykge1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGhvdyB0byB0aHJlYWQgcHVibGlzaFJlc3VsdCBpbnRvIGhlcmU/IFR5cGVTY3JpcHQgc2F5cyBpdCdzIG5vdCBoZXJlLiBodHRwczovL2dpdGh1Yi5jb20vZXJpY2JsYWRlL3F1YWdnYTIvaXNzdWVzLzQ2NiNpc3N1ZWNvbW1lbnQtMTcyNDI0ODA4MCBzYXlzIGl0J3MgbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHVibGlzaFJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIHB1Ymxpc2hSZXN1bHQoZS5kYXRhLnJlc3VsdCwgd29ya2VyVGhyZWFkLmltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGVycm9yOiAnICsgZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICBjbWQ6ICdpbml0JyxcclxuICAgICAgICBzaXplOiB7IHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpIH0sXHJcbiAgICAgICAgaW1hZ2VEYXRhOiB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLFxyXG4gICAgICAgIGNvbmZpZzogY29uZmlnRm9yV29ya2VyKGNvbmZpZyksXHJcbiAgICB9LCBbd29ya2VyVGhyZWFkLmltYWdlRGF0YS5idWZmZXJdKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFdvcmtlclBvb2woY2FwYWNpdHk6IG51bWJlciwgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtPzogYW55LCBjYj86IEZ1bmN0aW9uKSB7XHJcbiAgICBjb25zdCBpbmNyZWFzZUJ5ID0gY2FwYWNpdHkgLSB3b3JrZXJQb29sLmxlbmd0aDtcclxuICAgIGlmIChpbmNyZWFzZUJ5ID09PSAwICYmIGNiKSB7XHJcbiAgICAgICAgY2IoKTtcclxuICAgIH0gZWxzZSBpZiAoaW5jcmVhc2VCeSA8IDApIHtcclxuICAgICAgICBjb25zdCB3b3JrZXJzVG9UZXJtaW5hdGUgPSB3b3JrZXJQb29sLnNsaWNlKGluY3JlYXNlQnkpO1xyXG4gICAgICAgIHdvcmtlcnNUb1Rlcm1pbmF0ZS5mb3JFYWNoKGZ1bmN0aW9uICh3b3JrZXJUaHJlYWQpIHtcclxuICAgICAgICAgICAgd29ya2VyVGhyZWFkLndvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFTlYgIT09ICd1bmRlZmluZWQnICYmIEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciB0ZXJtaW5hdGVkIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd29ya2VyUG9vbCA9IHdvcmtlclBvb2wuc2xpY2UoMCwgaW5jcmVhc2VCeSk7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB3b3JrZXJJbml0aWFsaXplZCA9ICh3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQpID0+IHtcclxuICAgICAgICAgICAgd29ya2VyUG9vbC5wdXNoKHdvcmtlclRocmVhZCk7XHJcbiAgICAgICAgICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCA+PSBjYXBhY2l0eSAmJiBjYikge1xyXG4gICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluaXRXb3JrZXIoY29uZmlnLCBpbnB1dFN0cmVhbSwgd29ya2VySW5pdGlhbGl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZGVycyhyZWFkZXJzOiBBcnJheTxRdWFnZ2FKU1JlYWRlckNvbmZpZz4pIHtcclxuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAnc2V0UmVhZGVycycsIHJlYWRlcnMgfSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJSZWFkZXIobmFtZTogc3RyaW5nLCByZWFkZXI6IEJhcmNvZGVSZWFkZXJDb25zdHJ1Y3Rvcikge1xyXG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdyZWdpc3RlclJlYWRlcicsIG5hbWUsIHJlYWRlciB9KSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5IH0gZnJvbSAnaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcclxuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbVR5cGUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuXHJcbi8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIGFuIElucHV0U3RyZWFtIHR5cGVzY3JpcHQgaW50ZXJmYWNlLCBzbyB3ZSBkb24ndCBoYXZlIGFuIFwiYW55XCIgaW4gdGhlIG5leHQgbGluZVxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cElucHV0U3RyZWFtKHR5cGU6IElucHV0U3RyZWFtVHlwZSA9ICdMaXZlU3RyZWFtJywgdmlld3BvcnQ6IEVsZW1lbnQgfCBudWxsLCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnVmlkZW9TdHJlYW0nOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZpZGVvLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ0ltYWdlU3RyZWFtJzpcclxuICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVJbWFnZVN0cmVhbSgpIH07XHJcbiAgICAgICAgY2FzZSAnTGl2ZVN0cmVhbSc6IHtcclxuICAgICAgICAgICAgbGV0IHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCkge1xyXG4gICAgICAgICAgICAgICAgdmlkZW8gPSB2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aWRlbykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZCh2aWRlbyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZpZGVvLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvIGFzIEhUTUxWaWRlb0VsZW1lbnQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAqIHNldHVwSW5wdXRTdHJlYW0gaW52YWxpZCB0eXBlICR7dHlwZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmlkZW86IG51bGwsIGlucHV0U3RyZWFtOiBudWxsIH07XHJcbiAgICB9XHJcbn1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cclxuaW1wb3J0IHR5cGUgeyBQb2ludCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuZXhwb3J0IHR5cGUgQm94ID0gQXJyYXk8WyBudW1iZXIsIG51bWJlciBdPjtcclxuXHJcbmV4cG9ydCB0eXBlIExpbmUgPSBbIFBvaW50LCBQb2ludCBdO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVCb3goYm94OiBCb3gsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBsZXQgY29ybmVyID0gYm94Lmxlbmd0aDtcclxuICAgIHdoaWxlIChjb3JuZXItLSkge1xyXG4gICAgICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XHJcbiAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVMaW5lKGxpbmU6IExpbmUsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBsaW5lWzBdLnggKz0geE9mZnNldDtcclxuICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xyXG4gICAgbGluZVsxXS54ICs9IHhPZmZzZXQ7XHJcbiAgICBsaW5lWzFdLnkgKz0geU9mZnNldDtcclxufVxyXG4iLCJpbXBvcnQgeyB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcclxuaW1wb3J0IHsgUXVhZ2dhSlNSZXN1bHRPYmplY3QsIFF1YWdnYUpTUmVhZGVyQ29uZmlnLCBCYXJjb2RlUmVhZGVyQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuaW1wb3J0IHsgZHJhd0FyZWFJZkNvbmZpZ3VyZWQgfSBmcm9tICcuLi9jb21tb24vYXJlYV9vdmVybGF5JztcclxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcclxuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XHJcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XHJcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XHJcbmltcG9ydCBGcmFtZUdyYWJiZXIgZnJvbSAnLi4vaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyc7XHJcbmltcG9ydCBJbnB1dFN0cmVhbSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtJztcclxuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcclxuaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCB9IGZyb20gJy4uL1F1YWdnYUNvbnRleHQnO1xyXG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCBfZ2V0Vmlld1BvcnQgZnJvbSAnLi9nZXRWaWV3UG9ydCc7XHJcbmltcG9ydCBfaW5pdEJ1ZmZlcnMgZnJvbSAnLi9pbml0QnVmZmVycyc7XHJcbmltcG9ydCBfaW5pdENhbnZhcyBmcm9tICcuL2luaXRDYW52YXMnO1xyXG5pbXBvcnQgKiBhcyBRV29ya2VycyBmcm9tICcuL3F3b3JrZXInO1xyXG5pbXBvcnQgc2V0dXBJbnB1dFN0cmVhbSBmcm9tICcuL3NldHVwSW5wdXRTdHJlYW0nO1xyXG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XHJcbiAgICBjb250ZXh0OiBRdWFnZ2FDb250ZXh0ID0gbmV3IFF1YWdnYUNvbnRleHQoKTtcclxuXHJcbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH0gPSBfaW5pdEJ1ZmZlcnMoXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcclxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLmxvY2F0b3IsXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcclxuICAgICAgICB0aGlzLmNvbnRleHQuYm94U2l6ZSA9IGJveFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0QnVmZmVycyhpbWFnZVdyYXBwZXIpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdQb3J0KHRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZHkoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdENhbnZhcygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfaW5pdENhbnZhcyh0aGlzLmNvbnRleHQpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlID0gZG9tLmltYWdlO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkgPSBkb20ub3ZlcmxheTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5vdmVybGF5ID0gY3R4Lm92ZXJsYXk7XHJcblxyXG4gICAgICAgIC8vIERyYXcgYXJlYSBvdmVybGF5IGlmIGNvbmZpZ3VyZWRcclxuICAgICAgICBkcmF3QXJlYUlmQ29uZmlndXJlZChcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZyxcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSxcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkKTogdm9pZCA9PiB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgaW5pdCB3YXMgYWJvcnRlZCAoZS5nLiwgYnkgY2FsbGluZyBzdG9wKCkgZHVyaW5nIGluaXRpYWxpemF0aW9uKVxyXG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBSZWFjdCBTdHJpY3RNb2RlIHdoZXJlIGNvbXBvbmVudHMgYXJlIG1vdW50ZWQvdW5tb3VudGVkIHJhcGlkbHlcclxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluaXRBYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignSW5pdGlhbGl6YXRpb24gd2FzIGFib3J0ZWQnKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBub3QgaW5pdGlhbGl6ZWQnKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgaW5wdXRTdHJlYW0gaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWQgYmVmb3JlIHByb2NlZWRpbmdcclxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0lucHV0IHN0cmVhbSBub3QgaW5pdGlhbGl6ZWQnKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQmFyY29kZUxvY2F0b3IuY2hlY2tJbWFnZUNvbnN0cmFpbnRzKHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSwgdGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRvcik7XHJcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlciA9IEZyYW1lR3JhYmJlci5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbChcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcsXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/Lm51bU9mV29ya2VycyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZURhdGEoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIGluaXRJbnB1dFN0cmVhbShjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0eXBlOiBpbnB1dFR5cGUsIGNvbnN0cmFpbnRzIH0gPSB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtO1xyXG4gICAgICAgIGNvbnN0IHsgdmlkZW8sIGlucHV0U3RyZWFtIH0gPSBzZXR1cElucHV0U3RyZWFtKGlucHV0VHlwZSwgdGhpcy5nZXRWaWV3UG9ydCgpLCBJbnB1dFN0cmVhbSk7XHJcblxyXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdMaXZlU3RyZWFtJyAmJiB2aWRlbykge1xyXG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgY29uc3RyYWludHMpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBpbnB1dFN0cmVhbS50cmlnZ2VyKCdjYW5yZWNvcmQnKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBjYWxsYmFjayhlcnIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbnB1dFN0cmVhbSkge1xyXG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRBdHRyaWJ1dGUoJ3ByZWxvYWQnLCAnYXV0bycpO1xyXG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRJbnB1dFN0cmVhbSh0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKTtcclxuICAgICAgICAgICAgaW5wdXRTdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucmVjb3JkJywgdGhpcy5jYW5SZWNvcmQuYmluZCh1bmRlZmluZWQsIGNhbGxiYWNrKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0gPSBpbnB1dFN0cmVhbTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRCb3VuZGluZ0JveGVzKCk6IEFycmF5PEFycmF5PEFycmF5PG51bWJlcj4+PiB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdGUgPyBCYXJjb2RlTG9jYXRvci5sb2NhdGUoKVxyXG4gICAgICAgICAgICA6IFtbXHJcbiAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzBdKSxcclxuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMV0pLFxyXG4gICAgICAgICAgICAgICAgdmVjMi5jbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXHJcbiAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzNdKSxcclxuICAgICAgICAgICAgXV0gYXMgdW5rbm93biBhcyBBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xyXG4gICAgdHJhbnNmb3JtUmVzdWx0KHJlc3VsdDogYW55LCB0cmFuc2Zvcm1lZEJveGVzOiBTZXQ8YW55PiA9IG5ldyBTZXQoKSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XHJcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IHRvcFJpZ2h0Lnk7XHJcblxyXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBCYXJjb2RlSW5mbyBtYXkgbm90IGJlIHRoZSByaWdodCB0eXBlIGhlcmUuXHJcbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSwgdHJhbnNmb3JtZWRCb3hlcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBtb3ZlTGluZShyZXN1bHQubGluZSwgeE9mZnNldCwgeU9mZnNldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0LmJveCAmJiAhdHJhbnNmb3JtZWRCb3hlcy5oYXMocmVzdWx0LmJveCkpIHtcclxuICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94LCB4T2Zmc2V0LCB5T2Zmc2V0KTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtZWRCb3hlcy5hZGQocmVzdWx0LmJveCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0LmJveGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGlmIHRoaXMgYm94IGhhcyBhbHJlYWR5IGJlZW4gdHJhbnNmb3JtZWQgKGVpdGhlciBhcyByZXN1bHQuYm94IG9yIHRocm91Z2ggYmFyY29kZXMpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkQm94ZXMuaGFzKHJlc3VsdC5ib3hlc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3hlc1tpXSwgeE9mZnNldCwgeU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRCb3hlcy5hZGQocmVzdWx0LmJveGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCwgaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IGRhdGEgc3RydWN0dXJlIGhvbGRzIGEgXCJiYXJjb2Rlc1wiIHJlc3VsdCwgaWYgYW55Li4uXHJcbiAgICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xyXG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGJhcmNvZGU6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KSA9PiB0aGlzLmFkZFJlc3VsdChiYXJjb2RlLCBpbWFnZURhdGEpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEhKHJlc3VsdCAmJiAocmVzdWx0LmJhcmNvZGVzXHJcbiAgICAgICAgICAgID8gcmVzdWx0LmJhcmNvZGVzLnNvbWUoKGJhcmNvZGUpID0+IGJhcmNvZGUuY29kZVJlc3VsdClcclxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXHJcbiAgICBwdWJsaXNoUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QgfCBudWxsID0gbnVsbCwgaW1hZ2VEYXRhPzogYW55KTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHJlc3VsdFRvUHVibGlzaDogQXJyYXk8UXVhZ2dhSlNSZXN1bHRPYmplY3Q+IHwgUXVhZ2dhSlNSZXN1bHRPYmplY3QgfCBudWxsID0gcmVzdWx0O1xyXG5cclxuICAgICAgICBpZiAocmVzdWx0ICYmIHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtUmVzdWx0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQ/LmJhcmNvZGVzPy5sZW5ndGggPiAwID8gcmVzdWx0LmJhcmNvZGVzIDogcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRzLnB1Ymxpc2goJ3Byb2Nlc3NlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIEV2ZW50cy5wdWJsaXNoKCdkZXRlY3RlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvY2F0ZUFuZERlY29kZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xyXG4gICAgICAgIGlmIChib3hlcykge1xyXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVSZXN1bHQgPSAoYXdhaXQgdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpKSB8fCB7fTtcclxuICAgICAgICAgICAgZGVjb2RlUmVzdWx0LmJveGVzID0gYm94ZXM7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChkZWNvZGVSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VSZXN1bHQgPSBhd2FpdCB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tSW1hZ2UodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcclxuICAgICAgICAgICAgaWYgKGltYWdlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoaW1hZ2VSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlcnNVcGRhdGVkID0gUVdvcmtlcnMudXBkYXRlV29ya2Vycyh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKTtcclxuICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpO1xyXG4gICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc3RhcnRDb250aW51b3VzVXBkYXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBuZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICAvLyBmcmVxdWVuY3kgc3BlY2lmaWVzIGEgbWF4aW11bSByYXRlLCBub3QgYW4gYWJzb2x1dGUuIElmIHRoZSBzeXN0ZW0gY2Fubm90XHJcbiAgICAgICAgLy8gYWNoaWV2ZSB0aGUgcmVxdWVzdGVkIGZyZXF1ZW5jeSwgc2NhbnMgd2lsbCBvY2N1ciBhcyBmYXN0IGFzIHBvc3NpYmxlLlxyXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMTAwMCAvICh0aGlzLmNvbnRleHQuY29uZmlnPy5mcmVxdWVuY3kgfHwgNjApO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHsgY29udGV4dCB9ID0gdGhpcztcclxuXHJcbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA+PSBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBkZWxheTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBuZXdGcmFtZShwZXJmb3JtYW5jZS5ub3coKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkICYmIHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtPy50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzdG9wKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBTZXQgaW5pdEFib3J0ZWQgZmxhZyBpZiBzdG9wKCkgaXMgY2FsbGVkIHdoaWxlIGluaXQoKSBpcyBzdGlsbCBpbiBwcm9ncmVzc1xyXG4gICAgICAgIC8vIChpLmUuLCBiZWZvcmUgZnJhbWVncmFiYmVyIGlzIGluaXRpYWxpemVkKS4gVGhpcyBwcmV2ZW50cyB0aGUgY2FuUmVjb3JkXHJcbiAgICAgICAgLy8gY2FsbGJhY2sgZnJvbSBjb250aW51aW5nIGFmdGVyIHN0b3AoKSB3YXMgY2FsbGVkLlxyXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5pdEFib3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBRV29ya2Vycy5hZGp1c3RXb3JrZXJQb29sKDApO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbSAmJiB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xyXG4gICAgICAgICAgICBhd2FpdCBDYW1lcmFBY2Nlc3MucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0/LmNsZWFyRXZlbnRIYW5kbGVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5zZXRSZWFkZXJzKHJlYWRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBRV29ya2Vycy5zZXRSZWFkZXJzKHJlYWRlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBCYXJjb2RlUmVhZGVyQ29uc3RydWN0b3IpOiB2b2lkIHtcclxuICAgICAgICBCYXJjb2RlRGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBRV29ya2Vycy5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xyXG5pbXBvcnQgVHlwZURlZnMgZnJvbSAnLi9jb21tb24vdHlwZWRlZnMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XHJcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcclxuaW1wb3J0ICogYXMgUmVhZGVycyBmcm9tICcuL3JlYWRlci9pbmRleCc7XHJcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcclxuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xyXG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XHJcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XHJcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcvY29uZmlnJztcclxuXHJcbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcclxuXHJcbmNvbnN0IGluc3RhbmNlID0gbmV3IFF1YWdnYSgpO1xyXG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XHJcblxyXG5jb25zdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSA9IHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcclxuICAgICAgICBsZXQgcHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNiKSB7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXNldCB0aGUgaW5pdEFib3J0ZWQgZmxhZyB3aGVuIHN0YXJ0aW5nIGEgbmV3IGluaXRcclxuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmluaXRBYm9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xyXG4gICAgICAgIC8vIFRPRE8gIzE3OTogcGVuZGluZyByZXN0cnVjdHVyZSBpbiBJc3N1ZSAjMTc5LCB3ZSBhcmUgdGVtcCBkaXNhYmxpbmcgd29ya2Vyc1xyXG4gICAgICAgIGlmIChxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XHJcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbWFnZVdyYXBwZXIpIHtcclxuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5vblVJVGhyZWFkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcik7XHJcbiAgICAgICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRJbnB1dFN0cmVhbShjYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfSxcclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoY29uZmlnLCBjYikge1xyXG4gICAgICAgIC8vIElmIGNvbmZpZyBpcyBwcm92aWRlZCwgY2FsbCBpbml0KCkgdGhlbiBzdGFydCgpXHJcbiAgICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgICAgICBsZXQgcHJvbWlzZTtcclxuICAgICAgICAgICAgaWYgKCFjYikge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmluaXQoY29uZmlnLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHN0YXJ0RXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Ioc3RhcnRFcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGluaXQoKSBoYXNuJ3QgYmVlbiBjb21wbGV0ZWQsIHRocm93IGFuIGVycm9yXHJcbiAgICAgICAgaWYgKCFfY29udGV4dC5mcmFtZWdyYWJiZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCgpIHdhcyBjYWxsZWQgYmVmb3JlIGluaXQoKSBjb21wbGV0ZWQuICdcclxuICAgICAgICAgICAgICAgICsgJ0NhbGwgaW5pdCgpIGZpcnN0LCBvciBjYWxsIHN0YXJ0KGNvbmZpZykgdG8gY29tYmluZSBpbml0IGFuZCBzdGFydC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0YXJ0KCk7XHJcbiAgICB9LFxyXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5zdG9wKCk7XHJcbiAgICB9LFxyXG4gICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfY29udGV4dC5zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBvbkRldGVjdGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25EZXRlY3RlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuICAgIG9mZkRldGVjdGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuICAgIG9uUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25Qcm9jZXNzZWQgY2FsbGVkIHdpdGggaW52YWxpZCBjYWxsYmFjaywgaWdub3JpbmcnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG4gICAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbiAocmVhZGVycykge1xyXG4gICAgICAgIGlmICghcmVhZGVycykge1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5zZXRSZWFkZXJzIGNhbGxlZCB3aXRoIG5vIHJlYWRlcnMsIGlnbm9yaW5nJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2Uuc2V0UmVhZGVycyhyZWFkZXJzKTtcclxuICAgIH0sXHJcbiAgICByZWdpc3RlclJlYWRlcjogZnVuY3Rpb24gKG5hbWUsIHJlYWRlcikge1xyXG4gICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyBuYW1lLCBpZ25vcmluZycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVhZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIHJlYWRlciwgaWdub3JpbmcnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xyXG4gICAgfSxcclxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiAocmVzdWx0Q29sbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdENvbGxlY3RvciAmJiB0eXBlb2YgcmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBfY29udGV4dC5yZXN1bHRDb2xsZWN0b3IgPSByZXN1bHRDb2xsZWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldCBjYW52YXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcclxuICAgIH0sXHJcbiAgICBkZWNvZGVTaW5nbGU6IGZ1bmN0aW9uIChjb25maWcsIHJlc3VsdENhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgcXVhZ2dhSW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XHJcbiAgICAgICAgY29uZmlnID0gbWVyZ2Uoe1xyXG4gICAgICAgICAgICBpbnB1dFN0cmVhbToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcclxuICAgICAgICAgICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNpemU6IDgwMCxcclxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyYyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbnVtT2ZXb3JrZXJzOiAodHlwZW9mIEVOViAhPT0gJ3VuZGVmaW5lZCcgJiYgRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1ZykgPyAwIDogMSxcclxuICAgICAgICAgICAgbG9jYXRvcjoge1xyXG4gICAgICAgICAgICAgICAgaGFsZlNhbXBsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSwgY29uZmlnKTtcclxuICAgICAgICAvLyBUT0RPICMxNzU6IHJlc3RydWN0dXJlIHdvcmtlciBzdXBwb3J0IHNvIHRoYXQgaXQgd2lsbCB3b3JrIHdpdGggdHlwZXNjcmlwdCB1c2luZyB3b3JrZXItbG9hZGVyXHJcbiAgICAgICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9sb2FkZXJzL3dvcmtlci1sb2FkZXIvXHJcbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3b3JrZXJzIHJlcXVpcmUgV29ya2VyIGFuZCBCbG9iIHN1cHBvcnQgcHJlc2VudGx5LCBzbyBpZiBubyBCbG9iIG9yIFdvcmtlciB0aGVuIHNldFxyXG4gICAgICAgIC8vIHdvcmtlcnMgdG8gMC5cclxuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDAgJiYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIG5vIFdvcmtlciBhbmQvb3IgQmxvYiBzdXBwb3J0IC0gZm9yY2luZyBudW1PZldvcmtlcnMgdG8gMCcpO1xyXG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdChjb25maWcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfSwgbnVsbCwgcXVhZ2dhSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gYWRkIHRoZSB1c3VhbGx5IGV4cGVjdGVkIFwiZGVmYXVsdFwiIGZvciB1c2Ugd2l0aCByZXF1aXJlLCBidWlsZCBzdGVwIHdvbid0IGFsbG93IHVzIHRvXHJcbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxyXG4gICAgZ2V0IGRlZmF1bHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlO1xyXG4gICAgfSxcclxuICAgIFJlYWRlcnMsXHJcbiAgICBDYW1lcmFBY2Nlc3MsXHJcbiAgICBJbWFnZURlYnVnLFxyXG4gICAgSW1hZ2VXcmFwcGVyLFxyXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XHJcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcclxuZXhwb3J0IHtcclxuICAgIEJhcmNvZGVEZWNvZGVyLFxyXG4gICAgUmVhZGVycyxcclxuICAgIENhbWVyYUFjY2VzcyxcclxuICAgIEltYWdlRGVidWcsXHJcbiAgICBJbWFnZVdyYXBwZXIsXHJcbiAgICBSZXN1bHRDb2xsZWN0b3IsXHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=